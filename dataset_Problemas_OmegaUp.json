[
    {
        "titulo": "11656. Laberinto final",
        "url": "https://omegaup.com/arena/problem/Laberinto-final/",
        "descripcion": "El Malvado Robot OMI ha bloqueado las salidas del templo mientras entrenaban, entonces la prueba final será escapar del templo.El templo se puede ver como una matriz de N X M en donde esta representado por un \".\" un camino libre y una \"X\" una pared, con la posibilidad de hacer movimientos de tipo (i-1,j),(i,j+1),(i+1,j)y(i,j-1). Para esta prueba desarrollaron el poder de bola de fuego que les permite destruir paredes, sin embargo, no pueden destruir más de k paredes, si no el templo se derrumbaría y todos morirían :(. Ayuda a los programadores mayas a encontrar el camino más corto a la salida del templo representada por un \"M\" su posición en la matriz y una \"S\" la posición de la salida.",
        "entrada": "Tres enteros N, M y k seguido de N líneas con M caracteres de tipo \".\", \"X\", \"M\" y \"S\" descritas anteriormente.",
        "salida": "Un único número que sea el número de pasos del camino más corto con las condiciones ya mencionadas. En caso de que no exista camino posible imprime \"F\" sin comillas para darle tus respetos a los programadores mayas.",
        "nivel": "Avanzado (difícil) - Programación competitiva",
        "categorias": [
            "Matrices",
            "Colas",
            "Búsqueda en amplitud"
        ],
        "estructuras": [
            "int",
            "vector<vector<char>>",
            "vector<vector<int>>",
            "queue<>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef struct{\n    int aa, bb, cc, dd;\n}sobra;\n\nint a, b, c, d, e, f, g, h, l;\nchar num[102][102];\nint sub[102][102];\nqueue<sobra>falta;\nsobra z;\n\nint main(){\n  cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  cin>>a>>b>>c;\n for(auto i=0; i<a; ++i){\n       for(auto j=0; j<b; ++j){\n           cin>>num[i][j];\n           if(num[i][j]=='M'){\n               z.aa=i;\n               z.bb=j;\n               z.cc=c;\n               z.dd=0;\n               falta.push(z);\n                sub[i][j]=1;\n          }\n     }\n }\n while(falta.size()){\n      z=falta.front();\n      falta.pop();\n      z.dd++;\n       z.aa--;\n       if(z.aa>-1){\n          if(num[z.aa][z.bb]=='.' and !sub[z.aa][z.bb]){\n                falta.push(z);\n                sub[z.aa][z.bb]=z.dd;\n         }\n         else if(num[z.aa][z.bb]=='.' and z.dd<sub[z.aa][z.bb]){\n               falta.push(z);\n                sub[z.aa][z.bb]=z.dd;\n         }\n         else if(num[z.aa][z.bb]=='X' and z.cc and !sub[z.aa][z.bb]){\n              z.cc--;\n               falta.push(z);\n                z.cc++;\n               sub[z.aa][z.bb]=z.dd;\n         }\n         else if(num[z.aa][z.bb]=='X' and z.cc and z.dd<sub[z.aa][z.bb]){\n              z.cc--;\n               falta.push(z);\n                z.cc++;\n               sub[z.aa][z.bb]=z.dd;\n         }\n         else if(num[z.aa][z.bb]=='S'){\n                cout<<z.dd;return 0;\n          }\n     }\n     z.aa+=2;\n      if(z.aa<a){\n           if(num[z.aa][z.bb]=='.' and !sub[z.aa][z.bb]){\n                falta.push(z);\n                sub[z.aa][z.bb]=z.dd;\n         }\n         else if(num[z.aa][z.bb]=='.' and z.dd<sub[z.aa][z.bb]){\n               falta.push(z);\n                sub[z.aa][z.bb]=z.dd;\n         }\n         else if(num[z.aa][z.bb]=='X' and z.cc and !sub[z.aa][z.bb]){\n              z.cc--;\n               falta.push(z);\n                z.cc++;\n               sub[z.aa][z.bb]=z.dd;\n         }\n         else if(num[z.aa][z.bb]=='X' and z.cc and z.dd<sub[z.aa][z.bb]){\n              z.cc--;\n               falta.push(z);\n                z.cc++;\n               sub[z.aa][z.bb]=z.dd;\n         }\n         else if(num[z.aa][z.bb]=='S'){\n                cout<<z.dd;return 0;\n          }\n     }\n     z.aa--;\n       z.bb--;\n       if(z.bb>-1){\n          if(num[z.aa][z.bb]=='.' and !sub[z.aa][z.bb]){\n                falta.push(z);\n                sub[z.aa][z.bb]=z.dd;\n         }\n         else if(num[z.aa][z.bb]=='.' and z.dd<sub[z.aa][z.bb]){\n               falta.push(z);\n                sub[z.aa][z.bb]=z.dd;\n         }\n         else if(num[z.aa][z.bb]=='X' and z.cc and !sub[z.aa][z.bb]){\n              z.cc--;\n               falta.push(z);\n                z.cc++;\n               sub[z.aa][z.bb]=z.dd;\n         }\n         else if(num[z.aa][z.bb]=='X' and z.cc and z.dd<sub[z.aa][z.bb]){\n              z.cc--;\n               falta.push(z);\n                z.cc++;\n               sub[z.aa][z.bb]=z.dd;\n         }\n         else if(num[z.aa][z.bb]=='S'){\n                cout<<z.dd;return 0;\n          }\n     }\n     z.bb+=2;\n      if(z.bb<b){\n           if(num[z.aa][z.bb]=='.' and !sub[z.aa][z.bb]){\n                falta.push(z);\n                sub[z.aa][z.bb]=z.dd;\n         }\n         else if(num[z.aa][z.bb]=='.' and z.dd<sub[z.aa][z.bb]){\n               falta.push(z);\n                sub[z.aa][z.bb]=z.dd;\n         }\n         else if(num[z.aa][z.bb]=='X' and z.cc and !sub[z.aa][z.bb]){\n              z.cc--;\n               falta.push(z);\n                z.cc++;\n               sub[z.aa][z.bb]=z.dd;\n         }\n         else if(num[z.aa][z.bb]=='X' and z.cc and z.dd<sub[z.aa][z.bb]){\n              z.cc--;\n               falta.push(z);\n                z.cc++;\n               sub[z.aa][z.bb]=z.dd;\n         }\n         else if(num[z.aa][z.bb]=='S'){\n                cout<<z.dd;return 0;\n          }\n     }\n }\n cout<<\"F\";\n\n    return 0;\n}\n"
    },
    {
        "titulo": "10234. Los discos de la recursión",
        "url": "https://omegaup.com/arena/problem/Los-discos-de-la-recursion/",
        "descripcion": "Para todos los que hayan tomado clases de recursión con el profesor de programacion competitiva saben que le gusta explicar la recursión como una pila de discos (probablemente se pregunten que son los discos, pero eso no es de interés ahora). En una pila de disco uno pone un disco encima de otro y cuando los quieres sacar empiezas por el ultimo que metiste. Lamentablemente un día que el profesor explicaba este tema se le rompió uno de los discos que llevaba y es cuando se percató que cada disco tiene una resistencia, si a un disco le pones más discos de los que resiste se rompe. Por ejemplo, supongamos que tenemos disco de resistencia 3, 2, 1, 1. La mejor forma de ordenarlos es la siguiente: No podemos poner el de resistencia 2 abajo porque no resistiría los otros 3 discos arriba de él y lo mismo para el de 1 resistencia. Ángel le intereso tanto esto que se empezó a preguntar dado ciertos discos ¿Cuánto es el mínimo número de pilas que se puede hacer tal que no se rompa ningún disco? Y como buen programador decidiste ayudarlo en esta complicada tarea. Dado n discos con resistencias r_i decir cuánto es el mínimo número de pilas necesarias para que ningún disco se rompa.",
        "entrada": "En la primera línea un entero n (0<n<=10^6) representando la cantidad de discos. Seguido de n números r_i (0<=r_i<=10^6) que representan las resistencias de cada disco.",
        "salida": "Un único número entero que representa la cantidad mínima de pilas necesarias.",
        "nivel": "Avanzado (difícil) - Programación competitiva",
        "categorias": [
            "Vectores",
            "Ordenamiento",
            "Listas doblemente ligadas"
        ],
        "estructuras": [
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct lazos{\n    int val, prev, next;\n};\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int a, b, c=0, d, e=0, f;\n    cin>>a;\n    vector<int>ar(a);\n    for(auto i=0; i<a; i++){\n        cin>>ar[i];\n    }\n    sort(ar.begin(),ar.end());\n    vector<lazos>arr(a+1);\n    for(auto i=0; i<a; i++){\n        arr[i].val=ar[i];\n        arr[i].prev=i-1;\n        arr[i].next=i+1;\n    }\n    arr[a].val=-1;\n    arr[a].prev=a-1;\n    arr[a].next=-1;\n    while(arr[c].val!=-1){\n        e++;\n        d=c=arr[c].next;\n        arr[d].prev=-1;\n        f=1;\n        for(; arr[d].val!=-1; d=arr[d].next){\n            if(arr[d].val>=f){\n                f++;\n                if(c==d){\n                    c=arr[c].next;\n                }\n                else{\n                    arr[arr[d].prev].next=arr[d].next;\n                }\n                arr[arr[d].next].prev=arr[d].prev;\n            }\n        }\n    }\n    cout<<e;\n    \n    return 0;\n}\n"
    },
    {
        "titulo": "296. Decepción",
        "url": "https://omegaup.com/arena/problem/decepcion/",
        "descripcion": "Dado un entero n, se forma una fila de n torres con alturas desde 1 hasta n centímetros, ninguna altura aparece más de una vez. Se quieren conocer todas las permutaciones de esta fila tal que viendo la fila de frente solo se vean F torres diferentes y vista por detrás solo se vean B torres. Se dice que podemos ver una torre con altura H si no hay otra torre delante de ella (con respecto a nuestra visión) con altura mayor a H.",
        "entrada": "Tres enteros separados por espacios: n, F y B (1<=n,F,B<=13).",
        "salida": "Un entero que representa el número de permutaciones que cumplen con las condiciones establecidas.",
        "nivel": "Avanzado (difícil) - Programación competitiva",
        "categorias": [
            "Matrices",
            "Programación dinámica",
            "Teoría de numeros"
        ],
        "estructuras": [
            "int",
            "vector<vector<int>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    vector<vector<int>>choose(15,vector<int>(15));\n    vector<vector<int>>stirling(15,vector<int>(15));\n    int N, F, B;\n    cin>>N>>F>>B;\n    for (int i = 0; i < 15; i++){\n        choose[i][0] = choose[i][i] = 1;\n        for (int j = 1; j < i; j++){\n            choose[i][j] = choose[i-1][j-1] + choose[i-1][j];\n        }\n    }\n    stirling[0][0] = 1;\n    for (int i = 1; i <= N; i++){\n        for (int j = 1; j <= i; j++){\n            stirling[i][j] = stirling[i-1][j-1] + (i-1) * stirling[i-1][j];\n        }\n    }\n    int ans = 0;\n    for (int i = 0; i < N; i++){\n        ans += choose[N-1][i] * stirling[i][F-1] * stirling[N-i-1][B-1];\n    }\n    cout<<ans;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "148. Bloques",
        "url": "https://omegaup.com/arena/problem/bloques/",
        "descripcion": "Link, el héroe del tiempo, se encuentra en la Caverna de hielo. Está en un gran laberinto helado, formado por espacios libres (representados con puntos '.') y espacios bloqueados (representados con numerales '#'). En una de las posiciones libres, en un cuadro por debajo del nivel del suelo de los demás espacios libres, hay un gran botón que mientras es presionado (subiendo Link en él) abre una salida por la que puede escapar, pero al dejar de presionarlo vuelve a cerrar la salida. Sin embargo, eso no es obstáculo para nuestro héroe, pues ha encontrado dos grandes bloques de hielo que le permitirán escapar. Los bloques de hielo son pesados, por lo que para moverlos Link necesita estar en un espacio libre (opuesto a la dirección en la que el bloque se moverá). Por ejemplo, si a la izquierda del bloque el espacio esta libre puedes moverlo hacia la derecha. Sin embargo, como el laberinto está helado, los bloques se mueven en una forma muy peculiar. Al comenzar a desplazarse en una dirección los bloques siguen avanzando hasta toparse con un espacio bloqueado (ya sea un '#' o el otro bloque de hielo) o hasta llegar al botón. Tu objetivo es ayudar a Link a determinar la menor cantidad posible de movimientos de bloque necesarios para llevar uno de los bloques de hielo al botón para poder escapar. Un movimiento consiste en el empujón inicial que Link le da y que lo hace llegar hasta donde se tope con un espacio bloqueado. Consideraciones: #1. El laberinto consistirá de n*n cuadros, donde 5<=n<=40. #2. Se garantiza que las orillas del laberinto consisten únicamente de '#'. #3. Se garantiza que habrá exactamente dos bloques de hielo en el laberinto, indicados por la letra B. Cuando un bloque esté en un cuadrado este se considerará bloqueado (es decir, un bloque no puede atravesar al otro bloque). #4. Se garantiza que habrá exactamente un botón en el laberinto, señalado con la letra 'A'. Este cuadrado está libre (desde él puedes empujar bloque si los hay en las posiciones contiguas). #5. Puedes asumir que tu puedes llegar a cualquier posición libre del laberinto en todo momento, aún si está rodeada por posiciones bloqueadas. #6. Se garantiza que es posible siempre llevar un bloque al botón. #7. Puedes mover los bloques en el orden que quieras.",
        "entrada": "La primera línea tendrá un entero n (5<=n<=40) que indica el tamaño del laberinto. Las siguientes n líneas serán la descripción del laberinto.",
        "salida": "Un único número, la mínima cantidad de movimientos de desplazamiento de bloque (descritos previamente) necesarios para llevar uno de ellos al botón.",
        "nivel": "Avanzado (difícil) - Programación competitiva",
        "categorias": [
            "Matrices",
            "Búsqueda en amplitud"
        ],
        "estructuras": [
            "long long",
            "vector<vector<char>>",
            "vector<vector<long long>>",
            "vector<vector<vector<vector<bool>>>>"
        ],
        "codigo": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nlong long num[5][1000000];\nlong long sum[2][4];\nbool nums[42][42][42][42];\nchar subs[44][44];\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b=1, c, d, e, f, g, h, l, m, n, o, p=0, q, r, s;\n    sum[0][2]=sum[1][0]=1;\n    sum[0][3]=sum[1][1]=-1;\n    cin>>a;\n    for(auto i=0; i<a; i++){\n        for(auto j=0; j<a; j++){\n            cin>>subs[i][j];\n            if(subs[i][j]=='B'){\n                subs[i][j]='.';\n                if(p){\n                    r=i;\n                    s=j;\n                }\n                else{\n                    p=i;\n                    q=j;\n                }\n            }\n        }\n   }\n   num[0][0]=p;\n   num[1][0]=q;\n   num[2][0]=r;\n   num[3][0]=s;\n   nums[p][q][r][s]=true;\n   nums[r][s][p][q]=true;\n   while(c<b){\n        h=num[0][c];\n        m=num[1][c];\n        l=num[2][c];\n        n=num[3][c];\n        for(auto i=0; i<4; i++){\n            d=h;\n            e=m;\n            f=sum[0][i];\n            g=sum[1][i];\n            if((d-f==l && e-g==n) || subs[d-f][e-g]=='#'){\n                continue;\n            }\n            while((d+f!=l || e+g!=n) && subs[d+f][e+g]=='.'){\n                d+=f;\n                e+=g;\n            }\n            if(((d+f==l && e+g==n) || subs[d+f][e+g]=='#') && nums[d][e][l][n]==false){\n                nums[d][e][l][n]=true;\n                nums[l][n][d][e]=true;\n                num[0][b]=d;\n                num[1][b]=e;\n                num[2][b]=l;\n                num[3][b]=n;\n                num[4][b]=num[4][c]+1;\n                b++;\n            }\n            else if(subs[d+f][e+g]=='A'){\n                num[4][b]=num[4][c]+1;\n                o=c;\n                c=b+1;break;\n            }\n        }\n        if(c>b){\n            c=o;break;\n        }\n        for(auto i=0; i<4; i++){\n            d=l;\n            e=n;\n            f=sum[0][i];\n            g=sum[1][i];\n            if(subs[d-f][e-g]=='#' || (d-f==h && e-g==m))continue;\n            while(subs[d+f][e+g]=='.' && (d+f!=h || e+g!=m)){\n                d+=f;\n                e+=g;\n            }\n            if((subs[d+f][e+g]=='#' || (d+f==h && e+g==m)) && nums[h][m][d][e]==false){\n                nums[h][m][d][e]=true;\n                nums[h][m][d][e]=true;\n                num[0][b]=h;\n                num[1][b]=m;\n                num[2][b]=d;\n                num[3][b]=e;\n                num[4][b]=num[4][c]+1;\n                b++;\n            }\n            else if(subs[d+f][e+g]=='A'){\n                num[4][b]=num[4][c]+1;\n                o=c;\n                c=b+1;break;\n            }\n        }\n        if(c>b){\n            c=o;break;\n        }\n        c++;\n    }\n    cout<<num[4][c]+1;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "336. Mapas de bits",
        "url": "https://omegaup.com/arena/problem/Mapas-de-bits/",
        "descripcion": "Un mapa de bits es una estructura de datos que se utiliza en muchas áreas de la computación . En gráficas por computadora, por ejemplo, un mapa de bits puede representar una imagen donde un 1 representa un pixel negro y un 0 representa un píxel blanco. Considera las siguientes dos maneras de representar un mapa de bits rectangular: Con la primera forma, simplemente se representa como una matriz bidimensional de 1s y 0s . La segunda manera se basa en una técnica de descomposición . En primer lugar, se considera todo el mapa de bits. Si todos los bits dentro del mapa son 1, entonces 1 es la salida. Si todos los bits son 0, entonces la salida es 0. De lo contrario, se escribe una D como salida, y luego el mapa de bits se divide en cuatro partes ( como se describe a continuación ) , y cada una de las partes se procesa de la misma manera que el mapa de bits original. La primera sección en ser procesada es la parte superior izquierda, luego la superior derecha, después la inferior izquierda, y por último la inferior derecha. Cuando un mapa de bits tiene un número par de filas y un número par de columnas, todas las secciones tienen las mismas dimensiones. Cuando el número de columnas es impar, las secciones de la izquierda tienen una columna más que las de la derecha. Cuando el número de filas es impar las secciones superior izquierda y superior derecha tienen una fila más que las partes inferiores. Toma en cuenta que si una región que tiene una sola fila o una columna se divide, habrá dos mitades como resultado, la mitad superior se procesa primero. De igual forma cuando una sola columna se divide, sólo hay dos secciones donde la mitad izquierda se procesa antes que la derecha. Escribe un programa que lea un mapa de bits en una forma y lo transforme en la otra forma.",
        "entrada": "La entrada consistirá en un mapa de bits. Comienza con una línea que da su formato (\"B\" o \"D\") y sus dimensiones en filas y columnas. Ninguna dimensión será mayor que 2000. La siguiente línea contiene la secuencia de caracteres (\"1\", \"0\" y \"D\") que representan el mapa de bits, sin espacios. Un mapa de bits de tipo \"B\" se escribirá de izquierda a derecha y de arriba a abajo.",
        "salida": "La salida consistirá en un mapa de bits. La primera línea describe el formato al que estás traduciendo y el número de filas y de columnas. La siguiente línea debe contener la cadena de caracteres que represente al mapa de bits.",
        "nivel": "Avanzado (medio) - Temas especializados",
        "categorias": [
            "Caracteres y cadenas",
            "Recursión",
            "Compresión de datos"
        ],
        "estructuras": [
            "bool",
            "int",
            "char",
            "string",
            "vector<vector<char>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring BtoD(vector<vector<char>> &mapa, int i, int j, int filas, int columnas) {\n    if(!filas || !columnas){\n        return \"\";\n    }\n    bool todosUnos = true, todosCeros = true;\n    for (int r = i; r < i + filas; ++r) {\n        for (int c = j; c < j + columnas; ++c) {\n            if (mapa[r][c] == '0') todosUnos = false;\n            if (mapa[r][c] == '1') todosCeros = false;\n        }\n    }\n    if (todosUnos) return \"1\";\n    if (todosCeros) return \"0\";\n    string resultado = \"D\";\n    int mitadFilas = filas / 2 + (filas % 2);\n    int mitadColumnas = columnas / 2 + (columnas % 2);\n    resultado += BtoD(mapa, i, j, mitadFilas, mitadColumnas);\n    resultado += BtoD(mapa, i, j + mitadColumnas, mitadFilas, columnas - mitadColumnas);\n    resultado += BtoD(mapa, i + mitadFilas, j, filas - mitadFilas, mitadColumnas);\n    resultado += BtoD(mapa, i + mitadFilas, j + mitadColumnas, filas - mitadFilas, columnas - mitadColumnas);\n    return resultado;\n}\n\nstring DtoB(string &mapa, int &pos, int filas, int columnas) {\n    if(!filas || !columnas){\n        return \"\";\n    }\n    char bit = mapa[pos++];\n    if (bit != 'D') {\n        return string(filas * columnas, bit);\n    }\n    int mitadFilas = filas / 2 + (filas % 2);\n    int mitadColumnas = columnas / 2 + (columnas % 2);\n    string parte1 = DtoB(mapa, pos, mitadFilas, mitadColumnas);\n    string parte2 = DtoB(mapa, pos, mitadFilas, columnas - mitadColumnas);\n    string parte3 = DtoB(mapa, pos, filas - mitadFilas, mitadColumnas);\n    string parte4 = DtoB(mapa, pos, filas - mitadFilas, columnas - mitadColumnas);\n    string resultado;\n    for (int i = 0; i < mitadFilas; ++i) {\n        resultado += parte1.substr(i * mitadColumnas, mitadColumnas) + parte2.substr(i * (columnas - mitadColumnas), columnas - mitadColumnas);\n    }\n    for (int i = 0; i < filas - mitadFilas; ++i) {\n        resultado += parte3.substr(i * mitadColumnas, mitadColumnas) + parte4.substr(i * (columnas - mitadColumnas), columnas - mitadColumnas);\n    }\n    return resultado;\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    char formato;\n    int filas, columnas;\n    cin >> formato >> filas >> columnas;\n    string mapa;\n    cin >> mapa;\n    if (formato == 'B') {\n        vector<vector<char>> mapaMatriz(filas, vector<char>(columnas));\n        for (int i = 0; i < filas; ++i) {\n            for (int j = 0; j < columnas; ++j) {\n                mapaMatriz[i][j] = mapa[i * columnas + j];\n            }\n        }\n        cout << \"D \" << filas << \" \" << columnas << endl;\n        cout << BtoD(mapaMatriz, 0, 0, filas, columnas) << endl;\n    } else {\n        int pos = 0;\n        cout << \"B \" << filas << \" \" << columnas << endl;\n        cout << DtoB(mapa, pos, filas, columnas) << endl;\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "6881. Gasolineras",
        "url": "https://omegaup.com/arena/problem/Gasolineras/",
        "descripcion": "En un círculo hay N gasolineras. Las gasolineras están numeradas de 0 a (N-1) inclusive. Tienes la siguiente información respecto a las gasolineras: La cantidad de gasolina que esa gasolinera en particular da, y. La distancia de esa gasolinera a la siguiente gasolinera en kilometros. Inicialmente, tienes un carro con un tanque de capacidad infinita y sin gasolina. Quieres hacer un recorrido que pase por todas las gasolineras. Debes empezar el recorrido en cualquiera de las gasolineras. Calcula la gasolinera con menor numeración donde la camioneta podrá completar el círculo. Considera que la camioneta se detendrá en cada gasolinera y tomará toda la gasolina que tenga. La camioneta se moverá un kilómetro por cada litro de gasolina.",
        "entrada": "En la primera línea un entero, N. Las siguientes N líneas contienen un par de enteros cada una, la cantidad de gasolinera que ofrece esa gasolinera y la distancia entre esa gasolinera y la siguiente.",
        "salida": "Un solo entero, un entero que será el mínimo índice en el cual se puede empezar el recorrido.",
        "nivel": "Avanzado (medio) - Programación competitiva",
        "categorias": [
            "Vectores",
            "Técnica de dos apuntadores",
            "Colas"
        ],
        "estructuras": [
            "long long",
            "vector<long long>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n     cout.tie(0);\n      long long a, b, c, d, e, f=1, g, h;\n   vector<long long>num;\n     cin>>a;\n   for(auto i=0; i<a; i++){\n       cin>>b>>e;\n        num.push_back(b-e);\n   }\n b=1;\n  e=num[0];\n while(b<a){\n       if(e>=0){\n         b++;\n          d=(d+1)%a;\n            e+=num[d];\n        }\n     else{\n         b--;\n          e-=num[c];\n            c=(c+1)%a;\n        }\n }\n cout<<c;\n      \n  return 0;\n}\n"
    },
    {
        "titulo": "10867. Antivirus",
        "url": "https://omegaup.com/arena/problem/Antivirus/",
        "descripcion": "El famoso virus de CODEVID-10011 a llegado a los laboratorios de informática de Bachilleres 2, un profesor asustado de que este virus afecte a todas las computadoras del laboratorio te pidió tu ayuda para que elimines a todos los números infectados. A un número k le puedes aplicar la operación ANALIZAR: que consiste en reemplazar el número por la suma del cuadrado de sus dígitos. Por ejemplo, si tenemos el número 13 y le aplicamos la operación ANALIZAR nos quedaría: 1^2+3^2=10. Luego a este número le podemos volver aplicar la operación ANALIZAR y así sucesivamente. Se dice que K es un número infectado si después de cierta cantidad de operaciones ANALIZAR el número es 1. El profesor no conoce con precisión la ubicación de estos números por tanto te dará t números y tu tarea será encontrar el siguiente número infectado más pequeño.",
        "entrada": "La primera línea de entrada es un entero t (1<=t<=10^6), seguido de t líneas con un entero k (0<=k<=10^6).",
        "salida": "La única línea de salida para cada k_i consiste en el siguiente número infectado más pequeño para el número dado k_i. Si el entero k_i, es un número infectado en sí mismo, entonces, el siguiente número infectado más pequeño debe imprimirse como salida.",
        "nivel": "Avanzado (medio) - Programación competitiva",
        "categorias": [
            "Vectores",
            "Cálculo matemático",
            "Programación dinámica"
        ],
        "estructuras": [
            "bool",
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<short>estado(1000004,-1);\n\n// Funcion para calcular la suma del cuadrado de los digitos\nint analizar(int num) {\n    int suma = 0;\n while (num > 0) {\n     int digito = num % 10;\n        suma += digito * digito;\n      num /= 10;\n    }\n return suma;\n}\n\n// Funcion recursiva para determinar si un numero es infectado\nbool es_infectado(int num) {\n    if(estado[num]!=-1){\n      return estado[num];\n   }\n estado[num]=0;\n    estado[num]=es_infectado(analizar(num));\n  return estado[num];\n}\n\nint main() {\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  estado[1]=1;\n  int t;\n    cin >> t;\n while (t--) {\n     int k;\n        cin >> k;\n     k++;\n      // Busqueda del siguiente numero infectado\n        while (!es_infectado(k)) {\n            k++;\n      }\n     cout << k << \"\\n\";\n }\n\n   return 0;\n}\n"
    },
    {
        "titulo": "4800. Juanito y los primos",
        "url": "https://omegaup.com/arena/problem/Juanito-y-los-primos/",
        "descripcion": "Dado un entero \\delta, decir si \\delta es primo o no.",
        "entrada": "La entrada consiste en un solo entero \\delta (1<=\\delta<=10^18) que representa la puntuación de Juanito.",
        "salida": "Si \\delta no es primo, imprimir \"no es primo\", en caso contrario imprimir \"si es primo\".",
        "nivel": "Avanzado (medio) - Programación competitiva",
        "categorias": [
            "Teoría de numeros"
        ],
        "estructuras": [
            "bool",
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n// Funcion para determinar si un numero es primo\nbool esPrimo(ll delta) {\n    if (delta <= 1) return false;\n    if (delta <= 3) return true;\n    if (delta % 2 == 0 || delta % 3 == 0) return false;\n    for (ll i = 5; i * i <= delta; i += 6) {\n        if (delta % i == 0 || delta % (i + 2) == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    ll delta;\n    cin >> delta;\n    if (esPrimo(delta)) {\n        cout << \"si es primo\" << endl;\n    } else {\n        cout << \"no es primo\" << endl;\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "11799. Numeración Maya",
        "url": "https://omegaup.com/arena/problem/Numeracion-Maya/",
        "descripcion": "El lenguaje de Maya++ esta codificado vigesimal (es decir, base 20). Esta numeración esta dada por los siguientes simbolos y sus valores de la numeración decimal: ?=0, *=1, -=5. Recordemos que en la numeración maya si la cantidad de * modulo 5 es igual a 0 se sustituye los * por un -. A continuación mostramos algunas equivalencias con el sistema decimal: ?/=0, */=1, **/=2, -/=5, --/=10, --*/=11, ?/*/=20, */*/=21. Escribe un programa que convierte un número entero de sistema decimal a una cadena que representa su valor en la númeración maya dado con las condiciones anteriores y viceversa.",
        "entrada": "En la primera línea un entero T que indica el tipo de converción que vas hacer (1 -decimal a numeración maya, 2 -numeración maya a decimal), en la segunda línea un entero n o una cadena s dependiendo del tipo de conversión.",
        "salida": "La cadena s que representa a x si T=1, o el entero x que representa a s si T=2.",
        "nivel": "Avanzado (fácil) - Programación competitiva",
        "categorias": [
            "Caracteres y cadenas",
            "Cálculo matemático"
        ],
        "estructuras": [
            "long long",
            "vector<long long>",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  long long a, b=14, c, d, e, f, g, h;\n  long long num[]={1, 20, 400, 8000, 160000, 3200000, 64000000, 1280000000, 25600000000, 512000000000, 10240000000000, 204800000000000, 4096000000000000, 81920000000000000, 1638400000000000000};\n  string z, x;\n  cin>>a;\n   if(a==1){\n     cin>>a;\n       if(!a){\n           cout<<\"?/\";return 0;\n        }\n     while(num[b]>a){\n          b--;\n      }\n     for(; b>=0; --b){\n         c=a/num[b];\n           switch(c){\n                case 0: z=\"?/\"+z;break;\n             case 1: z=\"*/\"+z;break;\n             case 2: z=\"**/\"+z;break;\n                case 3: z=\"***/\"+z;break;\n               case 4: z=\"****/\"+z;break;\n              case 5: z=\"-/\"+z;break;\n             case 6: z=\"-*/\"+z;break;\n                case 7: z=\"-**/\"+z;break;\n               case 8: z=\"-***/\"+z;break;\n              case 9: z=\"-****/\"+z;break;\n             case 10: z=\"--/\"+z;break;\n               case 11: z=\"--*/\"+z;break;\n              case 12: z=\"--**/\"+z;break;\n             case 13: z=\"--***/\"+z;break;\n                case 14: z=\"--****/\"+z;break;\n               case 15: z=\"---/\"+z;break;\n              case 16: z=\"---*/\"+z;break;\n             case 17: z=\"---**/\"+z;break;\n                case 18: z=\"---***/\"+z;break;\n               case 19: z=\"---****/\"+z;break;\n          }\n         a%=num[b];\n        }\n     cout<<z;\n  }\n else{\n     cin>>z;\n       for(auto i=0; i<z.size(); ++i){\n            if(z[i]=='/'){\n                if(x==\"?\"){\n                 b=0;\n              }\n             else if(x==\"*\"){\n                    b=1;\n              }\n             else if(x==\"**\"){\n                   b=2;\n              }\n             else if(x==\"***\"){\n                  b=3;\n              }\n             else if(x==\"****\"){\n                 b=4;\n              }\n             else if(x==\"-\"){\n                    b=5;\n              }\n             else if(x==\"-*\"){\n                   b=6;\n              }\n             else if(x==\"-**\"){\n                  b=7;\n              }\n             else if(x==\"-***\"){\n                 b=8;\n              }\n             else if(x==\"-****\"){\n                    b=9;\n              }\n             else if(x==\"--\"){\n                   b=10;\n             }\n             else if(x==\"--*\"){\n                  b=11;\n             }\n             else if(x==\"--**\"){\n                 b=12;\n             }\n             else if(x==\"--***\"){\n                    b=13;\n             }\n             else if(x==\"--****\"){\n                   b=14;\n             }\n             else if(x==\"---\"){\n                  b=15;\n             }\n             else if(x==\"---*\"){\n                 b=16;\n             }\n             else if(x==\"---**\"){\n                    b=17;\n             }\n             else if(x==\"---***\"){\n                   b=18;\n             }\n             else if(x==\"---****\"){\n                  b=19;\n             }\n             c+=num[d]*b;\n              d++;\n              x=\"\";\n           }\n         else{\n             x=x+z[i];\n         }\n     }\n     cout<<c;\n  }\n\n   return 0;\n}\n"
    },
    {
        "titulo": "11649. Tabla de ganar",
        "url": "https://omegaup.com/arena/problem/Tabla-de-ganar/",
        "descripcion": "Jugaran el juego de \"Tabla de ganar\" el cual consiste en un tablero de N X N en donde pueden existir o no piedras en el tablero cumpliendo la siguiente condición. Si existe una piedra en la coordenada (i,j) no puede existir otra piedra en esa misma fila i y columna j. El juego consiste que dado el tablero de N X N: Se jugará por turnos en donde se colocarán piedras en el tablero respetando la condición antes mencionada. El primer turno será siempre del hombre misterioso. Cuando en el turno de un jugador ya no se pueda poner piedras, este habrá perdido. Dado un número t de partidas que van a jugar teniendo cada una un tablero diferente, ayuda a los programadores mayas a saber quién ganará la partida. Se te asegura que los dos jugadores jugaran de manera óptima.",
        "entrada": "Un número t, el número de partidas. Para cada partida un número N, el tamaño del tablero, seguido de N cadenas de caracteres de tamaño N que contiene dígitos en donde si es 1, significa que en esa coordenada hay una piedra y si es 0 significa que esta vacia.",
        "salida": "Para cada una de las partidas muestra \"Hombre misterioso\" o \"Programadores mayas\" sin comillas, según quien haya ganado la partida.",
        "nivel": "Avanzado (fácil) - Programación competitiva",
        "categorias": [
            "Teoría de juegos"
        ],
        "estructuras": [
            "char",
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  int a, b, c, e, f, g, h;\n  char d;\n   cin>>a;\n   while(a--){\n       cin>>b;\n       c=0;\n      e=b;\n      b*=b;\n     while(b--){\n           cin>>d;\n           c+=(int)d-48;\n     }\n     cout<<(((e-c)%2)?\"Hombre misterioso\\n\":\"Programadores mayas\\n\");\n    }\n \n  return 0;\n}\n"
    },
    {
        "titulo": "11597. Primer combate",
        "url": "https://omegaup.com/arena/problem/Primer-combate/",
        "descripcion": "La batalla se desenvolvera en una barranca de longitud N. Los programadores mayas inicialmente estan en la posición 1, representado con la letra M, el Malvado Robot OMI en la posición 2 representado por la letra R y los espacios vacios de la barranca represetados por la letra O. La batalla sucede de la siguiente manera: Los programadores mayas buscan llevar al Malvado Robot OMI hasta la posición N para tirarlo de la barranca avanzaNdo 1 posición en cada segundo del combate. El Malvado Robot OMI cuando está en cualquier posición 1<=j<=N y los programadores mayas se encuentran en la posición de j-1 utiliza su poder de teletransportar, que consiste en teletransportar a los programadores mayas a la posición número 1 y genera una explosión que lo impulsa a la posición j+1. Por ejemplo, para N=5 el combate se ve de la siguiente manera deacuerdo a su duración en segundos: MROOO, MOROO, OMROO, MOORO, OMORO, OOMRO, MOOOR, OMOOR, OOMOR, OOOMR. Para tener ventaja respecto al Malvado Robot OMI, se quiere saber en que posición estarían los programadores mayas y el Malvado Robot OMI en el segundo K. Se te darán varios casos de este problema, para ser más concisos tendrás que resolver T casos. En cada caso se te dará la longitud de la barranca y el segundo que se quiere saber la posición. Para cada caso deberás responder como se vería la batalla en el segundo dado.",
        "entrada": "Se te dara T casos de prueba con dos enteros cada uno, N_i y K_i.",
        "salida": "T líneas separadas por un salto de línea con dos enteros cada una. a_i y b_i, la posición de los programadores mayas y la posición del Malvado Robot Maya en el segundo K_i.",
        "nivel": "Avanzado (fácil) - Programación competitiva",
        "categorias": [
            "Cálculo matemático"
        ],
        "estructuras": [
            "long long",
            "sqrt()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  long long a, b, c, d, e, f, g, h;\n cin>>a;\n   while(a--){\n       cin>>b>>c;\n        b=c*2;\n        b=sqrt(b);\n        b=max((long long)0,b-3);\n      while((b+1)*b/2<c){\n           b++;\n      }\n     c-=(b-1)*b/2;\n     if(c){\n            cout<<c<<\" \"<<b+1<<\"\\n\";\n     }\n     else{\n         cout<<b<<\" \"<<b+1<<\"\\n\";\n     }\n }\n \n  return 0;\n}\n"
    },
    {
        "titulo": "11153. Primer divisor",
        "url": "https://omegaup.com/arena/problem/Primer-divisor/",
        "descripcion": "Un estudiante esta estudiando teoria de números y le sorprendio las propiedades de los divisores. Para dos enteros positivos a y b, a es un divisor de b si y solo si existe un entero c tal que a*c=b. Para n>=2 denotaremos la función f(n) que nos da como resultado el divisor positivo más pequeño de n, excepto 1. Por ejemplo, f(7)=7, f(10)=2, f(35)=5. El estudiante queria poner un problema en el examen con estas características pero le parecía muy facil, entonces se le ocurrio que al entero n se le puede agregar f(n), esto lo puede hacer varias veces, obteniendo asi lo siguiente: n, n_1=n+f(n), n_2=n_1+f(n_1), n_3=n_2+f(n_2), ..., n_k=n_(k-1)+f(n_(k-1)). Por ejemplo, si tuvieramos a n=5 el valor de n_1 seria igual a 5+5=10, si n=6, tendriamos n_1=6+2=8. Al estudiante le gusto mucho la nueva operación, entonces te pedira encontrar el k-esimo valor de n para t casos de prueba. Por ejemplo, si n=5 y k=2 tenemos que n_1=5+5=10, n_2=10+2=12. Encuentra el valor de n_k para los t casos.",
        "entrada": "Se te dara un número t (1<=t<=10^5), seguido de eso t líneas con dos enteros n (2<=n<=10^6) y k (1<=k<=10^8).",
        "salida": "Seran t numeros separados por un salto de línea con el valor de n_k.",
        "nivel": "Avanzado (fácil) - Programación competitiva",
        "categorias": [
            "Teoría de numeros"
        ],
        "estructuras": [
            "int",
            "sqrt()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint binario(int b, int c){\n //Optimizacion; Inicia en el 3, ya que se descarto al 2 como uno de sus divisores\n int d=3, raiz=sqrt(b);\n    while(d<=raiz){\n       if(b%d==0){\n           break;\n        }\n     //Optimizacion: Avanza de 2 en 2, ya que el 2 (que ya se descarto) es el unico primo par\n      d+=2;\n }\n return ((b%d==0)?b+d+--c*2:b*2+--c*2);\n}\n\nint main(){\n      cin.tie(0);\n   ios_base::sync_with_stdio(0);\n     cout.tie(0);\n      int a, b, c;\n      cin>>a;\n   while(a--){\n       cin>>b>>c;\n        cout<<((b%2)?binario(b,c):b+c*2)<<\"\\n\";\n    }\n \n  return 0;\n}\n"
    },
    {
        "titulo": "11152. Calculadora Binaria",
        "url": "https://omegaup.com/arena/problem/Calculadora-Binaria/",
        "descripcion": "Un estudiante quiere crear una calculadora especial, la cual haga problemas en binario, el problema es que él no sabe binario, entonces te pide tu ayuda para crear una calculadora. Recordemos que un número binario esta compuesto por las potencias de 2, por ejemplo, si tenemos el número k=100101, el valor del números es igual a 2^0*1+2^1*0+2^2*1+2^3*0+2^4*0+2^5*1, definamos a n como la ultima posicion de nuestro número binario, siendo la primera 0. De esta manera podemos decir que k_0=1, k_1=0, k_2=1, ..., k_n=1. La calculadora funciona con dos números A y B, realiza 3 tipos de operaciones. 1: Es la suma de todas las i que cumple con la siguiente condición: A_i=B_i=1. 2: Es la suma de todas las i que cumple con la siguiente condición: A_i=B_i=0. 3: Es la suma de todas las i que cumplen con la siguiente condición: A_i!=B_i. Las operaciones se realizan para todas las 0<=i<=max(n_A,n_B). Tu tarea sera crear la calculadora para dos números enteros a y b con las operaciones 1, 2 y 3.",
        "entrada": "Se te daran los números A, B y t (1<=t<=3), siendo A y B los valores a los cuales se les aplicara la operación de tipo t.",
        "salida": "Un unico número entero el cual sera el resultado de la operación de tipo t con los números A y B.",
        "nivel": "Avanzado (fácil) - Programación competitiva",
        "categorias": [
            "Caracteres y cadenas",
            "Cálculo matemático"
        ],
        "estructuras": [
            "long long",
            "char",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid binario(int ax, string &bx){\n  char z;\n   while(ax){\n        z=48+ax%2;\n        bx=z+bx;\n      ax/=2;\n    }\n}\n\nint main(){\n   cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  long long a, b, c, d=0, e, i, j;\n  string x, y;\n  cin>>a>>b>>c;\n binario(a,x);\n binario(b,y);\n e=(x.size()<y.size())?1:2;\n    while(fabs(x.size()-y.size())){\n       (e==1)?x=\"0\"+x:y=\"0\"+y;\n   }\n for(i=j=x.size()-1; i>=0; i=j=j-1){\n       x[i]-=48;\n     y[j]-=48;\n     ((c==1 && x[i] && y[j]) || (c==2 && !x[i] && !y[j]) || (c==3 && x[i]-y[j]))?d+=x.size()-1-i:d+=0;\n }\n cout<<d;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "239. Dos Alfiles",
        "url": "https://omegaup.com/arena/problem/DosAlfiles/",
        "descripcion": "Como es bien sabido en las familias de los reyes, el rey blanco y el rey negro, han estado en guerras desde hace siglos, no se sabe aun por que nunca termina su larga contienda, esta vez ellos desean enfrentarse solo con sus alfiles. Como siempre, se enfrentaran en un terreno típico, lleno de cuadrados (tablero de ajedrez), los terrenos de batalla los hay de diferentes tamaños pero siempre son cuadrados. Tu como un consejero real, le debes de informar a tu rey, quien es el rey que tiene mas probabilidades de ganar (el rey que posee en el tablero el mayor numero de piezas). Y cuantas de estas pacificas piezas debes de enviar. Considerando que los alfiles, son piezas de las cuales no les gusta mucho la guerra, es mas, ningún alfil tanto negro como blanco desean atacarse entre si, por lo que debes de enviar el numero correcto de piezas de ajedrez, de manera que ningún alfil ataque a otro alfil aun siendo del mismo bando debes decir cual es el maximo numero de alfiles a enviar por rey, de lo contrario serás perseguido por la santa inquisición.",
        "entrada": "Un entero N (1<=N<=2^64) que indica el tamaño del tablero de ajedrez (N*N).",
        "salida": "Un entero A que indica la cantidad de alfiles que deba de enviar cada rey para la contienda, si un rey envia mas alfiles se toma en cuenta el maximo numero de alfiles que envie el rey que pueda enviar mas piezas. (en el caso de que el numero de piezas de los alfiles sea impares, se le da la ventaja segun el tablero en el que se encuentre, si N es par, se le da la ventaja al rey negro, si N es impar, al rey blanco) ademas debes informar sobre las K (K modulo 10) formas posibles en que puedes acomodar los alfiles. Despues, una cadena C que diga \"TABLAS\" si las probabilidades de ganar son iguales para los dos reyes, o \"KW\" si el rey blanco tiene mas probabilidades de ganar, o \"KB\" en el caso que el rey negro tenga mas posibilidades.",
        "nivel": "Avanzado (fácil) - Programación competitiva",
        "categorias": [
            "Teoría de numeros"
        ],
        "estructuras": [
            "unsigned long long",
            "pow()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nunsigned long long alfiles(unsigned long long n) {\n    return n-1;//(n + max(0ULL, n - 2) ) / 2\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    unsigned long long n;\n    cin >> n;\n    if(n==1){\n        cout<<\"1 1 KW\";return 0;\n    }\n    unsigned long long totalAlfiles = alfiles(n);\n    unsigned long long k = (unsigned long long)pow(2,n%4) % 10;\n    if(k==1){\n        k=6;\n    }\n    cout << totalAlfiles << \" \" << k << \" \";\n    if (totalAlfiles*2 % 2 == 0) {\n        cout << \"TABLAS\\n\";\n    } else {\n        if (n % 2 == 0) {\n            cout << \"KB\\n\";\n        } else {\n            cout << \"KW\\n\";\n        }\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "169. Metro",
        "url": "https://omegaup.com/arena/problem/metro/",
        "descripcion": "En el mushroom kingdom desean crear una red de líneas de tren subterráneo que conecte todo el reino. El mushroom kingdom cuenta con n (3<=n<=30000) estaciones numeradas de 1 a n, las cuales deben conectarse con vías. Para ello, se han realizado estudios que permitieron calcular cuál sería el costo c (1<=c<=1000) de conectar la estación i con la estación j (1<=i,j<=n, con i distinto de j) para m (2<=m<=200000) pares de estaciones i,j. Como se quiere hacer un uso eficiente de los recursos, te han encomendado la creación de un programa que determine cuál es el costo mínimo de unir todas las estaciones, es decir, cuál es el menor costo posible para construir vías que permitan llegar desde cualquier estación a cualquier otra. Debes tomar en cuenta las siguientes consideraciones: #1. Siempre será posible conectar todas las estaciones con los pares i,j dados en la entrada. #2. Si el par i,j aparece en la entrada, no aparecerá el par j,i ni habrá repeticiones.",
        "entrada": "La primera línea de la entrada tendrá 2 enteros n (3<=n<=30000) y m (2<=m<=200000), el número de estaciones y el número de posibles tramos a construir. Las siguientes m líneas contendrán la descripción de un posible tramo con 3 enteros i, j y c (1<=c<=1000), donde i y j (1<=i,j<=n) son las estaciones a conectarse y c es el costo que tendría su construcción.",
        "salida": "Un único número, el menor costo resultante de conectar todas las estaciones.",
        "nivel": "Avanzado (fácil) - Programación competitiva",
        "categorias": [
            "Vectores",
            "Ordenamiento",
            "Recursión",
            "Grafos"
        ],
        "estructuras": [
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Edge {\n    int u, v, w;\n    bool operator<(const Edge& other) const {\n        return w < other.w;\n    }\n};\n\nvector<Edge> edges;\nvector<int> parent;\n\nint find(int x) {\n    if (parent[x] != x) {\n        parent[x] = find(parent[x]);\n    }\n    return parent[x];\n}\n\nvoid unionSets(int x, int y) {\n    int rootX = find(x);\n    int rootY = find(y);\n    parent[rootX] = rootY;\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int n, m;\n    cin >> n >> m;\n    edges.resize(m);\n    parent.resize(n + 1);\n    for (int i = 0; i < m; ++i) {\n        cin >> edges[i].u >> edges[i].v >> edges[i].w;\n    }\n    sort(edges.begin(), edges.end());\n    for (int i = 1; i <= n; ++i) {\n        parent[i] = i;\n    }\n    int totalCost = 0;\n    for (const Edge& edge : edges) {\n        if (find(edge.u) != find(edge.v)) {\n            unionSets(edge.u, edge.v);\n            totalCost += edge.w;\n        }\n    }\n    cout << totalCost << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "19753. Estudiando las Ruinas",
        "url": "https://omegaup.com/arena/problem/Estudiando-las-Ruinas/",
        "descripcion": "La Universidad, donde Santy gobierna, es tan antigua que muchos la consideran una ruina. Existen partes que ya no tienen ni suelo. Santy, como buen director, ha decidido restaurar el lugar. Un alumno ha hecho un mapa del lugar, por suerte el perímetro de la universidad se encuentra intacto gracias a unas luces colocadas alrededor. Pero por dentro hay huecos que hay que cubrir. Tu tarea consiste únicamente en contar la cantidad de huecos que hay en las ruinas. El mapa del lugar consiste en una matriz de N x M que contiene unos y ceros, donde un cero representa una zona vacía y un uno una parte completa de las ruinas. El perímetro de las ruinas se encuentra intacto, por lo que podemos distinguir el área exterior de las partes vacías de las ruinas por el área delimitada por los unos.",
        "entrada": "Dos enteros i<=N,M<=1000 que representan las dimensiones del mapa. Luego, los elementos a_(i,j)=0,1 del mapa, donde 0 representa un lugar fuera de las ruinas o un lugar a restaurar, y un 1 una zona firme de las ruinas.",
        "salida": "Deberás imprimir la cantidad de lugares a restaurar dentro de las ruinas.",
        "nivel": "Intermedio (difícil) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Matrices",
            "Búsqueda en amplitud"
        ],
        "estructuras": [
            "int",
            "pair<int,int>",
            "vector<pair<int,int>>",
            "vector<vector<int>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int a, b, c, e, f, g, h, n,m;\n    cin>>n>>m;\n    vector<vector<int>> escuela(n+2,vector<int>(m+2,0));\n    for(auto i = 1; i<=n;i++){\n        for(auto j=1;j<=m;j++){\n            cin>>a;\n            if(a){\n                escuela[i][j]=0;\n            }\n            else{\n                escuela[i][j]=1;\n                b++;\n            }\n        }\n    }\n    vector<pair<int,int> >z;\n    pair<int,int>zz;\n    for(auto i = 1; i<=n;i++){\n        if(escuela[i][1]==1){\n            b--;\n            escuela[i][1]=0;\n            z.push_back({i,1});\n        }\n        if(escuela[i][m]==1){\n            b--;\n            escuela[i][m]=0;\n            z.push_back({i,m});\n        }\n            \n    }\n    for(auto i = 1; i<=m;i++){\n        if(escuela[1][i]==1){\n            b--;\n            escuela[1][i]=0;\n            z.push_back({1,i});\n        }\n        if(escuela[n][i]==1){\n            b--;\n            escuela[n][i]=0;\n            z.push_back({n,i});\n        }\n    }\n    while(z.size()){\n        zz=z.back();\n        z.pop_back();\n        int i=zz.first, j=zz.second;\n            if(escuela[i-1][j]){\n                b--;\n                escuela[i-1][j]=0;\n                z.push_back({i-1,j});\n            }\n            if(escuela[i+1][j]){\n                b--;\n                escuela[i+1][j]=0;\n                z.push_back({i+1,j});\n            }\n            if(escuela[i][j-1]){\n                b--;\n                escuela[i][j-1]=0;\n                z.push_back({i,j-1});\n            }\n            if(escuela[i][j+1]){\n                b--;\n                escuela[i][j+1]=0;\n                z.push_back({i,j+1});\n            }\n    }\n    cout<<b;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "141. Oro",
        "url": "https://omegaup.com/arena/problem/oro/",
        "descripcion": "Una compañía de venta de oro necesita tu ayuda para saber cuál es el menor exceso que puede tener. La compañía tiene registradas N rocas que contienen oro. Para obtener ese oro la compañía tiene que elegir algunas rocas y destruirlas quedándose con el oro que contenían. El problema es que tener exceso de oro implica tener que resguardarlo y eso es muy costoso.",
        "entrada": "N (1<=N<=20) y B (1<=B<=[sum_{i=0}^{N-1}O_i]). El número de rocas y el total de oro requerido, respectivamente. N líneas, cada una con un entero O_i (1<=O_i<=10^6) que es la cantidad de oro que tiene cada roca.",
        "salida": "Un solo entero con el exceso mínimo de oro, dado que se obtuvieron B unidades de oro.",
        "nivel": "Intermedio (difícil) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Vectores",
            "Colas",
            "Ordenamiento",
            "Búsqueda en amplitud"
        ],
        "estructuras": [
            "long long",
            "vector<long long>",
            "pair<long long,long long>",
            "queue<pair<long long,long long>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c=1000001;\n    queue<pair<long long,long long>>falta;\n    pair<long long,long long> z;\n    cin>>a>>b;\n    vector<long long>num(a);\n    for(auto i=0; i<a; i++){\n        cin>>num[i];\n    }\n    sort(num.begin(),num.end());\n    for(auto i=a-1; i>0; i--){\n        if(num[i]>=b){\n            c=num[i];\n        }\n        else{\n            z.first=num[i];\n            z.second=i;\n            falta.push(z);\n        }\n    }\n    if(num[0]>=b){\n        c=num[0];\n    }\n    while(falta.size()){\n        z=falta.front();\n        falta.pop();\n        for(auto i=z.second-1; i>0; i--){\n            z.first+=num[i];\n            if(c>z.first && z.first>=b){\n                c=z.first;\n            }\n            else if(z.first<b){\n                z.second=i;\n                falta.push(z);\n            }\n            z.first-=num[i];\n        }\n        z.first+=num[0];\n        if(c>z.first && z.first>=b){\n            c=z.first;\n        }\n    }\n    cout<<c-b;\n \n    return 0;\n}\n"
    },
    {
        "titulo": "1342. Nieves y el merge-sort",
        "url": "https://omegaup.com/arena/problem/Nieves-y-el-merge-sort/",
        "descripcion": "El merge-sort es un algoritmo que ordena, ya sea creciente o decreciente, un arreglo. La idea viene de partir el arreglo a ordenar en 2 subarreglos del mismo tamaño, ordenarlos y luego unir estos 2 subarreglos de tal forma que el arreglo unido siga ordenado. Para unir éstos dos subarreglos se mete cada uno en una cola(*), se va comparando cada elemento inicial de las 2 colas, se decide cual es el menor (o mayor) y se agrega dicho elemento al arreglo ordenado (y se elimina el elemento de la cola corespondiente). Esto se hace hasta que no queden elementos en las colas. Para ordenar los subarreglos se puede usar, recursivamente, el merge-sort. La recursión acaba cuando se llega a subarreglos triviales (de tamaño 1). Un ejemplo: (8 7 6 5 4 3 2 1) <- arreglo a ordenar. (8 7 6 5) -- (4 3 2 1) <- subarreglos. (5 6 7 8) -- (1 2 3 4) <- se ordenan (recursion) y se meten a sus respectivas colas, donde los primero elementos a comparar serán el (5) y el (1), por lo tanto se va a escoger el elemento (1); luego el (5) con el (2), luego el (5) con el (3)... quedando: (1 2 3 4 5 6 7 8).; Nieves (el viejo), después de tantos años sin programar, decidio implementar éste algoritmo para ordenar un arreglo de manera creciente. Sin embargo cometió un error a la hora de meter los subarreglos ordenados a las colas: El subarreglo izquierdo si lo metió a una cola, sin embargo el subarreglo derecho lo metió a una pila(**). El resto del algoritmo lo siguió al pie de la letra. Usando el mismo ejemplo, a la hora de unir los subarreglos, se compararía el elemento (5) con el elemento (4); luego el elemento (5) con el (3), luego el (5) con el (2)... quedando: (4 3 2 1 5 6 7 8). Tu labor será imitar el código de Nieves para ayudarle en un futuro no muy lejano. (**) La cola es una estructura de datos llamada FIFO = First In First Out (primero en llegar, primero en salir). (*) La pila es una estructura de datos llamada FILO = First In Last Out (primero en llegar, último en salir).",
        "entrada": "Primera línea: n (0<n<=65536, n siemore sera una potencia de 2), la cantidad de elementos a ordenar. Segunda línea: x_1, x_2, ..., x_n, los x_i (0<=x_i<=10^7) elementos a ordenar separados por un espacio.",
        "salida": "Los n números separados por un espacio y ordenados según el algoritmo de Nieves.",
        "nivel": "Intermedio (difícil) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Vectores",
            "Ordenamiento"
        ],
        "estructuras": [
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid merge(vector<int>& arr, int l, int m, int r) {\n    int n1 = m - l + 1;\n    int n2 = r - m;\n    vector<int> L(n1), R(n2);\n    for (int i = 0; i < n1; i++)\n        L[i] = arr[l + i];\n    for (int j = 0; j < n2; j++)\n        R[j] = arr[m + 1 + j];\n    int i = 0, j = n2 - 1, k = l; \n    while (i < n1 && j >= 0) {\n        if (L[i] <= R[j]) {\n            arr[k] = L[i];\n            i++;\n        } else {\n            arr[k] = R[j];\n            j--;\n        }\n        k++;\n    }\n    while (i < n1) {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n    while (j >= 0) {\n        arr[k] = R[j];\n        j--;\n        k++;\n    }\n}\n\nvoid mergeSort(vector<int>& arr, int l, int r) {\n    if (l < r) {\n        int m = l + (r - l) / 2;\n        mergeSort(arr, l, m);\n        mergeSort(arr, m + 1, r);\n        merge(arr, l, m, r);\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int n;\n    cin >> n;\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n    mergeSort(arr, 0, n - 1);\n    for (int i = 0; i < n; i++) {\n        cout << arr[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "1300. Suma Manhattan",
        "url": "https://omegaup.com/arena/problem/Suma-Manhattan/",
        "descripcion": "Dada una lista S de N puntos en el plano cartesiano, calcula la suma de las distancias Manhattan entre todas las parejas posibles de puntos. En otras palabras, calcula el valor de la siguiente expresión: [sum_{i=0}^{N-2}[sum_{j=i+1}^{N-1}manhattan(S_i,S_j)]], la cual es de complejidad cuadratica, recuerda que la distancia Manhattan entre dos puntos manhattan((p_1,p_2),(q_1,q_2)) es |p_1-q_1|+|p_2-q_2|, donde |x| representa el valor absoluto de x.",
        "entrada": "En la primer línea un entero N (N<=500000, por lo que 500000^2 seria muy grande), la cantidad de puntos. En las siguientes N líneas, dos enteros x_i y y_i (-10^8<=x_i,y_i<=10^8) representando las coordenadas de un punto.",
        "salida": "Un sólo entero: el resultado de evaluar la expresión requerida. Imprime el resultado módulo 1000000007 (10^9+7).",
        "nivel": "Intermedio (difícil) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Vectores",
            "Ordenamiento",
            "Aritmética modular",
            "Cálculo matemático"
        ],
        "estructuras": [
            "int",
            "vector<vector<>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n \nusing namespace std;\n\nint MOD=1000000007, N;\n \nint solve(int *p){\n    int i, ret=0;\n    sort(p,p+N);\n    for(i=0; i<N; i++){\n        ret=(ret+(long long)p[i]*(2*i-N+1))%MOD;\n    }\n    return ret+(ret<0?MOD:0);\n}\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int MAXN=500010;\n    cin>>N;\n    vector<vector<int>>(2,vector<int>(N+1));\n    for(auto i=0; i<N; i++){\n        cin>>points[0][i]>>points[1][i];\n    }\n    cout<<(solve(points[0])+solve(points[1]))%MOD;\n}\n"
    },
    {
        "titulo": "7920. Incrementando intervalos",
        "url": "https://omegaup.com/arena/problem/Incrementando-intervalos/",
        "descripcion": "Cuentas con un arreglo de N enteros que valen 0 inicialmente. Se te darán M intervalos con extremos I,F y para cada uno deberás incrementar los elementos del arreglo que están de la posición I a la posición F, sin incluir esta última. ¿Qué valor tendrán los elementos del arreglo después de procesar todos los intervalos?",
        "entrada": "Dos enteros N,M seguido de M parejas de enteros I,F que denotan los extremos de cada intervalo. Puedes suponer que 0<=N,M<=100000 y que 0<=I<=F<=N.",
        "salida": "Los N enteros del arreglo después de procesar todos los intervalos.",
        "nivel": "Intermedio (difícil) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Vectores",
            "Técnica de diferencias",
            "Suma de prefijos"
        ],
        "estructuras": [
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 100005; \nint arr[MAXN]; \n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int N, M;\n    cin >> N >> M;\n    // Aplicar la t?nica de diferencias\n    for(auto i = 0; i < M; i++) {\n        int I, F;\n        cin >> I >> F;\n        arr[I]++; \n        arr[F]--; \n    }\n    // Reconstruir el arreglo sumando las diferencias\n    for(auto i = 1; i < N; i++) {\n        arr[i] += arr[i - 1];\n    }\n    // Imprimir el arreglo resultante\n    for(auto i = 0; i < N; i++) {\n        cout << arr[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "10839. Equipo de Basket",
        "url": "https://omegaup.com/arena/problem/Equipo-de-Basquet/",
        "descripcion": "Se te dará una lista de N enteros que representan la altura de las personas y el orden en el que están formados. Deberás decir cuantos equipos de K personas puedes formar tal que estén todos juntos (una secuencia contigua) y que todos tengan alturas distintas.",
        "entrada": "Un número N que indica el número de personas y K que es la cantidad de personas que se necesitan para el equipo. Luego, la lista de N números A_i que representan la altura de las personas.",
        "salida": "Un único entero que representa la cantidad de equipos buenos que se pueden formar.",
        "nivel": "Intermedio (difícil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Vectores",
            "Tablas de dispersión",
            "Ventana deslizante"
        ],
        "estructuras": [
            "int",
            "vector<int>",
            "set<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    ios::sync_with_stdio(0);\n  cin.tie(0);\n   cout.tie(0);\n  int n, m, a, b, c=0, d, e, f, g, h;\n   vector<int>ar(100000,0);\n  set<int>ar2;\n  cin>>n>>m;\n    for(auto i=0; i<n; i++){\n      cin>>ar[i];\n   }\n a=0;\n  d=0;\n  while(a<n){\n       if(ar2.count(ar[a])){\n         while(ar[d]!=ar[a]){\n              ar2.erase(ar[d]);\n             d++;\n          }\n         d++;\n      }\n     else{\n         ar2.insert(ar[a]);\n        }\n     a++;\n      if(a-d>=m){\n           c++;\n      }\n     else if(a-d>m){\n           ar2.erase(ar[d]);\n     }\n }\n cout<<c;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "11817. Escolta",
        "url": "https://omegaup.com/arena/problem/Escolta/",
        "descripcion": "Dadas las estaturas de los estudiantes de cada grupo, debes elegir un estudiante por grupo tal que la diferencia entre el más alto y el más pequeño de los que elijas sea la mínima posible.",
        "entrada": "En la primera línea se darán 3 enteros N, M y K los cuales representa el tamaño de los grupos. En la segunda, tercera y cuarta línea se darán los conjuntos a, b y c, respectivamente, los cuales contendrán las estaturas de los estudiantes de cada grupo.",
        "salida": "Una única línea con 3 enteros que representen la altura de los alumnos que se debe elegir por grupo que cumpla la condición anteriormente descrita. Si hay más de una solución imprime cualquiera.",
        "nivel": "Intermedio (difícil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Vectores",
            "Colas",
            "Ordenamiento"
        ],
        "estructuras": [
            "int",
            "queue<int>",
            "pair<int,int>",
            "vector<pair<int,int>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef struct{\n    long long aa, bb, cc, dd;\n}sobras;\n\nlong long a, b, c, d, e, f, g, h;\nvector<pair<long long,long long> >falta;\nqueue<long long>aa;\nqueue<long long>bb;\nqueue<long long>cc;\nsobras sub;\n\nint main(){\n cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  cin>>a>>b>>c;\n while(a--){\n       cin>>d;\n       falta.push_back(make_pair(d,1));\n  }\n while(b--){\n       cin>>d;\n       falta.push_back(make_pair(d,2));\n  }\n while(c--){\n       cin>>d;\n       falta.push_back(make_pair(d,3));\n  }\n sort(falta.begin(),falta.end());\n  for(auto i=0; i<falta.size(); ++i){\n        switch(falta[i].second){\n          case 1: aa.push(i);break;\n         case 2: bb.push(i);break;\n         case 3: cc.push(i);break;\n     }\n }\n sub.dd=1000000000;\n    while(aa.size() && bb.size() && cc.size()){\n       a=min(min(falta[aa.front()].first,falta[bb.front()].first),falta[cc.front()].first);\n      b=max(max(falta[aa.front()].first,falta[bb.front()].first),falta[cc.front()].first);\n      if(b-a<sub.dd){\n           sub.dd=b-a;\n           sub.aa=aa.front();\n            sub.bb=bb.front();\n            sub.cc=cc.front();\n        }\n     if(aa.front()<=bb.front() && aa.front()<=cc.front()){\n         aa.pop();\n     }\n     else if(bb.front()<=aa.front() && bb.front()<=cc.front()){\n            bb.pop();\n     }\n     else if(cc.front()<=aa.front() && cc.front()<=bb.front()){\n            cc.pop();\n     }\n }\n cout<<falta[sub.aa].first<<\" \"<<falta[sub.bb].first<<\" \"<<falta[sub.cc].first;\n\n  return 0;\n}\n"
    },
    {
        "titulo": "11599. Ordenando tareas",
        "url": "https://omegaup.com/arena/problem/Ordenando-tareas/",
        "descripcion": "A los chicos de Yucatán se les conoce por ser muy cumplidos con sus tareas. El sistema que se tiene dentro del estados ha ido funcionando bien a lo largo de la olimpiada y se maneja de la siguiente forma: Cada problema esta numerado del 1 al 10^6. Cada vez que alguien empieza a resolver un problema ingresa su número en una plataforma y una vez que acabe de resolverlo (o intentar resolverlo) ingresa el número, pero en negativo. Por ejemplo, si se empezó a resolver el problema 5, se acabó y luego se empezó con el problema 1 y se terminó; la salida de la plataforma se vería algo como: [5,-5,1,-1]. Santy puso unas reglas para el ingreso de los datos en la plataforma: Por día, se debe intentar resolver por lo menos un problema. No se puede dejar de intentar un problema si ni siquiera se empezó. Al final del día todos los problemas que se empezaron deben estar terminados (no puedes desvelarte un día entero resolviendo problemas). Cada problema solo se puede intentar máximo 1 vez por día. Algunos ejemplos de días puedes ser: [5,1,-5,-1] Caso correcto. [5,-5,1,-1] Caso correcto.[5,1,-5] Dia incorrecto: El 1 se empezó ese día, pero nunca acabo. [5,-1,-5] Dia incorrecto: Se termino el problema 1 sin siquiera empezarlo. [5,-5,5,-5] Dia incorrecto: Se intento un problema más de una vez el mismo día. Los chicos de Yucatán ya habían pasado varios días sin que Santy los revise. Cuando de la nada un portal sale y succiona varias cosas cercanas, entre las cosas que el portal se llevo fue la maquina encargada de llevar el control de los días. Ellos no sabían muy bien que hacer, había personas al otro lado del portal pidiéndoles que los acompañen. Sin embargo, ellos sabían que si Santy llegaba y no veía el trabajo que habían hecho se iba a enojar. Lo que se descompuso fue la máquina que llevaba la sección de días, pero las entradas aún estaban allí. Es decir, si teníamos dos días [5,-5],[1,5,-5,-1] ahora sin la maquina perdida tenemos solos 5,-5,1,5,-5,-1. Los chicos de Yucatán saben que Santy no se enojara siempre y cuando haya un patrón lógico en la entrada (esto es que se cumplas las condiciones dichas anteriormente por día). Ayuda a los chicos de Yucatán encontrar alguna forma de partir las entradas en días válidos. Se te dará la lista de entradas que se tiene y deberás de decir una forma valida de partir los días. La forma es válida si cada día satisface las condiciones dichas anteriormente.",
        "entrada": "Un número n indicando el número de entradas. Seguido se te dará la lista de entradas que son enteros entre 1 y 10^6 ya sea negativos o positivos.",
        "salida": "Un número d indicando el número de días en los cuales partiste lo anterior. Tendrás que dar una lista de d números r_i, cada número representa el número de días que abarca el i-esimo día. Imprimir un -1 en caso de que no sea posible partir en un día valido.",
        "nivel": "Intermedio (difícil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Vectores"
        ],
        "estructuras": [
            "int",
            "vector<int>",
            "vector<pair<int,int>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(9);\n cout.tie(0);\n  int a, b, c, d, e, f, g, h;\n   vector<pair<int,int> >num(1000002,{0,0});\n vector<int>sub;\n   vector<int>sum;\n   cin>>a;\n   while(a--){\n       cin>>b;\n       c++;\n      if(b>0){\n          if(num[b].first){\n             while(a--){\n                   cin>>b;\n               }\n             cout<<-1;return 0;\n            }\n         if(num[b].second && d){\n               while(a--){\n                   cin>>b;\n               }\n             cout<<-1;return 0;\n            }\n         else{\n             d++;\n              sum.push_back(b);\n             num[b].first++;\n               num[b].second++;\n          }\n     }\n     else{\n         b=fabs(b);\n            if(!num[b].first){\n                while(a--){\n                   cin>>b;\n               }\n             cout<<-1;return 0;\n            }\n         else{\n             d--;\n              num[b].first--;\n               if(!d){\n                   while(sum.size()){\n                        num[sum[sum.size()-1]].second=0;\n                      sum.pop_back();\n                   }\n                 sub.push_back(c);\n                 c=0;\n              }\n         }\n     }\n }\n if(d){\n        cout<<-1;\n }\n else{\n     cout<<sub.size()<<\"\\n\";\n        for(auto i=0; i<sub.size(); ++i){\n          cout<<sub[i]<<\" \";\n      }\n }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "8415. Display Led",
        "url": "https://omegaup.com/arena/problem/Display-Led/",
        "descripcion": "Las pantallas de led se conforman de una gran cantidad de puntos individuales que al encenderse y apagarse pueden mostrar imágenes de alta calidad. Los leds tienden a fallar, por lo que existe un dispositivo capaz de tomar una lectura de datos que indica los leds que ya no funcionan. Realizar un programa que lea la información del estatus de la pantalla led e indique cual es el tamaño del área más grande de las que fallan y cuál es el tamaño de área más pequeña. Es posible que todos los leds fallen pero también es posible que no exista ningún led descompuesto. Este tipo de pantallas siempre genera fallas en tamaños rectangulares y además esas área de fallas son perfectamente distinguibles, nunca se tocan unas con otras de manera vertical ni horizontal (en diagonal si podrían llegar a tocarse). En las lecturas de una pantalla led, las \"X\" indican un led que falla, mientras que los \"0\" (cero) indican un led que funciona correctamente.",
        "entrada": "En la primera línea aparecerá el número de renglones R (1<=R<=300) y el número de columnas C (1<=C<=300) de la pantalla led separados por un espacio en blanco. A continuación, aparecerán R líneas de C caracteres cada una de ellas representando con la pantalla led. Este grupo de caracteres solo incluye la X o el 0, donde la X representa un led descompuesto y el 0 representa un led que funciona correctamente.",
        "salida": "En la primera línea debe aparecer un entero indicando el tamaño del área más grande de leds descompuestos. La segunda línea, un entero que representa el tamaño del área más pequeña de leds descompuestos. Puede que no existan leds descompuestos, en cuyo caso, tanto el área más grande como el área más pequeña será 0 (cero).",
        "nivel": "Intermedio (difícil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Matrices",
            "Componentes Conexas",
            "Búsqueda en profundidad",
            "Recursión"
        ],
        "estructuras": [
            "int",
            "char",
            "bool",
            "INT_MAX"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint R, C;\nchar pantalla[305][305];\nbool visitado[305][305];\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\nint floodFill(int i, int j) {\n if (i < 0 || i >= R || j < 0 || j >= C || pantalla[i][j] == '0' || visitado[i][j]) {\n      return 0;\n }\n visitado[i][j] = true;\n    int tamano = 1;\n   for (int k = 0; k < 4; ++k) {\n     tamano += floodFill(i + dx[k], j + dy[k]);\n    }\n return tamano;\n}\n\nint main() {\n cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  cin >> R >> C;\n    for (int i = 0; i < R; ++i) {3\n     cin >> pantalla[i];\n   }\n int maxArea = 0, minArea = INT_MAX;\n   for (int i = 0; i < R; ++i) {\n     for (int j = 0; j < C; ++j) {\n         if (pantalla[i][j] == 'X' && !visitado[i][j]) {\n               int tamano = floodFill(i, j);\n             maxArea = max(maxArea, tamano);\n               minArea = min(minArea, tamano);\n           }\n     }\n }\n if (minArea == INT_MAX) {\n     minArea = 0;\n  }\n cout << maxArea << endl;\n  cout << minArea << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "7401. Clipping de lineas",
        "url": "https://omegaup.com/arena/problem/Clipping-de-lineas/",
        "descripcion": "Encontrar qué pedazo de un segmento queda dentro de un area rectangular dada.",
        "entrada": "Ocho números decimales, separados por espacios. Los primeros cuatro números delimitan el area rectangular (x_min, y_min, x_max, y_max) los siguientes dos números especifican el punto de inicio de la línea (x_1,y_1) y los últimos dos, el punto final (x_2,y_2).",
        "salida": "La salida debe contener cuatro números decimales separados por espacio, donde los dos primeros deben ser las coordenadas (x,y) del punto inicial y los últimos las coordenadas (x,y) del punto final. Cada número debe estar redondeado a dos decimales. En caso de que la línea no intersecte con el rectángulo, se debe escribir la palabra NADA.",
        "nivel": "Intermedio (difícil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Cálculo matemático"
        ],
        "estructuras": [
            "double",
            "fixed",
            "setprecision()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Point {\n    double x, y;\n};\n\nPoint intersection(Point p1, Point p2, Point min_xy, Point max_xy) {\n    double t_min = 0, t_max = 1;\n    for (int i = 0; i < 2; i++) {\n        double t1 = (min_xy.x - p1.x) / (p2.x - p1.x);\n        double t2 = (max_xy.x - p1.x) / (p2.x - p1.x);\n        if (i == 1) {\n            t1 = (min_xy.y - p1.y) / (p2.y - p1.y);\n            t2 = (max_xy.y - p1.y) / (p2.y - p1.y);\n        }\n        if (t1 > t2) {\n            swap(t1, t2);\n        }\n        t_min = max(t_min, t1);\n        t_max = min(t_max, t2);\n    }\n    if (t_min <= t_max && t_min >= 0 && t_min <= 1 && t_max >= 0 && t_max <= 1) {\n        return {p1.x + t_min * (p2.x - p1.x), p1.y + t_min * (p2.y - p1.y)};\n    } else {\n        return {-1, -1};\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    cout << fixed << setprecision(2);\n    Point min_xy, max_xy, p1, p2;\n    cin >> min_xy.x >> min_xy.y >> max_xy.x >> max_xy.y >> p1.x >> p1.y >> p2.x >> p2.y;\n    Point p1_clipped = intersection(p1, p2, min_xy, max_xy);\n    Point p2_clipped = intersection(p2, p1, min_xy, max_xy);\n    if (p1_clipped.x != -1 && p2_clipped.x != -1) {\n        cout << p1_clipped.x << \" \" << p1_clipped.y << \" \" << p2_clipped.x << \" \" << p2_clipped.y << endl;\n    } else {\n        cout << \"NADA\" << endl;\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "116. Curiosity",
        "url": "https://omegaup.com/arena/problem/curiosity/",
        "descripcion": "El robot de exploración Curiosity ha llegado por fin a Marte, la NASA te ha pedido que le ayudes a resolver un problema con su sistema de navegación. El lugar donde se encuentra Curiosity se representa como una cuadrícula de N x M, NASA quiere mover su robot de la posición inicial (X_i,Y_i) a una posición final (X_f,Y_f). Curiosity solo tiene programados K diferentes tipos de movimientos los cuales están representados en una matriz de K elementos [X_1,Y_1, ]...[X_K,Y_k] donde cada par [X,Y] representan el número de cuadros que se mueve en cada uno de los ejes. En cada paso Curiosity puede ejecutar cualquiera de estos movimientos siempre y cuando no se salga de la cuadrícula. Tu tarea consiste en dada la posición inicial de Curiosity determinar cuál es el número mínimo de pasos que necesita ejecutar para llegar a su posición final.",
        "entrada": "En la primer línea tendrás los números N, M (1<=N,M<=1000) y K (1<=K<=10). En la siguiente línea tendrás dos enteros que representan la posición inicial de curiosity (las coordenadas van desde 1,1 hasta n,m). En la tercer línea dos enteros que representan la posición final deseada. Las siguientes K líneas contienen un par de enteros que indican cada movimiento posible.",
        "salida": "Un solo entero representando el número mínimo de pasos para llegar a la posición final, en caso de que no sea posible llegar debes imprimir -1.",
        "nivel": "Intermedio (difícil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Matrices",
            "Colas",
            "Búsqueda en amplitud"
        ],
        "estructuras": [
            "bool",
            "int",
            "vector<pair<int,int>>",
            "vector<vector<bool>>",
            "queue<>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Cell {\n    int x, y, dist;\n};\n\nbool isValid(int x, int y, int N, int M) {\n    return (x >= 1 && x <= N && y >= 1 && y <= M);\n}\n\nint minSteps(int N, int M, int xi, int yi, int xf, int yf, vector<pair<int, int>>& moves) {\n    vector<vector<bool>> visited(N + 1, vector<bool>(M + 1, false));\n    queue<Cell> q;\n    q.push({xi, yi, 0});\n    visited[xi][yi] = true;\n    while (!q.empty()) {\n        Cell curr = q.front();\n        q.pop();\n        if (curr.x == xf && curr.y == yf) {\n            return curr.dist;\n        }\n        for (auto move : moves) {\n            int nextX = curr.x + move.first;\n            int nextY = curr.y + move.second;\n            if (isValid(nextX, nextY, N, M) && !visited[nextX][nextY]) {\n                visited[nextX][nextY] = true;\n                q.push({nextX, nextY, curr.dist + 1});\n            }\n        }\n    }\n    return -1; // No se encontro un camino\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int N, M, K;\n    cin >> N >> M >> K;\n    int xi, yi, xf, yf;\n    cin >> xi >> yi >> xf >> yf;\n    vector<pair<int, int>> moves(K);\n    for (int i = 0; i < K; ++i) {\n        cin >> moves[i].first >> moves[i].second;\n    }\n    int result = minSteps(N, M, xi, yi, xf, yf, moves);\n    cout << result << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "341. Concierto del Doctor",
        "url": "https://omegaup.com/arena/problem/Concierto-de-Dr-Lira/",
        "descripcion": "Un doctor está aprendiendo a tocar la guitarra para darle un concierto a sus minions y quiere evitar tocar todas las canciones al mismo volumen para no aburrirlos, por lo cual decidió cambiar el volumen de la guitarra antes de cada canción. Antes de que inicie el concierto, el doctor hizo una lista de los cambios de volumen que vas a aplicar antes de cada canción. Para cada valor, el doctor puede ya sea subir el volumen o bajarlo. El doctor ha pedido tu ayuda para calcular cuál podría ser el volumen máximo que puede usar para tocar su última canción. Para evitar dejar sordos a sus minions, el doctor te pide que nunca se exceda un valor máximo permitido. De igual forma, el doctor también ha decidido usar un valor inicial para el volumen. En ningún momento el volumen puede ser menor a 0. Si no hay forma de tocar la lista con los cambios indicados por el doctor sin exceder el valor máximo permitido o con un volumen menor a 0, escribe -1.",
        "entrada": "La primer línea contendrá N (1<=N<=50), el número de cambios de volumen. La segunda línea contendrá N enteros N_i (1<=N_i<=1000), el i-esimo elemento representa el valor del cambio de volumen que se puede aplicar antes de la i-ésima canción. La tercer línea contendrá dos enteros: B y M que representa el volúmen inicial y el máximo permitido.",
        "salida": "El volumen máximo que puede usar para tocar su última canción, o -1 si en algun punto se excede el valor maximo permitido o se vuelve negativo.",
        "nivel": "Intermedio (difícil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Vectores",
            "Matrices",
            "Programación dinámica"
        ],
        "estructuras": [
            "int",
            "vector<int>",
            "vector<vector<bool>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int N, B, M;\n    cin >> N;\n    vector<int> cambios(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> cambios[i];\n    }\n    cin >> B >> M;\n    // dp[i][j] indica si es posible alcanzar el volumen j despu? de i canciones\n    vector<vector<bool>> dp(N + 1, vector<bool>(M + 1, false));\n    // Inicializaci?: el volumen inicial es alcanzable\n    dp[0][B] = true;\n    for (int i = 1; i <= N; ++i) {\n        for (int j = 0; j <= M; ++j) {\n            if (dp[i - 1][j]) {\n                // Intentar subir el volumen\n                if (j + cambios[i - 1] <= M) {\n                    dp[i][j + cambios[i - 1]] = true;\n                }\n                // Intentar bajar el volumen\n                if (j - cambios[i - 1] >= 0) {\n                    dp[i][j - cambios[i - 1]] = true;\n                }\n            }\n        }\n    }\n    // Encontrar el volumen m?imo alcanzable para la ?ltima canci?\n    int volumen_maximo = -1;\n    for (int j = M; j >= 0; --j) {\n        if (dp[N][j]) {\n            volumen_maximo = j;\n            break;\n        }\n    }\n    cout << volumen_maximo << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "159. Problema",
        "url": "https://omegaup.com/arena/problem/subsecuencias/",
        "descripcion": "Dada una secuencia de n números S=S_1,S_2,...,S_n queremos partir esta secuencia en dos sub-secuencias A y B de manera que la diferencia entre la suma de los elementos de A y la suma de los elementos de B sea la mínima posible. Es decir, las secuencias A y B deben satisfacer que: #1. Todos los elementos en A pertenecen a la secuencia S. #2. Todos los elementos en B pertenecen en la secuencia S. #3. Todos los elementos de la secuencia S pertenecen a A o pertenecen a B, pero no a ambos. #4. De entre todos los pares de sub-secuencias que satisfacen las 3 propiedades anteriores, la diferencia entre la suma de los elementos de A y la suma de los elementos de B es la mínima posible.",
        "entrada": "En la primera línea se encuentra un entero n (2<=n<=1000). En la segunda línea habrá n enteros S_i (1<=S_i<=20000) separados por espacios representando los elementos de la secuencia S (Teniendo en cuenta que la suma de todos los elementos de la secuencia original será a lo más igual a 20000).",
        "salida": "Un entero representando la diferencia mínima entre la suma de los elementos de una partición de S como se describe arriba. Nótese que la salida siempre será un número entero no-negativo.",
        "nivel": "Intermedio (difícil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Vectores",
            "Programación dinámica"
        ],
        "estructuras": [
            "int",
            "vector<int>",
            "vector<bool>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int n;\n    cin >> n;\n    vector<int> S(n);\n    int sumaTotal = 0;\n    for (int i = 0; i < n; ++i) {\n        cin >> S[i];\n        sumaTotal += S[i];\n    }\n    // Usamos DP para calcular todas las posibles sumas de subconjuntos\n    vector<bool> posible(sumaTotal + 1, false);\n    posible[0] = true; \n    for (int i = 0; i < n; ++i) {\n        for (int j = sumaTotal; j >= S[i]; --j) {\n            if (posible[j - S[i]]) {\n                posible[j] = true;\n            }\n        }\n    }\n    // Encontrar la suma m? cercana a la mitad de la suma total\n    int minDiferencia = sumaTotal;\n    for (int i = sumaTotal / 2; i >= 0; --i) {\n        if (posible[i]) {\n            minDiferencia = sumaTotal - 2 * i;\n            break;\n        }\n    }\n    cout << minDiferencia << endl;\n\n    return 0;\n"
    },
    {
        "titulo": "88. Engranes",
        "url": "https://omegaup.com/arena/problem/engranes/",
        "descripcion": "Se tienen dos engranes A y B, acoplados (dientes consecutivos de A tocan valles consecutivos de B) con N y M dientes, respectivamente. Los dientes de A están numerados del 0 al N-1, y los valles de B están numerados del 0 al M-1. Inicialmente, el diente 0 de A está tocando el valle 0 de B, en el primer paso el diente 1 tocará el valle 1 y así sucesivamente. Cada uno de los N dientes del engrane A está pintado con alguno de los k colores distintos, numerados del 0 al k-1, donde k<=A. Al girar, los dientes del engrane A tocan los valles (el espacio entre dientes) del engrane B, y al hacer contacto pintan el valle con el color del diente de A que lo tocó (si ya estaba pintado, el color anterior queda completamente cubierto del nuevo color). El color de los dientes de A nunca cambia, sólo cambia el color de los valles de B. Si después de mucho tiempo de estar girando, un valle j del engrane B nunca más cambia de color, decimos que ese valle es \"estable\". De otro modo, decimos que ese valle es \"inestable\". Dados los números N, M, k y el color de cada uno de los dientes del engrane A, determina si el j-esimo valle del engrane B es estable o inestable, para una lista de T valles de interés L_1, L_2, ..., L_T.",
        "entrada": "En la primera linea los números N (2<=N<=10^6), M (N<=M<=10^15), k. En la segunda linea, N números separados por espacios indicando el color de cada diente del engrane A. En la tercera linea, el número T (1<=T<=1000) de valles de interés. En la cuarta linea, la lista L_1, L_2, ..., L_T (0<=L_i) de valles de interés.",
        "salida": "Para cada elemento L de la lista de interés, imprime un dígito binario (0,1), donde 0 significa que el valle número L_i es inestable, y 1 significa que es estable.",
        "nivel": "Intermedio (difícil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Vectores",
            "Recursión"
        ],
        "estructuras": [
            "bool",
            "int",
            "long long",
            "vector<bool>",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long a, b, c, d, e, f;\nvector<int>num(1000002,0);\nvector<bool>sub(1000002,false), sum(1000002,false);\n\nlong long nums(long long x, long long y){\n    if(x==0)return y;\n    return nums(y%x,x);\n}\n  \nbool subs(long long g){\n    int h=g%c, l=num[h], m=a%c;\n    bool n=true;\n    if(sub[h]){\n        return sum[h];\n    }\n    for(auto i=1; i<b; i++){\n        h=(h+m)%c;\n        if(num[h]!=l){\n            n=false;break;\n        }\n    }\n    h=g%c;\n    sum[h]=n;\n    sub[h]=true;\n    for(auto i=1; i<b; i++){\n        h=(h+m)%c;\n        sum[h]=n;\n        sub[h]=true;\n    }\n  \n    return n;\n}\n  \nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    cin>>c>>a>>f;\n    for(auto i=0; i<c; i++){\n        cin>>num[i];\n    }\n    cin>>e;\n    b=c/nums(c,a);\n    for(auto i=0; i<e; i++){\n        cin>>d;\n        if(subs(d)){\n            cout<<\"1\";\n        }\n        else{\n            cout<<\"0\";\n        }\n    }\n    cout<<\"\\n\";\n    \n    return 0;\n}\n"
    },
    {
        "titulo": "160. Pulseras",
        "url": "https://omegaup.com/arena/problem/pulseras/",
        "descripcion": "Deseas averiguar cuántas pulseras diferentes pueden crearse con la siguientes consideraciones: #1. Una pulsera es una secuencia de cuentas blancas o negras, con un inicio y un final (los extremos que se atan). #2. No puede haber dos cuentas negras juntas. Esto aplica también para la inicial y la final, pues al atarla quedaran una a lado de la otra. #3. La longitud de la secuencia será 3<=n<=1000000.; Como el número de pulseras puede ser muy grande, solo deseas averiguar su congruencia módulo 1000000007 (10^9+7).",
        "entrada": "La primera y única línea tendrá un entero n (3<=n<=1000000) que indica el tamaño de las pulseras.",
        "salida": "Un único número, la cantidad de diferentes pulseras que se pueden formar de longitud n módulo 1000000007.",
        "nivel": "Intermedio (difícil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Vectores",
            "Cálculo matemático",
            "Aritmética modular",
            "Programación dinámica"
        ],
        "estructuras": [
            "int",
            "long long",
            "vector<long long>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long MOD = 1000000007;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int n;\n    cin >> n;\n    vector<long long> dp(n + 1);\n    dp[0] = 1; // Caso base: una pulsera vac?\n    dp[1] = 1; // Caso base: una pulsera con una cuenta (blanca o negra)\n    for (int i = 2; i <= n; ++i) {\n        dp[i] = (dp[i - 1] + dp[i - 2]) % MOD; \n    }\n    // Posibles configuraciones de inicio y fin\n    long long resultado = (dp[n] + dp[n - 2]) % MOD; \n    cout << resultado << \"\\n\";\n\n    return 0;\n}\n"
    },
    {
        "titulo": "118. Minecraft",
        "url": "https://omegaup.com/arena/problem/minecraft/",
        "descripcion": "Algunos de ustedes han jugado minecraft y saben que es un juego bastante simple, destruyes y colocas bloques a placer tratando de saciar tu ocio. En este problema partimos de un mapa con diversos bloques pero para facilitarte la tarea hemos decidido darte un mapa en 2D y al igual que en minecraft hay bloques con distintas durezas. La idea es que busques el tiempo mínimo que te tomará llegar de un punto a otro, los únicos movimientos que puedes hacer son verticales y horizontales, no te puedes desplazar en diagonal. Si una casilla se encuentra vacía, entonces solo te tomará una unidad de tiempo caminar por ahí, en caso de que se encuentre un bloque se te indicará la cantidad X de tiempo que te tomará destruir el bloque antes de que puedas caminar por ahí si es que el bloque se puede destruir (por lo que te tomará X+1 unidades de tiempo caminar por ahí), en caso contrario se te indicará que dicho bloque no puede ser destruido.",
        "entrada": "Un mapa descrito con caracteres donde '#' significa un bloque indestructible, '.' un bloque vacío, y los dígitos del '1' al '9' bloques que toman de 1 a 9 unidades de tiempo destruir respectivamente. Además una posición inicial y una posición final a la que debes llegar, en el caso de que la posición final no se encuentre libre, deberás primero destruir el bloque que se encuentre en dicha posición. La posición inicial siempre estará libre. La entrada vendrá de la siguiente forma: #1. Dos enteros N y M (5<=N,M<=500) que indican la cantidad de filas y columnas del mapa respectivamente. #2. Dos números f_0 y c_0 que indican la posición inicial en la que te encuentras. #3. Dos números f_1 y c_1 que indican la posición final a la que debes llegar. #4. N líneas con M caracteres describiendo el mapa, empezando por la posición (1,1).",
        "salida": "El tiempo mínimo en el que te transportas del punto inicial al punto final.",
        "nivel": "Intermedio (difícil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Matrices",
            "Grafos",
            "Búsqueda en amplitud",
            "Colas"
        ],
        "estructuras": [
            "bool",
            "int",
            "string",
            "vector<vector<bool>>",
            "vector<vector<int>>",
            "queue<pair<int, int>>",
            "vector<pair<int, int>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N, M;\nvector<vector<int>> mapa;\nvector<vector<bool>> visitado;\nint f_inicial, c_inicial;\nint f_final, c_final;\n\nint bfs() {\n    queue<pair<int, int>> q;\n    q.push({f_inicial, c_inicial});\n    visitado[f_inicial][c_inicial] = true;\n    vector<pair<int, int>> movimientos = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    vector<vector<int>> distancia(N, vector<int>(M, 1e9));\n    distancia[f_inicial][c_inicial] = 0;\n    bool bandera=false;\n    while (!q.empty()) {\n        int f_actual = q.front().first;\n        int c_actual = q.front().second;\n        q.pop();\n        if (f_actual == f_final && c_actual == c_final) {\n            bandera=true;continue;\n        }\n        for (auto& mov : movimientos) {\n            int f_siguiente = f_actual + mov.first;\n            int c_siguiente = c_actual + mov.second;\n            if (f_siguiente >= 0 && f_siguiente < N && c_siguiente >= 0 && c_siguiente < M) {\n                if (mapa[f_siguiente][c_siguiente] != -1) {\n                    if (distancia[f_siguiente][c_siguiente] > distancia[f_actual][c_actual] + mapa[f_siguiente][c_siguiente] + 1) {\n                        distancia[f_siguiente][c_siguiente] = distancia[f_actual][c_actual] + mapa[f_siguiente][c_siguiente] + 1;\n                        q.push({f_siguiente, c_siguiente});\n                        visitado[f_siguiente][c_siguiente] = true;\n                    }\n                }\n            }\n        }\n    }\n    if(bandera){\n        return distancia[f_final][c_final];\n    }\n    return -1;\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    cin >> N >> M;\n    cin >> f_inicial >> c_inicial;\n    cin >> f_final >> c_final;\n    f_inicial--;\n    c_inicial--;\n    f_final--;\n    c_final--;\n    mapa.assign(N, vector<int>(M, 0));\n    visitado.assign(N, vector<bool>(M, false));\n    for (int i = 0; i < N; i++) {\n        string linea;\n        cin >> linea;\n        for (int j = 0; j < M; j++) {\n            if (linea[j] == '#') {\n                mapa[i][j] = -1; \n            } else if (linea[j] == '.') {\n                mapa[i][j] = 0; \n            } else {\n                mapa[i][j] = linea[j] - '0'; \n            }\n        }\n    }\n    int tiempo_minimo = bfs();\n    cout << tiempo_minimo << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "258. Super Nieves Bros",
        "url": "https://omegaup.com/arena/problem/super-nieves-bros/",
        "descripcion": "El juego es una cuadrícula de N x M. Algunas celdas de la cuadrícula tienen una plataforma en la cual Plasma Nieves se puede parar. Todas las celdas del renglón del fondo del mapa siempre tienen una plataforma. Los renglones del mapa están numerados del 1 al N empezando desde arriba (por lo que todas las celdas del renglon numerado con N tienen una plataforma) y las columnas están numeradas del 1 al M empezando desde la izquierda. Exactamente una de las celdas contiene una puerta y Plasma Nieves necesita llegar ahí. Inicialmente, nuestro héroe se encuentra posicionado en el piso (el renglón de más abajo). Plasma Nieves se puede mover horizontalmente hacia los 2 lados adyacentes si ambos contienen una plataforma. Plasma Nieves también cuenta con una escalera que puede usar para subir o bajar de renglón. Si la escalera es de longitud L, Plasma Nieves puede moverse entre dos celdas (i_1,j) y (i_2,j) si ambas contienen una plataforma y |i_1-i_2|<=L (el valor absoluto de la diferencia entre las alturas es menor o igual a la longitud de la escalera). Plasma Nieves es muy fuerte y hábil, así que puede cargar la escalera a donde vaya y usarla múltiples veces. Debido a que la escalera es muy costosa de obtener, Plasma Nieves necesita que le ayudes a determinar cuál es el tamaño mínimo de escalera L que necesita tal que puede llegar del piso a la puerta. Por razones que no podemos comprender, Plasma Nieves no puede brincar hacía abajo, por lo que forzosamente tiene que usar la escalera para bajar a alguna posicion valida alcansable por la misma.",
        "entrada": "En la primer línea habrá dos enteros N y M (1<=N,M<=50), representando el número de renglones y columnas. En la segunda línea habrá dos enteros R y C (los cuales siempre estarán dentro de la cuadrícula), indicando el renglón y la columna donde se encuentra la puerta (la cual siempre estárá en una plataforma). Después habrá N líneas con M caracteres cada uno. Las 'X' representan las plataformas y los '.' espacios vacíos.",
        "salida": "El tamaño mínimo de la escalera que se necesita para llegar del piso a la puerta. Escribe 0 si se puede solucionar sin escalera.",
        "nivel": "Intermedio (difícil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Grafos",
            "Búsqueda en amplitud"
        ],
        "estructuras": [
            "int",
            "vector<vector<char>>",
            "vector<vector<bool>>",
            "pair<int, int>",
            "queue<pair<int, int>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, m, r, c, ans;\nvector<vector<char>> grid;\nvector<vector<bool>> visited;\npair<int, int> start, door;\nqueue<pair<int, int>> q;\n\nbool isValid(int x, int y){\n    return (x >= 0 && x < n && y >= 0 && y < m && grid[x][y] == 'X' && !visited[x][y]);\n}\n\nvoid bfs(int l){\n    while(!q.empty()){\n        pair<int, int> curr = q.front();\n        q.pop();\n        int x = curr.first;\n        int y = curr.second;\n        if(curr == door){\n            return;\n        }\n        // Movement with the ladder\n        for(auto i = max(0, x - l); i <= min(n - 1, x + l); i++){\n            if(isValid(i, y)){\n                visited[i][y] = true;\n                q.push({i, y});\n            }\n        }\n        // Horizontal movement\n        if(isValid(x, y - 1)){\n            visited[x][y - 1] = true;\n            q.push({x, y - 1});\n        }\n        if(isValid(x, y + 1)){\n            visited[x][y + 1] = true;\n            q.push({x, y + 1});\n        }\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    cin >> n >> m;\n    cin >> r >> c;\n    door = {r - 1, c - 1}; \n    grid.assign(n, vector<char>(m));\n    visited.assign(n, vector<bool>(m, false));\n    for(auto i = 0; i < n; i++){\n        for(auto j = 0; j < m; j++){\n            cin >> grid[i][j];\n            if(i == n - 1 && grid[i][j] == 'X'){\n                start = {i, j};\n            }\n        }\n    }\n    if(start == door){\n        cout << \"0\\n\";\n        return 0;\n    }\n    for(auto l = 0; l <= n; l++){\n        q.push(start);\n        visited.assign(n, vector<bool>(m, false));\n        visited[start.first][start.second] = true;\n        bfs(l);\n        if(visited[door.first][door.second]){\n            ans = l;\n            break;\n        }\n    }\n    cout << ans << \"\\n\";\n\n    return 0;\n}\n"
    },
    {
        "titulo": "236. La Venganza de Silvio",
        "url": "https://omegaup.com/arena/problem/VenganzaDeSilvio/",
        "descripcion": "Silvio Rodríguez Domínguez (San Antonio de los Baños, 29 de noviembre de 1946) es un cantautor, guitarrista y poeta cubano, exponente característico de la música de su país surgida con la Revolución cubana, conocida como la Nueva Trova Cubana, que comparte con otros reconocidos cantautores tales como Pablo Milanés, Noel Nicola y Vicente Feliú. Después de la gran decepción que sufrió al poner su pizzería, juró cobrar venganza sobre los olímpicos. Ahora decidió torturar al Agente Solid Nieves, obligándolo a hacer cuentas increíblemente tediosas mientras escucha sus éxitos de antaño, como \"Quick puede no ser Quick\". Le dio un entero N, el cual debía elevar a la M-ésima potencia, y prometió que lo dejaría libre si contestaba correctamente. Siendo muy listo, Silvio eligió una M muy grande para que el Agente Solid Nieves nunca lograra terminar, y además se la dio en base 2. Por si no fuera suficiente, pidió que la respuesta se la diera módulo m. Ayuda al Agente Solid Nieves a contestar la pregunta de Silvio para poder escapar.",
        "entrada": "En la primer línea, dos enteros, N y m. En la segunda línea, la representación en binario de M.",
        "salida": "Un entero, N^M(mod m), de donde N, M y m (m!=0) son enteros no negativos. Ademas: N,m<2^31 y M<=2^1000001.",
        "nivel": "Intermedio (difícil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Caracteres y cadenas",
            "Aritmética modular",
            "Exponenciación binaria"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll exp_binaria(ll base, string exponente, ll modulo) {\n    ll resultado = 1;\n    ll base_actual = base % modulo;\n    for (int i = exponente.length() - 1; i >= 0; --i) {\n        if (exponente[i] == '1') {\n            resultado = (resultado * base_actual) % modulo;\n        }\n        base_actual = (base_actual * base_actual) % modulo;\n    }\n    return resultado;\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    ll N, m;\n    string M;\n    cin >> N >> m;\n    cin >> M;\n    cout << exp_binaria(N, M, m) << \"\\n\";\n\n    return 0;\n}\n"
    },
    {
        "titulo": "8319. El Trabajador Novato",
        "url": "https://omegaup.com/arena/problem/El-Trabajador-Novato/",
        "descripcion": "Un establecimiento de paquetería se dedica a entregar la correspondencia de sus clientes principales a través de un empleado de confianza. La paquetería siempre tiene personal calificado que realiza este trabajo. Cierto día, la paquetería quiso jugar una broma a un trabajador joven recién contratado para darle la novatada de bienvenida. La broma consistía en que el trabajador joven debería llevar X correspondencia a uno de los clientes, y éste al recibirla le haría pensar que se equivocó de cliente, así que lo mandaría visitar a otro cliente (que el destinatario tiene en común con la paquetería), y así. Los clientes de la paquetería (en complicidad) quieren evitar situaciones incomodas, así que no le pedirán al trabajador novato que visite al mismo cliente (incluido regresar a la paquetería) dos veces. La paquetería sabe cuánto cuesta el viaje para ir con sus clientes y el viaje entre dos clientes que se conocen y quiere saber ¿Cuál es la cantidad máxima de dinero que gastará en viajes por la broma que le jugará a su trabajador novato? La paquetería y sus clientes están etiquetados de 0 a n-1, y su red de conexiones forma un árbol. En otras palabras, cada dos de los clientes a,b se conocen entre sí, posiblemente de manera indirecta (hay una secuencia de clientes comenzando desde a y terminando en b, de tal forma que cada dos clientes consecutivos en la secuencia se conocen directamente), y hay exactamente n-1 pares de clientes que se conocen directamente o conocen a la paquetería. A la paquetería se le asigna el número 0.",
        "entrada": "La primera línea de la entrada contiene el número n de clientes, incluyendo a la paquetería, (3<=n<=100). Las siguientes n-1 líneas contienen tres enteros separados por espacios u, v y c (0<=u,v<=n-1,1<=c<=10^4), lo que significa que u y v son clientes (que se conocen directamente o conocen la paquetería) y el costo por viajar entre u y v es c. Se debe garantizar que la red social de la entrada forma un árbol.",
        "salida": "La salida es un único entero - la suma máxima de costos.",
        "nivel": "Intermedio (difícil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Vectores",
            "Arboles",
            "Búsqueda en profundidad",
            "Recursión"
        ],
        "estructuras": [
            "vector<pair<int>>",
            "pair<int>",
            "long long",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<pair<int>>num[101];\nlong long a, b, c, d;\nint nums[101];\npair<int> z;\n\nvoid sub(int x){\n    for(auto i=0; i<num[x].size(); i++){\n        if(!nums[num[x][i].first]){\n            c+=num[x][i].second;\n            b=max(b,c);\n            nums[num[x][i].first]=1;\n            sub(num[x][i].first);\n            nums[num[x][i].first]=0;\n            c-=num[x][i].second;\n        }\n    }\n    return;\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    cin>>a;\n    for(auto i=1; i<a; i++){\n        cin>>b>>c>>d;\n        z.first=c;\n        z.second=d;\n        num[b].push_back(z);\n        z.first=b;\n        num[c].push_back(z);\n    }\n    b=c=0;\n    nums[0]=1;\n    sub(0);\n    cout<<b;\n    \n    return 0;\n}"
    },
    {
        "titulo": "11824. Limonadas",
        "url": "https://omegaup.com/arena/problem/Limonadas/",
        "descripcion": "Naty tiene una fábrica de limonadas y necesita vender una cantidad \"X\" de litros, ella recolecta el agua de lluvia directamente de las fosas que se forman en su terreno. Escribe un programa que conociendo los \"X\" litros de limonada que deberá vender Naty y el relieve de su terreno, le indique cuantos litros de agua debe comprar para poder preparar sus limonadas. En caso que recolecte mas agua de la que necesita, deberás imprimir el total de litros de agua que le sobran.",
        "entrada": "En la primera línea el número 0<X<=10^9 que representa la cantidad de limonada que Naty debe vender. En la segunda línea al valor 0<N<10^6 indicando el relieve del terreno de Naty. En la tercera línea \"N\" valores enteros 0<H<10^5 qué representa la altura del terreno de Naty.",
        "salida": "Una sola línea indicando la cantidad de litros de agua que le hacen falta a Naty para poder vender los \"X\" litros de limonada o la cantidad de litros que le sobraron. (Se te asegura que el resultado cabe en un entero signado de 32 bits).",
        "nivel": "Intermedio (difícil) - Matemáticas en la programación",
        "categorias": [
            "Vectores",
            "Técnica de dos apuntadores"
        ],
        "estructuras": [
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  int a, b, c, d, e, f, g, h;\n   vector<int>num(1000001,0);\n    cin>>a>>b;\n    for(auto i=0; i<b; ++i){\n       cin>>num[i];\n  }\n c=0;\n  while(c<b-1 && num[c]<num[c+1]){\n      c++;\n  }\n if(c+1==b){\n       cout<<a;return 0;\n }\n d=b-1;\n    while(d>0 && num[d]<num[d-1]){\n        d--;\n  }\n if(d==0){\n     cout<<a;return 0;\n }\n while(c<d){\n       if(num[c]<=num[d]){\n           e=num[c];\n         c++;\n          while(num[c]<e){\n              f+=(e-num[c]);\n                c++;\n          }\n     }\n     else{\n         e=num[d];\n         d--;\n          while(num[d]<e){\n              f+=(e-num[d]);\n                d--;\n          }\n     }\n }\n cout<<abs(a-f);\n\n return 0;\n}\n"
    },
    {
        "titulo": "11382. Bienestar Azteca",
        "url": "https://omegaup.com/arena/problem/Bienestar-Azteca/",
        "descripcion": "La página de Bienestar Azteca se encuentra saturada pero tu necesitas de la beca para poder ir a la OMI Zacatecas 2020 entonces tus amigos programadores te comentaron que en la escuela de Bachilleres 2 se encuentra un internet tan potente que te permite entrar a la página antes que nadie, solo que tienes que estar situado en un punto y mirando a una dirección en concreto. Tus amigos programadores no te dieron las coordenadas de esa posición ni la dirección que tienes que mirar, pero te dieron las siguientes indicaciones para poder encontrarlo. Inicias en la coordenada (1,1). Te moveras en forma de espiral con esta secuencia de dierecciones: este, sur, oeste y norte. Avanzas en una dirección hasta que te encuentres una casilla por la que ya hayas pasado o el límite de la escuela, cuando esto pase, cambias de dirección. Cuando ya no te puedes mover hacia ningun lado esa es la coordenada y la dirección es la ultima dirección que usaste para llegar a esa coordenada. Por ejemplo, cuando N=3 y M=3, iniciamos en la coordenada (1,1), nos movemos hacia el Este hasta la coordenada (1,3), como nos encontramos con el límite de la escuela cambiamos la dirección hacia el Sur hasta la coordenada (3,3), cambiamos nuevamente de dirección hacia el Oeste hasta las coordenadas (3,1) porque nos encontramos con el límite, cambiamos una vez más la dirección hacia el Norte y nos ubicamos en la coordenada (2,1), como nos encontramos una casilla que ya habíamos visitado reiniciamos la secuencia de direcciones y nos movemos hacia el Este, siendo nuestra ultima coordenada (2,2) mirando hacia la dirección del Este. Encuentra las coordenadas exactas en la que te debe ubicar y la dirección a la que debes mirar para poder entrar a la página de bienestar azteca.",
        "entrada": "Dos números N y M que son el tamaño de la escuela.",
        "salida": "Dos números x y y que son las coordenadas que debes estar situado y una caracter s que puede ser E(este), S(sur), O(oeste) o N(norte) que es la dirección a la que debes mirar en esas coordenadas.",
        "nivel": "Intermedio (difícil) - Matemáticas en la programación",
        "categorias": [
            "Cálculo matemático"
        ],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  int a, b, c, d, e, f, g, h;\n   cin>>a>>b;\n    if(a==b){\n     if(a%2){\n          cout<<(a/2)+1<<\" \"<<(a/2)+1<<\" E\";\n        }\n     else{\n         cout<<(a/2)+1<<\" \"<<a/2<<\" O\";\n        }\n }\n else if(a%2==0 && b%2==0){\n        if(b<a){\n          cout<<(min(a,b)/2)+1<<\" \"<<(min(a,b)/2)<<\" N\";\n        }\n     else{\n         cout<<(min(a,b)/2)+1<<\" \"<<(min(a,b)/2)<<\" O\";\n        }\n }\n else if(a%2 && b%2){\n      if(a<b){\n          cout<<(min(a,b)/2)+1<<\" \"<<max(a,b)-(min(a,b)/2)<<\" E\";\n       }\n     else{\n         cout<<max(a,b)-(min(a,b)/2)<<\" \"<<(min(a,b)/2)+1<<\" S\";\n       }\n }\n else if(min(a,b)%2){\n      if(a<b){\n          cout<<(min(a,b)/2)+1<<\" \"<<max(a,b)-(min(a,b)/2)<<\" E\";\n       }\n     else{\n         cout<<max(a,b)-(min(a,b)/2)<<\" \"<<(min(a,b)/2)+1<<\" S\";\n       }\n }\n else{\n     if(a<b){\n          cout<<(min(a,b)/2)+1<<\" \"<<(min(a,b)/2)<<\" O\";\n        }\n     else{\n         cout<<(min(a,b)/2)+1<<\" \"<<(min(a,b)/2)<<\" N\";\n        }\n }\n \n  return 0;\n}\n"
    },
    {
        "titulo": "11389. Polvo de Sahara",
        "url": "https://omegaup.com/arena/problem/Polvo-de-Sahara/",
        "descripcion": "El polvo de Sahara, el desierto más grande del mundo ha llegado a América, este polvo tiene componentes quimicos que pueden generar alergias e incluso la muerte si es respirado, la CIA (Centro de Investigación Arenoso) ha hecho una investigación a profundidad y tiene una lista de N países, que va de 1 hasta N, los cuales estan marcados con números claves. Si la clave del país i-ésimo es potencia de 2, significa que ese país tiene alto riesgo de ser afectados por este polvo. Tu tarea sera encontrar cuantos países se encuentran en alto riesgo ante el polvo de Sahara y cuales son estos países para advertirles lo antes posible.",
        "entrada": "Un entero N que es el número de países seguido de N números, el i-ésimo valor es la clave del i-ésimo país.",
        "salida": "Un entero K que es el número de países con alto riesgo seguido de un salto de l[inea con K números separados por un espacio los cuales son los países.",
        "nivel": "Intermedio (difícil) - Matemáticas en la programación",
        "categorias": [
            "Vectores",
            "Cálculo matemático",
            "Manipulación de bits"
        ],
        "estructuras": [
            "long long",
            "vector<long long>",
            "~",
            "&"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  long long a, b, c, d, e, f, g, h;\n vector<long long>num;\n cin>>a;\n   for(auto i=1; i<=a; i++){\n      cin>>b;\n       if(b-(b&~(b-1))==0){\n          num.push_back(i);\n     }\n }\n cout<<num.size()<<\"\\n\";\n    for(auto i=0; i<num.size(); i++){\n      cout<<num[i]<<\" \";\n  }\n \n  return 0;\n}\n"
    },
    {
        "titulo": "8057. El autor no se molestó en escribir un título",
        "url": "https://omegaup.com/arena/problem/No-se-molesto-en-escribir-uno/",
        "descripcion": "Te enfadaste de agregarle historias a tus problemas porque nadie los resuelve. Por eso escribiste un problema con la siguiente redacción: Dado un número w y otro número n, decir si para todos los números enteros p y q distintos mayores a 1 y menores o iguales a n se cumple que: w mod p != w mod q.",
        "entrada": "Dos números w y n (1<=w,n<=10^18).",
        "salida": "Imprimir \"Si\" si se cumple la condicion, y \"No\" si existen p y q que no lo cumplan.",
        "nivel": "Intermedio (difícil) - Matemáticas en la programación",
        "categorias": [
            "Tablas de dispersión",
            "Teoría de numeros"
        ],
        "estructuras": [
            "long long",
            "set<long long>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n   cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  long long w, n;\n   cin >> w >> n;\n    if (n > w+1) {\n        cout << \"No\\n\"; \n       return 0;\n }\n set<long long> residuos;\n  for (long long p = 2; p <= n; ++p) {\n      long long residuo = w % p;\n        if (residuos.count(residuo)) {\n            cout << \"No\\n\";\n            return 0;\n     }\n     residuos.insert(residuo);\n }\n cout << \"Si\\n\"; \n\n return 0;\n}\n"
    },
    {
        "titulo": "9411. Suma Números",
        "url": "https://omegaup.com/arena/problem/Suma-Numeros/",
        "descripcion": "Las disputas entre Isaac y Godofredo continúan. Ambos quieren ser reconocidos como los mejores para resolver acertijos matemáticos. Esta rivalidad parecería ya tener siglos, se trata de definir quien es el primero en los cálculos. En esta ocasión Godofredo ha sido retado por Isaac. El reto consiste en sumar los dígitos de los números en una serie definida por dos números enteros hasta que el resultado final tenga solo un dígito. Por ejemplo, la serie definida por los enteros 99 y 103 es la siguiente; 99, 100, 101, 102 y 103. La suma de los dígitos de estos números es (9 + 9) + (1 + 0 + 0) + (1 + 0 + 1) + (1 + 0 + 2) + (1 + 0 + 3) = 28. Sin embargo, 28 aun tiene dos dígitos, por lo que hay que sumarlos de nuevo. La suma es 2 + 8 = 10. Como el resultado aun tiene mas de un dígito, estos se vuelven a sumar. 1 + 0 = 1. Finalmente nos detenemos pues el resultado tiene solamente 1 dígito. Godofredo le ha pedido ayuda a su amigo Alan, que sabe mucho de este tipo de enigmas. Alan le asegura a Godofredo que este problema se puede resolver fácilmente con la ayuda de una computadora. Después de esto Alan se retira, pues tiene que hacer una prueba. Así, que Godofredo necesita tu ayuda para resolver el reto que Isaac le ha puesto.",
        "entrada": "Para ayudarle a Godofredo, es necesario escribir un programa que lea un número entero N (1<=N<=1000), seguido por N pares de números enteros a y b (1<=a<b<=1000), de donde el número leído primero siempre será menor al segundo número.",
        "salida": "Por cada par, indica la suma de los dígitos de la secuencia de números definida por el par, hasta que la cantidad de dígitos en la suma sea solo 1.",
        "nivel": "Intermedio (difícil) - Matemáticas en la programación",
        "categorias": [
            "Teoría de numeros"
        ],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n// Funcion para calcular la suma de los digitos de un n?mero\nint sumaDigitos(int num) {\n    int suma = 0;\n    while (num > 0) {\n        suma += num % 10;\n        num /= 10;\n    }\n    return suma;\n}\n\n// Funcion para calcular la raiz digital (suma de digitos recursiva hasta un solo d?ito)\nint raizDigital(int num) {\n    int resultado = num;\n    while (resultado > 9) {\n        resultado = sumaDigitos(resultado);\n    }\n    return resultado;\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int N;\n    cin >> N;\n    for (int i = 0; i < N; ++i) {\n        int a, b;\n        cin >> a >> b;\n        // Optimizacion: Calculamos la raiz digital de la suma del rango\n        // en lugar de sumar los digitos de cada numero individualmente.\n        int sumaRango = (b * (b + 1) / 2) - (a * (a - 1) / 2);\n        cout << raizDigital(sumaRango) << endl;\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "10344. Coronavirus",
        "url": "https://omegaup.com/arena/problem/Coronavirus/",
        "descripcion": "Ultimamente el coronavirus ha sido un virus con gran efecto alrededor de todo el mundo, el problema con este virus es que no se había encontrada una cura ¡Hasta el día de hoy! Milagrosamente en la Organización de Mundos Intergalacticos (OMI) se ha encontrado una forma de combatir contra tan temible virus. Lo malo es que es un proceso un poco costoso. El coronavirus se ha visto (no efectos de la vida real) que cambia la secuencia de ADN en tu cuerpo, por tanto, la cura que se ha ideado es volver a los genes como estabán antes. Existen dos tipos de genes diremos \"1\" y \"0\". Los genes normalmente están intercalados, es decir, después de un 1 siempre va un 0 y después de un 0 siempre va ir un 1. Esto quiere decir que los genes deben tener la forma ... 0 1 0 1 0 1 ..., entonces el coronavirus afecta esto y cambia unos genes. Se ha creado una maquina que puede hacer 2 operaciones: #1. Intercambiar la posición de dos genes. Es decir, si yo tengo 1 1 0 0; podemos intercambiar el de la ultima posicion con el de la primera para que quede 0 1 0 1. #2. Cambiar un gen completo, es decir, si tenemos 1 1 1; podemos cambiar el gen de en medio por un 0. Como cada vez que la maquina hace una operación genera cierto costo, nosotros queremos minimizar el número de movimientos. Dada una cadena genetica (representado por n números 0 o 1) decir cuál es la minima cantidad necesaria de movimientos para generar una secuencia normal (que después de cada 0 haya un 1 y viceversa).",
        "entrada": "En la primera linea un número n (1<=n<=10^6) que representa el tamaño de la cadena genetica. En la siguiente linea n números separados por un espacio representando la cadena genetica.",
        "salida": "Un único número entero que representa la cantidad mínima de movimientos a realizar.",
        "nivel": "Intermedio (difícil) - Matemáticas en la programación",
        "categorias": [
            "Cálculo matemático"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c=0, d=0, e=0;\n    cin>>a;\n    for(auto i=1; i<=a; i++){\n        cin>>b;\n        if(i%2 && b){\n            c++;\n        }\n        else if(i%2==0 && !b){\n            d++;\n        }\n        e+=b;\n    }\n    if(!(a%2)){\n        if(c+d<=a-c-d){\n            c+=d;\n        }\n        else{\n            c=a-c-d;\n        }\n        cout<<abs(a/2-e)+(c-abs(a/2-e))/2;\n    }\n    else if(c+d<a-c-d){\n        c+=d;\n        cout<<abs(a/2-e)+(c-abs(a/2-e))/2;\n    }\n    else{\n        c=a-c-d;\n        cout<<abs((a/2)+1-e)+(c-abs((a/2)+1-e))/2;\n    }\n    \n    return 0;\n}\n"
    },
    {
        "titulo": "4276. Loggy y la Navidad",
        "url": "https://omegaup.com/arena/problem/Loggy-y-la-Navidad/",
        "descripcion": "Loggy, el castor programador, está muy contento por la llegada de la Navidad en su ciudad. Todos están poniendo sus arboles, y Loggy no es la excepción. El decidió constuir un árbol binario el cuál tendrá su raíz hasta el techo de su casa. Para este problema podemos definir un árbol binario como una colección de nodos conectados entre sí. El nodo que se encuentra más arriba es llamado raíz, cada nodo puede tener 0, 1 o 2 nodos más que cuelgan de él llamados hijos. Los nodos que no tienen hijos son llamadas hojas. Además, cada nodo tiene exactamente un padre, excepto por la raíz que no tiene padre. Loggy compró una caja de L esferas. Las esferas solo las pondrá en las hojas del árbol. El desea que en el árbol que contruya pueda usar todas las esferas para decorar todas las hojas (una esfera por hoja). Sin embargo, Loggy está limitado por la altura de su casa, así que la altura del árbol no puede ser mayor que la altura H de su casa. La altura de un árbol es la cantidad de aristas por las que hay que pasar para ir de la raíz a su hoja más lejana. Además, Loggy quiere que su árbol sea lo más bonito posible y además cumpla la condición de las esferas y las hojas. Un árbol A es más bonito que un árbol B si A tiene más nodos que B. Dada la altura de la casa de Loggy y la cantidad de esferas en la caja que compró, ayudale a saber la cantidad de nodos que tendrá el árbol más bonito que cumpla con la condición de usar todas las esferas en cada una de las hojas y su altura no pase de la altura de la casa de Loggy.",
        "entrada": "En la primera y única línea tendrás 2 enteros : H y L. La altura de la casa de Loggy y el número de esferas en la caja respectivamente.",
        "salida": "Un único entero N que representa la cantidad de nodos que tendrá el árbol más bonito.",
        "nivel": "Intermedio (difícil) - Matemáticas en la programación",
        "categorias": [
            "Cálculo matemático"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long nodosParaHojas(long long H, long long L) {\n    long long hojasActuales = 1;\n    long long nodos = 0;\n    long long altura = -1;\n    while (altura < H && hojasActuales < L) {\n        nodos += hojasActuales;\n        hojasActuales *= 2;\n        altura++;\n    }\n    return nodos+(H-altura)*L;\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long H, L;\n    cin >> H >> L;\n    cout << nodosParaHojas(H, L) << \"\\n\";\n\n    return 0;\n}\n"
    },
    {
        "titulo": "6272. Los libros de Santy 2",
        "url": "https://omegaup.com/arena/problem/Los-libros-de-Santy-2/",
        "descripcion": "Un estudiante especifico tiene muchos libros, los cuales tienen un numero como identificador y todos son distintos, lo malo es que su hermana menor se los desordeno todos. Además mañana ese estudiante entra a la escuela y necesita tener todos sus libros ordenados, al igual que debe tener una forma rápida de buscar aquellos que necesite. Así que decidió hacer un programa que le diga la posición de sus libros después de ordenarlos de menor a mayor. Dado un arreglo de N números no ordenados que representan los libros, decir en que posición se encuentran Q de esos libros después de ser ordenados.",
        "entrada": "Primera linea: N y Q (0<N,Q<=10^4) que representan el numero de libros que hay y los que quiere conocer su posición. Segunda linea: N números A_i (0<=A_i<=10^17) que representa el ID de cada libro. Tercera linea: Q números B_i (Cada B_i pertenece al conjunto A_i) que representa el ID de cada libro que busca.",
        "salida": "Una linea con Q números separados por un espacio representando la posición de cada libro después de ser ordenado; donde el numero 1 responde a B_1 (i responde a B_i) teniendo en cuenta que esta indexado desde 0. Nota: Este estudiante a veces puede ser muy tonto y pedir el mismo libro más de una vez.",
        "nivel": "Intermedio (medio) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Vectores",
            "Ordenamiento",
            "Tablas de dispersión"
        ],
        "estructuras": [
            "int",
            "long long",
            "vector<long long>",
            "unordered_map<long long, int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int N, Q;\n    cin >> N >> Q;\n    vector<long long> libros(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> libros[i];\n    }\n    // Creamos una copia para ordenar y encontrar las posiciones\n    vector<long long> librosOrdenados = libros;\n    sort(librosOrdenados.begin(), librosOrdenados.end());\n    // Guardamos las posiciones en un mapa\n    unordered_map<long long, int> posiciones;\n    for (int i = 0; i < N; ++i) {\n        posiciones[librosOrdenados[i]] = i;\n    }\n    // Buscamos las posiciones de los libros solicitados\n    for (int i = 0; i < Q; ++i) {\n        long long libroBuscado;\n        cin >> libroBuscado;\n        cout << posiciones[libroBuscado] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "1348. Planetas",
        "url": "https://omegaup.com/arena/problem/Planetas/",
        "descripcion": "En una galaxia existen N planetas alineados en una recta. Cada planeta tiene una única posición X_i y ningún par de planetas comparten una posición. Quieres poner un meteorito, pero sabes que los planetas tienen gravedad y ejercen una fuerza sobre el meteorito igual a 1/|X_i-M| donde M es la posicion del meteorito. Tu tarea consiste en decir todos los puntos en los cuales si pones el meteorito, nunca chocará con un planeta. El meteorito no choca si su trayectoria no lo hace ocupar la misma posición que un planeta. Recuerda que la aceleración de un objeto es proporcional a la fuerza neta (es decir, la suma de las fuerzas) sobre él, por lo que el meteorito no chocará si su fuerza neta izquierda difiere por muy poco de su fuerza neta derecha.",
        "entrada": "En la primer línea, N (1<=N<=1000), el número de planetas. En la segunda línea N enteros X_i (-10000<=X_i<=10000) diciendo las coordenadas de los planetas.",
        "salida": "En la primer línea, K, el número de puntos en el cual el meteorito no causa daños a algún planeta. En la siguiente línea K números, las posiciones en los cuales no hace daño, con una precisión de 10^-3 y ordenados de forma creciente.",
        "nivel": "Intermedio (medio) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Vectores",
            "Ordenamiento",
            "Búsqueda binaria"
        ],
        "estructuras": [
            "int",
            "double",
            "vector<int>",
            "vector<double>",
            "fixed",
            "setprecision()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ndouble calcularFuerza(double m, int x) {\n    return 1.0 / abs(x - m);\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int n;\n    cin >> n;\n    vector<int> planetas(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> planetas[i];\n    }\n    sort(planetas.begin(), planetas.end());\n    vector<double> posicionesSeguras;\n    for (int i = 0; i < n - 1; ++i) {\n        double l = planetas[i], r = planetas[i + 1];\n        for (int j = 0; j < 500; ++j) { // B?squeda binaria\n            double m = (l + r) / 2;\n            double fuerzaIzquierda = 0, fuerzaDerecha = 0;\n            for (int k = 0; k <= i; ++k) {\n                fuerzaIzquierda += calcularFuerza(m, planetas[k]);\n            }\n            for (int k = i + 1; k < n; ++k) {\n                fuerzaDerecha += calcularFuerza(m, planetas[k]);\n            }\n            if (abs(r - l) < 1e-6) { // Punto de equilibrio\n                posicionesSeguras.push_back(m);\n                break;\n            } else if (fuerzaIzquierda > fuerzaDerecha) {\n                l = m;\n            } else {\n                r = m;\n            }\n        }\n    }\n    cout << posicionesSeguras.size() << \"\\n\";\n    cout << fixed << setprecision(3);\n    for (double pos : posicionesSeguras) {\n        cout << pos << \" \";\n    }\n    cout << \"\\n\";\n\n    return 0;\n}\n"
    },
    {
        "titulo": "5020. El cuervo y la jarra",
        "url": "https://omegaup.com/arena/problem/El-cuervo-y-la-jarra/",
        "descripcion": "Un cuervo sediento encontró una jarra con un poco de agua, pero no la suficiente como para alcanzar a beberla con su corto pico. En lo que meditaba acerca de su mala fortuna, el cuervo comenzó a caminar y encontró un camino de piedritas. Al cuervo entonces se le ocurrió un plan: elegirá una piedrita del camino y empezará a meter ésta y todas las piedritas de adelante dentro la jarra, una tras otra, hasta lograr que el agua suba lo suficiente para poder alcanzarla con su pico. No todas las piedritas tienen el mismo volumen: las más grandes contribuyen más a subir el nivel del agua. Si el cuervo comienza tirando la piedrita K y necesita que las piedritas a meter en la jarra sumen un volumen mínimo de V, ¿cuál es la última piedrita que necesita tirar?",
        "entrada": "Un entero N seguido de los N volúmenes P_0,...,P_{n-1} de las piedritas. Posteriormente un entero M seguido de M preguntas descritas por los enteros V, K donde V es el volumen mínimo de piedritas que el cuervo debe tirar dentro de la jarra y K es el índice de la primera piedrita elegida por el cuervo. Puedes suponer que (1<=N<=10^5), (1<=M<=10^5), (1<=P_i<=10^4), (1<=V<=10^9) y (0<=K<N).",
        "salida": "Para cada pregunta, el menor índice (J<N) tal que P_K+P_(K+1)+...+P_J>=V. En caso de que no exista tal índice, imprimir el valor de N.",
        "nivel": "Intermedio (medio) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Vectores",
            "Suma de prefijos",
            "Búsqueda binaria"
        ],
        "estructuras": [
            "long long",
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long a, b, c, d, e, f, g, h, l;\n\nint num[100002];\n\nvoid sub(){\n    if(c>num[a]){\n        cout<<a;return;\n    }\n    if(c<=num[d]){\n        cout<<d-1;return;\n    }\n    e=0;\n    f=a;\n    h=0;\n    l=a;\n    while(e<=f){\n        g=(e+f)/2;\n        if(num[g]==c){\n            cout<<g-1;return;\n        }\n        else if(num[g]>c){\n            l=min(l,g);\n            f=g-1;\n        }\n        else{\n            h=max(h,g);\n            e=g+1;\n        }\n    }\n    cout<<l-1;return;\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    cin>>a;\n    for(auto i=1; i<=a; i++){\n        cin>>num[i];\n        num[i]+=num[i-1];\n    }\n    cin>>b;\n    while(b--){\n        cin>>c>>d;\n        d++;\n        c+=num[d-1];\n        sub();\n        cout<<\"\\n\";\n    }\n    \n    return 0;\n}\n"
    },
    {
        "titulo": "16556. Fábrica de Globos",
        "url": "https://omegaup.com/arena/problem/Fabrica-de-Globos/",
        "descripcion": "Tienen una maquina la cual pone el precio a las bolsas, pero últimamente ha estado fallando y esto ocasiona que, la máquina, aumente o disminuya el precio de cada una. Desafortunadamente aún no encuentran la falla de la máquina, pero saben los cambios que realizará. Hay N bolsas, las cuales están en una fila horizontal numeradas de 1 al N. La máquina hará P cambios en el precio, uno después de otro, los cuales se identifican por los siguientes datos: Un carácter C que puede ser A o D, que indica si Aumentó o Disminuyó el precio. Dos números: X y Y. Representan que, de la bolsa X a la Y, la máquina cambió su precio (1<=X<=Y<=N). Un número G, el número que sumó o restó al precio de cada bolsa (1<=G<=10^9).",
        "entrada": "En la primera línea dos números N y K. El número de bolsas que hay y el precio mínimo que cada bolsa debe tener. En la segunda línea un número P. La cantidad de cambios en los precios que realizó la máquina. Las siguientes P lineas contienen un carácter C y tres números: X, Y y G. Corresponden a los datos de la operación de la máquina.",
        "salida": "Una única línea que contenga un entero: La cantidad de bolsas cuyo precio es menor a K pesos.",
        "nivel": "Intermedio (medio) - Análisis y diseño de algoritmos",
        "categorias": [
            "Vectores",
            "Suma de prefijos"
        ],
        "estructuras": [
            "char",
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint main(){\n   ios::sync_with_stdio(false);\n  cin.tie(0),cout.tie(0);\n   ll n, m, a, b, c, d, e=0, f=0, g, h;\n  vector<ll>ar(100002,0);\n   cin>>n>>m>>a;\n char x;\n   while(a--){\n       cin>>x>>b>>c>>d;\n      if(x=='D'){\n           d*=-1;\n        }\n     ar[b]+=d;\n     ar[c+1]-=d;\n   }\n n++;\n  for(auto i=1; i<n; i++){\n      e+=ar[i];\n     if(e<m){\n          f++;\n      }\n }\n cout<<f;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "19589. Buscando Pokemones",
        "url": "https://omegaup.com/arena/problem/Buscando-Pokemones/",
        "descripcion": "Ash es el entrenador Pokémon más reconocido de toda la historia. Pero no todo entrenador Pokémon reconocido puede superar el desafío que tenga delante. Actualmente, Ash se encuentra frente a una hilera de N arbustos. El arbusto i contiene al Pokémon x_i, representado por una letra del alfabeto inglés, y desde el arbusto i te puedes mover al i+1 y al i-1, excepto en los extremos para los cuales ya no hay más arbustos. Una vez que entras en un arbusto, debes moverte a lo largo de la hilera y al salir no puedes volver a entrar de nuevo. Ash quiere saber cuál es la menor cantidad de movimientos que debe hacer para atrapar la mayor cantidad de Pokémon distintos posible.",
        "entrada": "Se te dará un número 1<=N<=10^5 indicando la cantidad de arbustos en la hilera, en la siguiente línea se te dará una cadena de caracteres de tamaño N representando los Pokémon que hay en cada arbusto.",
        "salida": "Deberás imprimir la cantidad mínima de movimientos que Ash debe realizar dentro de los arbustos para alcanzar el objetivo.",
        "nivel": "Intermedio (medio) - Análisis y diseño de algoritmos",
        "categorias": [
            "Caracteres y cadenas",
            "Tablas de dispersión",
            "Ventana deslizante"
        ],
        "estructuras": [
            "int",
            "char",
            "string",
            "set<char>",
            "map<char,int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    ios::sync_with_stdio(0);\n  cin.tie(0);\n   cout.tie(0);\n  int n, m, a, b, c, d, e, f, g, h;\n vector<char>ar(100000);\n   unordered_set<char>ar2;\n   unordered_map<char,int>ar3;\n   cin>>n;\n   for(auto i=0; i<n; i++){\n      cin>>ar[i];\n       ar2.insert(ar[i]);\n        ar3[ar[i]]=0;\n }\n a=ar2.size();\n ar2.clear();\n  c=0;\n  while(ar2.size()<a){\n      ar2.insert(ar[c]);\n        ar3[ar[c]]++;\n     c++;\n  }\n d=0;\n  while(ar3[ar[d]]>1){\n      ar3[ar[d]]--;\n     d++;\n  }\n b=c-d;\n    for(; c<n;){\n      ar3[ar[c]]++;\n     c++;\n      while(ar3[ar[d]]>1){\n          ar3[ar[d]]--;\n         d++;\n      }\n     b=min(b,c-d);\n }\n cout<<b;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "7734. Dándole fuerza a los Vengadores",
        "url": "https://omegaup.com/arena/problem/Fuerza-a-los-Vengadores/",
        "descripcion": "La batalla entre ambos equipos (vengadores y enemigos) esta balanceada en cuanto integrantes. Ambos tienen N miembros en su equipo y cada miembro cuenta con una fuerza F_i. Para saber que equipo va ganar se calculan los Puntos de victoria. Los puntos de victoria que tiene cada equipo se calcula de la siguiente forma: tomas a cada miembro de los vengadores A_i (1<=i<=N) y comparas la fuerza de todos contra cada uno de los integrantes del equipo de Thanos T_j (1<=j<=N). Si la fuerza del vengador es mayor, los vengadores ganan un punto, si es igual nadie recibe punto y si es menor el equipo de Thanos recibe un punto. Haces la comparación para cada posible par de A_i y T_j para obtener los puntos en total. Si el equipo de los vengares tiene más puntos significa que ellos ganan, si esto sucede debes imprimir \"Avengers\" y por cuantos puntos ganan. De lo contrario significa que Felipe debe actuar para darle más puntos de victoria a los vengadores, así que debes imprimir \"Thanos\" y un número indicando el mínimo número de puntos que necesitan los vengadores para ganarle al equipo de Thanos.",
        "entrada": "Un único número entero N que el indica el número de integrantes que tiene cada equipos. En la siguiente linea N números enteros positivos separados por un espacio representando la fuerza de cada integrante de los vengadores. En la siguiente linea N números enteros positivos separados por un espacio representando la fuerza de cada integrante del grupo de Thanos",
        "salida": "Una palabra \"Thanos\" o \"Avengers\" dependiendo de quien gane. En otra linea un entero S representando lo dicho en el problema.",
        "nivel": "Intermedio (medio) - Análisis y diseño de algoritmos",
        "categorias": [
            "Vectores",
            "Ordenamiento",
            "Técnica de dos apuntadores"
        ],
        "estructuras": [
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    ios::sync_with_stdio(0);\n  cin.tie(0);\n   cout.tie(0);\n  int n, m, a=0, b=0, c, d, e, f, g, h;\n    vector<int>ar(500001), ar2(500001);\n   cin>>n;\n   for(auto i=0; i<n; i++){\n      cin>>ar[i];\n   }\n for(auto i=0; i<n; i++){\n      cin>>ar2[i];\n  }\n sort(ar,ar+n);\n    sort(ar2,ar2+n);\n  ar2[n]=100000001;\n ar[n]=100000001;\n  for(auto i=0; i<n;){\n      d=ar[i];\n      e=i+1;\n        while(ar[e]==d){\n          e++;\n      }\n     while(ar2[a]<d){\n          a++;\n      }\n     b+=a*(e-i);\n       while(ar2[a]==d){\n         a++;\n      }\n     b-=(n-a)*(e-i);\n       i=e;\n  }\n if(b>0){\n      cout<<\"Avengers\\n\"<<b;\n }\n else{\n     cout<<\"Thanos\\n\"<<-b+1;\n    }\n\n   return 0;\n}\n"
    },
    {
        "titulo": "13000. Pareja que suma K",
        "url": "https://omegaup.com/arena/problem/SumaParejaK/",
        "descripcion": "Dado un arreglo de tamaño N, con elementos a_1,...,a_n decir si existe un pareja (a_i,a_j) tal que a_i+a_j=k para k dado y además i!=j.",
        "entrada": "El número N, la cantidad de elementos del arreglo. Los elementos a_1,...,a_n en la siguiente linea. Y después el número k que se quiere formar.",
        "salida": "En caso de existir la suma, sacar la pareja (a_i,a_j) tal que min(a_i,a_j) sea lo menor posible. Deberás imprimir la pareja de menor a mayor. En caso de que no exista imprimir (0,0).",
        "nivel": "Intermedio (medio) - Análisis y diseño de algoritmos",
        "categorias": [
            "Vectores",
            "Ordenamiento",
            "Técnica de dos apuntadores"
        ],
        "estructuras": [
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint main(){\n   ios::sync_with_stdio(0);\n  cin.tie(0);\n   cout.tie(0);\n  ll n, m, a=0, b, c, d, e, f, g, h;\n    vector<ll>ar(1000000,0);\n  cin>>n;\n   for(auto i=0; i<n; i++){\n      cin>>ar[i];\n   }\n cin>>m;\n   sort(ar,ar+n);\n    b=n-1;\n    while(a<b){\n       c=ar[a]+ar[b];\n        if(c==m){\n         cout<<ar[a]<<\" \"<<ar[b];break;\n      }\n     else if(c>m){\n         b--;\n      }\n     else{\n         a++;\n      }\n }\n if(a>=b){\n     cout<<\"0 0\";\n    }\n\n   return 0;\n}\n"
    },
    {
        "titulo": "11838. Feria de negocios",
        "url": "https://omegaup.com/arena/problem/OMI-CDMX-EDOMEX-2020-Negocios/",
        "descripcion": "N personas se encuentran en una feria de N negocios. La i-ésima persona está inicialmente en el i-ésimo puesto. Inicialmente, cada persona cuenta con una cantidad de dinero para invertir de C_i pesos. En cada puesto se puede invertir desde 1 hasta P_i pesos. Las personas en la feria no son expertas en finanzas y su estrategia es la siguiente: En cada puesto invierten tanto dinero como puedan, es decir, el mínimo entre el dinero que les quede y el máximo permitido (P_i) de ese puesto. Luego de invertir en un puesto, avanzan al puesto siguiente. Si ya no hay más puestos o si se les acaba el dinero, se retiran de la feria. Tu tarea es contestar la siguiente pregunta: ¿cuánto dinero recolectó cada puesto?",
        "entrada": "En la primera línea un entero N, el número de personas y puestos en la feria. En la segunda línea N enteros C_1,C_2,C_3,...,C_N, el dinero inicial de la i-ésima persona. En la tercera línea N enteros P_1,P_2,P_3,...,P_N, el precio de la acción del i-ésimo negocio.",
        "salida": "Una sola línea con N enteros, donde el i-ésimo entero representa la cantidad de dinero que recolectó el i-ésimo negocio.",
        "nivel": "Intermedio (medio) - Análisis y diseño de algoritmos",
        "categorias": [
            "Vectores",
            "Suma de prefijos",
            "Búsqueda binaria"
        ],
        "estructuras": [
            "long long",
            "vector<long long>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef struct{\n    long long aa, bb, cc, dd, ee;\n}sobra;\nlong long a, b, c, d, e, f, g, h;\nsobra num[100002];\n\nint main(){\n  cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  cin>>a;\n   for(auto i=1; i<=a; ++i){\n      cin>>num[i].aa;\n   }\n for(auto i=1; i<=a; ++i){\n      cin>>num[i].ee;\n       num[i].bb=num[i].ee+num[i-1].bb;\n  }\n for(auto i=1; i<=a; ++i){\n      if(num[a].bb-num[i-1].bb<=num[i].aa){\n         num[i].cc++;\n          num[i].cc+=num[i-1].cc;\n           cout<<num[i].cc*num[i].ee+num[i].dd<<\" \";continue;\n      }\n     if(num[i].aa<num[i].ee){\n          num[i].cc+=num[i-1].cc;\n           cout<<num[i].cc*num[i].ee+num[i].aa+num[i].dd<<\" \";continue;\n        }\n     b=i;\n      c=a;\n      while(b<=c){\n          d=(b+c)/2;\n            if(num[d].bb-num[i-1].bb<=num[i].aa){\n             e=d;\n              b=d+1;\n            }\n         else{\n             c=d-1;\n            }\n     }\n     while(num[e+1].bb-num[i-1].bb<=num[i].aa){\n            e++;\n      }\n     num[i].cc++;\n      num[i].cc+=num[i-1].cc;\n       num[e+1].cc--;\n        num[e+1].dd+=num[i].aa-num[e].bb+num[i-1].bb;\n     //cout<<\"-\"<<num[e+1].dd<<\" \"<<e+1<<\" \"<<num[i].cc<<\"-\\n\";\n       cout<<(num[i].cc*num[i].ee)+num[i].dd<<\" \";\n }\n\n   return 0;\n}\n"
    },
    {
        "titulo": "11840. Trajineras",
        "url": "https://omegaup.com/arena/problem/Trajineras/",
        "descripcion": "Dada la carga máxima L de la trajinera y los pesos a_i de los N integrantes de la familia de Karel en el orden en el que se formaron, debes ayudar a Karel a encontrar el máximo número k tal que cualesquier grupo continuo de k familiares que se elija de la fila no se excederá la capacidad L de la trajinera.",
        "entrada": "En la primera línea dos enteros N y L, que representan la cantidad de robots en la familia de Karel y la carga máxima de las trajineras, respectivamente. En la segunda línea N valores enteros a_i qué representa el peso del i-ésimo robot en la fila.",
        "salida": "Una sola línea con un entero indicando el máximo K tal que ningún grupo de K robots continuos en la fila exceda la carga máxima. Observa que el máximo K puede ser 0.",
        "nivel": "Intermedio (medio) - Análisis y diseño de algoritmos",
        "categorias": [
            "Vectores",
            "Suma de prefijos",
            "Ventana deslizante",
            "Técnica de dos apuntadores"
        ],
        "estructuras": [
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  int a, b, c, d, e, f, g, h;\n   vector<int>num(100002,0);\n cin>>a>>b;\n    for(auto i=1; i<=a; ++i){\n      cin>>num[i];\n      if(num[i]>b){\n         i++;\n          while(i<=a){\n              cin>>num[i];\n              i++;\n          }\n         cout<<0;return 0;\n     }\n     num[i]+=num[i-1];\n }\n if(num[a]<b){\n     cout<<a;return 0;\n }\n c=a-1;\n    d=a-1;\n    while(d<=a){\n      while(num[d]-num[d-c]>b){\n         d--;\n          c--;\n      }\n     while(d<=a && num[d]-num[d-c]<=b){\n            d++;\n      }\n }\n cout<<c;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "11391. Torre 5G",
        "url": "https://omegaup.com/arena/problem/Torre-5G/",
        "descripcion": "La torre 5G se coloca en un posición y tiene un alcance circular, en donde K es el radio del circulo, tu vives en un vecindario muy particular que tiene forma de circunferencia con N casas, cada una tiene n_i personas que viven en ella. Debido a la mala fama que tiene la torre 5G tienes que contratar el servicio en una posicion donde la suma de las personas que viven en las casas que estan dentro del rango de la torre sea la mínima a cualquier otra posición del vecindario porque así reduciras la probabilidad de que las personas se enteren de la existencia de la torre 5G. Tu tarea sera encontrar la posición idónea de la torre con la mínima suma de persona que viven dentro del rango.",
        "entrada": "Dos enteros N y K que son el número de casas del vecindario y el radio de la torre 5G, seguido de N números que representa las personas que viven en la i-ésima casa.",
        "salida": "Un solo entero que representa la suma mínima de personas que viven dentro del rango de la torre 5G.",
        "nivel": "Intermedio (medio) - Análisis y diseño de algoritmos",
        "categorias": [
            "Vectores",
            "Ventana deslizante"
        ],
        "estructuras": [
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  int a, b, c, d, e, f, g, h;\n   vector<int>num;\n   cin>>a>>b;\n    for(auto i=0; i<=b*2; i++){\n        cin>>c;\n       d+=c;\n     num.push_back(c);\n }\n e=d;\n  for(auto i=(b*2)+1; i<a; i++){\n     cin>>c;\n       d+=c-num[i-((b*2)+1)];\n        num.push_back(c);\n     e=min(e,d);\n   }\n for(auto i=a; i<a+b*2; i++){\n       d+=num[i-a]-num[i-((b*2)+1)];\n     e=min(e,d);\n   }\n cout<<e;\n  \n  return 0;\n}\n"
    },
    {
        "titulo": "9532. RooTriangulos",
        "url": "https://omegaup.com/arena/problem/RooTriangulos/",
        "descripcion": "El perímetro de un triángulo con aristas de largo a, b, c es a+b+c. Tienes varios palos de diferentes longitudes. Puedes construir un triángulo con aristas de largo x<=y<=z si y sólo si x+y>z.",
        "entrada": "La primer línea de entrada contendrá el número N (3<=N<=50) de elementos. La segunda línea contendrá los N_i (1<=N_i<=1000) elementos separados por un espacio.",
        "salida": "Regresa el máximo perímetro posible de un triángulo que puede ser construido con los palos que tienes a tus disposición. Cada lado del triángulo debe ser construido usando un sólo palo. Tampoco puedes romper los palos existentes. Regresa -1 si el triángulo no puede ser construido.",
        "nivel": "Intermedio (medio) - Análisis y diseño de algoritmos",
        "categorias": [
            "Vectores",
            "Ordenamiento",
            "Técnica de dos apuntadores"
        ],
        "estructuras": [
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int N;\n    cin >> N;\n    vector<int> palos(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> palos[i];\n    }\n    sort(palos.begin(), palos.end());\n    int maxPerimetro = -1;\n    for (int i = N - 1; i >= 2; --i) {\n        if (palos[i - 1] + palos[i - 2] > palos[i]) {\n            maxPerimetro = palos[i] + palos[i - 1] + palos[i - 2];\n            break; // Encontramos el triangulo valido con mayor perimetro\n        }\n    }\n    cout << maxPerimetro << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "9530. RooPibipollo",
        "url": "https://omegaup.com/arena/problem/RooPibipollo/",
        "descripcion": "Zots es un pequeño niño maya que a diario ayuda a su mama a vender pibipollos, los cuales transporta en su sabucan (morral o bolsa) y solo se le permite meter 2 pibipollos en una sola bolsa ya que sino se aplastan. Desgraciadamente solo tiene un sabucan. Para que dos pibipollos puedan entrar en su sabucan se requiere que la suma de sus longitudes no sea mayor a la longitud de la bolsa, dos o más pibipollos pueden tener la misma longitud. Se te pide que hagas un programa que diga cuantos pares de pibipollos pueden entrar en un determinado sabucan.",
        "entrada": "En la primera línea hay 2 números enteros, el primer número N indica el número de pibipollos que tiene que vender Zots, este número puede ir desde el valor de 2 hasta el valor de 20,000. El segundo número será el tamaño del sabucan, en las siguientes N líneas están las longitudes de los pibipollos. Las longitud de los pibipollos varía de desde 1 hasta 1,000,000. El sabucan siempre medirá menos de 10,000,000.",
        "salida": "Tu programa deberá entregar un solo número entero que contenga la cantidad de parejas de pibipollos que pueden entrar en el sabucan.",
        "nivel": "Intermedio (medio) - Análisis y diseño de algoritmos",
        "categorias": [
            "Vectores",
            "Ordenamiento",
            "Técnica de dos apuntadores"
        ],
        "estructuras": [
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int N, tamanoSabucan;\n    cin >> N >> tamanoSabucan;\n    vector<int> longitudesPibipollos(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> longitudesPibipollos[i];\n    }\n    sort(longitudesPibipollos.begin(), longitudesPibipollos.end());\n    int parejas = 0;\n    int izquierda = 0;\n    int derecha = N - 1;\n    while (izquierda < derecha) {\n        if (longitudesPibipollos[izquierda] + longitudesPibipollos[derecha] <= tamanoSabucan) {\n            parejas += derecha - izquierda; \n            ++izquierda;\n        } else {\n            --derecha;\n        }\n    }\n    cout << parejas << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "314. Xbox Live Points",
        "url": "https://omegaup.com/arena/problem/Xbox-Live-Points/",
        "descripcion": "Con la salida del nuevo Xbox One, la compañía está llevando a cabo una campaña para promocionar el nuevo producto. Para ello quiere obsequiar puntos para Xbox Live de una manera muy peculiar. Primero, se van a elegir al azar N cajas muy bonitas, que en su interior contienen un número anotado en un papelito, ese número indica la cantidad de puntos que te van a regalar si eliges esa caja. Para hacer las cosas más interesantes, te dicen que ese número puede ser tanto positivo, negativo o cero. Pero descuida, te aseguran que si eliges bien, nunca te llevarás puntos en contra. Después, las N cajas van a ser colocadas en una fila y podrás tomar la cantidad de cajas que quieras siempre y cuando sean cajas consecutivas. Luego, te darán la oportunidad de saber de antemano el valor que tienen las cajas para que, un segundo después, tomes las cajas que más te gusten (o que más puntos te den) respetando la restricción. Cada número estará entre -100 y 100. Como buen olímpico, quieres maximizar el número de puntos y para ello vas a escribir un programa que te diga cuál es ese máximo número de puntos que puedes conseguir en esta gran oportunidad. Dados N números, decir cuál es el máximo de puntos que puedes escoger cumpliendo con las condiciones.",
        "entrada": "Línea 1: Un número N (1<=N<=1000000) que representa el número de cajas. Línea 2: N números, donde el i-ésimo número representa los puntos en la caja i (-100<=N_i<=100).",
        "salida": "Línea 1: Un número que diga cuál es la suma máxima de puntos que puedes obtener.",
        "nivel": "Intermedio (medio) - Análisis y diseño de algoritmos",
        "categorias": [
            "Vectores",
            "Programación dinámica"
        ],
        "estructuras": [
            "int",
            "long long",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int N;\n    cin >> N;\n    vector<int> puntos(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> puntos[i];\n    }\n    long long suma_actual = 0;\n    long long suma_maxima = puntos[0];\n    for (int i = 0; i < N; ++i) {\n        suma_actual += puntos[i];\n        suma_maxima = max(suma_maxima, suma_actual);\n        if (suma_actual < 0) {\n            suma_actual = 0;\n        }\n    }\n    cout << suma_maxima << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "1357. Carretera",
        "url": "https://omegaup.com/arena/problem/carretera/",
        "descripcion": "Desde el techo de tu casa puedes ver una larga carretera (de hecho, infinita), con N carros cruzando en ambos sentidos a distintas velocidades. Como tienes un severo problema con las redes sociales, te interesaría tomarle una foto a todos los carros que están cruzando, pero te gustaría poder hacerle la mayor cantidad de zoom. Para ello, estás dispuesto a esperar tanto tiempo sea necesario para que el cuadro que tu fotografía requiere para capturar los N carros sea lo más pequeño posible. Hay suficientes carriles en la carretera para que no choquen nunca los carros al pasarse entre sí.",
        "entrada": "En la primer línea, N (1<=N<=10^5), la cantidad de carros. En las siguientes N líneas, dos enteros, x_i y v_i (|x_i|,|v_i|<=10^5), la posición inicial (en metros) y la velocidad (en metros por segundo) del i-ésimo carro. Los carros no cambian nunca su velocidad. El signo de la velocidad indica la dirección del carro.",
        "salida": "El ancho mínimo posible de una fotografía que cubra a los N carros. Tu respuesta se considerará correcta si tiene un error relativo menor a 10^-6.",
        "nivel": "Intermedio (medio) - Análisis y diseño de algoritmos",
        "categorias": [
            "Vectores",
            "Búsqueda binaria"
        ],
        "estructuras": [
            "int",
            "double",
            "vector<>",
            "fixed",
            "setprecision()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Car {\n    double x, v;\n};\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int N;\n    cin >> N;\n    vector<Car> cars(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> cars[i].x >> cars[i].v;\n    }\n    auto get_width = [&](double time) {\n        double min_pos = 1e9, max_pos = -1e9;\n        for (int i = 0; i < N; ++i) {\n            double pos = cars[i].x + cars[i].v * time;\n            min_pos = min(min_pos, pos);\n            max_pos = max(max_pos, pos);\n        }\n        return max_pos - min_pos;\n    };\n    double left = 0, right = 1e5; // Rango inicial de tiempo\n    double eps = 1e-9; // Precisi? deseada\n    while (right - left > eps) {\n        double mid = (left + right) / 2;\n        if (get_width(mid) < get_width(mid + eps)) {\n            right = mid;\n        } else {\n            left = mid;\n        }\n    }\n    cout << fixed << setprecision(7) << get_width(left) << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "8524. Exponenciación con multiplicaciones y divisiones",
        "url": "https://omegaup.com/arena/problem/Exponenciacion-con-multiplicacio/",
        "descripcion": "Escribe un programa que calcule en cuántos pasos puedes calcular la potencia entera A^B, si comienzas en X=1 y sólo tienes disponibles las siguientes tres operaciones: multiplicar X por A, dividir X entre A y elevar X al cuadrado. En los tres casos, el antiguo valor de X se pierde y sólo puede usarse el nuevo valor.",
        "entrada": "Un entero B. Puedes suponer que 0<=B<=20.",
        "salida": "La menor cantidad de pasos que necesitas para calcular A^B según lo descrito.",
        "nivel": "Intermedio (medio) - Análisis y diseño de algoritmos",
        "categorias": [
            "Vectores",
            "Cálculo matemático",
            "Búsqueda en amplitud"
        ],
        "estructuras": [
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint calcularPasos(int b) {\n    vector<int> dp(b + 1, INT_MAX);\n    dp[0] = 0; \n    dp[1] = 1; \n    for (int i = 2; i <= b; ++i) {\n        dp[i] = min(dp[i], dp[i - 1] + 1); // Multiplicar por A\n        if (i % 2 == 0) {\n            dp[i] = min(dp[i], dp[i / 2] + 1); // Elevar al cuadrado\n        }\n        if (i % 3 == 0) {\n            dp[i] = min(dp[i], dp[i / 3] + 2); // Dividir entre A y elevar al cuadrado \n        }\n    }\n    return dp[b];\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int b;\n    cin >> b;\n    cout << calcularPasos(b) << endl;\n\n    return 0;\n"
    },
    {
        "titulo": "19593. A Más B",
        "url": "https://omegaup.com/arena/problem/A-Mas-B-big/",
        "descripcion": "Dar la respuesta de la suma de dos numeros A+B.",
        "entrada": "Dos numeros enteros A y B (1<=A,B<=10^10^5).",
        "salida": "Un entero que sea la respuesta a A+B.",
        "nivel": "Intermedio (medio) - Matemáticas en la programación",
        "categorias": [
            "Caracteres y cadenas",
            "Números grandes"
        ],
        "estructuras": [
            "int",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    ios::sync_with_stdio(0);\n  cin.tie(0);\n   cout.tie(0);\n  int n, m, a, b, c, d, e, f, g, h;\n vector<char>ar(100005);\n   string s,r;\n   cin>>s>>r;\n    c=0;\n  d=0;\n  for(a=s.size()-1, b=r.size()-1; (a>-1 && b>-1); a--, b--){\n        ar[c]=((int)s[a]+(int)r[b]+(int)d-96)%10+48;\n      d=((int)s[a]+(int)r[b]+(int)d-96)/10;\n     c++;\n  }\n while(a>-1){\n      ar[c]=((int)s[a]+d-48)%10+48;\n     d=((int)s[a]+d-48)/10;\n        a--;\n      c++;\n  }\n while(b>-1){\n      ar[c]=((int)r[b]+d-48)%10+48;\n     d=((int)r[b]+d-48)/10;\n        b--;\n      c++;\n  }\n if(d){\n        cout<<d;\n  }\n while(--c>-1){\n        cout<<ar[c];\n  }\n\n   return 0;\n}\n"
    },
    {
        "titulo": "10823. Atsa y el torneo de programación",
        "url": "https://omegaup.com/arena/problem/atsa-copa-fut/",
        "descripcion": "Una persona quiere organizar una copa individual de programación. En el torneo participarán N personas, que competirán en eventos 1 vs 1, de tal forma que al final cada competidor se habrá enfrentado con todos los demás. Todos los encuentros serán mostrados en transmisiones en vivo. La persona quiere saber que tanto alcance tendrán todas las transmisiones. Debido a que algunos competidores son más populares que otros sus encuentros tendrán más alcance. Se tiene un registro del nivel de popularidad de cada concursante. El nivel del concursante i se puede expresar como un valor P_i. El encuentro entre los concursantes a y b tendrá un alcance P_a*P_b. Formalmente, la persona quiere calcular [sum_{i=1}^{N}[sum_{j=i+1}^{N}P_i*P_j]].",
        "entrada": "La primera línea contiene N (1<=N<=10^5). La segunda línea contiene los N valores de P_i (1<=P_i<=10^3).",
        "salida": "Una sola linea con el alcance total.",
        "nivel": "Intermedio (medio) - Matemáticas en la programación",
        "categorias": [
            "Vectores",
            "Cálculo matemático"
        ],
        "estructuras": [
            "long long",
            "vector<long long>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n   cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  int N;\n    cin >> N;\n vector<long long> P(N);\n   for (int i = 0; i < N; ++i) {\n     cin >> P[i];\n  }\n long long alcance_total = 0;\n  long long suma_actual = 0;\n    // Optimizacion: Calculamos la suma en tiempo O(N)\n for (int i = N - 1; i >= 0; --i) {\n        alcance_total += P[i] * suma_actual;\n      suma_actual += P[i];\n  }\n cout << alcance_total << endl;\n\n  return 0;\n}\n"
    },
    {
        "titulo": "6532. Karel y los quebrados",
        "url": "https://omegaup.com/arena/problem/Karel-y-los-quebrados/",
        "descripcion": "Karel sabe que para cada fracción 1/k (k>0) siempre puede encontrar dos enteros positivos \"x\" \"y\" tales que: 1/k=1/x+1/y. A Karel le interesa mucho los quebrados, por lo que te ha pedido que para un numero k le ayudes a encontrar cuantos pares de números enteros \"x\" y \"y\" existen que cumplan con lo anterior.",
        "entrada": "Un único número entero k (0<k<=10^4).",
        "salida": "En la primera linea de salida un numero n que representa la cantidad de pares (x,y), En la segunda linea una lista ordenada de los valores (x,y).",
        "nivel": "Intermedio (medio) - Matemáticas en la programación",
        "categorias": [
            "Teoría de numeros"
        ],
        "estructuras": [
            "int",
            "vector<pair<int,int>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n   cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  int k;\n    cin >> k;\n vector<pair<int, int>> soluciones;\n    // Para encontrar las soluciones (x, y) de la ecuacion 1/k = 1/x + 1/y,\n    // podemos despejar y obteniendo: y = k*x / (x-k)\n // Iteramos sobre los posibles valores de x, desde k+1 hasta 2k.\n  // Este rango se elige para asegurar que x > k y que y sea positivo.\n  for (int x = k + 1; x <= 2 * k; ++x) {\n        // Verificamos si y es un entero positivo\n     if (k * x % (x - k) == 0 && k * x / (x - k) > 0) {\n            int y = k * x / (x - k);\n          soluciones.push_back({y,x});\n      }\n }\n // Imprimimos la cantidad de soluciones encontradas\n   cout << soluciones.size() << endl;\n    // Imprimimos las soluciones (x, y) en el formato especificado\n    for (auto& sol : soluciones) {\n        cout << \"1/\" << k << \" = 1/\" << sol.first << \" + 1/\" << sol.second << endl;\n }\n\n   return 0;\n}\n"
    },
    {
        "titulo": "7813. DCM Euclides",
        "url": "https://omegaup.com/arena/problem/DCM-Euclides/",
        "descripcion": "Escribe un programa que calcule el divisor común máximo de dos enteros.",
        "entrada": "Una línea con 2 enteros a y b separados por un espacio (1<=a,b<=10^7).",
        "salida": "Un entero: el divisor común máximo de los enteros.",
        "nivel": "Intermedio (medio) - Matemáticas en la programación",
        "categorias": [
            "Teoría de numeros"
        ],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int a, b;\n    cin >> a >> b;\n    // Implementaci? del algoritmo de Euclides\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    cout << a << endl; \n\n    return 0;\n}\n"
    },
    {
        "titulo": "2817. Agente A, El Héroe Nacional",
        "url": "https://omegaup.com/arena/problem/Agente-A-El-Heroe-Nacional/",
        "descripcion": "El Agente A está en una misión secreta y ha conseguido robar el arma secreta enemiga, si consigue desactivarla será un héroe nacional, sin embargo, ha sido descubierto, y ahora el malvado Doctor B y su ejército lo están buscando para \"encargarse\" de él, el Agente A se ha visto rodeado y sabe que su fin está cerca, sabe que en exactamente t minutos antes de que el Doctor B y su ejército lleguen hasta él, el arma secreta del Doctor B tiene un elaborado sistema de seguridad, el arma cuenta con N filtros de seguridad, en cada filtro de seguridad, se muestran inicialmente en una pantalla 2 números: a_inicial y b_inicial; la labor de inteligencia del Agente A le ha permitido saber que en cada filtro de seguridad debe volver a los 2 números 0 mediante algunos movimientos válidos, el arma no le permite realizar movimientos inválidos, un movimiento válido consiste en: #1. A los números en la pantalla (a_actual y b_actual) restarles un divisor que tengan en común esos números (los que se muestran en la pantalla en ese momento) y que a su vez divida a a_inicial o a b_inicial (los números iniciales que se mostraron en la pantalla). #2. Si alguno de los números actuales en la pantalla es 0 volver 0 al otro.; Una vez que hace un movimiento válido debe esperar 1 minuto para poder hacer otro, por esto el agente tomó su cronómetro y lo inicio en t, el agente A sólo puede hacer un movimiento si el cronómetro no ha llegado a 0. Ayúdale al Agente A a convertirse en héroe nacional.",
        "entrada": "En la primera línea el número N (1<=N<=100000) el número de filtros de seguridad. En la siguiente línea el número t (1<=t<=2^63) la cantidad de tiempo que el Agente A tiene antes de que el Doctor B se \"encargue\" de él. En las siguientes N líneas 2 números a y b (1<=a,b<=1000000) describiendo un filtro de seguridad.",
        "salida": "Si no puede superar los N filtros de seguridad antes de que el Doctor B le atrape imprime: \"El Agente A no sera heroe nacional, el Doctor B destruira su pais\". En caso contrario imprime 1 número: La mínima cantidad de tiempo que le toma al Agente A desactivar el arma.",
        "nivel": "Intermedio (medio) - Matemáticas en la programación",
        "categorias": [
            "Cálculo matemático"
        ],
        "estructuras": [
            "long long",
            "__gcd()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e, f=0;\n    cin>>c>>e;\n    while(c--){\n        cin>>a>>b;\n        d=__gcd(a,b);\n        if(d==1){\n            f+=min(a,b)+1;continue;\n        }\n        while(a && b){\n            a-=d;\n            b-=d;\n            f++;\n            if((!b && a) || (!a && b)){\n                f++;break;\n            }\n        }\n        if(f-1>e){\n            cout<<\"El Agente A no sera heroe nacional, el Doctor B destruira su pais\";return 0;\n        }\n    }\n    if(f-1>e)cout<<\"El Agente A no sera heroe nacional, el Doctor B destruira su pais\";\n    else cout<<f-1;\n    \n    return 0;\n}\n"
    },
    {
        "titulo": "6354. La Risa en Vacaciones 2",
        "url": "https://omegaup.com/arena/problem/La-Risa-en-Vacaciones-2/",
        "descripcion": "Existen 30 ciudades, numeradas del 0 al 29. Estás a punto de salir de vacaciones, en las cuales visitarás una o más de éstas ciudades. En el trabajo te estan preguntando constantemente que ciudades visitarás, pero tu no quieres decirles, para que no te vayan a encontrar y a molestar con asuntos de trabajo durante tus vacaciones. Pero tampoco eres buena para decir mentiras. Para lidiar con este problema has ideado una forma de codificar tu itinerario para tus vacaciones que consiste en representar las ciudades como bits en un número binario. Si visitas la ciudad k, entonces el bit k tendrá un 1, sino tendrá un 0. Por ejemplo, si visitas las ciudades 2 y 3, esto equivale al número 1100, que representa el número 12. Entonces si alguién te pregunta que ciudades visitaras, tu dices 12. La otra persona no sabrá de que estas hablando y dejará de molestarte. Y a su vez tu estarás diciendo la verdad, así que tu alma puede estar tranquila. Escribe un programa que dadas las ciudades que visitarás en tus vacaciones, imprima un número indicando el itinerario codificado.",
        "entrada": "Un número n (0<=n<=30), indicando la cantidad de ciudades que visitarás. Le siguen n líneas indicando cada una de las ciudades que visitarás.",
        "salida": "Un sólo número indicando el itinerario codificado.",
        "nivel": "Intermedio (fácil) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Manipulación de bits"
        ],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int n, itinerario = 0;\n    cin >> n;\n    for(auto i = 0; i < n; ++i){\n        int ciudad;\n        cin >> ciudad;\n        itinerario |= (1 << ciudad); \n    }\n    cout << itinerario << \"\\n\";\n\n    return 0;\n}\n"
    },
    {
        "titulo": "6355. La Risa en Vacaciones 3",
        "url": "https://omegaup.com/arena/problem/La-Risa-en-Vacaciones-3/",
        "descripcion": "Existen 30 ciudades, numeradas del 0 al 29. Estás a punto de salir de vacaciones, en las cuales visitarás una o más de éstas ciudades. En el trabajo te estan preguntando constantemente que ciudades visitarás, pero tu no quieres decirles, para que no te vayan a encontrar y a molestar con asuntos de trabajo durante tus vacaciones. Para lidiar con este problema has ideado una forma de codificar tu itinerario para tus vacaciones que consiste en representar las ciudades como bits en un número binario. Si visitas la ciudad k, entonces el bit k tendrá un 1, sino tendrá un 0. Por ejemplo, si visitas las ciudades 2 y 3, esto equivale al número 1100, que representa el número 12. Entonces si alguién te pregunta que ciudades visitaras, tu dices 12. Otra cosa importante es que dado que eres muy original y siempre quieres ser diferente a los demás, sólo visitarás ciudades que NO hayan sido visitadas por ninguno de tus amigos anteriormente. Dados los itinierarios codificados de tus amigos, escribe un programa que indique las ciudades que visitarás en las vacaciones.",
        "entrada": "Un número n (0<=n<=10), indicando la cantidad de amigos que te dijeron sus itinerarios de viajes previos. Le siguen n líneas con los itinerarios codificados de tus amigos.",
        "salida": "Las ciudades que visitarás en las vacaciones, en orden ascendente y en líneas separadas. Si NO hay ciudades que visitar, imprimir el mensaje ''Sin vacaciones''.",
        "nivel": "Intermedio (fácil) - Estructuras de datos y Algoritmos: 2",
        "categorias": [
            "Manipulación de bits"
        ],
        "estructuras": [
            "bool",
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int n;\n    cin >> n;\n    // Se utiliza un entero para almacenar los itinerarios de todos los amigos, \n    // ya que 2^30 es menor al l?ite de un entero (int).\n    int itinerarios_amigos = 0;\n    for (int i = 0; i < n; ++i) {\n        int itinerario_amigo;\n        cin >> itinerario_amigo;\n        itinerarios_amigos |= itinerario_amigo; // Combinar los itinerarios\n    }\n    // Iterar sobre cada ciudad (bit)\n    bool sin_vacaciones = true;\n    for (int ciudad = 0; ciudad < 30; ++ciudad) {\n        // Verificar si la ciudad (bit) NO est? en los itinerarios de los amigos\n        if (!(itinerarios_amigos & (1 << ciudad))) {\n            cout << ciudad << \"\\n\";\n            sin_vacaciones = false;\n        }\n    }\n    if (sin_vacaciones) {\n        cout << \"Sin vacaciones\\n\";\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "6353. La Risa en Vacaciones",
        "url": "https://omegaup.com/arena/problem/La-Risa-en-Vacaciones/",
        "descripcion": "Existen n ciudades, numeradas del 0 al n-1. Estás a punto de salir de vacaciones, en las cuales visitarás una o más de éstas ciudades. En el trabajo te estan preguntando constantemente que ciudades visitarás, pero tu no quieres decirles, para que no te vayan a encontrar y a molestar con asuntos de trabajo durante tus vacaciones. Pero tampoco eres buena para decir mentiras. Para lidiar con este problema has ideado una forma de codificar tu itinerario para tus vacaciones que consiste en representar las ciudades como bits en un número binario. Si visitas la ciudad k, entonces el bit k tendrá un 1, sino tendrá un 0. Por ejemplo, si visitas las ciudades 2 y 3, esto equivale al número 1100, que representa el número 12. Entonces si alguién te pregunta que ciudades visitaras, tu dices 12. La otra persona no sabrá de que estas hablando y dejará de molestarte. Y a su vez tu estarás diciendo la verdad, así que tu alma puede estar tranquila. Escribe un programa que dado el itinerario codificado, imprima las ciudades que visitarás en tus vacaciones.",
        "entrada": "Un número k (0<=k<=2^30), indicando tu itinierario codificado.",
        "salida": "Las ciudades que visitarás durante tus vacaciones, cada una en una línea por separado y en orden ascendente. Si no visitarás ninguna ciudad, imprimir el mensaje ''No hay risas sin vacaciones >(''.",
        "nivel": "Intermedio (fácil) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Manipulación de bits"
        ],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int k;\n    cin >> k;\n    if (k==0){\n        cout << \"No hay risas sin vacaciones >('\\n\";\n        return 0;\n    }\n    for (int i=0; i<30; i++){\n        if ((1<<i) & k){\n            cout << i << \"\\n\";\n        }\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "1254. Tirando Tortillas",
        "url": "https://omegaup.com/arena/problem/Tirando-Tortillas/",
        "descripcion": "En cierta ciudad extraña, cierta tortillería extraña tiene muchas costumbres raras en su forma de funcionar. Una de estas costumbres es atender de una manera extraña, esto sucede así: Llega la primera persona que atenderá pidiendo x tortillas y sacan de la maquina de tortillas x tortillas, ahora pueden pasar 2 cosas: Llega otra persona y se pone delante de la que ya estaba y hace su pedido. Si el pedido es más grande que el anterior entonces solo sacan más tortillas pero si es menor entonces tiran las tortillas que sobran y vuelve a suscitarse alguno de estos 2 casos. Entregan las tortillas, la persona se va y vuelven a sacar x tortillas que es el pedido de la persona que estaba atrás de la que se acaba de ir (En caso de que todavía haya persona). El jefe de la tortillería esta muy ocupado atendiendo su carnicería, por eso te ha pedido que a partir de lo que sucedió en un día digas cuantas tortillas se tiraron.",
        "entrada": "En la primera línea N, que es el número de cosas que pasaron en un día (N siempre es par). De la línea N a la N+1 pueden haber uno de estos dos: Una letra ‘C’ seguido de un número x ,que significa que llegó una persona pidiendo x tortillas y que la tortillería saca x tortillas. Si ya había sacado anteriormente tortillas pasa lo que se explica en la descripción. Una letra ‘G’, que significa que se entregan las tortillas, la persona se va y ahora se atiende a la de atrás.",
        "salida": "El número de tortillas tiradas.",
        "nivel": "Intermedio (fácil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Caracteres y cadenas",
            "Pilas"
        ],
        "estructuras": [
            "char",
            "int",
            "stack<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  int a, b, c, d, e, f, g, h;\n   char z;\n   stack<int>num;\n    cin>>a>>z>>b;\n num.push(b);\n  a--;\n  while(a--){\n       cin>>z;\n       if(z=='C'){\n           cin>>b;\n           if(num.size()){\n               c+=max((int)0,num.top()-b);\n           }\n         num.push(b);\n      }\n     else{\n         num.pop();\n        }\n }\n cout<<c;\n  \n  return 0;\n}\n"
    },
    {
        "titulo": "10866. Programador desordenado",
        "url": "https://omegaup.com/arena/problem/Programador-desordenado/",
        "descripcion": "Josué es un programador desordenado ya que al programar declara sus variables con letras del abecedario y no le pone nombres congruentes de acuerdo con el problema que está resolviendo, después de estar un buen rato programando se le olvido cual era la variable que contiene el resultado de su código. Para su buena suerte recuerda que dicha variable es la que más se repite en su código, cada variable tiene asignado un numero diferente, pero Josué no tiene tiempo de buscar esta variable por tanto te pide tu ayuda para encontrar la variable que tiene la respuesta de su código en lo que resuelve más problemas.Dado N números encontrar el número asignado a la variable que más se repite en su código.",
        "entrada": "En la primera línea un entero N, en la segunda línea N (1<=N<=10^6) enteros n_i (1<=n_i<=10^6) que representan los números de las variables.",
        "salida": "Un único entero que representa la variable respuesta de Josué. Se te asegura que no existe otra variable con la misma frecuencia máxima.",
        "nivel": "Intermedio (fácil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Tablas de dispersión"
        ],
        "estructuras": [
            "int",
            "unordered_map<int,int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int N;\n    cin >> N;\n    unordered_map<int, int> frecuencia;\n    int max_frecuencia = 0;\n    int variable_respuesta = 0;\n    for (int i = 0; i < N; ++i) {\n        int variable;\n        cin >> variable;\n        frecuencia[variable]++;\n        if (frecuencia[variable] > max_frecuencia) {\n            max_frecuencia = frecuencia[variable];\n            variable_respuesta = variable;\n        }\n    }\n    cout << variable_respuesta << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "10727. Posicion Fibonacci",
        "url": "https://omegaup.com/arena/problem/Posicion-Fibonacci/",
        "descripcion": "Como ya sabemos la sucesión de fibonacci esta compuesta por los números: 1, 1, 2, 3, 5, 8, 13, 21, 34... Sabiendo esto tu tarea es dado un numero N debes encontrar la posición que ocupa en la sucesión de fibonacci.",
        "entrada": "Un numero N solamente (N<2^64).",
        "salida": "Un único entero que indique en que posición se encuentra el numero en la sucesión. Si el numero no se encuentra en la sucesión imprimir un -1.",
        "nivel": "Intermedio (fácil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Cálculo matemático"
        ],
        "estructuras": [
            "unsigned long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n// Funcion para encontrar la posicion de un numero en la secuencia de Fibonacci\nint encontrarPosicionFibonacci(unsigned long long n) {\n    if (n == 1) return 1; // Caso base: 1 esta en la posicion 1 y 2\n    if (n == 2) return 3; // Caso base: 2 esta en la posicion 3\n    unsigned long long a = 1, b = 1, c = a + b; \n    int posicion = 3; // Empezamos desde la posicion 3\n    // Calculamos la secuencia hasta que superemos o igualemos a 'n'\n    while (c <= n) {\n        if (c == n) {\n            return posicion; // Encontramos la posicion\n        }\n        a = b;\n        b = c;\n        c = a + b;\n        posicion++;\n    }\n    return -1; // 'n' no se encuentra en la secuencia\n}\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    unsigned long long n;\n    cin >> n;\n    cout << encontrarPosicionFibonacci(n) << endl; \n\n    return 0;\n}\n"
    },
    {
        "titulo": "7393. Serie Misteriosa",
        "url": "https://omegaup.com/arena/problem/Serie-Misteriosa/",
        "descripcion": "Pichu es un gato peludo, hermoso y naranjoso. La mayoría del tiempo hace cosas de gato (comer, dormir y eso). Sin embargo, a veces le da por hacer cosas menos interesantes. Un día se metió a ver la oficina de un tipo misterioso. Como el tipo era muy misterioso, tenía un pizarrón misterioso que tenía escrita una serie numérica (por supuesto, muy misteriosa)... La serie solo tenía 6 números escritos: 1, 11, 21, 1211, 111221, 312211, ...; Pichu quería saber cuál era el n-ésimo número de la serie, pero no logró adivinar el patrón de la serie misteriosa. Afortunadamente, hay un humano tratando de resolver problemas en OmegaUp que le va a ayudar... O al menos lo intentará. Escribe un programa que dado un número n determine el n-ésimo número de la serie misteriosa.",
        "entrada": "Un número entero n (n<=30).",
        "salida": "El n-ésimo número de la serie misteriosa.",
        "nivel": "Intermedio (fácil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "int",
            "char",
            "string",
            "to_string()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring serieMisteriosa(int n) {\n    if (n == 1) return \"1\";\n    if (n == 2) return \"11\";\n    string anterior = \"11\";\n    for (int i = 3; i <= n; ++i) {\n        string actual = \"\";\n        int contador = 1;\n        char digitoActual = anterior[0];\n        for (int j = 1; j < anterior.size(); ++j) {\n            if (anterior[j] == digitoActual) {\n                contador++;\n            } else {\n                actual += to_string(contador) + digitoActual;\n                digitoActual = anterior[j];\n                contador = 1;\n            }\n        }\n        actual += to_string(contador) + digitoActual;\n        anterior = actual;\n    }\n    return anterior;\n}\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int n;\n    cin >> n;\n    cout << serieMisteriosa(n) << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "1917. Dígitos volteados",
        "url": "https://omegaup.com/arena/problem/Digitos-Volteados/",
        "descripcion": "Acabas de encontrar una secuencia muy larga de N dígitos 0, 1 y 2, y decidiste comenzar a jugar un juego. En cada turno, comienzas desde la izquierda de la secuencia buscando un dígito 0 seguido de un 1. Si no los encuentras, el turno termina. De lo contrario, si el 0 estaba en una posición par, cambias el 0 y el 1 por dos 0s. En cambio, si estaba en una posición impar, cambias el 1 y el 0 por dos 1s. Con esto termina el turno. ¡Recuerda que comenzamos a contar las posiciones de los arreglos desde 0! Como es un juego muy divertido, decidiste continuar jugándolo durante K turnos. Al terminar de jugar no estabas seguro si seguiste los pasos correctamente, así que decidiste escribir un programa que corrobore la respuesta.",
        "entrada": "En la primera línea dos enteros: N y K. En la segunda línea, N dígitos 0, 1 o 2, separados por espacios. (1<=N<=50000) y (1<=k<=10^9).",
        "salida": "Una línea con los N dígitos después de los turnos.",
        "nivel": "Intermedio (fácil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Vectores",
            "Teoría de juegos"
        ],
        "estructuras": [
            "long long",
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b;\n    int num[50010];\n    cin>>a>>b;\n    for(auto i=0; i<a; i++){\n        cin>>num[i];\n    }\n    for(auto i=0; i<a; i++){\n        if(i%2==0 && num[i]==0 && num[i+1]==1 && num[i+2]==1){\n            if(b%2){\n                num[i+1]=0;\n            }\n            break;\n        }\n        else if(i%2==0 && num[i]==0 && num[i+1]==1){\n            b--;\n            num[i+1]=0;\n            if(b==0){\n                break;\n            }\n        }\n        else if(i%2 && num[i]==0 && num[i+1]==1){\n            if(b%2){\n                num[i]=1;\n            }\n            break;\n        }\n    }\n    for(auto i=0; i<a; i++){\n        cout<<num[i]<<\" \";\n    }\n        \n    return 0;\n}"
    },
    {
        "titulo": "12176. Cuantas veces aparece el numero",
        "url": "https://omegaup.com/arena/problem/Cuantas-veces-aparece-el-numero/",
        "descripcion": "Un gerente de una tienda ha tenido problemas de ventas últimamente por lo que ahora en adelante quiere vender los productos que mas se venden, y tu como buen programador le quieres ayudar a salvar su negocio. El te dará un numero N que representa la cantidad de ventas y un numero M que representa la cantidad mínima de ventas para seguir vendiendo un producto posteriormente N números que representa el ID de cada producto vendido.",
        "entrada": "Un numero N y un numero M seguido de los N números.",
        "salida": "Por cada producto que se haya vendido mas o igual de M veces imprimir el ID del producto seguido del numero de veces que se vendió ordenados por ID.",
        "nivel": "Básico (difícil) - Introducción a la programación",
        "categorias": [
            "Vectores",
            "Tablas de dispersión"
        ],
        "estructuras": [
            "int",
            "map<int,int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e, f, g, h;\n   vector<int>sub;\n  map<int,int>num;\n    cin>>a>>b;\n    while(a--){\n        cin>>c;\n        num[c]++;\n        if(num[c]==b){\n            sub.push_back(c);\n        }\n    }\n    sort(sub.begin(),sub.end());\n    for(auto i=0; i<sub.size(); ++i){\n        cout<<sub[i]<<\" \"<<num[sub[i]]<<\"\\n\";\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "12321. Primos Relativos",
        "url": "https://omegaup.com/arena/problem/Primos-Relativos/",
        "descripcion": "A Óscar se le ha asignado la tarea de revisar una lista de pares de números y determinar cuales de estos pares son primos relativos y cuales no. Como esta tarea es muy tediosa, Óscar te ha pedido ayuda sabiendo que eres un buen programador. Así que Óscar te ha pedido que escribas un programa que haga su tarea. Como él es un gran amigo tuyo, has decidido ayudarlo.",
        "entrada": "Tu programa recibirá como entrada un número, al que llamaremos N, que indica cuantos pares deberás revisar. Después de leer N, tu programa deberá leer cada uno de los N pares.",
        "salida": "Por cada par de números (todos son números enteros) tu programa deberá imprimir una línea de texto con la leyenda \"Primos Relativos\", cuando el par leído corresponda a un par de números coprimos. Si el par de números leídos no son primos, entonces tu programa imprimirá una línea de texto con la leyenda \"No primos\".",
        "nivel": "Básico (difícil) - Introducción a la programación",
        "categorias": [
            "Cálculo matemático"
        ],
        "estructuras": [
            "int",
            "__gcd()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e, f, g, h;\n    cin>>a;\n    while(a--){\n        cin>>b>>c;\n        cout<<((__gcd(b,c)==1)?\"Primos Relativos\\n\":\"No primos\\n\");\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "12276. Analizando y transformando una cadena",
        "url": "https://omegaup.com/arena/problem/Analizando-y-transformando-una-c/",
        "descripcion": "Escribe un programa que lea una línea de texto y que: Calcule la longitud de la línea y la cantidad de espacios que hay en ella. Cambie las letras mayúsculas por minúsculas, y viceversa. Incremente en uno cada dígito de la línea (excepto los dígitos 9, que se quedan como están).",
        "entrada": "Una línea de texto de a lo mucho 50 caracteres de longitud. Puedes suponer que la línea incluye letras, dígitos, espacios sencillos y símbolos de puntuación. El salto de línea no se considera parte de la entrada.",
        "salida": "En la primera línea, dos enteros que correspondan con el tamaño de la línea y la cantidad de espacios que hay en ella, respectivamente. En la segunda línea, la línea después de ser modificada.",
        "nivel": "Básico (difícil) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "int",
            "string",
            "getline()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  long long a=0, b, c, d, e, f, g, h;\n   string z;\n getline(cin,z);\n   cout<<z.size()<<\" \";\n    for(auto i=0; i<z.size(); ++i){\n        if(z[i]>='a' && z[i]<='z'){\n           z[i]-=32;\n     }\n     else if(z[i]>='A' && z[i]<='Z'){\n          z[i]+=32;\n     }\n     else if(z[i]>='0' && z[i]<'9'){\n           z[i]++;\n       }\n     else if(z[i]==' '){\n           a++;\n      }\n }\n cout<<a<<\"\\n\"<<z;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "9565. Cantidad de Divisores",
        "url": "https://omegaup.com/arena/problem/Cantidad-de-factores-primos/",
        "descripcion": "Dados n números enteros, encontrar la cantidad de divisores de cada uno.",
        "entrada": "La entrada empieza con un entero positivo n (1<=n<=10^4), la cantidad de casos. Luego le seguirán n enteros positivos x (1<=x<=10^6).",
        "salida": "Por cada número de la entrada se debe imprimir la cantidad de divisores del número.",
        "nivel": "Básico (difícil) - Introducción a la programación",
        "categorias": [
            "Cálculo matemático"
        ],
        "estructuras": [
            "int",
            "sqrt()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  int a, b, c, d, raiz;\n cin>>a;\n   while(a--){\n           cin>>b;\n           c=0;\n          d=1;\n          raiz=sqrt(b);\n     while(d<raiz){\n            if(b%d==0){\n                   c+=2;\n             }\n             d++;\n          }\n     if(raiz*raiz==b){\n             c++;\n          }\n         cout<<c<<\"\\n\";\n     }\n\n   return 0;\n}\n"
    },
    {
        "titulo": "19751. Contando perimetros",
        "url": "https://omegaup.com/arena/problem/Contando-perimetros/",
        "descripcion": "La universidad no cuenta con mucha iluminación, por eso Santy quiere poner una cinta LED (como la que usan los gamers) alrededor de toda la escuela. Sin embargo, para poder hacer esto, necesita saber cuánto mide el perímetro de la escuela. Por suerte, se tiene un mapa completo de la escuela. Además, la escuela es un área completamente conectada (no tiene huecos en medio). Tu tarea será determinar el perímetro de la escuela. El mapa de la escuela consiste en un rectángulo de N x M donde cada espacio puede o no pertenecer a la estructura de la universidad.",
        "entrada": "Se te darán los enteros 1<=N,M<=1000 que indican las dimensiones del mapa. Luego se te darán enteros a_(i,j)=0,1 que representan el mapa. Un 0 indica que ese espacio no le pertenece a la universidad y un 1 indica que sí. Cada espacio mide 1 unidad de alto y una de ancho.",
        "salida": "Deberás imprimir un entero indicando el perímetro de la universidad.",
        "nivel": "Básico (difícil) - Introducción a la programación",
        "categorias": [
            "Matrices"
        ],
        "estructuras": [
            "int",
            "vector<vector<int>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    ios_base::sync_with_stdio(false);\n cin.tie(0);\n   cout.tie(0);\n  int a, b, c, e, f, g, h, n,m;\n    cin>>n>>m;\n    vector<vector<int>> escuela(n+2,vector<int>(m+2,0));\n    for(auto i = 1; i<=n;i++){\n        for(auto j=1;j<=m;j++){\n            cin>>escuela[i][j];\n        }\n    }\n    int perimetro = 0;\n    for(auto i = 1; i<=n;i++){\n        for(auto j=1;j<=m;j++){\n            if(!escuela[i][j]) continue;\n            if(escuela[i-1][j] == 0){\n                perimetro++;\n            }\n            if(escuela[i+1][j] == 0){\n                perimetro++;\n            }\n            if(escuela[i][j-1] == 0){\n                perimetro++;\n            }\n            if(escuela[i][j+1] == 0){\n                perimetro++;\n            }\n        }\n    }\n    cout<<perimetro;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "19752. Diversión Bibliotecaria",
        "url": "https://omegaup.com/arena/problem/Diversion-Bibliotecaria/",
        "descripcion": "El Instituto Central del Pensamiento Creativo no es la universidad más seria de todas, por así decirlo. Un ejemplo de esto es su sistema bibliotecario; toda la universidad se rehúsa a ordenar los libros alfabéticamente, porque eso es muy aburrido. Sin embargo, a falta de creatividad, los libros no se encuentran ordenados de alguna forma especial. Santy ha decidido arreglar esto durante su mandato. Se le ha ocurrido una forma un tanto curiosa de ordenar algunos de los libros. Él quiere formar una línea de libros de tal forma que si tomamos la inicial de cada libro, esta línea forme un palíndromo*. Como quiere ordenar la mayor cantidad de libros posibles, quiere la línea más larga que se pueda. Además de esto, para hacerlo aún más interesante, dentro de todas las opciones iguales quiere la menor lexicográficamente*. *Palíndromo: Un palíndromo es una palabra que se lee de la misma forma de derecha a izquierda que de izquierda a derecha. Por ejemplo, aérea, ana, salas, rodador. *Lexicográficamente: Se dice que una palabra es menor a otra lexicográficamente si el primer caracter donde difieren es menor (va primero en el alfabeto) en la primera palabra. Por ejemplo, amancio es menor que amando porque el primer caracter donde difieren es donde uno es c y el otro d, donde la c viene primero en el alfabeto. Más aún, el prefijo de una palabra siempre será menor lexicográficamente. Por ejemplo, auto es menor que automático.",
        "entrada": "Se te dará una cadena de caracteres S de letras mayúsculas del alfabeto inglés que representan las iniciales de los libros que hay actualmente. La cadena tiene a lo más 5000 caracteres.",
        "salida": "Deberás imprimir la cadena que te pide el problema.",
        "nivel": "Básico (difícil) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas",
            "Tablas de dispersión"
        ],
        "estructuras": [
            "int",
            "char",
            "string",
            "map<char,int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    ios_base::sync_with_stdio(false);\n cin.tie(0);\n   cout.tie(0);\n  int a, b, c, e, f, g, h;\n    map<char,int>y;\n    int n;\n    string x;\n    cin>>x;\n    char z='@';\n    a=x.size();\n    for(auto i = 0; i<a; i++){\n        y[x[i]]++;\n    }\n    vector<char>zz;\n    for(const auto &d: y){\n        if(d.second%2 && z=='@'){\n            z=d.first;\n        }\n        b=d.second;\n        if(b%2){\n            b--;\n        }\n            b/=2;\n            while(b--){\n            cout<<d.first;\n            zz.push_back(d.first);\n            }\n    }\n    if(z!='@'){\n        cout<<z;\n    }\n    while(zz.size()){\n        cout<<zz.back();\n        zz.pop_back();\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "13001. Suma elementos consecutivos",
        "url": "https://omegaup.com/arena/problem/Suma-elementos-consecutivos/",
        "descripcion": "Dado un arreglo de tamaño n, determinar si existen k elementos consecutivos tales que sumen l.",
        "entrada": "En la primera línea los enteros n, k y l (1<=k<=n<=10^6) (1<=l<=10^14). En la segunda línea, n enteros a_i (0<=a_i<=10^8) separados por un espacio.",
        "salida": "Imprimir un \"Si\" si existen k elementos consecutivos que sumen l o un \"No\" en caso de que no exista.",
        "nivel": "Básico (difícil) - Introducción a la programación",
        "categorias": [
            "Vectores",
            "Ventana deslizante"
        ],
        "estructuras": [
            "long long",
            "vector<long long>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint main(){\n   ios::sync_with_stdio(0);\n  cin.tie(0);\n   cout.tie(0);\n  ll n, m, a, b=0, c=0, d, e, f, g, h;\n  vector<ll>ar(1000000,0);\n  cin>>n>>m>>a;\n for(auto i=0; i<m; i++){\n      cin>>ar[i];\n       b+=ar[i];\n }\n if(b==a){\n     c=1;\n  }\n for(auto i=m; i<n; i++){\n      cin>>ar[i];\n       b+=ar[i]-ar[i-m];\n     if(b==a){\n         c=1;\n      }\n }\n if(c){\n        cout<<\"Si\";\n }\n else{\n     cout<<\"No\";\n }\n\n   return 0;\n}\n"
    },
    {
        "titulo": "19749. Acechando Igualdades",
        "url": "https://omegaup.com/arena/problem/Acechando-Igualdades/",
        "descripcion": "El dictador Santy ha llegado al poder en el Instituto Central del Pensamiento Creativo. En esta universidad, los alumnos destacados reciben un apoyo económico para incentivarlos a seguir destacando. Sin embargo, durante el mandato anterior, se habían estado haciendo tratos oscuros y algunos alumnos recibían más que otros. Tú conoces la lista actual de los montos económicos que se le da a cada alumno. Tu tarea será determinar la cantidad minima de montos que debes cambiar para que todos sean iguales.",
        "entrada": "Se te dará un entero 1<=N<=100 indicando la cantidad de alumnos destacados. En la siguiente línea, habrá N enteros 1<=a_i<=100 que representan los apoyos económicos que se le da a los alumnos.",
        "salida": "Deberás imprimir la cantidad minima de montos que debes modificar para que a todos les toque lo mismo.",
        "nivel": "Básico (difícil) - Introducción a la programación",
        "categorias": [
            "Vectores",
            "Tablas de dispersión"
        ],
        "estructuras": [
            "int",
            "unordered_map<int,int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    ios_base::sync_with_stdio(false);\n cin.tie(0);\n   cout.tie(0);\n    int a, b, c, d, e, f, g, h;\n unordered_map<int,int> dinero;\n    int n;\n    cin>>n;\n    int aux;\n    for(auto i = 0; i<n; i++){\n        cin>>aux;\n        dinero[aux]++;\n    }\n    int mayor = 0;\n    for(const auto &d: dinero){\n        if(d.second > mayor) mayor = d.second;\n    }\n    cout<<n-mayor;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "19594. Cazador de Anomalías",
        "url": "https://omegaup.com/arena/problem/Cazador-de-Anomalias/",
        "descripcion": "Un elemento a_i de un arreglo se define como una anomalía si existe a_j tal que a_i<a_j. Tu tarea consiste en encontrar la cantidad de anomalías en el arreglo.",
        "entrada": "Se te dará un número 1<=N<=10^5 indicando la cantidad de elementos en el arreglo. Luego se te darán los elementos del arreglo 1<=a_i<=10^5.",
        "salida": "Deberás imprimir la cantidad de anomalías en el arreglo.",
        "nivel": "Básico (difícil) - Introducción a la programación",
        "categorias": [
            "Vectores"
        ],
        "estructuras": [
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    ios::sync_with_stdio(0);\n  cin.tie(0);\n   cout.tie(0);\n  int n, m, a, b, c, d, e, f, g, h;\n vector<int>ar(500000,0);\n  cin>>n>>b;\n    c=b;\n  d=1;\n  for(auto i=1; i<n; i++){\n      cin>>b;\n       if(b==c){\n         d++;\n      }\n     else if(b>c){\n         d=1;\n          c=b;\n      }\n }\n cout<<n-d;\n\n  return 0;\n}\n"
    },
    {
        "titulo": "10691. Spotifly",
        "url": "https://omegaup.com/arena/problem/Spotify/",
        "descripcion": "Como sabes, tu amigo es extremadamente metódico, asi que para poder crear la playlist tiene diferentes opciones: 1- Ingresa una canción a la playlist, pero recuerda estas playlist se basan en el tiempo de duración de las canciones y no tanto en el nombre de la canción. 2- Reproduce la canción que se encuentra al inicio de la playlist en ese momento. 3- Elimina la canción que se encuentra al inicio de la playlist sin que se reproduzca. 4- Muestra el tiempo que se lleva reproduciendo música en la fiesta. 5- Muestra cuantas canciones se encuentran en la playlist. 6- Se detiene la reproducción de la playlist.",
        "entrada": "Recibirás una serie de número que representan las instrucciones que te da tu amigo, síguelas al pie de la letra para que la fiesta sea todo un éxito.",
        "salida": "Existe la posibilidad de que le tengas que contestar preguntas a tu amigo, como por ejemplo cuanto tiempo se ha reproducido música en la fiesta o cuantas canciones hay en la playlist.",
        "nivel": "Básico (difícil) - Introducción a la programación",
        "categorias": [
            "Colas"
        ],
        "estructuras": [
            "float",
            "queue<float>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  float a, b, c, d, e, f, g, h;\n queue<float>num;\n  cin>>a;\n   while(a!=6){\n      switch((int)a){\n           case 1: cin>>a;num.push(a);break;\n         case 2: b+=num.front();num.pop();break;\n           case 3: num.pop();break;\n          case 4: cout<<b<<\"\\n\";break;\n           case 5: cout<<num.size()<<\"\\n\";break;\n      }\n     cin>>a;\n   }\n \n    return 0;\n}\n"
    },
    {
        "titulo": "6705. PSP y tamaños relativos",
        "url": "https://omegaup.com/arena/problem/PSP-y-tamanos-relativos/",
        "descripcion": "Personal Software Process (PSP), es un conjunto de prácticas desarrolladas para la administración del tiempo y las actividades personales de programadores o ingenieros de software. Está alineado y diseñado para emplearse en organizaciones con modelos de procesos CMMI o ISO 15504. Fue propuesto por Watts Humphrey en 1995. Uno de los muchos procesos que se incluyen en PSP implica el cálculo de una tabla de tamaños relativos usando desviación estándar. En esta tabla se deben calcular los siguientes tamaños: muy pequeño (VS), pequeño(S), medio (M), grande(L) y muy grande(VL) utilizando desviación estándar. Para calcular una tabla de tamaños relativos usando desviación estándar se usa el siguiente proceso: Leer n datos de entrada. Transformar cada uno de los datos a su logarirmo natural. Esto es necesario porque no se deben tener tamaños negativos y los valores pequeños tienden a amontonarse. Calcular el promedio de estos n valores logarítmicos mediante avg=[sum_{i=1}^{n}ln(x_i)]/n. Calcular la varianza: var=\\sigma^2=[sum_{i=1}^{n}(ln(x_i)-avg)^2]/(n-1). Calcular la desviación estándar: \\sigma=sqrt(var). Calcular los rangos: ln(VS)=avg-2*\\sigma, ln(S)=avg-\\sigma, ln(M)=avg, ln(L)=avg+\\sigma, ln(VL)=avg+2*\\sigma. Por último, convertir los valores logarítmicos a su tamaño natural usando el anti-logaritmo: VS=e^ln(VS), S=e^ln(S), M=e^ln(M), L=e^ln(L), VL=e^ln(VL).",
        "entrada": "Primero se leerá el valor de n (3<=n<=100) que representa el número de datos a recibir. A continuación se leerán n datos de tipo real.",
        "salida": "Imprimir los valores de los rangos VS, S, M, L y por último VL. Cada uno de ellos en un renglón y redondeados a dos decimales.",
        "nivel": "Básico (difícil) - Introducción a la programación",
        "categorias": [
            "Vectores",
            "Cálculo matemático"
        ],
        "estructuras": [
            "int",
            "double",
            "vector<double>",
            "log()",
            "pow()",
            "fixed",
            "setprecision()",
            "exp()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n   int n;\n    cin >> n;\n // Usamos vector para mayor flexibilidad\n  vector<double> datos(n);\n  // Leemos los datos\n   for (int i = 0; i < n; ++i) {\n     cin >> datos[i];\n  }\n // Calculamos la suma de los logaritmos naturales\n double sum_ln = 0;\n    for (int i = 0; i < n; ++i) {\n     sum_ln += log(datos[i]);\n  }\n // Calculamos el promedio de los logaritmos naturales\n double avg = sum_ln / n;\n  // Calculamos la suma de las diferencias cuadradas\n    double sum_sq_diff = 0;\n   for (int i = 0; i < n; ++i) {\n     sum_sq_diff += pow(log(datos[i]) - avg, 2);\n   }\n // Calculamos la varianza\n double var = sum_sq_diff / (n - 1);\n   // Calculamos la desviacion estandar\n    double std_dev = sqrt(var);\n   // Calculamos los limites de los rangos\n    double ln_VS = avg - 2 * std_dev;\n double ln_S = avg - std_dev;\n  double ln_M = avg;\n    double ln_L = avg + std_dev;\n  double ln_VL = avg + 2 * std_dev;\n // Imprimimos los rangos, redondeados a dos decimales\n cout << fixed << setprecision(2);\n cout << exp(ln_VS) << endl;\n   cout << exp(ln_S) << endl;\n    cout << exp(ln_M) << endl;\n    cout << exp(ln_L) << endl;\n    cout << exp(ln_VL) << endl;\n\n return 0;\n}\n"
    },
    {
        "titulo": "10220. Oro del sabio",
        "url": "https://omegaup.com/arena/problem/Oro-del-sabio/",
        "descripcion": "Cuenta la historia que existía un viejo sabio que regalaba oro a todo aquel que pudiera contestar su problema de forma eficiente, un día este sabio se le acercó al grupo organizador de la Olimpiada de Yucatán y les dijo el problema. Al ser personas muy hábiles pudieron con el problema con facilidad y le dieron el oro a uno de ellos... ya nunca volvimos a saber de aquella persona, ni el oro. Como personas creativas los organizadores decidieron poner este problema como parte del selectivo estatal y en vez de dar oro a quien lo responda, se darán puntos (mucho mejor) :D. El problema consiste en que tienes una línea de n montones de monedas, tu conoces la cantidad inicial de cada montón. Luego el sabio te hará preguntas, cada pregunta consiste en agregarle cierta cantidad de monedas a todos los montones de un rango y después de agregarles dicha cantidad decir cuánto es el total de monedas que hay en toda la fila. Por ejemplo, si tienes una línea de monedas 3, 6, 2, 4, entonces el total es de 3+6+2+4=15. Luego el sabio le agrega 5 a todos los montones desde el segundo hasta el cuarto y queda como 3, 11, 7, 9 y ahora hay 30. Se te dan los n montones iniciales de monedas, luego se te harán k preguntas en donde la pregunta i consiste en aumentar los montones desde x_i hasta y_i en r_i y decir cuanto suman todos los montones.",
        "entrada": "En la primera línea dos números enteros n y k (0<n,k<10^5) que representan el número de montes y el número de preguntas, respectivamente. En la segunda línea n enteros que representan los montones iniciales m_i (0<m_i<10^5). Las siguientes K líneas son tercias de números x_i, y_i (1<=x_i<=y_i<=n) y r_i (0<r_i<10^5), los primeros dos son el rango de aumento y el tercero en cuanto aumentan los montones.",
        "salida": "k números enteros que representan la respuesta a cada pregunta. Por cada una de esas preguntas debes decir la cantidad de monedas que hay en total (considerando todos los montones).",
        "nivel": "Básico (difícil) - Introducción a la programación",
        "categorias": [
            "Cálculo matemático"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d=0, e;\n    cin>>a>>b;\n    while(a--){\n        cin>>c;\n        d+=c;\n    }\n    //Optimizacion: En lugar de implementar un vector y sumar en todas las posiciones del rango,\n    //simplemente se realiza una suma en una sola variable (dado que se da la suma total, no de un rango).\n    while(b--){\n        cin>>a>>c>>e;\n        d+=((c-a)+1)*e;\n        cout<<d<<\"\\n\";\n    }\n    \n    return 0;\n}\n"
    },
    {
        "titulo": "9534. RooEnigma2",
        "url": "https://omegaup.com/arena/problem/RooEnigma2/",
        "descripcion": "Dada una configuración inicial, la máquina criptográfica alemana Enigma, de la segunda guerra mundial, sustituía cada letra digitada en el teclado por otra letra. La sustitución era bastante compleja, pero la máquina tenía una vulnerabilidad: ¡una letra nunca sería sustituida por ella misma! esa vulnerabilidad fue explorada por Alan Turing, quien trabajo en el criptoanálisis de Enigma durante la guerra. El objetivo era encontrar una configuración inicial de la máquina usando la suposición de que el mensaje contenía cierta expresión usual de comunicación, como por ejemplo la palabra ARMADA. Esas expresiones eran llamadas cribs. Si el mensaje cifrado era, por ejemplo, FDMLCRDMRALF, el trabajo de probar las posibles configuraciones de la máquina era simple porque la palabra ARMADA, si estuviese en ese mensaje cifrado, solo podría estar en dos posiciones, ilustradas en la tabla de abajo con una flecha. Las otras cinco posiciones no podrían corresponder al mismo crib ARMADA porque al menos una letra del crib, subrayada en la tabla de abajo, es emparejada con su correspondiente en el mensaje cifrado; como Enigma nunca sustituirá una letra por ella misma, esas cinco posiciones son descartadas por las pruebas. Escribe un programa para que, dado un mensaje cifrado en un crib, se calcule el número de posiciones posibles para el crib en el mensaje cifrado.",
        "entrada": "La primera línea de entrada contiene el mensaje cifrado, que es una secuencia de por lo menos una letra y máximo 10^4 letras. La segunda línea contiene el crib, que es una secuencia de por lo menos una letra y máximo el mismo número de letras que el mensaje. El crib y el mensaje únicamente incluyen las 26 letras del abecedario, mayúsculas y sin tildes.",
        "salida": "Imprima una línea con un entero, indicando el número de posiciones posibles para un crib en el mensaje cifrado.",
        "nivel": "Básico (difícil) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "bool",
            "int",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    string mensaje, crib;\n    cin >> mensaje >> crib;\n    int posiciones = 0;\n    int n = mensaje.size();\n    int m = crib.size();\n    for (int i = 0; i <= n - m; ++i) {\n        bool posible = true;\n        for (int j = 0; j < m; ++j) {\n            if (mensaje[i + j] == crib[j]) {\n                posible = false;\n                break;\n            }\n        }\n        if (posible) {\n            posiciones++;\n        }\n    }\n    cout << posiciones << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "8208. Buscando el mejor servicio",
        "url": "https://omegaup.com/arena/problem/Buscando-el-mejor-servicio/",
        "descripcion": "A una adolescente le gusta escuchar música todo el tiempo desde Spotify, Apple Music y YouTube Music. Sin embargo, con la cuarta transformación, nuestro presidente presentó una nueva ley que impide tener más de un servicio de streaming por ciudadano. Por esta razón, la adolescente debe elegir con cuál de todos se debe quedar en función del nombre de la canción más larga que tenga en sus diferentes playlists.",
        "entrada": "Tres líneas con las 3 canciones en el siguiente orden: primero la canción de Spotify, luego la de Apple Music y luego una de YouTube Music. Cada nombre de canción puede contener una cantidad indeterminada de espacion.",
        "salida": "El nombre del servicio de streaming donde va a seguir escuchando música la adolescente. Si todas las canciones son iguales en tamaño, entonces eligirá YouTube Music.",
        "nivel": "Básico (difícil) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "int",
            "string",
            "getline()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    string spotify, apple, youtube;\n    getline(cin, spotify);\n    getline(cin, apple);\n    getline(cin, youtube);\n    int max_len = spotify.length();\n    string servicio = \"Spotify\";\n    if (apple.length() > max_len) {\n        max_len = apple.length();\n        servicio = \"Apple Music\";\n    }\n    if (youtube.length() >= max_len) {\n        servicio = \"YouTube Music\";\n    }\n    cout << servicio << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "8644. Números Narcisistas",
        "url": "https://omegaup.com/arena/problem/Numeros-Narcisistas/",
        "descripcion": "Un número es narcisista si es igual a la suma de las potencias de sus cifras elevadas a la cantidad de cifras del número. Así, el número narcisista más pequeño es 153, que tiene 3 cifras y 1 elevado a 3 + 5 elevado a 3 + 3 elevado a 3 = 153. Leer un número entero X (mayor que 1 y menor que <500000) e informar si el mismo es narcisista.",
        "entrada": "La entrada consiste de una única línea conteniendo un valor entero x.",
        "salida": "La salida consiste de una línea con el mensaje \"Es Narcisista\" o \"No es Narcisista\" según corresponda a X.",
        "nivel": "Básico (difícil) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b=0, c=0, d;\n    string z;\n    cin>>z;\n    d=z.size();\n    for(auto i=0; i<d; i++){\n        a=z[i]-48;\n        c*=10;\n        c+=a;\n        b+=pow(a,z.size());\n    }\n    if(c==b){\n        cout<<\"Es Narcisista\";\n    }\n    else{\n        cout<<\"No es Narcisista\";\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "2208. Interview Question",
        "url": "https://omegaup.com/arena/problem/InterviewQuestion/",
        "descripcion": "Un amigo mío fue preguntado hoy en una entrevista para el puesto de desarrollador de software: Dadas dos cadenas s1 y s2, ¿cómo verificarías si s1 es una versión rotada de s2? Ejemplo: Si s1 = \"stackoverflow\", entonces las siguientes son algunas de sus versiones rotadas: “tackoverflows”, “ackoverflowst”, “overflowstack”, mientras que “stackoverflwo” no es una versión rotada. La respuesta que dio fue: Toma s2 y encuentra el prefijo más largo que es una subcadena de s1, eso te dará el punto de rotación. Una vez que encuentres ese punto, divide s2 en ese punto para obtener s2a y s2b, luego verifica si la concatenación de s2a y s2b es igual a s1. Parece una buena solución para mí y mi amigo, pero el entrevistador pensó lo contrario. Pidió una solución más simple. Por favor, ayúdame diciendo cómo lo harías. ¡Gracias anticipadas!",
        "entrada": "Una línea con un entero N, que es el número de casos de prueba siguientes. Luego siguen 2N líneas. Cada caso de prueba contiene un par de cadenas, s1 y s2, cada una en su propia línea. s1 y s2 pueden contener letras minúsculas, mayúsculas y números. Sin espacios. Las coincidencias deben ser sensibles a mayúsculas y minúsculas.",
        "salida": "Para cada caso de prueba, imprime una línea que contenga ‘Yes’ si s1 es una versión rotada de s2, o ‘No’ en caso contrario. Cuando hayas terminado con los casos de prueba, imprime la línea “Do I get the job?”",
        "nivel": "Básico (difícil) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "int",
            "string",
            "getline()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n// Funcion para verificar si s1 es una rotacion de s2\nstring isRotation(string s1, string s2) {\n    if (s1.length() != s2.length()) {\n        return \"No\";\n    }    \n    string temp = s1 + s1;\n    if (temp.find(s2) != string::npos) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int N;\n    cin >> N;\n    cin.ignore(); // Consumir el salto de linea despues de leer N\n    for (int i = 0; i < N; ++i) {\n        string s1, s2;\n        getline(cin, s1);\n        getline(cin, s2);\n        cout << isRotation(s1, s2) << endl;\n    }\n    cout << \"Do I get the job?\" << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "2981. Evaluar polinomios",
        "url": "https://omegaup.com/arena/problem/Evaluar-polinomios/",
        "descripcion": "Escribe un programa que, dados los valores de las incógnitas x_0, x_1, ..., x_n-1, evalúe una secuencia de polinomios. Cada polinomio es una suma de productos de variables.",
        "entrada": "El entero N seguido de N números en punto flotante, Posteriormente una secuencia de polinomios, uno por línea, los cuales deben procesarse hasta el fin de archivo. Puedes suponer que (1<=N<=10).",
        "salida": "Por cada polinomio, un real que corresponda con la evaluación del polinomio. El valor impreso se considerará correcto si está razonablemente cerca del valor exacto.",
        "nivel": "Básico (difícil) - Introducción a la programación",
        "categorias": [
            "Vectores",
            "Caracteres y cadenas",
            "Cálculo matemático"
        ],
        "estructuras": [
            "int",
            "string",
            "double",
            "vector<double>",
            "getline()",
            "fixed",
            "setprecision()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ndouble evaluar_polinomio(const string& polinomio, const vector<double>& variables) {\n    istringstream iss(polinomio);\n    string termino;\n    double resultado = 0.0;\n    while (getline(iss, termino, '+')) {\n        double valor_termino = 1.0;\n        for (int i = 0; i < termino.size(); ++i) {\n            if (termino[i] == 'x') {\n                valor_termino *= variables[termino[i + 1] - '0'];\n            }\n        }\n        resultado += valor_termino;\n    }\n    return resultado;\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int N;\n    cin >> N;\n    vector<double> variables(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> variables[i];\n    }\n    string polinomio;\n    getline(cin, polinomio); // Consumir el salto de l?ea despu? de leer N\n    while (getline(cin, polinomio)) {\n        double resultado = evaluar_polinomio(polinomio, variables);\n        cout << fixed << setprecision(2) << resultado << endl;\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "11455. Filtrando múltiplos",
        "url": "https://omegaup.com/arena/problem/Filtrando-multiplos/",
        "descripcion": "Escribe un programa que lea una secuencia de N enteros y un entero k y que reimprima la secuencia dada, reemplazando los enteros que no son múltiplos de K por una X mayúscula.",
        "entrada": "Un entero N seguido de una línea con los N enteros de la secuencia y de otra línea con un entero K. Los enteros de la secuencia aparecen separados por espacios. Puedes suponer que todos los enteros de la entrada están en el rango de 1 a 100.",
        "salida": "La secuencia leída con los elementos que no son múltiplos de K reemplazados por una X mayúscula.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores"
        ],
        "estructuras": [
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e;\n    vector<int>num(1000000,0);\n    cin>>a;\n    for(auto i=0; i<a; ++i){\n        cin>>num[i];\n    }\n    cin>>b;\n    for(auto i=0; i<a; ++i){\n        if(num[i]%b==0){\n            cout<<num[i]<<\" \";\n        }\n        else{\n            cout<<\"X \";\n        }\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "11414. Sumando elementos opuestos de un arreglo",
        "url": "https://omegaup.com/arena/problem/Sumando-elementos-opuestos-de-un/",
        "descripcion": "Dado un arreglo de N enteros donde N es par, escribe un programa que sume (en parejas) los elementos de lados opuestos del arreglo: el primer elemento con el último, el segundo elemento con el penúltimo, etc.",
        "entrada": "Un entero N seguido de una línea con los N enteros del arreglo separados por espacios. Puedes suponer que 2<=N<=200 y que N es par.",
        "salida": "Los N/2 enteros que se obtienen al sumar los elementos de lados opuestos del arreglo, comenzando por los elementos de los extremos.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores"
        ],
        "estructuras": [
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e;\n    vector<int>num(1000000,0);\n    cin>>a;\n    for(auto i=0; i<a; ++i){\n        cin>>num[i];\n    }\n    for(auto i=0, j=a-1; i<a/2; ++i, --j){\n        cout<<num[i]+num[j]<<\"\\n\";\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "8632. Días de Felicidad",
        "url": "https://omegaup.com/arena/problem/Dias-de-Felicidad/",
        "descripcion": "Domene tiene un método muy peculiar para calificar qué tan felices fueron sus días en el Tec. Entre más feliz es, lo califica con un número más alto, y entre menos feliz, con uno más bajo. Su preocupación últimamente ha sido por tener una racha de días donde la felicidad no baje. Esto es un problema porque si tiene un dia muy muy feliz, lo tendrá que calificar muy alto, y el siguiente día podría no ser tan feliz (aun y siendo feliz). Ayuda a Domene a calcular cual es la racha más larga de días consecutivos sin que la felicidad bajara.",
        "entrada": "N, El número de días en la lista, seguido por otra línea con N días con felicidad M.",
        "salida": "La racha más larga de días sin que la felicidad bajara.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores"
        ],
        "estructuras": [
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b=0, c=0, d, e=0;\n    cin>>a;\n    while(a--){\n        cin>>b;\n        if(b>=c){\n            d++;\n            c=b;\n        }\n        else{\n            e=max(e,d);\n            d=1;\n            c=b;\n        }\n    }\n    e=max(e,d);\n    cout<<e;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "7131. Modificando un arreglo",
        "url": "https://omegaup.com/arena/problem/Modificando-un-arreglo/",
        "descripcion": "Dado un arreglo de N enteros que comienzan valiendo 0, escribe un programa que lea M índices y para cada índice incremente la variable correspondiente del arreglo.",
        "entrada": "Dos enteros N (1<=N<=100) y M (0<=M<=100) seguidos de una secuencia de M enteros. Puedes suponer que todos los índices están en el rango de 0 a N-1.",
        "salida": "Los N enteros del arreglo después de haber aplicado todos los incrementos.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores"
        ],
        "estructuras": [
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e, f, g, h;\n   vector<int>num(10000,0);\n    cin>>a>>b;\n    while(b--){\n        cin>>c;\n        num[c]++;\n    }\n    for(auto i=0; i<a; ++i){\n        cout<<num[i]<<\" \";\n    }\n    \n    return 0;\n}\n"
    },
    {
        "titulo": "11884. Una fórmula con muchas divisiones",
        "url": "https://omegaup.com/arena/problem/Una-formula-con-muchas-divisione/",
        "descripcion": "Dados dos reales \"x\" y \"y\", escribe un programa que calcule el valor de \"z\" dado por: z=((x^3+x^2)/(y^2-y)-(x/y+5))/2x",
        "entrada": "Dos reales \"x\" y \"y\". Puedes suponer que -10<=x,y<=10 y que no se producirán divisiones entre cero.",
        "salida": "Un real que sea el valor de z. Tu programa se considerará correcto si el valor calculado es razonablemente cercano a la respuesta exacta.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Cálculo matemático"
        ],
        "estructuras": [
            "int",
            "pow(,)"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  long double a, b, c, d, e, f, g, h;\n   cin>>a>>b;\n    cout<<(((pow(a,3)+pow(a,2))/(pow(b,2)-b))-((a/b)+5))/(2*a);\n\n    return 0;\n}\n"
    },
    {
        "titulo": "9421. Cifrado Chido1",
        "url": "https://omegaup.com/arena/problem/Cifrado-Chido1/",
        "descripcion": "Trabajas en la CIA y se te dio el encargo de cifrar las palabras que te envian dependiendo de la primera letra del mensaje si es una vocal se muestran primero las vocales, luego las consonantes y si la primera letra es una consonante primero se muestran las consonantes, luego las vocales.",
        "entrada": "Un string palabra.",
        "salida": "Si es vocal la primera letra primero se muestran las vocales y despues las consonantes siguiendo el orden de la palabra original Si es consonante la primera letra primero se muestran las consonantes y despues las vocales siguiendo el orden de la palabra original.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "long long",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  long long a, b, c, d, e, f, g, h;\n string z;\n cin>>z;\n   if(z[0]=='a' || z[0]=='e' || z[0]=='i' || z[0]=='o' || z[0]=='u' || z[0]=='A' || z[0]=='E' || z[0]=='I' || z[0]=='O' || z[0]=='U'){\n       b=1;\n  }\n for(auto i=0; i<z.size(); ++i){\n        if(b && (z[i]=='a' || z[i]=='e' || z[i]=='i' || z[i]=='o' || z[i]=='u' || z[i]=='A' || z[i]=='E' || z[i]=='I' || z[i]=='O' || z[i]=='U')){\n            cout<<z[i];\n       }\n     else if(!b && (z[i]!='a' && z[i]!='e' && z[i]!='i' && z[i]!='o' && z[i]!='u' && z[i]!='A' && z[i]!='E' && z[i]!='I' && z[i]!='O' && z[i]!='U')){\n          cout<<z[i];\n       }\n }\n ++b%=2;\n   for(auto i=0; i<z.size(); ++i){\n        if(b && (z[i]=='a' || z[i]=='e' || z[i]=='i' || z[i]=='o' || z[i]=='u' || z[i]=='A' || z[i]=='E' || z[i]=='I' || z[i]=='O' || z[i]=='U')){\n            cout<<z[i];\n       }\n     else if(!b && (z[i]!='a' && z[i]!='e' && z[i]!='i' && z[i]!='o' && z[i]!='u' && z[i]!='A' && z[i]!='E' && z[i]!='I' && z[i]!='O' && z[i]!='U')){\n          cout<<z[i];\n       }\n }\n \n  return 0;\n}\n"
    },
    {
        "titulo": "6383. Matrices con Giro Completo",
        "url": "https://omegaup.com/arena/problem/Problema-Matrices-con-Giro-Compl/",
        "descripcion": "Dada una matriz cuadrada A de N X N, se puede definir la operación de giro a la derecha de A como sigue: el primer renglón de la matriz A se convierte en la última columna de la matriz girada, el segundo renglón de la matriz A se convierte en la penúltima columna de la matriz girada, y así sucesivamente hasta que el último renglón de la matriz A se convierte en la primera columna de la matriz girada. Por ejemplo, si N=3 y A es la matriz A={3 1 4,1 5 9,2 6 5}, entonces al girar A a la derecha obtenemos la matriz A={2 1 3,6 5 1,5 9 4}, Pero se realizarán de nuevo giros hasta volver a la matriz original, por lo que al siguiente giro obtenemos la matriz A={5 6 2,9 5 1,4 1 3}, Un siguiente giro dejará la matriz así: A={4 9 5,1 5 6,3 1 2} Y el último giro será la matriz original: A={3 1 4,1 5 9,2 6 5}",
        "entrada": "Consiste de un número entero N con 1<=N<=20, seguido de N renglones, cada uno de los cuales contiene N números enteros entre 0 y 9, separados por espacios, describiendo a la matriz A.",
        "salida": "Consiste de N*4 renglones, cada uno de los cuales contiene N números enteros separados por espacios describiendo a las matrices A'.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Matrices"
        ],
        "estructuras": [
            "int",
            "vector<vector<int>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  int a, b, c, d, e, f, g, h, l, m=1;\n   int num[1000][1000];\n  cin>>a;\n   for(auto i=0; i<a; i++){\n       for(auto j=0; j<a; j++){\n           cin>>num[i][j];\n       }\n }\n for(auto i=0; i<a; i++){\n       for(auto j=a-1; j>=0; j--){\n            cout<<num[j][i]<<\" \";\n       }\n     cout<<\"\\n\";\n    }\n cout<<\"\\n\";\n    for(auto i=a-1; i>=0; i--){\n        for(auto j=a-1; j>=0; j--){\n            cout<<num[i][j]<<\" \";\n       }\n     cout<<\"\\n\";\n    }\n cout<<\"\\n\";\n    for(auto i=a-1; i>=0; i--){\n        for(auto j=0; j<a; j++){\n           cout<<num[j][i]<<\" \";\n       }\n     cout<<\"\\n\";\n    }\n cout<<\"\\n\";\n    for(auto i=0; i<a; i++){\n       for(auto j=0; j<a; j++){\n           cout<<num[i][j]<<\" \";\n       }\n     cout<<\"\\n\";\n    }\n\n   return 0;\n}\n"
    },
    {
        "titulo": "6123. Matriz serpentina",
        "url": "https://omegaup.com/arena/problem/Matriz-serpentina/",
        "descripcion": "Escribe un programa que, dados dos números enteros M, N, construya una matriz con M renglones y N columnas cuyas entradas sean los números 1,2,...,M*N acomodados como una serpentina, comenzando con el 1 en la entrada (0,0), siguiendo hacia la derecha (hasta el final del renglón), luego una posición hacia abajo, siguiendo hacia la izquierda (hasta el principio del renglón), luego una posición hacia abajo y así sucesivamente (ver ejemplo).",
        "entrada": "Consiste de dos números enteros positivos, M, N (ambos menores que 20), separados por un espacio.",
        "salida": "La matriz requerida, debiendo haber M renglones, cada uno con N números enteros separados por espacios.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Matrices"
        ],
        "estructuras": [
            "int",
            "vector<vector<int>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  int a, b, c, d=0, e=0, f, g, h, l, m=1;\n   vector<vector<int> >num(1000,vector<int>(1000,0));\n    cin>>a>>b;\n    c=a*b;\n    while(c--){\n       num[d][e]=a*b-c;\n      if(m==1){\n         if(e==b-1){\n               d++;\n              m=2;\n          }\n         else{\n             e++;\n          }\n     }\n     else{\n         if(e==0){\n             d++;\n              m=1;\n          }\n         else{\n             e--;\n          }\n     }\n }\n for(auto i=0; i<a; i++){\n       for(auto j=0; j<b; j++){\n           cout<<num[i][j]<<\" \";\n       }\n     cout<<\"\\n\";\n    }\n\n   return 0;\n}\n"
    },
    {
        "titulo": "6892. Ordenamiento super basico",
        "url": "https://omegaup.com/arena/problem/boredx100/",
        "descripcion": "Como dejaron a Xela solo en su casa y tenia tiempo que no torturaba a los olímpicos de la OB pense en hacer un problema tan dificil que ni el mismo Legna pudiera resolver pero al ver a su gata dormiendo decidio mejor hacer un simple y aburrido problema de ordenacion.",
        "entrada": "La primer línea de entrada contendrá el número N. La segunda línea contendrá N elementos separados por un espacio.",
        "salida": "Solo debes de ordenarlos.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores",
            "Ordenamiento"
        ],
        "estructuras": [
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n     cout.tie(0);\n      int a, b, c, d, e, f, g, h;\n   vector<int>num;\n   cin>>a;\n   while(a--){\n       cin>>b;\n       num.push_back(b);\n }\n sort(num.begin(),num.end());\n  for(auto i=0; i<num.size(); i++){\n      cout<<num[i]<<\" \";\n  }\n     \n  return 0;\n}\n"
    },
    {
        "titulo": "6864. Direcciones al Tec",
        "url": "https://omegaup.com/arena/problem/itp18-direcciones/",
        "descripcion": "¡Hoy es el gran día! Hoy se lleva a cabo el 1er Concurso de Programación del Instituto Tecnológico de Pachuca; sin embargo de tan emocionadx que estás se te olvidó cómo llegar al Tec y vas a tener que pedir ayuda en la calle. El mapa de tu casa al Tec es un rectángulo de N casillas de alto por M casillas de ancho. Tu casa está en la esquina superior izquierda y el Tec está en la esquina inferior derecha. Empiezas tu recorrido en tu casa (esquina superior izquierda) viendo hacia el Este. Dado que no sabes cómo llegar en cada casilla (incluída la casilla inicial) pides ayuda a la persona en esa casilla. Esa persona te puede aconsejar: Sigue derecho, Gira a la derecha, Gira a la izquierda, ó, Date la vuelta. Después de recibir el consejo, lo sigues y avanzas una casilla. Al llegar a una nueva casilla vuelves a hacer el mismo proceso: preguntar, seguir consejo, avanzar una casilla. Así hasta que llegues al Tec (esquina inferior derecha) o te salgas del mapa (si te sales del mapa ya te perdiste y es un hecho que no llegarás al concurso). Escribe un programa que dadas las respuestas de las personas en cada casilla del mapa determine si vas a llegar al Tec o te vas a perder.",
        "entrada": "Dos enteros indicando las dimensiones del mapa. El formato es N M donde: N = alto del mapa, y M = ancho del mapa. N renglones conteniendo M valores separados por espacios. Estos valores representan los consejos que vas a recibir en cada casilla. Los posibles valores son: 0 = sigue derecho, 1 = gira a la derecha, 2 = gira a la izquierda, ó, 3 = date la vuelta.",
        "salida": "Imprime \"llegaste\" si siguiendo las instrucciones llegas al Tec, ó, imprime \"te perdiste\" si te sales del mapa.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Matrices"
        ],
        "estructuras": [
            "bool",
            "int",
            "vector<vector<int>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, m;\nvector<vector<int>> mapa;\n\n// Funcion para simular el movimiento en el mapa\nbool mover(int &i, int &j, int &dir) {\n    if (mapa[i][j] == 0) { // Sigue derecho\n       if (dir == 0) j++; // Este\n        else if (dir == 1) i++; // Sur\n        else if (dir == 2) j--; // Oeste\n      else i--; // Norte\n    } else if (mapa[i][j] == 1) { // Gira a la derecha\n        dir = (dir + 1) % 4;\n      if (dir == 0) j++; // Este\n        else if (dir == 1) i++; // Sur\n        else if (dir == 2) j--; // Oeste\n      else i--; // Norte\n    } else if (mapa[i][j] == 2) { // Gira a la izquierda\n      dir = (dir + 3) % 4;\n      if (dir == 0) j++; // Este\n        else if (dir == 1) i++; // Sur\n        else if (dir == 2) j--; // Oeste\n      else i--; // Norte\n    } else { // Date la vuelta\n        dir = (dir + 2) % 4;\n      if (dir == 0) j++; // Este\n        else if (dir == 1) i++; // Sur\n        else if (dir == 2) j--; // Oeste\n      else i--; // Norte\n    }\n // Verificar si se sale del mapa\n  if (i < 0 || i >= n || j < 0 || j >= m) return false;\n return true;\n}\n\nint main() {\n   cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  cin >> n >> m;\n    mapa.resize(n, vector<int>(m));\n   for (int i = 0; i < n; i++) {\n     for (int j = 0; j < m; j++) {\n         cin >> mapa[i][j];\n        }\n }\n int i = 0, j = 0, dir = 0; // Posicion inicial (0,0) viendo al Este\n    while (i != n - 1 || j != m - 1) { // Mientras no llegue al Tec\n       if (!mover(i, j, dir)) { // Simular movimiento\n            cout << \"te perdiste\\n\";\n           return 0;\n     }\n }\n cout << \"llegaste\\n\";\n\n    return 0;\n}\n"
    },
    {
        "titulo": "4103. Analizar palabra",
        "url": "https://omegaup.com/arena/problem/Analizar-palabra/",
        "descripcion": "Crear un programa para analizar palabras. Este programa recibirá una palabra solamente y a continuación revisará cuantas letras tiene, cuantas vocales y además imprimirá la cadena invertida.",
        "entrada": "Leer una cadena. Esta cadena será siempre una sola palabra, sin espacios.",
        "salida": "Debe imprimimir tres líneas: En la primera, la cantidad de letras que tiene la palabra. En la segunda, la cantidad de vocales que tiene la palabra (si se repiten también debe contarlas). Y en la tercera, la palabra invertida.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "int",
            "string",
            "tolower()",
            "reverse()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout.tie(0);\n  string palabra;\n  cin >> palabra;\n  int letras = palabra.length();\n  int vocales = 0;\n  for (char c : palabra) {\n   // Optimizacion: Convertir a minuscula para contar vocales sin importar mayusculas/minusculas\n    c = tolower(c);\n    if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n      vocales++;\n    }\n  }\n  reverse(palabra.begin(), palabra.end()); // Invertir la palabra\n  cout << letras << \"\\n\" << vocales << \"\\n\" << palabra << \"\\n\";\n\n  return 0;\n}\n"
    },
    {
        "titulo": "4028. Rango simple",
        "url": "https://omegaup.com/arena/problem/Rango-simple/",
        "descripcion": "Encontrar la cantidad de números que hay en un rango. Como entrada se tendrán N números y un rango. Lo único que debe hacer el programa es calcular la cantidad de números que hay dicho rango.",
        "entrada": "Leer primero N (1<=N<=100) que indica la cantidad de números que se leerán desde el teclado. En las siguientes N lineas se encuentran los datos de entrada. Al finalizar se tienen dos números enteros A y B (0<=A<=B<=1000) que indican el rango.",
        "salida": "Imprima la cantidad de números que existen en el rango desde A hasta B.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores"
        ],
        "estructuras": [
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n   cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  int N, A, B;\n  cin >> N;\n vector<int> nums(N);\n  for (int i = 0; i < N; ++i) {\n     cin >> nums[i];\n   }\n cin >> A >> B;\n    int count = 0;\n    for (int i = 0; i < N; ++i) {\n     if (nums[i] >= A && nums[i] <= B) {\n           count++;\n      }\n }\n cout << count << endl;\n\n  return 0;\n}\n"
    },
    {
        "titulo": "10694. Formula general",
        "url": "https://omegaup.com/arena/problem/Formula-general-/",
        "descripcion": "Escriba un programa que calcule las soluciones de una ecuación de segundo grado de la forma a*x^2+b*x+c=0, teniendo en cuenta que: x=(-b+-sqrt(b^2-4*a*c))/(2*a).",
        "entrada": "En las primeras tres lineas recibirás el valor de a, b y c.",
        "salida": "Mostrar el resultado de X_i y X_2.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Cálculo matemático"
        ],
        "estructuras": [
            "long long",
            "double",
            "sqrt()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  long long a, b, c;\n    cin >> a >> b >> c;\n   long long discriminante = b*b - 4*a*c;\n    if (discriminante < 0){\n       cout << \"La ecuacion no tiene soluciones reales\\n\"; \n   } else {\n      double x1 = (-b + sqrt(discriminante)) / (2*a);\n       double x2 = (-b - sqrt(discriminante)) / (2*a);\n       cout << \"X1 = \" << x1 << endl;\n      cout << \"X2 = \" << x2 << endl;\n  }\n\n   return 0;\n}\n"
    },
    {
        "titulo": "10471. Contando los segundos",
        "url": "https://omegaup.com/arena/problem/Contando-los-segundos/",
        "descripcion": "Ya es febrero y Luis está tan emocionado por ver a su novia Lucía en San Valentín que cuenta hasta los segundos que faltan para poder verla, o algo así. A Luis no es muy bueno con las cuentas, por eso pide tu ayuda para saber cuántos días, horas, minutos y segundos faltan para poder reunirse con su amada en este día especial. Tu tarea será ayudar al enamorado. Luis te dirá qué día es hoy y qué hora, minuto y segundo marca en su reloj, y en base a eso, le tendrás que decir cuántos días, horas, minutos y segundos faltan para las 00:00:00 del 14 de febrero, como Luis es muy distraído es posible que ya sea 14 de febrero, en cuyo caso solo te queda desearle un \"Feliz San Valentin\", o incluso que se le haya pasado la fecha, en cuyo caso tendrás que decir \"Mas suerte a la siguiente\".",
        "entrada": "Recibirás cuatro enteros d (29>=d>=0), h (12>=h>=0), m (59>=m>=0) y s (59>=s>=0); que indican el día, la hora, minuto y segundo en el reloj de Luis cuando empieza a contar.",
        "salida": "Cuatro enteros expresando los días, horas, minutos y segundos que faltan para el 14 de febrero. En caso de que ya sea 14 de febrero únicamente el mensaje \"Feliz San Valentin\" o bien el mensaje \"Mas suerte a la siguiente\" en caso de que la fecha se haya pasado.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Cálculo matemático"
        ],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int d, h, m, s;\n    cin >> d >> h >> m >> s;\n    if (d > 14) {\n        cout << \"Mas suerte a la siguiente\\n\";\n    } else if (d == 14) {\n        cout << \"Feliz San Valentin\\n\";\n    } else {\n        int totalSegundos = (14 - d - 1) * 86400 + (24 - h - 1) * 3600 + (60 - m - 1) * 60 + (60 - s); \n        int dias = totalSegundos / 86400;\n        totalSegundos %= 86400;\n        int horas = totalSegundos / 3600;\n        totalSegundos %= 3600;\n        int minutos = totalSegundos / 60;\n        totalSegundos %= 60;\n        cout << dias << \" \" << horas << \" \" << minutos << \" \" << totalSegundos << \"\\n\";\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "3172. occ15nsf21",
        "url": "https://omegaup.com/arena/problem/funcion_convergente/",
        "descripcion": "Considere una función f(n) definida así: f(n)=n/2 si n es par. f(n)=3n+1 si n es impar. Cuando se aplica repetidamente esta funcion a un número siempre se llega a 1. Por ejemplo si se comienza con 5, se tiene: f(5)=16 -> f(16)=8 -> f(8)=4 ->f(4)=2 -> f(2)=1. En este caso se aplica la función 5 veces para llegar a 1. Haga un programa que dado un numero n diga cuántas veces hay que aplicar f para llegar a 1.",
        "entrada": "Un entero n positivo.",
        "salida": "El número de veces que hay que aplicar f para llegar a 1.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Cálculo matemático"
        ],
        "estructuras": [
            "int",
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long n;\n    cin >> n;\n    int pasos = 0;\n    while (n != 1) {\n        if (n % 2 == 0) {\n            n /= 2;\n        } else {\n            n = 3 * n + 1;\n        }\n        pasos++;\n    }\n    cout << pasos << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "9533. RooClub",
        "url": "https://omegaup.com/arena/problem/RooClub/",
        "descripcion": "El club deportivo Cancún Caribe, está compuesto por N cantidad de socios. Debido a su impecable servicio y amplias instalaciones, se implementaron dos disciplinas deportivas más (futbol y atletismo); en las cuales una cantidad A, se inscribió en atletismo y una cantidad F, lo hizo en futbol, el resto R decidió no inscribirse a ninguna de las dos. Sin embargo hubo quienes aprovecharon y se inscribieron en ambas disciplinas. Con el objetivo de ofrecer un servicio plus que consiste en obsequiarles bebidas isotónicas para mitigar el desgaste y mantener una buena hidratación, solo a aquellos socios que se inscribieron a las dos disciplinas, se requiere saber la cantidad total de estos. Elabora un programa que permita conocer la cantidad total de socios que se inscribieron a las dos disciplinas, así como la cantidad total de socios que solo se inscribieron en atletismo y de los que solo lo hicieron a futbol.",
        "entrada": "Deberás leer un valor N (10<=N<=1000), que representa la cantidad total de socios que integran el club deportivo, así como una variable A que representa los socios inscritos en atletismo, una variable F que representa los socios inscritos en futbol y una variable R que representa a los socios que decidieron NO inscribirse a ninguna de las dos disciplinas (2<=A,F,R<=N/2).",
        "salida": "Deberás imprimir en una sola línea tres valores separados por un espacio, el primero que representa la cantidad de socios que se inscribieron a las dos disciplinas y quienes recibirán bebidas isotónicas; el segundo que representa la cantidad de socios que solo se inscribió en atletismo y el tercer valor que representa a los socios que hicieron lo propio solo a futbol.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Cálculo matemático"
        ],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int a, b, c, d;\n    cin>>a>>b>>c>>d;\n    if(a-b-c-d<=0){\n        cout<<abs(a-b-c-d)<<\" \"<<abs(a-c-d)<<\" \"<<abs(a-b-d);\n    }\n    else{\n        cout<<\"0 \"<<b<<\" \"<<c;\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "6818. Los Ultimos Seran Los Primeros",
        "url": "https://omegaup.com/arena/problem/Los-Ultimos-Seran-Los-Primeros/",
        "descripcion": "En una carrera en el pueblo de Yahualica todos los participantes creen que el que llegue primero será el ganador, pero no, las reglas son diferentes en Yahualica, el ganador es el que llega al último. Escribe un programa que dados los nombres de los concursantes como van cruzando la meta, imprima dichos nombres en orden de acuerdo al lugar que consiguieron en la competencia (El que llego al último obtiene el primer lugar, el penúltimo el segundo lugar, y así sucesivamente).",
        "entrada": "Varios nombres de concursantes como van cruzando la meta. La entrada termina con el string \"#\".",
        "salida": "Los nombres en orden al lugar que ocuparon en la competencia.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas",
            "Pilas"
        ],
        "estructuras": [
            "string",
            "stack<string>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    string nombre;\n    stack<string> pilaDeNombres;\n    // Leer nombres hasta encontrar \"#\"\n    while (cin >> nombre, nombre != \"#\") {\n        pilaDeNombres.push(nombre);\n    }\n    // Imprimir nombres en orden inverso\n    while (!pilaDeNombres.empty()) {\n        cout << pilaDeNombres.top() << \"\\n\";\n        pilaDeNombres.pop();\n    }\n\n     return 0;\n}\n"
    },
    {
        "titulo": "1900. Números pitagóricos",
        "url": "https://omegaup.com/arena/problem/Numeros-pitagoricos/",
        "descripcion": "Es bien conocido que las ternas pitagóricas son aquellas donde la suma de los cuadrados de dos de los numeros, te da el tercero al cuadrado. ¿Podrías identificar una terna pitagórica?",
        "entrada": "Una sola linea. Tres números enteros: a, b y c, tales que 0<=a,b,c<=1000.",
        "salida": "Una sola palabra, en una linea, \"Si\" o \"No\" si la terna es pitagórica o no.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Cálculo matemático"
        ],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int a, b, c;\n    cin >> a >> b >> c;\n    // Verificar todas las posibles combinaciones para la terna pitagorica\n    if (a*a + b*b == c*c || a*a + c*c == b*b || b*b + c*c == a*a) {\n        cout << \"Si\\n\";\n    } else {\n        cout << \"No\\n\";\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "4220. Contando Dinero",
        "url": "https://omegaup.com/arena/problem/ENIGMA/",
        "descripcion": "Un luchador de la EAW (Extreme Wrestling Action) que se hace llamar Enigma, ha estado ganando mucho dinero los ultimos meses; y aunque es muy bueno para las matematicas, aveces se le hace dificil hacer algunas sumas, ya sea que se equivoca o lo hace muy lento. El te dara una recompensa si lo haces bien y en menos tiempo de que el lo haria. El te dara un numero N de meses y luego N_i que es el dinero que gano en el i-esimo mes, luego te dara un numero M de consultas a realizar, por cada consulta te da 2 numeros l y r, y tu tendras que responderle rapidamente la suma total del dinero que gano entre el mes l y el mes r. Por ejemplo, si N = 5, y el dinero que gano en cada mes es 100 200 300 400 500 respectivamente; para la consulta l = 1 y r = 5, el resultado seria 1500, y si l = 2 y r = 4 entonces la suma seria 900.",
        "entrada": "En la primera linea un numero N (1<=N<=10^5), en la 2da linea N numeros que es la cantidad de dinero que Enigma gana en el i-esimo mes (-10^9<=N_i<=10^9). En la tercer linea un numero M (1<=M<=10^5) que es el numero de consultas a realizar, luego M lineas, en cada consulta dos enteros L y R (1<=L,R<=10^5).",
        "salida": "Por cada consulta, imprimir un entero indicando la suma total de dinero que Enigma gana entre los meses L y R.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores",
            "Suma de prefijos"
        ],
        "estructuras": [
            "int",
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long ganancias[100005]; // Arreglo para almacenar las ganancias de Enigma\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int N, M;\n    cin >> N;\n    // Lectura de las ganancias de cada mes\n    for (int i = 1; i <= N; ++i) {\n        cin >> ganancias[i];\n        ganancias[i] += ganancias[i - 1]; // Calcular la suma acumulada\n    }\n    cin >> M;\n    // Procesamiento de las consultas\n    for (int i = 0; i < M; ++i) {\n        int L, R;\n        cin >> L >> R;\n        cout << ganancias[R] - ganancias[L - 1] << \"\\n\"; // Imprimir la suma entre L y R\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "65. Patos",
        "url": "https://omegaup.com/arena/problem/patos/",
        "descripcion": "El señor Dengklek vive en el Reino de los Patos, donde humanos y patos viven juntos en paz y harmonía. Los patos estan numerados por números enteros positivos distintos de A a B, inclusive, donde A<=B. La última noche, el señor Dengklek no podía dormir, así que salió de su casa a intentar contar todos los patos en el reino. Cada vez que veía a un nuevo pato, decía su número en voz alta. El señor Dengklek sólo decía sus números (números que van de A a B). Nunca dijo el mismo número dos veces ni tampoco se tomó la molestia de decirlos en orden. Es posible que el señor Dengklek no haya visto a algunos patos. Obviamente, el número de patos que no vió depende de los valores de A y B. Los valores A y B son desconocidos para tí. Calcula el menor número de patos que el señor Dengklek se pudo haber perdido.",
        "entrada": "Un entero positivo N (1<=N<=50) con la cantidad de patos que el señor Dengklek vio. En la siguiente línea, habrá N números, representando los números de los patos que fueron vistos. Cada número de pato es un entero entre el 1 y el 100, inclusive. Todos los N_i números en la entrada son distintos.",
        "salida": "Un entero representando el menor número de patos que el señor Denglklek se pudo haber perdido.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores",
            "Cálculo matemático"
        ],
        "estructuras": [
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    //Code here\n    int N;\n    cin >> N;\n    vector<int> patosVistos(101, 0); \n    for (int i = 0; i < N; ++i) {\n        int pato;\n        cin >> pato;\n        patosVistos[pato] = 1; \n    }\n    int A = 1;\n    while (!patosVistos[A]) {\n        A++;\n    }\n    int B = 100;\n    while (!patosVistos[B]) {\n        B--;\n    }\n    int patosPerdidos = B - A + 1 - N;\n    cout << patosPerdidos << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "3581. La llave dorada",
        "url": "https://omegaup.com/arena/problem/Alicia-y-la-llave-dorada/",
        "descripcion": "Después de que la gran caída por el agujero terminó, Alicia se encontraba ilesa y frente a un largo pasillo con muchas puertas de cerraduras diversas. Un poco más adelante se encontraba una mesa de cristal con una llave dorada. Alicia quería salir de ahí tan pronto como fuera posible y pensó que seguramente alguna puerta correspondía con la llave, así tuviera que girar la llave para poder insertarla en la cerradura. Ayuda a Alicia a encontrar la puerta correcta.",
        "entrada": "Un entero N seguido de una matriz de N*N caracteres . y # que representa la forma de la llave. Posteriormente un entero M seguido de M matrices de N*N caracteres que representan las cerraduras de las M puertas, numeradas de 1 a M. Puedes suponer que 1<=N,M<=100. La entrada puede contener saltos de línea adicionales para separar los datos de la misma y deben ser ignorados.",
        "salida": "Un entero que es el número de la puerta que abre con la llave dada o -1 si ninguna puerta abre. La llave puede girarse 90, 180 o 270 grados.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Matrices",
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "bool",
            "int",
            "vector<vector<char>>",
            "vector<vector<vector<char>>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<vector<char>> rotarMatriz(const vector<vector<char>> &matriz) {\n    int n = matriz.size();\n    vector<vector<char>> rotada(n, vector<char>(n));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            rotada[j][n - 1 - i] = matriz[i][j];\n        }\n    }\n    return rotada;\n}\n\nbool compararMatrices(const vector<vector<char>> &llave, const vector<vector<char>> &cerradura) {\n    int n = llave.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (llave[i][j] != cerradura[i][j]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int n, m;\n    cin >> n;\n    vector<vector<char>> llave(n, vector<char>(n));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cin >> llave[i][j];\n        }\n    }\n    cin >> m;\n    vector<vector<vector<char>>> cerraduras(m, vector<vector<char>>(n, vector<char>(n)));\n    for (int k = 0; k < m; ++k) {\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                cin >> cerraduras[k][i][j];\n            }\n        }\n    }\n    int puerta = -1;\n    for (int k = 0; k < m; ++k) {\n        for (int r = 0; r < 4; ++r) { \n            if (compararMatrices(llave, cerraduras[k])) {\n                puerta = k + 1;\n                break;\n            }\n            llave = rotarMatriz(llave); \n        }\n        if (puerta != -1) {\n            break; \n        }\n    }\n    cout << puerta << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "6844. La Aventura de Kirby",
        "url": "https://omegaup.com/arena/problem/La-Aventura-de-Kirby/",
        "descripcion": "Oh no! Kirby se ha perdido en DreamLand! El malvado Meta Knight lo ha lanzado desde el Halberd y ahora el pobre no sabe donde esta... Afortunadamente, Kirby no esta solo... Cuenta con tu ayuda!. Con tus increíbles habilidades de programación puedes ayudarlo a hacer un mapa y encontrar la salida. El lugar donde kirby ha caído cuenta con N puertas, cada una con un numero. La salida tiene el numero K en ella. Ayuda a kirby a encontrar la posición en la que esta la salida.",
        "entrada": "En la primera linea un numero N (1<=N<=1000) que denota la cantidad de puertas en el area seguido de un numero K (0<=K<=1000) que corresponde al numero que tendra la salida. En la segunda linea N numeros, que seran el valor de cada puerta N_i.",
        "salida": "La posición en la que esta la puerta que lleva a la salida (las posiciones se cuentan desde 0). Si ninguna puerta cumple la condición imprime \"Poyo :(\" (Sin las comillas).",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores"
        ],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int N, K;\n    cin >> N >> K;\n    int puerta;\n    for (int i = 1; i <= N; ++i) {\n        cin >> puerta;\n        if (puerta == K) {\n            cout << i << endl;\n            return 0;\n        }\n    }\n    cout << \"Poyo :(\" << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "8658. Intervalo maximo consecutivo",
        "url": "https://omegaup.com/arena/problem/Intervalo-maximo-consecutivo/",
        "descripcion": "Dado un arreglo de tamaño N determine la longitud del intervalo más grande entre dos elementos consecutivos cuando el arreglo está ordenado de mayor a menor.",
        "entrada": "Un entero N seguido de N enteros. Puedes suponer que 1<=N<=1000.",
        "salida": "Un entero que representa la longitud del intervalo más grande.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores",
            "Ordenamiento"
        ],
        "estructuras": [
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int N;\n    cin >> N;\n    vector<int> arr(N);\n    for(auto i = 0; i < N; i++){\n        cin >> arr[i];\n    }\n    sort(arr.rbegin(), arr.rend()); // Ordenar de mayor a menor\n    int maxDiff = 0;\n    for(auto i = 1; i < N; i++){\n        maxDiff = max(maxDiff, arr[i - 1] - arr[i]);\n    }\n    cout << maxDiff << \"\\n\";\n\n    return 0;\n}\n"
    },
    {
        "titulo": "7186. Girando un vector",
        "url": "https://omegaup.com/arena/problem/Girando-vector/",
        "descripcion": "Escriba un programa que lea dos números enteros positivos N,G y un vector X de N componentes enteras y que escriba el vector Y de N componentes formado al girar G veces el vector X hacia la derecha. Al hacer esto, la componente más a la derecha de X se debe colocar en la componente más a la izquierda de Y. Por ejemplo, si N=5, X=(3,1,4,1,5), al girarlo una vez (G=1), se obtiene el vector Y=(5,3,1,4,1); y si se girara una vez más (G=2), se obtendría el vector Y=(1,5,3,1,4), etcétera.",
        "entrada": "Consiste de dos números enteros, N y G, separados por un espacio, con valores entre 1 y 100, y en la siguiente línea, N números enteros, separados por espacios, cada uno con valor entre 0 y 9 (las componentes de X).",
        "salida": "Consiste de N números enteros separados por espacios (las componentes de Y).",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores"
        ],
        "estructuras": [
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int N, G;\n    cin >> N >> G;\n    vector<int> X(N), Y(N);\n    for (int i = 0; i < N; ++i) {\n      cin >> X[i];\n    }\n    // Optimizar las rotaciones utilizando el m?ulo\n    G %= N; \n    for (int i = 0; i < N; ++i) {\n      Y[i] = X[(i - G + N) % N]; \n    }\n    for (int i = 0; i < N; ++i) {\n      cout << Y[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "6542. Frase Volteada",
        "url": "https://omegaup.com/arena/problem/Frase-Volteada/",
        "descripcion": "Dada una frase compuesta de letras y espacios, cambia el orden de las palabras para que queden exactamente al revés de como estaban inicialmente, pero haciendo que cada palabra: #1. Si inicia con mayúscula, dejarla igual, #2. Si no, voltear el orden de las letras y hacer que inicie en mayúscula.",
        "entrada": "Una sola entrada, como está descrita en el problema.",
        "salida": "Una sola salida, como está descrita en el problema.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "char",
            "string",
            "reverse()",
            "getline()",
            "vector<string>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n// Funci? para invertir una palabra\nstring invertirPalabra(string palabra) {\n    reverse(palabra.begin(), palabra.end());\n    return palabra;\n}\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    string frase;\n    getline(cin, frase);\n    string palabraActual = \"\";\n    vector<string> palabras;\n    // Separar la frase en palabras\n    for (char c : frase) {\n        if (c == ' ') {\n            palabras.push_back(palabraActual);\n            palabraActual = \"\";\n        } else {\n            palabraActual += c;\n        }\n    }\n    palabras.push_back(palabraActual);\n    // Invertir el orden de las palabras\n    reverse(palabras.begin(), palabras.end());\n    // Imprimir las palabras procesadas\n    for (int i = 0; i < palabras.size(); i++) {\n        if (isupper(palabras[i][0])) {\n            cout << palabras[i] << \" \";\n        } else {\n            palabras[i] = invertirPalabra(palabras[i]);\n            palabras[i][0] = toupper(palabras[i][0]);\n            cout << palabras[i] << \" \";\n        }\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "7465. Esta difícil joven, hoy no circula",
        "url": "https://omegaup.com/arena/problem/Esta-dificil-joven-hoy-no-circul/",
        "descripcion": "Con la entrada del nuevo gobierno, se planea un cambio a la reglamentación del famoso \"Hoy no circula\", en la que en vez de ver que día de la semana es, se verifica qué día del mes es y se siguen las siguientes reglas: • Los automóviles cuya placa contenga un número par solamente podrán circular los días pares del mes. • Los automóviles cuya placa contenga un número impar solamente podrán circular los días impares del mes. • El monto de la multa cambia diariamente. Ricardo es un oficial de policía muy flojo, por lo que en vez de aplicar las multas correspondientes inmediatamente, él va anotando las placas de todos los coches que pasan por enfrente de su tienda de donas favorita y aplica las multas al final del día. Ricardo te preguntó si tu \"le sabes\" a eso de las computadoras y te pidió que le hicieras una herramienta para ver el total de dinero que se va a recaudar debido a las multas que aplicará.",
        "entrada": "Un número N que representa cuántas placas Ricardo anotó mientras comía donas. N líneas que contienen los números de las N placas que Ricardo anotó. D, el número de día del mes, y, M, el monto de cuánto se cobrará de multa ese día.",
        "salida": "El monto total de las multas que se aplicarán ese día.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Cálculo matemático"
        ],
        "estructuras": [
            "int",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int N;\n    cin >> N; \n    // Dado que solo nos interesa la paridad de la placa, \n    // no es necesario almacenar el n?mero completo.\n    int placas_pares = 0; \n    for (int i = 0; i < N; ++i) {\n        string placa; \n        cin >> placa;\n        // Verificamos el ?ltimo d?ito de la placa\n        if ((placa.back() - '0') % 2 == 0) {\n            placas_pares++; \n        }\n    }\n    int D, M;\n    cin >> D >> M;\n    int total_multas = 0;\n    if (D % 2) { \n        total_multas = placas_pares * M;\n    } else {\n        total_multas = (N - placas_pares) * M;\n    }\n    cout << total_multas << \"\\n\";\n\n    return 0;\n}\n"
    },
    {
        "titulo": "6169. Encontrar valor",
        "url": "https://omegaup.com/arena/problem/Encontrar-valor/",
        "descripcion": "Hacer un programa que diga si un valor introducido desde teclado se encuentra o no en un arreglo. Si está en él, ha de mostrar la posición que ocupa.",
        "entrada": "Un entero N que indica la cantidad de elementos del arreglo (Un arreglo en orden ascendente). Las siguientes N lineas un entero que indica un elemento del arreglo. Un entero K que indica el valor que se quiere encontrar.",
        "salida": "Si el valor esta en el arreglo, mostrar la posición (en caso de que aparezca en dos posiciones, mostrar la menor). Si el valor no esta en el arreglo, mostrar \"NO\".",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores",
            "Búsqueda binaria"
        ],
        "estructuras": [
            "long long",
            "vector<long long>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d;\n    vector<long long>falta;\n    cin>>a;\n    while(a--){\n        cin>>b;\n        falta.push_back(b);\n    }\n    cin>>a;\n    b=0;\n    c=falta.size()-1;\n    while(b<=c){\n        d=(b+c)/2;\n        if(falta[d]==a){\n            while(d>-1 && falta[d]==a){\n                d--;\n            }\n            cout<<d+1;return 0;\n        }\n        else if(falta[d]<a){\n            b=d+1;\n        }\n        else{\n            c=d-1;\n        }\n    }\n    cout<<\"NO\";\n    \n    return 0;\n}\n"
    },
    {
        "titulo": "4984. EncuentraDivisibles",
        "url": "https://omegaup.com/arena/problem/EncuentraDivisibles/",
        "descripcion": "Dada una lista de 5 números naturales, identifica si algún número de la lista divide a algún otro.",
        "entrada": "5 números naturales, uno en cada renglón.",
        "salida": "La frase: \"Existen\" si existe dentro de la lista un número que divida exactamente a otro. La frase: \"No existen\" si ningún elemento de la lista divide exactamente a otro.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores"
        ],
        "estructuras": [
            "bool",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    vector<int> numeros(5);\n    for (int i = 0; i < 5; ++i) {\n        cin >> numeros[i];\n    }\n    bool existen = false;\n    for (int i = 0; i < 5; ++i) {\n        for (int j = 0; j < 5; ++j) {\n            if (i != j && numeros[i] != 0 && numeros[j] % numeros[i] == 0) {\n                existen = true;\n                break;\n            }\n        }\n    }   \n    if (existen) {\n        cout << \"Existen\\n\";\n    } else {\n        cout << \"No existen\\n\";\n    }\n    \n    return 0;\n}\n"
    },
    {
        "titulo": "1781. Elevador",
        "url": "https://omegaup.com/arena/problem/elevador/",
        "descripcion": "En el edificio más grande de nuestra ciudad, hay un sólo elevador. Una lista de peticiones se hace con N números positivos. El número indica a cuales pisos se detendrá el elevador, en un orden específico. 6 segundos se tarda el elevador en subir un piso, y 4 segundos en bajar un piso. El elevador se quedará por 5 segundos en cada parada. Dada una lista de peticiones, deberás calcular el total de tiempo que se necesitará para atender todas las peticiones de la lista. Todos los números en la entrada son menos a 100. El elevador inicia en el piso 0 al comienzo y no tiene que regresar cuando la lista se haya terminado.",
        "entrada": "Una línea con un entero positivo  N que indica el número de peticiones, seguido de N números positivos. Todos los números son menores que 100.",
        "salida": "Despliega el total de tiempo en una sóla línea, que el elevador tardará en procesar la lista de peticiones.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Cálculo matemático"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b=0, c=0, d;\n    cin>>a;\n    b+=(a*5);\n    while(a--){\n        cin>>d;\n        if(d>c){\n            b+=((d-c)*6);\n        }\n        else if(d<c){\n            b+=((c-d)*4);\n        }\n        c=d;\n    }\n    cout<<b;\n\n    return 0;\n}"
    },
    {
        "titulo": "5410. El elevador",
        "url": "https://omegaup.com/arena/problem/El-elevador-ASINUS/",
        "descripcion": "La torre Latinoamericana es uno de los edificios más emblemáticos de la Ciudad de México, ahí trabaja Chema, quien es el encargado del control del elevador. Sin embargo últimamente ha tenido algunos problemas ya que su supervisor ha recibido quejas de que el elevador no responde cuando lo mandas llamar, por lo cual el supervisor de Chema, supone que como ha comenzado un noviazgo con una señorita en el piso 21 se detiene en este piso, provocando que se ponga lento el servicio al hacer esperar a la gente que desea subir al mirador. Para solucionar el problema el supervisor desea instalar un programa en el elevador que le reporte cuáles pisos fueron visitados por Chema durante los recorridos, ya que el supervisor se encuentra en la recepción le será fácil general el reporte una vez que Chema regrese al Lobby y así saber si se detuvo en algún momento en el piso 21. Ayuda al supervisor con el programa para el elevador, en el cual se registren todos los pisos que visitó durante el recorrido, para al llegar al Lobby nuevamente se pueda imprimir un reporte con los pisos, en caso de que entre los pisos no aparezca el piso 21, sólo se generará el reporte, pero en caso de que sí aparezca, al final de la lista deberá de indicarse ALERTA.",
        "entrada": "N como el número pisos que visitó durante el recorrido >0 y <=45. Seguido del número de cada piso que se visitó.",
        "salida": "El registro de los pisos visitados. En caso de que no visitara el piso 21, sólo el registro, pero en caso de que visitara el piso 21, al final del registro se imprimirá: ALERTA. El número de pisos visitados debe ser >0 y <=45, de lo contrario se marcará \"ERROR\". El número de piso capturado debe ser >0 y <=45, de lo contrario se marcará \"ERROR\". El Lobby no se contará en los registros.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores"
        ],
        "estructuras": [
            "long long",
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c=0;\n    vector<long long>falta;\n    cin>>a;\n    if(a<=0 || a>45){\n        cout<<\"ERROR\";return 0;\n    }\n    while(a--){\n        cin>>b;\n        if(b==21){\n            c++;\n        }\n        else if(b==0){\n            cout<<\"ERROR\";return 0;\n        }\n        falta.push_back(b);\n    }\n    for(auto i=0; i<falta.size(); i++){\n        cout<<falta[i]<<\"\\n\";\n    }\n    if(c){\n        cout<<\"ALERTA\";\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "4085. El Intervalo y el divisor",
        "url": "https://omegaup.com/arena/problem/Multiplos-en-el-intervalo/",
        "descripcion": "Teniendo un intervalo de A y B, calcule cuantos números son divisibles por el número N.",
        "entrada": "Un número entero N, que representa el valor del divisor y dos números, A y B que representan el valor inicial y el final del intervalo respectivamente. Límites no establecidos",
        "salida": "Un solo número que representa la cantidad de números cuyo divisor es N",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Cálculo matemático"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c;\n    cin>>a>>b>>c;\n    cout<<(c/a)-((b-1)/a);\n    \n    return 0;\n}"
    },
    {
        "titulo": "814. Ej2.- Orden inverso",
        "url": "https://omegaup.com/arena/problem/Ej2--Orden-inverso/",
        "descripcion": "Elabora un programa que lea una secuencia de N palabras y las imprima en orden inverso.",
        "entrada": "N .- Numero de palabras, N palabras en N lineas diferentes (2<N<100).",
        "salida": "N lineas con las palabras en el orden inverso al que se leyeron.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Loops",
            "Caracteres y cadenas",
            "Pilas"
        ],
        "estructuras": [
            "string",
            "long long",
            "stack<string>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a;\n    stack<string>falta;\n    string z;\n    cin>>a;\n    while(a--){\n        cin>>z;\n        falta.push(z);\n    }\n    while(falta.size()){\n        cout<<falta.top()<<\"\\n\";\n        falta.pop();\n    }\n        \n    return 0;\n}\n"
    },
    {
        "titulo": "12322. Infección de negativos",
        "url": "https://omegaup.com/arena/problem/Infeccion-de-negativos-ANH/",
        "descripcion": "Los científicos del lugar (los de notación científica), han encontrado una vacuna en poco tiempo, pero ahora deben ubicar a todos los contagiados para poderlos vacunar primero y detener el contagio. Pero son muchos y sólo pueden probar a grupos de 30. Te contrataron para detectar a los infectados.",
        "entrada": "30 números enteros entre -10 y 50",
        "salida": "Los índices en los que se encuentran los números negativos separados por un espacio y la cantidad total de números negativos que hay en el grupo",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Vectores"
        ],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b=0, c, d, e, f, g, h;\n    for(auto i=0; i<30; ++i){\n        cin>>a;\n        if(a<0){\n            cout<<i<<\" \";\n            b++;\n        }\n    }\n    cout<<b;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "12323. Leer al reves",
        "url": "https://omegaup.com/arena/problem/Leer-al-reves-ANH/",
        "descripcion": "Ellos deben ingresar una palabra y el programa debe imprimirla al revés, de esta manera será más fácil leerla para ellos.",
        "entrada": "Una palabra con N caracteres",
        "salida": "La palabra escrita al revés.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e, f, g, h;\n   string s;\n    getline(cin,s);\n    reverse(s.begin(),s.end());\n    cout<<s;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "11614. Imprimir un arreglo al revez",
        "url": "https://omegaup.com/arena/problem/Imprimir-un-arreglo-al-revez/",
        "descripcion": "Leer un arreglo de N numeros e imprimirlo al revez.",
        "entrada": "En la primera linea de entrada un numero entero N (1<=N<=100). En la segunda linea de entrada, habra N numeros enteros que representan los elementos del arreglo",
        "salida": "El arreglo de N enteros, impreso al revez.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Vectores"
        ],
        "estructuras": [
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e, f, g, h;\n   vector<int>num(1000000,0);\n    cin>>a;\n    for(auto i=0; i<a; ++i){\n        cin>>num[i];\n    }\n    for(auto i=a-1; i>=0; --i){\n        cout<<num[i]<<\" \";\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "11773. Sumando Arreglos",
        "url": "https://omegaup.com/arena/problem/Sumando-Arreglos/",
        "descripcion": "En este problema realizaras la suma de dos arreglos con el mismo tamaño y varios números ya sean iguales o diferentes;",
        "entrada": "Un numero entero N que indicara el tamaño de los arreglos; Los siguientes N números serán los números de los arreglos;",
        "salida": "Una fila de la suma de los arreglos separados por un espacio;",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Vectores"
        ],
        "estructuras": [
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e, f, g, h;\n   vector<int>num(1000000,0);\n    cin>>a;\n    for(auto i=0; i<a; ++i){\n        cin>>num[i];\n    }\n    for(auto i=0; i<a; ++i){\n        cin>>b;\n        cout<<num[i]+b<<\" \";\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "10173. Parasoul",
        "url": "https://omegaup.com/arena/problem/Parasoul/",
        "descripcion": "Los amigos del mago siguen sin ser pros en programación, por lo que necesitan tu ayuda para resolver este problema y así entender mejor para no reprobar el siguiente semestre.",
        "entrada": "Tres números de tipo entero, N_1, N_2 y N_3, en donde se debe evaluar cual es el numero mayor. Si al menos uno de los números introducidos es diferente al resto, entonces solicitara un numero N el cual sera las veces que se mostrara el numero mayor en un aumento de 2. En caso de que los 3 numeros sean iguales, solo habra 3 datos como entrada.",
        "salida": "Mostrar X (el numero mayor de los 3 números) seguido del mismo valor pero aumentando +2 hasta N veces. En caso de que los 3 números sean iguales, mostrar X seguido del mismo valor aumentando +2 hasta 7 veces.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  long long a, b, c, d, e, f, g, h;\n cin>>a>>b>>c;\n if(a==b && a==c){\n     cout<<a<<\"\\n\"<<a+2<<\"\\n\"<<a+4<<\"\\n\"<<a+6<<\"\\n\"<<a+8<<\"\\n\"<<a+10<<\"\\n\"<<a+12<<\"\\n\"<<a+14;return 0;\n    }\n cin>>d;\n   a=max(max(a,b),c);\n    cout<<a<<\"\\n\";\n for(auto i=1; i<=d; ++i){\n      cout<<a+2*i<<\"\\n\";\n }\n\n   return 0;\n}\n"
    },
    {
        "titulo": "9464. B07 Mientras tanto",
        "url": "https://omegaup.com/arena/problem/B07-Mientras-tanto/",
        "descripcion": "Komugi es la mejor jugadora de Gungi del mundo. Pero con el avance de un nuevo contrincante Meruem parece ser que no podra tener el titulo de campeona para siempre. Pero como campeona de gungi que es, ella sabe que cosas como derrota no es una opcion, todo el tiempo es victoria o nada. Sin embargo, la derrota nos llega a todos, de una forma u otra, pero no hay que ponerse tristes por la derrota, siempre podemos ver para atras y ver cuantos puntos ganamos hasta este momento. Ayuda a Komugi a saber cuantos puntos obtuvo hasta su momento de la derrota, aunque no sabes en cuantos juegos participo sabes cuanto puntos obtuvo, que siempre representan una cantidad positiva excepto en el que pierde que se representa con un 0, despues del juego que perdio con 0 puntos no hay mas juegos.",
        "entrada": "Varios numeros positivos N menores a 100000 y un numero 0 que representa el final",
        "salida": "La suma total de los puntos conseguidos por Komugi.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  long long a=1, b=0, c, d, e, f, g, h;\n while(a){\n     cin>>a;\n       b+=a;\n }\n cout<<b;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "12110. Clasificando mascotas",
        "url": "https://omegaup.com/arena/problem/CR-2020-Clasificando-mascotas/",
        "descripcion": "Andrea tiene muchas mascotas y le encanta complicarle la vida a sus amigos. Decidió que cuando le pregunten algo sobre sus mascotas les dirá lo siguiente: Si el nombre de la mascota tiene 5 letras o menos, entonces es un perro. Si tiene 6 o más letras, es un gato. Si el nombre de la mascota tiene alguna 'a' o alguna 'y', entonces su mascota es hembra. En caso contrario, es macho. Ayuda a los amigos de Andrea a que descubran que tipo de animal es cada una de sus mascotas.",
        "entrada": "En la primera línea un entero N indicando el número de mascotas que tiene Andrea. Después vendrán N líneas. Cada línea representa cada uno de los nombres de las mascotas de Andrea. NOTA: Se te asegura que todos los nombres contendrán únicamente letras minúsculas.",
        "salida": "Deberás imprimir 4 líneas en el siguiente orden y con el siguiente formato (sin comillas): \"Tiene W perros macho\", \"Tiene X perros hembra\", \"Tiene Y gatos macho\", \"Tiene Z gatos hembra\". Donde W es el número de perros macho que tiene Andrea, X el número de perros hembra, Y el número de gatos macho y Z el número de gatos hembra.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Vectores",
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "int",
            "vector<string>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  long long a, b, c=0, d=0, e=0, f=0, g, h;\n string z;\n cin>>a;\n   while(a--){\n       cin>>z;\n       b=0;\n      for(auto i=0; i<z.size(); ++i){\n            if(z[i]=='a' || z[i]=='y'){\n               b=1;break;\n            }\n     }\n     if(b && z.size()<6){\n          c++;\n      }\n     else if(!b && z.size()<6){\n            d++;\n      }\n     else if(b && z.size()>5){\n         e++;\n      }\n     else{\n         f++;\n      }\n }\n cout<<\"Tiene \"<<d<<\" perros macho\\nTiene \"<<c<<\" perros hembra\\nTiene \"<<f<<\" gatos macho\\nTiene \"<<e<<\" gatos hembra\";\n\n    return 0;\n}\n"
    },
    {
        "titulo": "8457. Dados apilados",
        "url": "https://omegaup.com/arena/problem/Dados-apilados/",
        "descripcion": "Un día mientras Juan jugaba con sus amigos, notó que al apilar un número n de dados sobre una mesa, la suma que resulta de todos los valores en las caras visibles se encuentra acotada entre un valor inferior y uno superior.",
        "entrada": "Un entero n que representa el número de dados apilados. Puedes suponer que 1<=n<=1000000.",
        "salida": "Dos enteros separados por un espacio que representan el valor inferior y superior de la suma de todas las caras visibles de los dados.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  int a;\n    cin>>a;\n   cout<<a*14+1<<\" \"<<a*14+6;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "11750. Comprobación de triángulos",
        "url": "https://omegaup.com/arena/problem/Comprobacion-de-triangulos/",
        "descripcion": "Desarrolle un programa en lenguaje C/C++ que dadas las longitudes de 3 lados a, b y c, determine si pueden formar un triángulo o no. Sugerencia: Puede utilizar la desigualdad del triángulo para verificar si dados 3 lados es posible formar un triángulo.",
        "entrada": "El programa deberá recibir por la entrada estándar los valores positivos de longitudes de 3 segmentos a, B y C.",
        "salida": "El programa deberá imprimir SI, cuando sea posible formar un triángulo con los valores introducidos. Deberá imprimir NO en otro caso.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  long long a, b, c, d, e, f, g, h;\n cin>>a>>b>>c;\n if(c>b){\n      swap(b,c);\n    }\n if(b>a){\n      swap(a,b);\n    }\n cout<<((a-b-c<0)?\"SI\":\"NO\");\n\n    return 0;\n}\n"
    },
    {
        "titulo": "11733. Mayores de Edad",
        "url": "https://omegaup.com/arena/problem/MayEdadANH/",
        "descripcion": "Resulta que mi tío invirtió en un antro, ahí por la calle Primera, pero al que contrato de cadenero no es muy bueno para sacar edades. Entonces cuando pide el ID a los clientes, ve el año de edad y el tipo no sabe si son o no mayores de edad. Así que mi tío pidió si podíamos crear un programa para ayudar al cadenero a saber si los que entran son mayores o menores de edad introduciendo su año de nacimiento y el año actual. Con que este año cumpla 18 con eso lo dejarán entrar.",
        "entrada": "Dos números enteros separados por un espacio, el primero representa el año de nacimiento y el segundo el año actual.",
        "salida": "La frase \"Mayor de edad\" si tendrá 18 o más al finalizar el presente año o la frase \"Menor de edad\" si no tendrá 18.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  long long a, b, c, d, e, f, g, h;\n cin>>a>>b;\n    cout<<((b-a>17)?\"Mayor de edad\":\"Menor de edad\");\n\n   return 0;\n}\n"
    },
    {
        "titulo": "10704. Hipotenusa",
        "url": "https://omegaup.com/arena/problem/Hipotenusa/",
        "descripcion": "Escriba un programa que lea de la entrada estándar los dos catetos de un triángulo rectángulo y escriba en la salida estándar su hipotenusa.",
        "entrada": "Dos números reales los cuales serán el cateto 1 y el cateto 2.",
        "salida": "El resultado de la hipotenusa mostrando dos decimales.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Cálculo matemático"
        ],
        "estructuras": [
            "double",
            "sqrt()",
            "fixed",
            "setprecision()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    double cateto1, cateto2, hipotenusa;\n    cin >> cateto1 >> cateto2;\n    hipotenusa = sqrt(cateto1 * cateto1 + cateto2 * cateto2);\n    cout << fixed << setprecision(2) << hipotenusa << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "10462. El Mandado",
        "url": "https://omegaup.com/arena/problem/El-Mandado-/",
        "descripcion": "Bajas de tu cuarto para comer, y justo cuando te sientas, te manda tu mamá a la tienda por refresco, papas amarillas, servilletas y leche. Llegas a la tienda y saludas a Don Stevan, la persona que atiende la tienda y te dice que por la noche lo abducieron los aliens y ha olvidado como hacer operaciones básicas, así que tendrás que hacerlas por ti mismo. ¡Recuerda que robar es malo! así que asegúrate de hacer las cuentas correctamente.",
        "entrada": "Dos enteros correspondientes a la cantidad y el precio (Tanto el precio y la cantidad son números enteros, y son menores a 100.) para cada uno de los productos. Estos siempre serán refresco, papas amarillas, servilletas y leche.",
        "salida": "El total que gastaste en la tienda.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int total = 0;\n    for (int i = 0; i < 4; ++i) {\n        int cantidad, precio;\n        cin >> cantidad >> precio;\n        total += cantidad * precio; \n    }\n    cout << total << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "10463. Suma de cuadrados :D",
        "url": "https://omegaup.com/arena/problem/Suma-de-cuadrados-D/",
        "descripcion": "Calcula la suma de los cuadrados de cada número hasta X.",
        "entrada": "Un único entero X (X<=10).",
        "salida": "La suma total de todos los cuadrados hasta X.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int X;\n    cin >> X;\n    int suma = 0;\n    for(auto i = 1; i <= X; ++i){\n        suma += i*i;\n    }\n    cout << suma << \"\\n\";\n\n    return 0;\n}\n"
    },
    {
        "titulo": "10458. PromedioAlumno",
        "url": "https://omegaup.com/arena/problem/PromedioAlumno/",
        "descripcion": "Ayuda al maestro Willy a calcular el promedio de uno de sus alumnos.",
        "entrada": "Un entero n (0<=n<=100), la cantidad de calificaciones del alumno seguido de n numeros enteros Y (0<=Y<=100).",
        "salida": "El promedio de las calificaciones del alumno. El resultado no es necesariamente un entero. Si el resultado es entero imprime solamente el valor entero como se muestra en el ejemplo, si es decimal, redondea a una cifra.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "int",
            "double",
            "floor()",
            "fixed",
            "setprecision()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int n, calificacion;\n    double suma = 0; \n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        cin >> calificacion;\n        suma += calificacion;\n    }\n    double promedio = suma / n;\n    if (promedio == floor(promedio)) {\n        cout << (int)promedio << endl;\n    } else {\n        cout << fixed << setprecision(1) << promedio << endl;\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "10329. Palomitas grandes",
        "url": "https://omegaup.com/arena/problem/Palomitas-grandes/",
        "descripcion": "Un par de amigos van al cine cada 2 meses, y cada 4 meses piden palomitas grandes. Tu trabajo es determinar que van a pedir este par de amigos en determinado mes.",
        "entrada": "Un entero X (1<=X<=12) indicando el primer mes del año en el cual compraron palomitas grandes seguido de un entero Y (1<=Y<=12) el cual es el mes a determinar la compra.",
        "salida": "\"Palomitas grandes\" si los amigos compran palomitas grandes. \"Palomitas medianas\" Si no compran grandes y van al cine y \"Nada\" si los amigos no van al cine.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int X, Y;\n    cin >> X >> Y;\n    // Ajustamos los meses para que sean congruentes modulo 12\n    if (Y < X) {\n        Y += 12; \n    }\n    if ((Y - X) % 4 == 0) {\n        // Verificamos si compran palomitas grandes\n        cout << \"Palomitas grandes\\n\";\n    }\n    else if ((Y - X) % 2 == 0) {\n        // Verificamos si van al cine\n        cout << \"Palomitas medianas\\n\";\n    }\n    else {\n        // No van al cine\n        cout << \"Nada\\n\";\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "5835. Fahrenheit a Centigrados (agua fría y caliente)",
        "url": "https://omegaup.com/arena/problem/Fahrenheit-a-Centigrados/",
        "descripcion": "Escriba un programa que lea una temperatura F en grados Fahrenheit y que escriba la temperatura equivalente C en grados centígrados. Recuerde que 9C=5(F-32). Además, su programa debe decir si a esa temperatura el agua estaría fría (C<=36) o caliente (C>36). Use únicamente enteros para realizar los cálculos.",
        "entrada": "Consiste de un número entero F que tendrá un valor entre -450 y 1000.",
        "salida": "Consiste de dos números enteros C y E en ese orden y separados por un espacio, donde E=0 si el agua está fría y E=1 si está caliente.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int F, C, E;\n    cin >> F;\n    C = 5 * (F - 32) / 9; // Calculamos C directamente\n    E = (C > 36); // Usamos una comparacion booleana para determinar E\n    cout << C << \" \" << E << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "9417. Es hoy",
        "url": "https://omegaup.com/arena/problem/Es-hoy/",
        "descripcion": "¡Ha llegado el día! Por fin, ahora puedes HACKEAR LA NASA. Pero antes de ello tienes que solucionar este problema. MUAHAHAHA. Un profesor, ha comprado muchas cajas llenas de pelotas. A la hora de recibirlas, se dió cuenta que le enviaron dos tipos de cajas A y B, de las cuales hay N cajas de tipo A y M de tipo B. En cada caja hay una cantidad diferente de pelotas, así que te pide a ti (Supremo Dios de la Programación Tebana) a que le ayudes a saber cuantas pelotas hay en total de cada tipo de caja A y B. Toma en cuenta que si fallas, te va a reprobar y tampoco tendras permiso de hacker la nasa.",
        "entrada": "La primera y segunda líneas de entrada contendrán los numeros N y M (1<=N,M<=100) respectivamente. La siguientes N líneas contendrán la cantidad de pelotas en las cajas de tipo A y las proximas M lineas las de B.",
        "salida": "La cantidad de pelotas que hay de tipo A y las de tipo B.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout.tie(0);\n  int N, M;\n  cin >> N >> M;\n  int totalA = 0, totalB = 0;\n  for (int i = 0; i < N; ++i) {\n    int pelotas;\n    cin >> pelotas;\n    totalA += pelotas;\n  }\n  for (int i = 0; i < M; ++i) {\n    int pelotas;\n    cin >> pelotas;\n    totalB += pelotas;\n  }\n  cout << totalA << \" \" << totalB << \"\\n\";\n\n  return 0;\n}\n"
    },
    {
        "titulo": "9386. Samuel y sus lapiceras",
        "url": "https://omegaup.com/arena/problem/Samuel-y-sus-lapiceras/",
        "descripcion": "Un estudiante especifico esta aburrido en clases, y cuando el se aburre decide realizar algún calculo de cosas que parecen ser absurdas, en esta ocasión el ha decidido calcular el promedio de lapiceras negras que hay por alumno en su salón, por lo que, aprovechando que el profesor no se encontraba, empezó a preguntarle a cada uno de sus compañeros por la cantidad de lapiceras negras que tenia, y posteriormente calculo el promedio; una vez que lo hizo, decidió hacer lo mismo en toda la escuela, por lo que le pidió a sus amigos en cada salón que le mandaran la información de las lapiceras negras; ahora que tiene mucha información, necesita un programa que lo ayude a calcular el promedio con la información recibida, ayudalo a calcular el promedio de lapiceras.",
        "entrada": "Recibirás un numero n, que indica el numero de alumnos en el salón, después recibirás n números, que sera la cantidad de lapiceras por cada alumno en el salón.",
        "salida": "Deberás mostrar el promedio de lapiceras que hay en el salón analizado.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "int",
            "double"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int n, lapiceras, totalLapiceras = 0;\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        cin >> lapiceras;\n        totalLapiceras += lapiceras;\n    }\n    double promedio = (double)totalLapiceras / n;\n    cout << promedio << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "10233. Hora de entrega",
        "url": "https://omegaup.com/arena/problem/Hora-de-entrega/",
        "descripcion": "Un estudiante andaba en su clase de informática muy aburrido como siempre, ya que era un gran programador. Un día el maestro decide dejar la tarea en la página de colegio. Dentro de la página los alumnos suben su tarea desde una computadora a la hora que puedan; sin embargo, existe una hora límite. El estudiante al entrar a la página para ver las tareas se percata de un fallo. Al momento de mostrar las horas de entrega, hay ciertos números que no se logran distinguir. Como buen alumno, el estudiante reporto el fallo a control escolar y le respondieron \"puedes decirnos la hora que quieras y esa pondremos como el límite. Siempre y cuando se conserven los dígitos que si son visibles\". Como alumno flojo, el estudiante decide decir la hora más tarde posible. La hora está marcada desde 00:00 hasta las 23:59. Por ejemplo, si en la plataforma aparece ?1:2?, quiere decir que el primer digito de la hora y el ultimo digito de los minutos no son visibles. Por tanto, el estudiante dirá la hora 21:29, ya que es la más tarde que puede poner, de manera que ninguno de los dígitos que sí se veían cambien. Dada una hora dada en el formato hh:mm (horas:minutos). En donde algunos dígitos no son visibles (vamos a representarlos como -1), decir cuál es la hora más tarde que se puede formar, reemplazando esos dígitos que no son visibles (representados con -1).",
        "entrada": "4 números enteros que representan la hora, los primeros dos corresponden a la hora y los segundos corresponden a los minutos. Se pondrá un -1 en caso de que el digito no sea visible. Los 4 números son solo un digito y siempre se puede formar una hora valida, es decir, no se darán entradas como 5 -1 9 -1.",
        "salida": "4 números que representan la mayor hora válida que se puede formar.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int a, b, c, d, e, f, g;\n    cin>>a>>b>>c>>d;\n    if(a==-1 && b==-1){\n        a=2;\n        b=3;\n    }\n    if(a==-1){\n        if(b<4){\n            a=2;\n        }\n        else{\n            a=1;\n        }\n    }\n    if(b==-1){\n        if(a==2){\n            b=3;\n        }\n        else{\n            b=9;\n        }\n    }\n    if(c==-1){\n        c=5;\n    }\n    if(d==-1){\n        d=9;\n    }\n    cout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<d;\n    \n    return 0;\n}\n"
    },
    {
        "titulo": "6273. Un algoritmo de Gauss poco conocido",
        "url": "https://omegaup.com/arena/problem/Algoritmo-de-Gauss/",
        "descripcion": "La Pascua cae en el primer domingo que sigue a la primera luna llena que ocurra el 21 de marzo o después. El siguiente algoritmo, propuesto por Gauss, calculará, dado un año A>=1583, un número que representa la fecha de la Pascua de la siguiente forma: si J<=31, entonces la Pascua será el J de marzo; en otro caso la Pascua será el J-31 de abril. Pasos: #1 Haz B=A/100+1. #2 Haz C=3*B/4-12. #3 Haz E=(A mod 19)+1. #4 Haz F=(8*B+5)/25-(5+C). #5 Haz G=5*A/4-(C+10). #6 Haz H=(11*E+20+F) mod 30. #7 Si H no vale 25 entonces ir al paso 9. #8 Si E es mayor que 11 entonces suma 1 a H. #9 Si H vale 24 entonces suma 1 a H. #10 Haz I=44-H. #11 Si I es menor que 21 entonces suma 30 a I. #12 Haz J=I+7-[(G+I) mod 7]. En este algoritmo todas las divisiones son enteras y mod es el residuo de la división. Dado un año A, deberás calcular el día D y el mes M en el que cae la Pascua en el año A.",
        "entrada": "Consiste de un número entero A que tendrá un valor entre 1583 y 9999.",
        "salida": "Consiste de dos números enteros D y M, separados por un espacio (M=3 significa marzo y M=4 significa abril).",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int A, B, C, E, F, G, H, I, J, D, M;\n    cin >> A;\n    B = A / 100 + 1;\n    C = 3 * B / 4 - 12;\n    E = (A % 19) + 1;\n    F = (8 * B + 5) / 25 - (5 + C);\n    G = 5 * A / 4 - (C + 10);\n    H = (11 * E + 20 + F) % 30;\n    if (H != 25){\n        goto paso9;\n    }\n    if (E > 11){\n        H++;\n    }\n    paso9:\n    if (H == 24){\n        H++;\n    }\n    I = 44 - H;\n    if (I < 21){\n        I += 30;\n    }\n    J = I + 7 - ((G + I) % 7);\n    if (J <= 31){\n        D = J;\n        M = 3;\n    }\n    else{\n        D = J - 31;\n        M = 4;\n    }\n    cout << D << \" \" << M << \"\\n\";\n\n    return 0;\n}\n"
    },
    {
        "titulo": "8501. FuncionX",
        "url": "https://omegaup.com/arena/problem/FuncionX/",
        "descripcion": "Para un entero positivo n definamos una función f: f(n)=-1+2-3+4-5+..+((-1)^n)*n. Su tarea es calcular f(n) para un entero n dado.",
        "entrada": "La línea única contiene el entero positivo n (1<=n<=10^15).",
        "salida": "Imprimir f(n) en una sola línea.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n// Funcion para calcular f(n)\nlong long calcularFn(long long n) {\n    if (n % 2 == 0) {\n        return n / 2;\n    } else {\n        return -((n + 1) / 2);\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long n;\n    cin >> n;\n    cout << calcularFn(n) << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "5162. Respuesta al Universo",
        "url": "https://omegaup.com/arena/problem/Respuesta-al-Universo/",
        "descripcion": "Uno de tus amigos, antes de dormir tomó una lata de una bebida energetizante y como podrás imaginar no puede dormirse otra vez. Como tu tienes una salida importante con tus amigos mañana, decidiste decirle a tu perro que buscara la respuesta al universo. Tu amigo se puso a pensar y dedujo que para encontrar la respuesta tienes que tener N números, los multiplicas entre sí, luego los divides entre la multiplicación del tercer número por dos y por el último número de la lista, para finalmente sumarle el promedio de todos los números en posiciones impares. Y el resultado de todo esto sería alguna respuesta del universo. Pero tu al haber leído mucho, ya sabes la respuesta al universo... Aunque quizás no sepas la verdadera pregunta. Tu amigo no es programador por lo que el cuenta iniciando en 1 y no en 0. Y la respuesta al universo es única.",
        "entrada": "La primer línea de entrada contendrá el número N (3<=N<=1000) de elementos. Las siguientes N líneas contendrán las diferentes M (1<=M<=1000) cantidades a procesar.",
        "salida": "Únicamente tienes que regresar un entero con la respuesta.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores"
        ],
        "estructuras": [
            "long long",
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int N;\n    cin >> N;\n    vector<int> numeros(N);\n    long long multiplicacion = 1; // Usamos long long para evitar overflow\n    int sumaImpares = 0;\n    for (int i = 0; i < N; ++i) {\n        cin >> numeros[i];\n        multiplicacion *= numeros[i];\n        if (i % 2 == 0) {\n            sumaImpares += numeros[i];\n        }\n    }\n    // Aplicamos la formula, notando que el indice del ultimo elemento es N-1\n    long long resultado = multiplicacion / (numeros[2] * 2 * numeros[N - 1]);\n    resultado += (sumaImpares * 1.0) / ((N + 1) / 2); // Calculo del promedio\n    cout << resultado << endl; \n\n    return 0;\n}\n"
    },
    {
        "titulo": "9347. Equipo de Basquetbol",
        "url": "https://omegaup.com/arena/problem/Equipo-de-Basquetbol/",
        "descripcion": "El profesor de deportes esta reclutando a los y las integrantes de de la selección de basquetbol de la escuela, pero ha puesto una restricción para poder formar parte del equipo, el cual es que el participante debe de medir al menos 1.60 m. (160 cm.). Toda persona que quiera formar parte del equipo debe de ir a la enfermería para tomar su altura, donde se le notificara si es apto o no para el equipo. Tu tarea sera ayudar a enfermería para indicar si la persona es apta o no para estar en el equipo.",
        "entrada": "Como entrada recibirás una altura h, que representa la altura en centímetros del estudiante que quiere ingresar al equipo.",
        "salida": "Como salida deberas mostrar el mensaje de \"Bienvenido al equipo\" (sin las comillas), si la h es mayor o igual a 160 cm; de lo contrario usted debera mostrar el mensaje \"Lo siento, te faltan x cm para poder entrar al equipo\", donde x es la diferencia entre la altura del estudiante y la requerida para entrar al equipo.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int h;\n    cin >> h;\n    if (h >= 160){\n        cout << \"Bienvenido al equipo\\n\";\n    } else {\n        cout << \"Lo siento, te faltan \" << 160 - h << \" cm para poder entrar al equipo\\n\";\n    }\n\n   return 0;\n}\n"
    },
    {
        "titulo": "7538. Números pares entre dos números",
        "url": "https://omegaup.com/arena/problem/Numeros-pares-entre-dos-numeros/",
        "descripcion": "Realiza un programa que solicite al usuario dos números a y b; y que imprima los números pares que existen entre dichos números.",
        "entrada": "Dos números enteros a y b.",
        "salida": "Números pares enteros entre dichos números.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n// Funci? para imprimir los n?meros pares entre a y b (excluyendo a y b)\nvoid imprimirPares(int a, int b) {\n    // Ajustar el valor inicial si 'a' es par\n    if (a % 2 == 0) {\n        a += 2;\n    } else {\n        a += 1; \n    }\n    // Imprimir los n?meros pares en el rango\n    for (int i = a; i < b; i += 2) {\n        cout << i << endl;\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int a, b;\n    cin >> a >> b;\n    imprimirPares(a, b);\n\n    return 0;\n}\n"
    },
    {
        "titulo": "2990. Imprime Pares",
        "url": "https://omegaup.com/arena/problem/Imprime-Pares/",
        "descripcion": "Dado un número n, escribe un programa que imprima todos los números pares en el intervalo [1,n].",
        "entrada": "Un número n (1<=n<=100).",
        "salida": "Imprime los números pares en el intervalo [1,n]. Si no hay ningún número par en el intervalo [1,n] imprime el mensaje \"Nada que imprimir\".",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "bool",
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int n;\n    cin >> n;\n    bool encontrado = false;\n    for (int i = 2; i <= n; i += 2) {\n        cout << i << \" \";\n        encontrado = true;\n    }\n    if (!encontrado) {\n        cout << \"Nada que imprimir\";\n    }\n    cout << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "7404. ¡Amamos los dulces!",
        "url": "https://omegaup.com/arena/problem/Dulces-2/",
        "descripcion": "Andrés, Abel y Alan AMAN los dulces, por eso decidieron salir a pedir calaverita. Los tres se dejaron llevar por la euforia del momento y quedaron en juntar todo lo obtenido para, posteriormente, dividir las ganancias en partes iguales. Después de meditar un rato, vieron que no había sido un buen trato, pero no se podían ya echar para atrás. Lo único que les quedó fue, al menos, decir que no estaban dispuestos a recibir un \"cachito\" de dulce, lo que deberían obtener eran dulces enteros, y todos la misma cantidad. Después de una caminata kilométrica llena de risas, sustos y MUCHOS dulces ha llegado el punto de la repartición de los preciados bienes. Tu papel en esta historia es leer el número total de dulces recolectados y decir si existe un reparto igualitario de dulces enteros.",
        "entrada": "Un número entero N que denota el total de dulces recolectados por los tres amigos.",
        "salida": "La frase \"Felicidad pura\" si se pueden repartir los dulces entre los tres amigos en partes iguales y que a cada uno solo le toquen dulces enteros, la frase \"Pelea segura\" de lo contrario.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int N;\n    cin >> N;\n    if (N % 3 == 0) {\n        cout << \"Felicidad pura\" << endl;\n    } else {\n        cout << \"Pelea segura\" << endl;\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "8622. Diferencia en Minutos",
        "url": "https://omegaup.com/arena/problem/Diferencia-en-Minutos/",
        "descripcion": "Se leen cuatro valores enteros H1, M1, H2 y M2, que indican: H1:M1 la hora de comienzo y H2:M2 la hora de final de un intervalo de tiempo del mismo día (la hora:minuto de comienzo es menor o igual que la hora:minuto de final). Hay que informar la cantidad de minutos de diferencia entre ambas.",
        "entrada": "La entrada viene en dos líneas: en la primera vienen H1 y M1, en la segunda vienen H2 y M2.",
        "salida": "La salida consiste en sólo una línea, conteniendo un valor entero que es diferencia en minutos entre las dos horas ingresadas.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    // Leer las horas de inicio y fin\n    int H1, M1, H2, M2;\n    cin >> H1 >> M1 >> H2 >> M2;\n    // Convertir las horas a minutos\n    int minutosInicio = H1 * 60 + M1;\n    int minutosFin = H2 * 60 + M2;\n    // Calcular la diferencia en minutos\n    int diferencia = minutosFin - minutosInicio;\n    // Imprimir la diferencia\n    cout << diferencia << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "4071. CANICAS BÁSICO",
        "url": "https://omegaup.com/arena/problem/CANICAS-BASICO-ASINUS/",
        "descripcion": "Pepechuy y Junior son dos niños que todos los días juegan a las canicas ya que están obsesionados con ser el mejor de los dos. Sin embargo, siempre que jugan tienen el mismo problema, ya que están cursando a penas el primer año de primaria, por lo cual, saben perfectamente cuantos puntos obtiene cada uno al tirar, pero al terminar de jugar siempre olvidan la cantidad de puntos y no los pueden sumar para saber quien es el mejor, así que lo deciden lo mejor que su memoria les permite. Ayuda a Pepechuy y a Junior a llevar el control de la puntuación que obtienen en cada turno, considerando que el juego está conformado por 5 turnos, y cada uno de ellos tira después del turno del otro. Muéstrales al final del juego; quién obtuvo la mayor puntuación, para así llamarse el rey de las canicas de la calle San Toribio. Los puntos a obtener en cada turno, pueden ir desde 0, si no golpearon o metieron ninguna canica, a 1, 2 ó 3, dependiendo de qué movieron o metieron a la choya.",
        "entrada": "El puntaje que obtuvo Pepechuy en el primer turno, seguido del puntaje que obtuvo Junior también en el primer turno, posteriormente los siguientes puntajes en el mismo orden hasta completar los 5 turnos de cada uno.",
        "salida": "\"1\" si ganó Pepechuy, o bien \"2\" si ganó Junior, en caso de empate deberá indicar \"EMPATE\".",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int puntajePepechuy = 0;\n    int puntajeJunior = 0;\n    for (int turno = 1; turno <= 5; turno++) {\n        int puntosPepechuy, puntosJunior;\n        cin >> puntosPepechuy >> puntosJunior;\n        puntajePepechuy += puntosPepechuy;\n        puntajeJunior += puntosJunior;\n    }\n    if (puntajePepechuy > puntajeJunior) {\n        cout << \"1\\n\";\n    } else if (puntajeJunior > puntajePepechuy) {\n        cout << \"2\\n\";\n    } else {\n        cout << \"EMPATE\\n\";\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "2504. El problema de los Múltiplos",
        "url": "https://omegaup.com/arena/problem/El-problema-de-los-Multiplos/",
        "descripcion": "Si hacemos una lista de todos los números naturales antes del número 10 que son múltiplos de 3 ó 5, obtenemos el 3, 5, 6 y 9. La suma de esos múltiplos es 23. Encuentre la suma de todos los múltiplos de 3 o 5 que se localizan antes de cierto numero natural dado.",
        "entrada": "En una línea un único número natural N (1<=N<=90000).",
        "salida": "Una solo línea en la cual se deberá mostrar el resultado obtenido.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int N;\n    cin >> N;\n    long long suma = 0;\n    for (int i = 1; i < N; ++i){\n        if(i % 3 == 0 || i % 5 == 0){\n            suma += i;\n        }\n    }\n    cout << suma << \"\\n\";\n\n    return 0;\n}\n"
    },
    {
        "titulo": "3770. Serie-Navideña",
        "url": "https://omegaup.com/arena/problem/Serie-Navidena/",
        "descripcion": "¡YA VIENE LA NAVIDAD! Y Karel como todo buen amante de la navidad, ha decidido poner de una vez por todas su árbol navideño. Karel estaba muy emocionado poniendo todos los adornos en su árbol, cuando se dió cuenta que la serie de luces que había comprado el año pasado tenía focos fundidos (típico). Como Karel gastó mucho dinero en el Buen Fin comprando una computadora nueva, ha decidido que solamente comprará los foquitos necesarios para cambioar los que se han fundido. Ayuda a Karel a ver cuántos focos de la serie se han fundido y calcular cuánto dinero tendrá que gastar para comprarlos.",
        "entrada": "En la primera línea, dos números N (1<=N<=1000000) y M separados por un espacio, donde N representa el número de foquitos que tiene la serie y M el precio que tiene cada foquito. En la segunda línea N números serparados por un espacio. Si el número es 1, significa que es un foquito que funciona perfectamente, si es un 0, entonces ese foquito está fundido y debe ser reemplazado.",
        "salida": "Dos números, uno en cada línea. El primero indica el total de foquitos fundidos en la serie, y el segundo el total de dinero que Karel tendrá que gastar.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "int",
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int N, M, focosFundidos = 0;\n    long long costoTotal = 0; \n    cin >> N >> M;\n    for (int i = 0; i < N; ++i) {\n        int estadoFoco;\n        cin >> estadoFoco;\n        if (estadoFoco == 0) {\n            focosFundidos++;\n            costoTotal += M; \n        }\n    }\n    cout << focosFundidos << \"\\n\" << costoTotal << \"\\n\";\n\n    return 0;\n}\n"
    },
    {
        "titulo": "8167. Contando los medicamentos",
        "url": "https://omegaup.com/arena/problem/Contando-los-medicamentos/",
        "descripcion": "Una agencia de seguros tiene el mayor número de polizas en México. Actualmente, quiere expandir su mercado hacia la compra y venta de medicamentos y para iniciar su prueba piloto, usará a sus clientes para ver si es viable o no. La agencia distribuirá los medicamentos entre 4 grupos: los niños (0-10 años), jóvenes (11-17), adultos (18-60), ancianos (61 en adelante). Al primer grupo (niños) le darán 2 medicamentos, al segundo (jóvenes) 5, al tercero (adultos) 8 y al cuarto (ancianos) 10. Ayuda a la agencia a obtener el número de medicamentos necesarios para entregárselos a la persona que llegue.",
        "entrada": "Un número entero, E, que representa la edad de la persona que llegó por sus medicamentos.",
        "salida": "Un número entero M que representa el número de medicamentos que le tocan a la persona que llegó.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int E, M;\n    cin >> E;\n    if (E <= 10){\n        M = 2;\n    } else if (E <= 17){\n        M = 5;\n    } else if (E <= 60){\n        M = 8;\n    } else {\n        M = 10;\n    }\n    cout << M << \"\\n\";\n\n    return 0;\n}\n"
    },
    {
        "titulo": "836. Sumas y Restas",
        "url": "https://omegaup.com/arena/problem/Sumas-y-Restas/",
        "descripcion": "Se tienen 2 números diferentes A y B. Se desea saber la cantidad de números que existe entre A y B en una determinada secuencia. La secuencia comienza con el valor A, posteriormente se le suma 1, al valor resultante se le resta 2, al resultante se le suman 3, y así sucesivamente hasta llegar al número B. Se asegura que partiendo desde A y siguiendo el procedimiento correcto, la secuencia siempre te llevara al número B.",
        "entrada": "2 números enteros separados por un salto de línea, la primera línea contendrá el valor de A y la segunda línea contendrá el valor de B.",
        "salida": "Un solo número, representando la cantidad de números entre los valores de A y B que hay en la secuencia (teniendo en cuenta que A<=B o A>=B).",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c=0;\n    cin>>a>>b;\n    //Optimizacion: En lugar de generar la secuencia completa, se aplica una formula matematica\n    if(a<b){\n        c=((b-a)-1)*2;\n    }\n    else if(a>b){\n        c=((a-b)*2)-1;\n    }\n    cout<<c;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "5124. Doña Atanila",
        "url": "https://omegaup.com/arena/problem/Dona-Atanila-ASINUS/",
        "descripcion": "La señora Atanila se ha dedicado a vender tortas fuera del hospital de su comunidad desde hace algún tiempo, cerca de diez años, y al estar vendiendo en este lugar se ha vuelto una persona muy sensible ya que llega gente que usualmente tiene a familiares internados, por ello tiene un método para cobrar bastante especial. Para ello, la señora cuando le piden una torta hace una serie de preguntas que le permiten determinar el costo de ésta. El cobro de sus tortas debido a su éxito ha llegado a ser un poco agobiante por tal motivo ya no puede hacerlo mentalmente, para ello requiere tu ayuda para que calcule el costo con base en lo siguiente. Tipo de torta (si se introduce un número diferente de 1, 2, 3 ó 4, en el tipo de torta de imprime: ERROR.): (1)Adobada $15.00, (2)Cubana $25.00, (3)Jamón $12.00, (4)Lomo $15.00; Sin embargo los costos varían según los siguientes argumentos. Con base en los días internado: (a)Si tienen un familiar internado de 1 a 5 días -$3.00. (b)Si tienen un familiar internado de 6 a 30 días -$5.00. (c)Si tienen un paciente internado de 30 días o más -$8.00; Con base en la enfermedad: (1)Si el paciente tiene cáncer o diabetes -$2.00. (2)Si el paciente tiene alguna otra enfermedad Sin descuento; Con base en los ingredientes. Para ello, el cliente debe especificar si quiere una porción de algún ingrediente de más: (a)Si quiere aguacate +$2.00. (q)Si quiere queso +$2.50. (s)Sin ingredientes extra.",
        "entrada": "Se deberá introducir el tipo de torta que el cliente desea >=1, <=4, seguido del tipo de días que tiene su familiar internado (a, b, o c), después el tipo de enfermedad (1 ó 2) y finalmente si el cliente quiere algún ingrediente extra o no (a, q o s).",
        "salida": "El costo total a pagar por la torta.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "char",
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int tipoTorta;\n    char diasInternado, enfermedad, ingredienteExtra;\n    int costo = 0;\n    cin >> tipoTorta >> diasInternado >> enfermedad >> ingredienteExtra;\n    if (tipoTorta == 1) {\n        costo = 15.00;\n    } else if (tipoTorta == 2) {\n        costo = 25.00;\n    } else if (tipoTorta == 3) {\n        costo = 12.00;\n    } else if (tipoTorta == 4) {\n        costo = 15.00;\n    } else {\n        cout << \"ERROR.\" << endl;\n        return 0;\n    }\n    if (diasInternado == 'a') {\n        costo -= 3.00;\n    } else if (diasInternado == 'b') {\n        costo -= 5.00;\n    } else if (diasInternado == 'c') {\n        costo -= 8.00;\n    }\n    if (enfermedad == '1') {\n        costo -= 2.00;\n    }\n    if (ingredienteExtra == 'a') {\n        costo += 2.00;\n    } else if (ingredienteExtra == 'q') {\n        costo += 2.50;\n    }\n    cout << << costo << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "6010. Kaijus",
        "url": "https://omegaup.com/arena/problem/Kaijus/",
        "descripcion": "Los kaijus son mounstros que por alguna razón misteriosa salen de una abertura en el océano. La cantidad de Kaijus que aparecen cada año se duplica. El 2018 se espera que salga un Kaiju, en el 2019, saldrán 2 Kaijus, en el 2020, 4 Kaijus, en el 2021, 8 Kaijus, y así sucesivamente. Para defenderse de los Kaijus los humanos han creado sus propios mounstros llamados \"Jaegers\", que son robots piloteados por dos humanos, y que tienen bastantes monerías, como espadas, cohetes, etc. Hay un total de n Jaegers, y las peleas con los Kaijus son uno a uno. Escribe un programa que determine el año en el que los Kaijus superarán a los Jaegers en número. Ese año es de gran importancia, pues puede ser el año en que el ser humano deje de existir :(. Nota: El material con que se hacen los Jaegers se termino después de hacer el n-ésimo Jaeger, así que ya no se pueden hacer más :'(.",
        "entrada": "Un número n (1<=n<=10^9), indicando la cantidad de Jaegers que existen.",
        "salida": "El año en que los Kaijus superarán a los Jaegers en número.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b=1, c=1;\n    cin>>a;\n    while(b<=a){\n        c++;\n        b*=2;\n    }\n    cout<<2017+c;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "2390. Intervalos",
        "url": "https://omegaup.com/arena/problem/Intervalos/",
        "descripcion": "Escribe un programa que lea tres enteros a, b, c y determine si c se encuentra en el intervalo [a,b] a la izquierda o a la derecha del intervalo [a,b].",
        "entrada": "Una línea con los enteros a,b,c separados por un espacio.",
        "salida": "Imprime INTERVALO, IZQUIERDA o DERECHA según sea el caso.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int a, b, c;\n    cin >> a >> b >> c;\n    if (c >= a && c <= b){\n        cout << \"INTERVALO\\n\";\n    } else if (c < a){\n        cout << \"IZQUIERDA\\n\";\n    } else {\n        cout << \"DERECHA\\n\";\n    }\n\n   return 0;\n}\n"
    },
    {
        "titulo": "6202. Finales alternativos",
        "url": "https://omegaup.com/arena/problem/Finales-alternativos/",
        "descripcion": "Recientemente conociste un juego llamado Reversi, el cual consiste en que dos jugadores, cada uno con un color de ficha distinto, deberá ocupar la máxima cantidad de casillas de un tablero de 8*8. Estás decidido a mejorar en este juego, por lo que te has puesto a practicar jugando con tu hermano, sin embargo, después de un par de rondas, tu hermano se ha cansado de contar las fichas para ver quién ha ganado y te ha pedido a ti que las cuentes ahora.",
        "entrada": "64 enteros que representan las 64 casillas del tablero. Cada entero puede ser 0 que indica que la casilla está libre, 1 que indica que la casilla está ocupada por una ficha tuya o 2 que indica que la casilla está ocupada por tu hermano.",
        "salida": "Deberás indicar quién es el ganador del juego. Si tu hermano ganó deberás imprimir PERDI, si tú ganaste deberás imprimir GANE. Si ninguno ha ganado entonces mostrarás EMPATE.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int tablero[64];\n    int miFicha = 0, hermanoFicha = 0;\n    for (int i = 0; i < 64; ++i) {\n        cin >> tablero[i];\n        if (tablero[i] == 1) {\n            miFicha++;\n        } else if (tablero[i] == 2) {\n            hermanoFicha++;\n        }\n    }\n    if (miFicha > hermanoFicha) {\n        cout << \"GANE\\n\";\n    } else if (hermanoFicha > miFicha) {\n        cout << \"PERDI\\n\";\n    } else {\n        cout << \"EMPATE\\n\";\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "5258. Empleados Universitarios",
        "url": "https://omegaup.com/arena/problem/Empleados-Universitarios/",
        "descripcion": "En cierta isla habitada, existen 2 tipos de personas. 1.- Las personas honestas que siempre te dicen la verdad. 2.- Las personas deshonestas que siempre dicen mentiras. En ésta isla existe una universidad, con R empleados. Si uno se aproxima a uno de los empleados ellos siempre te dirán dos cosas. a.- \"Hay menos de N empleados que trabajan más que yo\". b.- \"Al menos M empleados tienen un salario mayor al mio\". Tambien se sabe que ningun empleado trabaja lo mismo que otro y que ninguno gana lo mismo que otro.",
        "entrada": "La entrada consiste en exactamente 1000 casos, cada uno en una linea. Cada linea contiene dos números N y M. (0<=N , M<=10^9) (0<=N+M=E) ",
        "salida": "Para cada linea de entrada, una linea que contenga E. la cantidad de empleados de la universidad",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b;\n    while(cin>>a){\n        cin>>b;\n        cout<<a+b<<\"\\n\";\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "4924. Elevando números al cuadrado",
        "url": "https://omegaup.com/arena/problem/Elevando-al-cuadrado/",
        "descripcion": "Juanito acaba de aprender en su clase acerca de como elevar números al cuadrado y se obsesiono tanto con estos que uso sus habilidades de informática para crear un programa capaz de elevar cualquier numero al cuadrado.El problema es que sus conocimientos de informatica no alcanzan para crear este programa, así que te pidió ayuda para hacer el programa.",
        "entrada": "En la primera linea recibirás n que es la cantidad de números que se elevaran al cuadrado. En la segunda linea recibirás los n números que elevaras al cuadrado separados por un espacio. (0<n<20, 0<=k_1,k_2...,k_n<1000)",
        "salida": "Deberás sacar los n números introducidos, elevados al cuadrado y separados por un espacio",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b;\n    cin>>a;\n    while(a--){\n        cin>>b;\n        cout<<b*b<<\" \";\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "5601. Mi Cumpleaños",
        "url": "https://omegaup.com/arena/problem/Mi-Cumpleanos/",
        "descripcion": "Hoy es tu fiesta de cumpleaños, y quieres atender bien a los invitados, por lo que decides ayudar a el mesero, al revisar que en cada lugar de la mesa este un vaso para las bebidas, te das cuenta que en algunos lugares el mesero dejo correctamente un vaso, que en otros lugares falta el vaso y en algunos lugares de la mesa dejo mas de un vaso.",
        "entrada": "La mesa con N lugares para sentarse, un 0 indica que falta el vaso en ese lugar, un numero entero mayor que cero indica cuantos vasos dejo el mesero en ese lugar. La mesa mas grande es de 100 lugares La mesa mas chica es de 5 lugares El numero maximo de vasos que dejo en un lugar el mesero es de 4",
        "salida": "Un numero negativo indica cuantos vasos faltan en la mesa. El numero cero indica que todos los lugares de la mesa tienen 1 vaso. Un numero positivo que indica si sobran vasos en dicha mesa.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b=0, c=0;\n    while(cin>>a){\n        b++;\n        c+=a;\n    }\n    cout<<c-b;\n\n    return 0;\n}"
    },
    {
        "titulo": "7078. El mini juego de la vida",
        "url": "https://omegaup.com/arena/problem/El-mini-juego-de-la-vida/",
        "descripcion": "En el año de 1970 el matemático John Conway desarrolló el llamado juego de la vida. Este juego consiste en seleccionar cada una de las casillas de un tablero inmenso e inspeccionar el valor contenido en dicha casilla. Una vez obtenido el valor almacenado en una casilla c se inspeccionan los valores almacenados en las ocho casillas más cercanas a esta (ver Figura). Sea N el número total de casillas vecinas con valor uno (en la figura (N=5)) .Las reglas del juego son las siguientes: Si (c=0) y (N!=3) entonces el nuevo valor de c es 0. Si (c=0) y (N=3) entonces el nuevo valor de c es 1. Si (c=1) y (N<2) o (N>3) entonces el nuevo valor de c es 0 . Si (c=1) y (N=2) o (N=3) entonces el nuevo valor de c es 1. Use estas reglas para determinar el nuevo valor de una casilla c.",
        "entrada": "Dos enteros c y N que representan el valor almacenado en una casilla c y el número de casillas vecinas de c con valor 1 respectivamente. Puede asumir que c solo puede tomar el valor 0 o el valor 1, y que (-10<=N<=10).",
        "salida": "Un entero que representa el nuevo valor de c de acuerdo a las reglas del juego de la vida o el mensaje \"ERROR\" si (N>8 o N<0).",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b;\n    cin>>a>>b;\n    if(b>8 || b<0 || a<0 || a>1){\n        cout<<\"ERROR\";return 0;\n    }\n    if(a==0){\n        if(b==3){\n            cout<<1;return 0;\n        }\n        cout<<0;return 0;\n    }\n    if(b<2 || b>3){\n        cout<<0;return 0;\n    }\n    cout<<1;\n    \n    return 0;\n}"
    },
    {
        "titulo": "1789. El Sentido de la Vida, el Universo y Todo lo Demás",
        "url": "https://omegaup.com/arena/problem/El-Sentido-de-la-Vida/",
        "descripcion": "Quieres encontrar el sentido de la vida, el universo y todo lo demás. Para ello, recibirás una lista muy larga de enteros y debes contestar cuántos tuviste que leer antes de encontrar 42.",
        "entrada": "Una lista de enteros, uno por línea.",
        "salida": "Un entero: cuántos enteros tuviste que leer antes de encontrar 42.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c=0;\n    cin>>a;\n    while(a!=42){\n        c++;\n        cin>>a;\n    }\n    cout<<c;\n    \n    return 0;\n}"
    },
    {
        "titulo": "3059. Edificación Virtual",
        "url": "https://omegaup.com/arena/problem/Edificacion-Virtual/",
        "descripcion": "Uno de los juegos más divertidos de la existencia es Minecraft. Mientras estabas en una de tus divertidas partidas online, uno de los jugadores extraños de internet te ha comentado algo súper importante: quiere construir una pirámide en dos dimensiones en Minecraft. Sin embargo, no es muy bueno con las matemáticas y ha pedido tu ayuda. Él necesita saber cuántos pisos tendrá su pirámide si solo tiene N bloques de tierra. Los pisos se cuentan de abajo hacia arriba. El último piso siempre tendrá 1 solo bloque, el penúltimo piso tendrá 2 bloques, el siguiente piso tendrá 3 bloques y así sucesivamente. Como eres una buena persona que ayuda a los extraños en internet, tu tarea es encontrar el número de pisos de esta pirámide. Se te asegura que dado N siempre es posible construir una pirámide de la forma ya descrita.",
        "entrada": "N, cuántos bloques de tierra tiene el extraño del internet.",
        "salida": "Cuántos pisos tendría su pirámide de tierra.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "long long",
            "sqrt()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a;\n    cin>>a;\n    a*=2;\n    a=sqrt(a);\n    cout<<a;\n        \n    return 0;\n}"
    },
    {
        "titulo": "8239. El espía David",
        "url": "https://omegaup.com/arena/problem/El-Espia-David-/",
        "descripcion": "El espía David tiene una misión para infiltrarse en la base secreta de la malvada Pandora y por ende necesita la clave para pasar por la puerta con un mecanismo el cual le da 5 letras del alfabeto y David tiene que darle a la máquina el valor de ese carácter en su código Ascii. Ayuda a David a poder pasar por la puerta.",
        "entrada": "5 letras del alfabeto separadas por espacio.",
        "salida": "Escribir el valor Ascii de esas letras separadas por espacio.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "long long",
            "char"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a;\n    char z;\n    for(auto i=0; i<5; i++){\n        cin>>z;\n        a=z;\n        cout<<a<<\" \";\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "5018. Divisible 7",
        "url": "https://omegaup.com/arena/problem/Divisible-7/",
        "descripcion": "El comité Quinatanarroense se siente bondadoso este año, y en tu primer problema de lenguaje te pedirá que hagas algo muy fácil. Tu tarea consiste en identificar si un numero es divisible entre 7, es decir, si un numero al dividirlo entre 7 nos da algún otro numero entero. Sin embargo eso no es todo, tienes que identificar cuantos números son divisibles entre 7 de entre toda una lista de N números. Dada una lista de N números identificar cuántos de ellos son divisibles entre 7 y arrojarlo como resultado.",
        "entrada": "En la primera línea un numero N que representa la cantidad de números a analizar. En la segunda línea tendrás N números aleatorios sin ningún orden. (0<=N<=100,000) Los N números estarán entre 0 y 65,000. Tu programa deberá ejecutarse en menos de 0.5 segundos.",
        "salida": "Una única línea con un numero que representa la cantidad de números divisibles entre 7.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Loops",
            "Teoría de números"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c=0;\n    cin>>a;\n    while(a--){\n        cin>>b;\n        if(b%7==0){\n            c++;\n        }\n    }\n    cout<<c;\n        \n    return 0;\n}"
    },
    {
        "titulo": "5831. Divisibles",
        "url": "https://omegaup.com/arena/problem/Divisibles/",
        "descripcion": "Hacer un programa que reciba dos número por el teclado, a y b. Si a es divisible entre b, el programa ha de mostrar el mensaje \"DIVISIBLES\".",
        "entrada": "Dos enteros a y b.",
        "salida": "Si a es divisible entre b imprimir DIVISIBLES, si no imprimir NO DIVISIBLES.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Condicionales"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b;\n    cin>>a>>b;\n    a%=b;\n    if(a){\n        cout<<\"NO DIVISIBLES\";\n    }\n    else{\n        cout<<\"DIVISIBLES\";\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "4991. Dungeon Lvl.1",
        "url": "https://omegaup.com/arena/problem/Dungeon-Lvl1/",
        "descripcion": "Acabas de adquirir un nuevo videojuego, se llama Dungeon. En la trama un hechicero te encerró en un calabozo por coquetear con su hija en la fiesta de la aldea. Ahora debes escapar para volver con tu amada (aunque sólo la hayas conocido por 10 minutos). Emocionado por comenzar tu nueva aventura, insertas el disquete en la computadora y te dispones a jugar. Como en todo juego, comienzas en el nivel uno (pues en los juegos para machos no hay tutoriales). Tu personaje aparece en el primer nivel de calabozo,una cuadrícula de N x M sobre la que puedes moverte solo hacia las casillas adyacentes (arriba,abajo,derecha,izquierda), para pasar al siguiente nivel debes encontrar la puerta que te llevará a la siguiente sala. Después de unos minutos de juego consigues encontrar la puerta, sólo para enterarte que necesitas una llave para abrirla. Dada la configuración del calabozo, la localización de la llave y la localización de la puerta. Debes imprimir el menor número de pasos que debes moverte para superar el nivel.",
        "entrada": "La primera linea consiste en dos números N y M. Las siguientes N lineas contendrán M caracteres, cada uno correspondiente a una casilla del calabozo (3<=N,M<=100). Los caracteres pueden ser: Un punto ‘.’: Representa que la casilla está libre y puedes pasar. Un asterisco ‘*’: Representa que hay una pared bloqueando el camino. Una P minúscula ‘p’: Representa la puerta. Una L minúscula ‘l’: Representa la llave. Una C minúscula ‘c’: Representa la posición inicial de tu personaje.",
        "salida": "Un número con la cantidad de movimientos mínimos necesarios para superar el nivel. En caso de no ser posible, imprimir -1.",
        "nivel": "Intermedio (medio) - Análisis y diseño de algoritmos",
        "categorias": [
            "Búsqueda en amplitud",
            "Colas",
            "Matrices"
        ],
        "estructuras": [
            "long long",
            "vector<vector<char>>",
            "queue<>",
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long a, b;\nstruct sobra{\n    int aa, bb, cc;\n};\nqueue<sobra>falta;\nchar num[102][102];\nsobra z;\n\nvoid sub(){\n    while(falta.size()){\n        falta.pop();\n    }\n    falta.push(z);\n    num[z.aa][z.bb]='*';\n    while(falta.size()){\n        z=falta.front();\n        falta.pop();\n        z.cc++;\n        z.aa++;\n        if(num[z.aa][z.bb]=='p'){\n            cout<<z.cc;return;\n        }\n        else if(num[z.aa][z.bb]=='.' || num[z.aa][z.bb]=='0'){\n            num[z.aa][z.bb]='*';\n            falta.push(z);\n        }\n        z.aa-=2;\n        if(num[z.aa][z.bb]=='p'){\n            cout<<z.cc;return;\n        }\n        else if(num[z.aa][z.bb]=='.' || num[z.aa][z.bb]=='0'){\n            num[z.aa][z.bb]='*';\n            falta.push(z);\n        }\n        z.aa++;\n        z.bb++;\n        if(num[z.aa][z.bb]=='p'){\n            cout<<z.cc;return;\n        }\n        else if(num[z.aa][z.bb]=='.' || num[z.aa][z.bb]=='0'){\n            num[z.aa][z.bb]='*';\n            falta.push(z);\n        }\n        z.bb-=2;\n        if(num[z.aa][z.bb]=='p'){\n            cout<<z.cc;return;\n        }\n        else if(num[z.aa][z.bb]=='.' || num[z.aa][z.bb]=='0'){\n            num[z.aa][z.bb]='*';\n            falta.push(z);\n        }\n    }\n    cout<<\"-1\";\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    cin>>a>>b;\n    for(auto i=1; i<=a; i++){\n        for(auto j=1; j<=b; j++){\n            cin>>num[i][j];\n            if(num[i][j]=='c'){\n                z.aa=i;\n                z.bb=j;\n                falta.push(z);\n                num[z.aa][z.bb]='0';\n            }\n        }\n    }\n    while(falta.size()){\n        z=falta.front();\n        falta.pop();\n        z.cc++;\n        z.aa++;\n        if(num[z.aa][z.bb]=='l'){\n            sub();return 0;\n        }\n        else if(num[z.aa][z.bb]=='.'){\n            num[z.aa][z.bb]='0';\n            falta.push(z);\n        }\n        z.aa-=2;\n        if(num[z.aa][z.bb]=='l'){\n            sub();return 0;\n        }\n        else if(num[z.aa][z.bb]=='.'){\n            num[z.aa][z.bb]='0';\n            falta.push(z);\n        }\n        z.aa++;\n        z.bb++;\n        if(num[z.aa][z.bb]=='l'){\n            sub();return 0;\n        }\n        else if(num[z.aa][z.bb]=='.'){\n            num[z.aa][z.bb]='0';\n            falta.push(z);\n        }\n        z.bb-=2;\n        if(num[z.aa][z.bb]=='l'){\n            sub();return 0;\n        }\n        else if(num[z.aa][z.bb]=='.'){\n            num[z.aa][z.bb]='0';\n            falta.push(z);\n        }\n    }\n    cout<<\"-1\";return 0;\n    \n    return 0;\n}"
    },
    {
        "titulo": "7042. Déjà Vu en ESCOM",
        "url": "https://omegaup.com/arena/problem/Deja-Vu-en-ESCOM/",
        "descripcion": "Últimamente en el Club de Algoritmia ESCOM se han desarrollado nuevas técnicas que no tienen nada que ver con la programación competitiva. En este caso hablaremos de las habilidades que han desarrollado nuestros integrantes para poder controlar los sueños de las personas. Aún después de tanta preparación los estudiantes siguen siendo un poco novicios en estas técnicas obscuras y tenebrosas. Por lo que el especialista en esta técnica, el profesor Norman nos ha pedido ayuda para resolver el siguiente problema. El profesor Norman puede meterse en los sueños de las personas cuando están dormidos, para que dentro del mismo sueño haga dormir al individuo y pueda volver a meterse de nuevo en su sueño. Es decir, el profesor puede estar en un sueño dentro de otro sueño. Como sus habilidades son bastante sorprendentes, el puede repetir este proceso infinito número de veces. Al momento de meterse en un sueño, este es identificado con un número que representa el tipo de sueño en el que se encuentra actualmente (Solo existen tipos de sueños desde 1 a 10^9). Cuando el profesor Norman se mete en una serie de sueños, esto es representado con un arreglo A de números enteros. Por ejemplo: A = [1,2,3,4,5,6]. Esto nos dice que el profesor se fue metiendo en un sueño de tipo 1, después en uno de tipo 2, 3 y así consecutivamente. Si Norman comienza metiéndose a un sueño de tipo x y en alguno de los sueños posteriores vuelve a estar en otro sueño de tipo x, el siente que ya lo vivió antes, es decir, un Déjà Vu! De igual manera, si él se mete por primera vez a un sueño de tipo x y inmediatamente a uno de tipo y y se repite la secuencia x, y posteriormente, es un Déjà Vu doble. Como quiere estar preparado para lo peor que pueda suceder, Norman quiere saber cuál es la máxima secuencia de sueños para la que va a sentir un Déjà Vu. Cabe aclarar que el profesor sentirá un Déjà Vu solo con secuencias de sueños similares a las que inician en el primero en el que se adentró.",
        "entrada": "La primera línea de entrada contendrá un numero N(1<=N<=10^6), indicando la cantidad de sueños a los que el profesor se adentró. En la siguiente línea habrán N números A_i(1<=A_i<=10^9) indicando cada tipo de sueño.",
        "salida": "Un numero representando la máxima secuencia de sueños para los cuales el profesor sentirá un Déjà Vu.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores"
        ],
        "estructuras": [
            "vector<int>",
            "long long",
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c=0;\n    int num[1000002];\n    cin>>a;\n    for(auto i=0; i<a; i++){\n        cin>>num[i];\n    }\n    for(auto i=1; i<a; i++){\n        if(num[i]==num[0]){\n            b=0;\n            while((i+b)<a && num[i+b]==num[b]){\n                b++;\n            }\n            c=max(c,b);\n            if((i+b)==a){\n                cout<<c;return 0;\n            }\n        }\n    }\n    cout<<c;\n    \n    return 0;\n}"
    },
    {
        "titulo": "1099. Cifrado de Vigenère",
        "url": "https://omegaup.com/arena/problem/vigenere/",
        "descripcion": "Para cifrar una palabra con el método Cifrado de Vigenère, se hace una tabla como la que se muestra y se escoge una palabra clave. Con un ejemplo explicaremos la forma de cifrar. Supongamos que el mensaje que queremos cifrar es la palabra AGUASCALIENTES y la palabra clave es OMIAGS. Paso 1: Se hacen corresponder las letras de la palabra que se tiene que cifrar con la letras de la palabra clave, (en caso de que la palabra clave sea más corta que el mensaje, se repite tantas veces como sea necesario): AGUASCALIENTES OMIAGSOMIAGSOM Paso 2: Sustituimos cada letra del mensaje con la letra de la tabla que se encuentra en el renglón de la letra de la palabra y la columna de la letra del mensaje. Por ejemplo, para sustituir la primera A, buscamos en el renglón de la O y la columna de la A, encontrando la O. La G se sustituirá por la letra que se encuentra en el renglón de la M y la columna de G, es decir, la S. La U se sustituirá por la letra que se encuentra en el renglón de la I y la columna de U, la C. Y así sucesivamente, la palabra AGUASCALIENTES se convertiría en OSCAYUOXQETLSE. Cifrar o descifrar un mensaje dado usando el Cifrado Vigenère.",
        "entrada": "La primera línea tendrá un 1 o un 2. La segunda línea tendrá la palabra que tendrás que cifrar o descifrar. La tercera línea tendrá la palabra clave. La palabras serán de longitud a lo más 100 y estarán formadas solamente por mayúsculas.",
        "salida": "Si en la entrada la primera línea era un 1, debes imprimir la palabra cifrada. Si en la entrada la primera línea era un 2, debes imprimir la descifrada.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Aritmética",
            "Loops",
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "long long",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c;\n    string z, zz;\n    cin>>a>>z>>zz;\n    if(a==1){\n        for(auto i=0; i<z.size(); i++){\n            b=z[i]-64;\n            c=zz[i%zz.size()]-65;\n            b+=c;\n            b%=26;\n            if(b==0){\n                b=26;\n            }\n            z[i]=64+b;\n            cout<<z[i];\n        }\n    }\n    else{\n        for(auto i=0; i<z.size(); i++){\n            b=z[i]-64;\n            c=zz[i%zz.size()]-65;\n            b-=c;\n            if(b<=0){\n                b+=26;\n            }\n            z[i]=64+b;\n            cout<<z[i];\n        }\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "8442. Perfectamente Balanceado",
        "url": "https://omegaup.com/arena/problem/OMI-2019-Progresion/",
        "descripcion": "Tras pelear con los Avengers para conseguir las gemas del infinito, Thanos está agotado. Sin embargo, tiene una última tarea pendiente. Thanos tiene un arreglo de N enteros que debe dejar perfectamente balanceado. Un arreglo de números está perfectamente balanceado si la diferencia entre un elemento y el siguiente siempre es la misma para todos los elementos del arreglo. la diferencia entre cualquier elemento y el siguiente siempre debe ser constante. Para balancear el arreglo, Thanos sólo puede sumar o restar 1 a cada elemento. Cada vez que Thanos sume o reste un 1 a algún elemento se considera que hizo una operación. Solo se puede hacer una operacion por elemento. Thanos ofreció salvarte cuando elimine a la mitad de la población a cambio de tu ayuda. Imprime el menor número de operaciones que se necesitan para que el arreglo quede perfectamente balanceado, o -1 si no es posible balancearlo. Subtarea 1 (17 puntos): Se asegura que siempre se puede balancear usando sólo la operación de suma. Subtarea 2 (21 puntos): El primer elemento no necesita que le apliques ninguna operación. Subtarea 3 (62 puntos): No hay consideraciones adicionales.",
        "entrada": "En la primer línea el entero N. En la segunda línea N enteros separados por un espacio que representan los números del arreglo. (1<= N<=100000), (1<=n_i<=10^9).",
        "salida": "Un entero que indica el menor número de operaciones necesarias para que el arreglo quede perfectamente balanceado, o -1 si no es posible balancearlo.",
        "nivel": "Avanzado (medio) - Programación competitiva",
        "categorias": [
            "Ciclos",
            "Vectores",
            "Recursión",
            "Condicionales",
            "Programación dinámica"
        ],
        "estructuras": [
            "long long",
            "pair<int,int>",
            "vector<int>",
            "int",
            "bool"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    typedef pair < int, int > pii;\n    typedef long long int lld;\n    int n;\n    cin >> n;\n    int arr[n];\n    for (int i = 0; i < n; ++i)\n        cin >> arr[i];\n    if (n == 1) {\n        cout << \"0\\n\";\n        return 0;\n    }\n    int ans = -1;\n    for(auto f = -1; f <= 1; ++f) for (int s = -1; s <= 1; ++s) {\n        arr[0] += f; arr[1] += s;\n        bool progresion = true;\n        int cnt = abs(f) + abs(s);\n        int k = arr[1] - arr[0];\n        int act = arr[0];\n        for (int i = 1; i < n; ++i) {\n            act += k;\n            if (abs(act - arr[i]) > 1) {\n                progresion = false;\n                break;\n            }\n            cnt += abs(act - arr[i]);\n        }\n        if (progresion) ans = ans == -1 ? cnt : min(ans, cnt);\n        arr[0] -= f; arr[1] -= s;\n    }\n    cout << ans << \"\\n\";\n\n    return 0;\n}"
    },
    {
        "titulo": "6129. Mesa Redonda",
        "url": "https://omegaup.com/arena/problem/COMI-Mesa-redonda/",
        "descripcion": "Hay una mesa (redonda) con N niños numerados de 1 a N, la maestra ha decidido hacer un nuevo juego para determinar quien sale primero a jugar en el recreo, en el cual, iniciando desde el primer niño, la maestra avanza K niños en el sentido de las manecillas del reloj. Donde termine la maestra, ese niño sale al recreo, luego la maestra se para en el siguiente niño y vuelve a repetir este proceso hasta que todos los niños salgan al recreo. Randy está impaciente por salir a comer y le interesa saber después de cuantos niños saldrá él al recreo. Randy siempre es el niño número 1.",
        "entrada": "Dos enteros, N y K, el número de niños y el salto de avance que se hace. (1<=N,K<=1000).",
        "salida": "Un entero que represente el número de niños que salieron antes de Randy.",
        "nivel": "Intermedio (difícil) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Punteros"
        ],
        "estructuras": [
            "int",
            "struct"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint localiza(int x);\nvoid alta(int x);\nvoid baja();\n\ntypedef struct reg{\n    reg *sig;\n    int  dat;       //número de alumno\n}reg;\n\nreg *p, *a, *aux;\nint  n, k, c;\n\nint main(){\n    p =(reg*)malloc(sizeof(reg));  //inicio d ela lista\n    p->sig=NULL;\n    a =(reg*)malloc(sizeof(reg));  //nodo actual\n    a->sig=NULL;\n    aux=(reg*)malloc(sizeof(reg));\n    aux->sig=NULL;\n    cin>>n>>k;\n    for(auto i=1;i<=n;i++) alta(i);\n    a=p;\n    while(1){\n        a=a->sig;\n        for(auto i=1;i<=k;i++) localiza(i);\n        if(a->dat==1) break;       //regresa con Randy\n        baja();\n    }\n    cout<<c;\n\n    return 0;\n}\n\nvoid alta(int x){\n    if (p->sig == NULL){       // Si Lista Vacia\n        p->sig = a;\n        a->dat = x;\n    }\n    else{\n        reg *n;\n        n=(reg*) malloc(sizeof(reg));\n        n->sig=p->sig;\n        n->dat=x;\n        a->sig=n;\n        a=n;\n    }\n}\n\nint localiza(int x){\n    if(a->sig!=NULL){       //Solo queda Randy\n        aux=a;\n        a=a->sig;\n    }\n}\n\nvoid baja(){\n    aux->sig=a->sig;\n    if (p==aux) p->sig=aux->sig;\n    c++;\n\n}"
    },
    {
        "titulo": "6201. Rectangulo",
        "url": "https://omegaup.com/arena/problem/COMI-Rectangulo/",
        "descripcion": "Karel el constructor ha decidido hacer una nueva casa en la metropolí de karelotitlan. Como sabras Karel no es muy bueno con las figuras geometricas irregulares, asi que ha decidido construir su casa en la primer calle y que su casa sera el espacio rectangular más grande que hay en la metropoli.",
        "entrada": "Se te dara n, el número de avenidas que hay en la metropoli, en la siguiente linea habra n enteros indicando cuanto espacio libre hay en esa avenida (partiendo de la primera calle). (1<=n<=10^6), (1<=n_i<=10^6).",
        "salida": "El área del rectángulo más grande.",
        "nivel": "Intermedio (fácil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Vectores",
            "Pilas"
        ],
        "estructuras": [
            "long long",
            "stack<long long>",
            "vector<long long>"
        ],
        "codigo": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    long long int hist[1000100];\n    long long int n;\n    stack<long long int> s;\n    cin>>n;\n    for(auto i=0;i<n;i++){\n        cin>>hist[i];\n    }\n    long long int area = 0;\n    long long int tp;\n    long long int areasuperior;\n    long long int i = 0;\n    while (i < n){\n        if (s.empty() || hist[s.top()] <= hist[i]){\n            s.push(i++);\n        }\n        else{\n            tp = s.top();\n            s.pop();\n            areasuperior = hist[tp] * (s.empty() ? i : i - s.top() - 1);\n            if (area < areasuperior)\n                area = areasuperior;\n        }\n    }\n    while (s.empty() == false){\n        tp = s.top();\n        s.pop();\n        areasuperior = hist[tp] * (s.empty() ? i : i - s.top() - 1);\n        if (area < areasuperior)\n            area = areasuperior;\n    }\n    cout<<area;\n}"
    },
    {
        "titulo": "3471. Carguero",
        "url": "https://omegaup.com/arena/problem/carguero/",
        "descripcion": "La Organización Mundial Inter-oceánica (OMI) ha iniciado operaciones en el país y actualmente dispone de 4 cargueros para transportar mercancía de un puerto marítimo a otro. A pocos días de realizar su primer envío de 12 contenedores, el jefe de operaciones ha decidido que cada carguero lleve 3 contenedores, y que éstos, de acuerdo con su peso, estén distribuidos de manera uniforme. Ayuda al jefe de operaciones para minimizar T-t, donde T es el peso del carguero con mayor carga y, t el peso del carguero con la carga menor.",
        "entrada": "12 líneas que contienen la carga c_i, donde (1<=c<=1000000).",
        "salida": "Una sola línea indicando el valor mínimo de T-t.",
        "nivel": "Intermedio (difícil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Vectores",
            "Recursión"
        ],
        "estructuras": [
            "vector<int>",
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint carga_peso[12];\nint carga_carguero[12];\nint carguero_count[4];\nint answer = -1;\n\nvoid recurse(int carga) {\n    if (carga == 12) {\n        int carguero_carga[4] = {0,0,0,0};\n        for (int i = 0; i < 12; i++) {\n            carguero_carga[carga_carguero[i]] += carga_peso[i];\n        }\n        int T = max(max(carguero_carga[0], carguero_carga[1]),\n                    max(carguero_carga[2], carguero_carga[3]));\n        int t = min(min(carguero_carga[0], carguero_carga[1]),\n                    min(carguero_carga[2], carguero_carga[3]));\n        if (answer == -1 || T - t < answer) {\n            answer = T - t;\n        }\n        return;\n    }\n    for (int carguero = 0; carguero < 4; carguero++) {\n        if (carguero_count[carguero] < 3) {\n            carga_carguero[carga] = carguero;\n            carguero_count[carguero]++;\n            recurse(carga+1);\n            carguero_count[carguero]--;\n        }\n    }\n}\n\nint main() {\n    for (int i = 0; i < 12; i++) {\n        cin >> carga_peso[i];\n    }\n    recurse(0);\n    cout << answer << '\\n';\n\n    return 0;\n}"
    },
    {
        "titulo": "6120. Canchas",
        "url": "https://omegaup.com/arena/problem/COMI-Canchas/",
        "descripcion": "El director de la escuela necesita tu ayuda para redistribuir la cancha de basket y de volley en el patio de la escuela. Ambas canchas ahora serán rectángulos cuyas esquinas estarán en coordenadas enteras dentro del nuevo patio. El director te dará las coordenadas de las esquinas opuestas de cada cancha nueva y quiere que calcules cuál será el área total del patio que quedará cubierta por ambas canchas. A pesar del tamaño del patio de la escuela, puede ser que ambas canchas puedan encimarse, por lo que deberás tomar eso en cuenta para no contar dos veces el área. Escribe un programa que dadas las coordenadas de un par de esquinas opuestas de cada cancha calcule el área total cubierta por ambas canchas.",
        "entrada": "Tu programa deberá leer del teclado dos líneas, cada una con 4 números enteros separados por un espacio que representan las coordendas x_1, y_1, x_2, y_2 de cada una de las canchas (0<=x_1,y_1,x_2,y_2<=10000).",
        "salida": "Tu programa deberá escribir en la pantalla un único número entero que represente el área total cubierta por ambas canchas.",
        "nivel": "Intermedio (medio) - Matemáticas en la programación",
        "categorias": [
            "Aritmética",
            "Condicionales",
            "Geometría Analítica"
        ],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main (){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    int x_1,y_1,x_2,y_2;\n    int a_1,b_1,a_2,b_2;\n    cin>>x_1>>y_1>>x_2>>y_2;\n    cin>>a_1>>b_1>>a_2>>b_2;\n    int s1=(abs(x_1-x_2)*abs(y_1-y_2));\n    int s2=(abs(a_1-a_2)*abs(b_1-b_2));\n    int res=s1+s2;\n    int a=max(x_1,a_1);\n    int b=min(x_2,a_2);\n    int c=max(y_1,b_1);\n    int d=min(y_2,b_2);\n    if(a<b&&c<d)res-=((b-a)*(d-c));\n    cout << res<<\"\\n\";\n\n    return 0;\n}"
    },
    {
        "titulo": "6110. Traductor",
        "url": "https://omegaup.com/arena/problem/COMI_Traductor/",
        "descripcion": "En un lejano planeta coexisten dos culturas ancestrales, la Numírica y la Enteral y pese a sus similitudes culturales, se comunican en lenguajes totalmente diferentes. Por ejemplo, en numírico podrías decir \"hola\" con \"53134\" mientras que en enteral sería \"46952\". Tu tarea será realizar traducciones entre ambos idiomas. Escribe un programa que dada una lista de palabras que representa un diccionario, pueda traducir palabras entre lenguajes.",
        "entrada": "La primer linea tendrá dos enteros d y w. Las siguientes d lineas representan las traducciones del diccionario. Cada una con un par de enteros; n_i y e_i separados por un espacio. n_i representa una palabra en numírico y e_i su representación a enteral. Puedes estar seguro de que las palabras no se repetirán en el diccionario. Las siguientes w líneas contienen un entero, representando la palabra en numírico que tendrás que traducir. (0<=d, w<=1000), (-2,000,000,000<=n_i,e_i<=2,000,000,000).",
        "salida": "Por cada palabra a traducir, deberás imprimir una línea que contenga su respectiva traduccion en enteral. Si una palabra no tiene traducción debes imprimir \"C?\" en esa línea.",
        "nivel": "Intermedio (medio) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Árbol de busqueda binaria",
            "Hashing",
            "Vectores",
            "Colas"
        ],
        "estructuras": [
            "queue<long long>",
            "long long",
            "vector<pair<long long,long long>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    queue<long long>falta;\n    queue<long long>sobra;\n    long long a, b, c, d, e, f;\n    cin>>a>>b;\n    long long num[2][a];\n    for(auto i=0; i<a; i++){\n        cin>>num[0][i]>>num[1][i];\n    }\n    for(auto i=0; i<a; i++){\n        c=0;\n        for(auto j=0; j<(a-i)-1; j++){\n            if(num[0][j+1]<num[0][j]){\n                swap(num[0][j],num[0][j+1]);\n                swap(num[1][j],num[1][j+1]);\n                c=1;\n            }\n        }\n        if(c==0){\n            break;\n        }\n        c=0;\n    }\n    while(b!=0){\n        b--;\n        cin>>c;\n        d=0; e=a-1;\n        while(d<=e){\n            f=(d+e)/2;\n            if(num[0][f]==c){\n                cout<<num[1][f]<<\"\\n\";break;\n            }\n            else if(num[0][f]>c){\n                e=f-1;\n            }\n            else{\n                d=f+1;\n            }\n        }\n        if(d>e){\n            cout<<\"C?\\n\";\n        }\n    }\n        \n    return 0;\n}"
    },
    {
        "titulo": "6955. Guacamole",
        "url": "https://omegaup.com/arena/problem/OMI2018-Guacamole/",
        "descripcion": "En la Feria de Chapultepec se encuentra el juego Guacamole, la versión mexicana de Whac-a-mole y obviamente quieres obtener la mayor cantidad de puntos posible. El juego es una cuadrícula de tamaño NxM en la que hay un topo en cada casilla. Los topos están escondidos inicialmente y en cada segundo salen topos de algunas casillas y se esconden topos de otras casillas. Obtienes puntos por cada topo que logras golpear. Para jugar tienes que seguir las siguientes reglas: El topo en la posición (i,j)aparecerá por primera vez en el segundo I_{i,j} y volverá a aparecer cada S_{i,j} segundos. Por ejemplo si I_{i,j}=2 y S_{i,j}=3, aparecerá un topo en la posición (i,j) en los segundos (2,5,8,11...) y durará un segundo afuera antes de volver a esconderse. El segundo que está afuera el topo es el único momento en que puedes ganar puntos por golpearlo, es decir, si el topo sale en el segundo 2, puedes golpearlo en ese segundo, para el segundo 3, se habrá escondido de nuevo. Debes elegir en qué casilla pegar en el segundo 1, no importa si hay o no topo afuera. No puedes no golpear. Es decir, en cada segundo debes golpear alguna casilla, sin importar si hay o no un topo afuera. Como no eres tan rápido para moverte por las casillas, si golpeas en la casilla (i,j), tu siguiente golpe (en el siguiente segundo) debe ser en esa misma casilla o en alguna de sus 8 adyacentes. Es decir, si (i,j) es la última casilla que golpeaste, en el siguiente turno puedes golpear las casillas (i,j),(i-1,j),(i-1,j-1),(i,j-1),(i+1,j),(i+1,j+1),(i,j+1),(i-1,j+1) y (i+1, j-1) y siempre y cuando estén dentro de la cuadrícula. Si golpeas en la posición (i,j) y hay un topo afuera, se suman P_{i,j} puntos a tu total. Si no hay un topo afuera, no se suma nada a tu total. Encuentra la mayor puntuación posible que se puede lograr con las reglas anteriores. Subtareas: En el 30% de los casos, para todo i,j. I_{i,j} = i+j-1(con (1<=i<=N,1<=j<=M), S_{i,j}=T, (0<=P_{i,j}), para el 70% restante no hay consideraciones adicionales.",
        "entrada": "En la primera línea 3 enteros: N, M y T que representan el número de filas, el número de columnas del tablero y los segundos que dura el juego, respectivamente. Sigue la matriz I de tamaño NxM que indica en qué segundo sale cada topo por primera vez. Después una matriz S de tamaño NxM que indica cuántos segundos tarda cada topo en volver a salir. Por último una matriz P de tamaño NxM  que indica cuántos puntos obtienes si logras golpear al topo en cada casilla. (1<=N,M<=100), (1<=T<=500), (1<=S_{i,j},I_{i,j}<=T), (-10^9<=P_{i,j}<=10^9).",
        "salida": "Un entero que indica el puntaje más alto que se puede obtener en el juego.",
        "nivel": "Avanzado (medio) - Programación competitiva",
        "categorias": [
            "Programación dinámica",
            "Vectores",
            "Recursión"
        ],
        "estructuras": [
            "bool",
            "long long",
            "vector<vector<vector<long long>>>",
            "vector<vector<vector<bool>>>",
            "vector<long long>"
        ],
        "codigo": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nll n,m,t,mdo[4][101][101],DP[101][101][501],ans;\nll dx[]= {0,1,1,0,-1,-1,-1,0,1};\nll dy[]= {0,0,-1,-1,-1,0,1,1,1};\nbool use[101][101][501];\n\nll fn(ll fila,ll columna, ll tiempo)\n{\n    if(tiempo>t) return 0LL;\n\n    if(use[fila][columna][tiempo]) return DP[fila][columna][tiempo];\n\n    use[fila][columna][tiempo] = true;\n\n    ll x=0,y;\n    bool useY=false;\n    if(tiempo>=mdo[1][fila][columna] && (tiempo-mdo[1][fila][columna])%mdo[2][fila][columna]==0) x=mdo[0][fila][columna];\n\n    for(ll k=0; k<9; k++)\n    {\n        ll f=fila+dy[k];\n        ll c=columna+dx[k];\n        if(f>=0 && f<n && c>=0 && c<m)\n        {\n            if(!useY)\n            {\n                useY=true;\n                y=fn(f,c,tiempo+1);\n            }\n            y=max(y,fn(f,c,tiempo+1));\n        }\n    }\n\n    return DP[fila][columna][tiempo]=x+y;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    cin >> n >> m >> t;\n    for(ll i=0; i<n; i++) for(ll j=0; j<m; j++) cin >> mdo[1][i][j];\n    for(ll i=0; i<n; i++) for(ll j=0; j<m; j++) cin >> mdo[2][i][j];\n    for(ll i=0; i<n; i++) for(ll j=0; j<m; j++) cin >> mdo[0][i][j];\n\n    ans=fn(0,0,1);\n    for(ll i=0; i<n; i++) for(ll j=0; j<m; j++) ans=max(ans,fn(i,j,1));\n\n    cout << ans;\n\n    return 0;\n"
    },
    {
        "titulo": "6378. COCI 20/01/2018 Olivander",
        "url": "https://omegaup.com/arena/problem/Olivander/",
        "descripcion": "Harry Potter ha dañado su vara mágica en una pelea con Lord Voldemort. El ha decidido conseguir una nueva vara en la tienda de varas de Olivander. En el piso de la tienda, él vió N varas y N cajas de varas. Las longitudes de las varas son respectivamente X_1, X_2,...X_n y las longitudes de las cajas son Y_1, Y_2,...Y_n. Una vara de longitud X puede ser puesta en una caja de tamaño Y si X<=Y. Harry quiere saber si puede poner todas las varas en cajas de tal manera que cada caja contenga exactamente una vara. Ayúdelo a resolver este difícil problema.",
        "entrada": "La primera línea de la entrada contiene el entero positivo N(2<=N,<=100), el número de la tarea. La segunda línea de la entrada contiene N números positivos X_i(1<=X_i<=10^9), los números de la tarea. La tercera línea de la entrada contiene N números positivos Y_i(1<=Y_i<=10^9), los números de la tarea.",
        "salida": "Si Harry puede poner todas las varas en cajas dé como salid 'DA' (si en croata), en otro caso dé como salida 'NE' (no en croata).",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores",
            "Ordenamiento"
        ],
        "estructuras": [
            "long long",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b;\n    vector<int>falta;\n    vector<int>faltas;\n    cin>>a;\n    for(auto i=0; i<a; i++){\n        cin>>b;\n        falta.push_back(b);\n    }\n    for(auto i=0; i<a; i++){\n        cin>>b;\n        faltas.push_back(b);\n    }\n    sort(falta.begin(),falta.end());\n    sort(faltas.begin(),faltas.end());\n    for(auto i=0; i<a; i++){\n        if(falta[i]>faltas[i]){\n            cout<<\"NE\";return 0;\n        }\n    }\n    cout<<\"DA\";\n    \n    return 0;\n}\n"
    },
    {
        "titulo": "3442. COCI TABOVI",
        "url": "https://omegaup.com/arena/problem/COCI-TABOVI/",
        "descripcion": "Zvonkec es aún otro programador empleado de una empresa pequeña. Cada día tiene que refactorizar un archivo de código fuente. Muy a su pesar, la fuente está generalmente lejos de ser clara y ordenada. Él está especialmente molesto con la indentación irregular, es decir, el número de tabuladores (tabs) indentados en cada línea. Afortunadamente, su editor tiene un comando para seleccionar un grupo de líneas consecutivas y añadir o eliminar un carácter del inicio de cada una. Ayuda a Zvonkec a organizar el código tan rápido como sea posible. Se te da el número de líneas N, una secuencia especificando el número de tabulaciones al inicio de cada línea, y una secuencia que especifica el número requerido de tabulaciones al inicio de cada línea. Zvonkec puede ejecutar cualquier número de comandos que consisten en: Seleccionar cualquier número de líneas consecutivas. Agregar o eliminar una sola tabulación de cada una de las líneas seleccionadas. Las dos acciones anteriores comprenden un solo comando, sin importar el número de líneas seleccionadas. Debe tenerse en cuenta que está prohibido eliminar más tabulaciones de una línea que en realidad no tiene ya tabulaciones al inicio, ya que el editor comenzaría a eliminar caracteres en vez de tabulaciones. Se te pide calcular el mínimo número de comandos requeridos para ordenar el código.",
        "entrada": "La primera línea contiene un entero positivo N. La segunda línea contiene una secuencia de N enteros P_i, especificando el número de tabulaciones al inicio de la i-ésima línea antes de cualquier edición. La tercera línea contiene una secuencia de N enteros K_i, especificando el número de tabulaciones que Zvonkec quiere al inicio de la i-ésima línea.",
        "salida": "La primera y la única línea debe contener el número requerido, como se especifica en la descripción del problema.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores"
        ],
        "estructuras": [
            "long long",
            "vector<pair<int,int>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d=0;\n    pair<int,int>num[1002];\n    cin>>a;\n    for(auto i=0; i<a; i++){\n        cin>>num[i].first;\n    }\n    for(auto i=0; i<a; i++){\n        cin>>num[i].second;\n    }\n    for(auto i=0; i<a; i++){\n        if(num[i].first==num[i].second){\n            continue;\n        }\n        if(num[i].first>num[i].second){\n            b=i;\n            c=num[i].first-num[i].second;\n            while(num[b].first>num[b].second){\n                if((num[b].first-num[b].second)<c){\n                    c=num[b].first-num[b].second;\n                }\n                b++;\n            }\n            for(auto j=i; j<b; j++){\n                num[j].first-=c;\n            }\n            d+=c;\n            i--;continue;\n        }\n        b=i;\n        c=num[i].first-num[i].second;\n        while(num[b].first<num[b].second){\n            if((num[b].first-num[b].second)>c){\n                c=num[b].first-num[b].second;\n            }\n            b++;\n        }\n        for(auto j=i; j<b; j++){\n            num[j].first-=c;\n        }\n        d-=c;\n        i--;continue;\n    }\n    cout<<d;\n    \n    return 0;\n}\n\n"
    },
    {
        "titulo": "4246. COCI-NIZOVI",
        "url": "https://omegaup.com/arena/problem/COCI-NIZOVI/",
        "descripcion": "Un arreglo en cierto lenguaje de programación está definido de la siguiente manera: El inicio y el final de un arreglo está denotado por una llave abierta y cerrada, respectivamente. Dentro de las llaves, hay (posiblemente 0) valores separados por comas (no hay una coma después del último elemento del arreglo). Cada valor puede ser una palabra (un arreglo de letras minúsculas del alfabeto inglés) u otro arreglo. Ejemplos de arreglos correctamente definidos son: {}, {a,b,c}, {abc,znj,{novi,niz},pozz}. Recientemente, has notado que el lenguaje de programación no arroja un error si no colocas la cantidad apropiada de espacios y líneas nuevas antes o después de las llaves o las comas. Dado el hecho de que te molesta que los valores estén muy apretados, has decidido ponerte a trabajar y modificar la forma de los arreglos de la siguiente manera: Cada valor que no es un arreglo o denota el inicio o el final de un arreglo (llaves) estará en su propia línea. Las comas están 'conectadas' con el valor ubicado directamente antes de ellas y hay una línea nueva después de cada coma. Después de la llave que denota el inicio de un arreglo, la indentación aumenta (moviendo el contenido a la derecha) dos espacios. Antes de la llave que denota el final de un arreglo '}', la indentación del contenido disminuye (moviendo el contenido a la izquierda) dos espacios.",
        "entrada": "La primera línea de entrada contiene un arreglo de caracteres S (1<=|S|<=1500) representando el arreglo de la tarea.",
        "salida": "La salida debe consistir de la versión modificada del arreglo de la tarea.",
        "nivel": "Básico (difícil) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "long long",
            "string",
            "getline()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a=0, b, c;\n    string z, zz=\"\";\n    getline(cin,z);\n    for(auto i=0; i<z.size()-1; i++){\n        if(z[i]==' ' || z[i]==','){\n            continue;\n        }\n        if(z[i]=='{'){\n            b=a;\n            while(b--){\n                cout<<\" \";\n            }\n            cout<<z[i]<<\"\\n\";\n            a+=2;continue;\n        }\n        if(z[i]=='}'){\n            b=1;\n            for(auto j=i+1; j<z.size(); j++){\n                if(z[j]=='}'){\n                    b--;break;\n                }\n                if(z[j]!=' ' && z[j]!=','){\n                    break;\n                }\n            }\n            a-=2;\n            c=a;\n            while(c--){\n                cout<<\" \";\n            }\n            cout<<\"}\";\n            if(b){\n                cout<<\",\";\n            }\n            cout<<\"\\n\";continue;\n        }\n        zz=zz+z[i];\n        i++;\n        while(z[i]!=' ' && z[i]!=',' && z[i]!='{' && z[i]!='}'){\n            zz=zz+z[i];\n            i++;\n        }\n        i--;\n        b=a;\n        while(b--){\n            cout<<\" \";\n        }\n        cout<<zz;\n        zz=\"\";\n        b=1;\n        for(auto j=i+1; j<z.size(); j++){\n            if(z[j]=='}'){\n                b--;break;\n            }\n            if(z[j]!=' ' && z[j]!=','){\n                break;\n            }\n        }\n        if(b){\n            cout<<\",\";\n        }\n        cout<<\"\\n\";\n    }\n    cout<<\"}\";\n    \n    return 0;\n}"
    },
    {
        "titulo": "4151. Carlos El Oso y la víbora",
        "url": "https://omegaup.com/arena/problem/carlos_el_oso_y_la_vibora/",
        "descripcion": "Carlos el Oso está aprendiendo a programar. La primer tarea es dibujar un oso! Sin embargo Carlos cree que eso es muy difícil para un principiante, así que mejor decide dibujar una víbora. Una víbora es un patrón en una tabla de n por m. Donde la celda de la c-ésima columna del r-iésimo renglón, se define como (r,c). La cola de la víbora está en (1,1) y su cuerpo se extiende por (1,m), luego va para abajo 2 renglones hasta (3,m) y luego a la izquierda hasta (3,1), etc. Tu tarea es díbujar la víbora de Carlos el oso; una celda vacía se representará por el caracter del punto \".\" y las celdas de la víbora se rellenarán con el signo de número \"#\". Ve los ejemplos para que entiendas mejor el patrón de la víbora.",
        "entrada": "La única línea contiene dos enteros: n y m (3<=n,m<=59). n es un número impar.",
        "salida": "La salida serán n líneas. Cada línea contendrá una cadena que constará de m caracteres. No muestre espacios.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Matrices",
            "Ciclos",
            "Geometría"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c=1;\n    cin>>a>>b;\n    for(auto i=1; i<=a; i++){\n        if(i%2){\n            for(auto j=1; j<=b; j++){\n                cout<<\"#\";\n            }\n        }\n        else{\n            if(c%2){\n                for(auto j=1; j<b; j++){\n                    cout<<\".\";\n                }\n                cout<<\"#\";\n            }\n            else{\n                cout<<\"#\";\n                for(auto j=1; j<b; j++){\n                    cout<<\".\";\n                }\n            }\n            c++;\n        }\n        cout<<\"\\n\";\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "3050. Casilla para votar",
        "url": "https://omegaup.com/arena/problem/Casilla-para-votar/",
        "descripcion": "Las votaciones en Nlognoria están a punto de llevarse a cabo, sin embargo, los ciudadanos no saben con certeza en dónde se encuentra su casilla para votar. Debido a este problema, el CEN (Consejo Nacional Electoral) de Nlognoria, ha decidido intervenir y te ha contratado para que les ayudes en esta importante labor. Lo interesante en esto, es que desde su fundación, Nlognoria siempre ha sido un país bastante regular, en primer lugar, se conforma de un territorio rectangular de anchura N y altura M, el cual se encuentra dividido en N x M regiones cuadradas, en donde en cada una puede haber una montaña, un pastizal, un tramo de agua o una casa. A su vez, los habitantes se organizaron en pueblos, construyendo nuevas casas en forma ortogonal a las ya existentes, o aislándose para crear un nuevo pueblo. Debido a esto, dos casas se encuentran en el mismo pueblo solo si existe un camino de movimientos ortogonales compuesto únicamente por casas que las interconecta. Cada habitante conoce las coordenadas donde se encuentra su casa. Para este año el CEN ha decidido poner una casilla en cada pueblo y lo hará primero buscando la casa que se encuentra más abajo y después la más a la derecha de cada uno. Así que el programa que te han encomendado tiene como objetivo que los ciudadanos puedan ingresar las coordenadas de su casa y éste imprima las coordenadas de la casilla en donde le toca votar.",
        "entrada": "La entrada comienza con dos números enteros N y M separados por un espacio con 1<=N,M<=10^2, que indica la anchura y longitud que tiene Nlognoria, posteriormente le siguen N líneas, cada una con M enteros 0<=m_i<=3 separados entre si por un espacio, en donde el valor 0 indica una porción de agua, el 1 una montaña, el 2 un pastizal y el 3 una casa. Seguido a esto se tiene un entero Q con 1<=Q<=10^4 que indica el número de peticiones que se harán al programa, seguido de Q coordenadas enteras en formato x y con 1<=x<=N y 1<=y<=M separadas por un espacio.",
        "salida": "Para cada petición, se deberá imprimir una línea en formato (x,y) la cual representa las coordenadas de la casilla en la que le toca votar al ciudadano, o la palabra montana, pastizal o agua indicando del tipo de terreno si es que no existe una casa en ese lugar.",
        "nivel": "Avanzado (difícil) - Programación competitiva",
        "categorias": [
            "Matrices",
            "Colas",
            "Búsqueda en amplitud"
        ],
        "estructuras": [
            "long long",
            "pair<int,pair<int,int>>[][]",
            "queue<pair<int,int>>",
            "pair<int,int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d;\n    pair<int,pair<int,int>>num[102][102];\n    queue<pair<int,int>>falta;\n    pair<int,int>z;\n    cin>>a>>b;\n    for(auto i=1; i<=a; i++){\n        for(auto j=1; j<=b; j++){\n            cin>>num[i][j].first;\n        }\n    }\n    for(auto i=1; i<=a; i++){\n        for(auto j=1; j<=b; j++){\n            if(num[i][j].first==3 && num[i][j].second.first==0){\n                z.first=i;\n                z.second=j;\n                c=i;\n                d=j;\n                falta.push(z);\n                num[i][j].second.first=-1;\n                while(falta.size()){\n                    z=falta.front();\n                    falta.pop();\n                    if(z.first>c){\n                        c=z.first;\n                        d=z.second;\n                    }\n                    else if(z.first==c && z.second>d){\n                        d=z.second;\n                    }\n                    z.first++;\n                    if(num[z.first][z.second].first==3 && num[z.first][z.second].second.first==0){\n                        num[z.first][z.second].second.first=-1;\n                        falta.push(z);\n                    }\n                    z.first-=2;\n                    if(num[z.first][z.second].first==3 && num[z.first][z.second].second.first==0){\n                        num[z.first][z.second].second.first=-1;\n                        falta.push(z);\n                    }\n                    z.first++;\n                    z.second++;\n                    if(num[z.first][z.second].first==3 && num[z.first][z.second].second.first==0){\n                        num[z.first][z.second].second.first=-1;\n                        falta.push(z);\n                    }\n                    z.second-=2;\n                    if(num[z.first][z.second].first==3 && num[z.first][z.second].second.first==0){\n                        num[z.first][z.second].second.first=-1;\n                        falta.push(z);\n                    }\n                }\n                z.first=i;\n                z.second=j;\n                falta.push(z);\n                num[i][j].second.first=c;\n                num[i][j].second.second=d;\n                while(falta.size()){\n                    z=falta.front();\n                    falta.pop();\n                    z.first++;\n                    if(num[z.first][z.second].first==3 && num[z.first][z.second].second.first==-1){\n                        num[z.first][z.second].second.first=c;\n                        num[z.first][z.second].second.second=d;\n                        falta.push(z);\n                    }\n                    z.first-=2;\n                    if(num[z.first][z.second].first==3 && num[z.first][z.second].second.first==-1){\n                        num[z.first][z.second].second.first=c;\n                        num[z.first][z.second].second.second=d;\n                        falta.push(z);\n                    }\n                    z.first++;\n                    z.second++;\n                    if(num[z.first][z.second].first==3 && num[z.first][z.second].second.first==-1){\n                        num[z.first][z.second].second.first=c;\n                        num[z.first][z.second].second.second=d;\n                        falta.push(z);\n                    }\n                    z.second-=2;\n                    if(num[z.first][z.second].first==3 && num[z.first][z.second].second.first==-1){\n                        num[z.first][z.second].second.first=c;\n                        num[z.first][z.second].second.second=d;\n                        falta.push(z);\n                    }\n                }\n            }\n        }\n    }\n    cin>>a;\n    while(a--){\n        cin>>b>>c;\n        if(num[b][c].first==3){\n            cout<<\"(\"<<num[b][c].second.first<<\",\"<<num[b][c].second.second<<\")\";\n        }\n        else{\n            switch(num[b][c].first){\n                case 0: cout<<\"agua\";break;\n                case 1: cout<<\"montana\";break;\n                case 2: cout<<\"pastizal\";break;\n            }\n        }\n        cout<<\"\\n\";\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "6275. Centro de un vector",
        "url": "https://omegaup.com/arena/problem/Centro-vector/",
        "descripcion": "Considera un vector x cuyas coordenadas van de la 0 a la n y contienen valores enteros. A una coordenada c (entre 0 y n) se le dice el centro de x si cumple que la suma desde i=0 hasta i=c-1 de (c-i)x_i es igual a la suma desde i=c+1 hasta n de (i-c)x_i. Observa que la entrada en la coordenada c no participa en ninguna de las dos sumas. Por ejemplo, si x es el vector (6,2,3,0,1), entonces c=1 es un centro de x, pues la primera suma (1-0)6 es igual a la segunda suma (2-1)3+(3-1)0+(4-1)1 (ambas valen 6). No todos los vectores tienen centro. Por ejemplo, el vector (1,2,1,1) no tiene centro porque ninguna de sus coordenadas cumple que las dos sumas son iguales. Advierte que el centro de un vector tiene interpretación física: si se considera a los valores contenidos en el vector como pesos, entonces un centro del vector (si acaso existe) corresponde con el centro de gravedad.",
        "entrada": "Consiste de un número entero n que tendrá un valor entre 1 y 1000 seguido de un renglón con n+1 números enteros, x_0, x_1, ..., x_n, separados por espacios, cada uno con valor entre 1 y 1000",
        "salida": "Consiste de dos números enteros c, s, separados por un espacio. El primero es el centro de x y el segundo es el valor de la suma. Si x no tiene centro, entonces c=-1, s=0.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Cálculos aritméticos",
            "Ciclos",
            "Vectores"
        ],
        "estructuras": [
            "long long",
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b=0, c=0, d=0;\n    int num[1001];\n    cin>>a;\n    for(auto i=0; i<=a; i++){\n        cin>>num[i];\n        c+=(num[i]*i);\n    }\n    if(c==0){\n        cout<<\"0 0\";return 0;\n    }\n    while(d<a){\n        d++;\n        for(auto i=d; i<=a; i++){\n            c-=num[i];\n        }\n        for(auto i=d-1; i>=0; i--){\n            b+=num[i];\n        }\n        if(b==c){\n            cout<<d<<\" \"<<b;return 0;\n        }\n        if(b>c){\n            cout<<\"-1 0\";return 0;\n        }\n    }\n    cout<<\"-1 0\";\n    \n    return 0;\n}"
    },
    {
        "titulo": "102. Cadenas de Potencias de 2",
        "url": "https://omegaup.com/arena/problem/cadenasp2/",
        "descripcion": "Si hicieras listas del 1 a una potencia de 2, las primeras cinco listas serían:1 12 1234 12345678 12345678910111213141516. Si solamente te quedaras con la cifra de las unidades y juntas todas esas cifras quedaría una cadena de este tipo: 1121234123456781234567890123456. Ahora imagina que se hace lo anterior para una infinidad de listas, ¿podrías decir qué cifra está en el lugar y a qué número corresponde dicha cifra?",
        "entrada": "La primera línea tendrá un entero , la cantidad de números en la lista, 0<n<=2^62",
        "salida": "Una línea con dos números separados por un espacio, la cifra y el número al que corresponde.",
        "nivel": "Intermedio (medio) - Matemáticas en la programación",
        "categorias": [
            "Cálculos aritméticos"
        ],
        "estructuras": [
            "unsigned long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    unsigned long long a, b = 1, c = 0;\n    cin >> a;\n    while (c < a)\n    {\n        c += b;\n        b *= 2;\n    }\n    if (c == a)\n    {\n        cout << (b / 2) % 10 << \" \" << b / 2;\n        return 0;\n    }\n    c -= (b / 2);\n    cout << (a - c) % 10 << \" \" << a - c;\n\n    return 0;\n}"
    },
    {
        "titulo": "2274. Arte Vacuno",
        "url": "https://omegaup.com/arena/problem/Arte-Vacuno/",
        "descripcion": "Un hecho poco conocido acerca de las vacas es que ellas son ciegas para el color verde, para ellas los colores rojo y verde se ven iguales. Esto hace especialmente difícil diseñar arte que sea atractivo tanto para vacas como para humanos. Considere una pintura en un cuadrado que está descrito como una cuadrícula NxN de caracteres (1 <= N <= 100), cada uno o R (rojo), G (verde) o B (azul). Una pintura es interesante si tiene muchas regiones coloreadas que puedan distinguirse unas de otras. Dos caracteres pertenecen a la misma región si están adyacentes directamente (este, oeste, norte o sur) y si ellas son indistinguibles por color. Por ejemplo, la pintura RRRBB GGBBB BBBRR BBRRR RRRRR tiene 4 regiones (2 rojas,1 azul y 2 verdes) si es vista por un humano y únicamente 3 regiones (2 rojo-verde, 1 azul) si es vista por una vaca. Dada una pintura como entrada, por favor, ayude a calcular el número de regiones en la pintura cuando es vista por un humano y cuando es vista por una vaca.",
        "entrada": "Línea 1: El entero N. Líneas 2..1+N: Cada línea contiene una cadena con N caracteres, describiendo una fila de pintura.",
        "salida": "Línea 1: Dos enteros separados por espacio, diciendo el número de regiones en la pintura cuando es vista por un humano y por una vaca.",
        "nivel": "Intermedio (difícil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Matrices",
            "Colas",
            "Búsqueda en amplitud"
        ],
        "estructuras": [
            "struct",
            "long long",
            "char",
            "vector<vector<char>>",
            "queue<>",
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long a, c = 0;\nstruct sobra\n{\n    int aa, bb;\n    char cc;\n};\nchar num[102][102];\nqueue<sobra> falta;\nsobra z;\n\nvoid sub(sobra x, char y)\n{\n    c++;\n    if (y == 'B')\n    {\n        num[x.aa][x.bb] = '2';\n        x.cc = '2';\n    }\n    else\n    {\n        num[x.aa][x.bb] = '1';\n        x.cc = '1';\n    }\n    falta.push(x);\n    while (falta.size())\n    {\n        x = falta.front();\n        falta.pop();\n        x.aa++;\n        if (num[x.aa][x.bb] == y)\n        {\n            num[x.aa][x.bb] = x.cc;\n            falta.push(x);\n        }\n        x.aa -= 2;\n        if (num[x.aa][x.bb] == y)\n        {\n            num[x.aa][x.bb] = x.cc;\n            falta.push(x);\n        }\n        x.aa++;\n        x.bb++;\n        if (num[x.aa][x.bb] == y)\n        {\n            num[x.aa][x.bb] = x.cc;\n            falta.push(x);\n        }\n        x.bb -= 2;\n        if (num[x.aa][x.bb] == y)\n        {\n            num[x.aa][x.bb] = x.cc;\n            falta.push(x);\n        }\n    }\n}\n\nvoid sum(sobra x, char y)\n{\n    c++;\n    falta.push(x);\n    while (falta.size())\n    {\n        x = falta.front();\n        falta.pop();\n        x.aa++;\n        if (num[x.aa][x.bb] == y)\n        {\n            num[x.aa][x.bb] = '.';\n            falta.push(x);\n        }\n        x.aa -= 2;\n        if (num[x.aa][x.bb] == y)\n        {\n            num[x.aa][x.bb] = '.';\n            falta.push(x);\n        }\n        x.aa++;\n        x.bb++;\n        if (num[x.aa][x.bb] == y)\n        {\n            num[x.aa][x.bb] = '.';\n            falta.push(x);\n        }\n        x.bb -= 2;\n        if (num[x.aa][x.bb] == y)\n        {\n            num[x.aa][x.bb] = '.';\n            falta.push(x);\n        }\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    cin >> a;\n    for (int i = 1; i <= a; i++)\n    {\n        for (int j = 1; j <= a; j++)\n        {\n            cin >> num[i][j];\n        }\n    }\n    for (int i = 1; i <= a; i++)\n    {\n        for (int j = 1; j <= a; j++)\n        {\n            if (num[i][j] == 'R')\n            {\n                z.aa = i;\n                z.bb = j;\n                sub(z, 'R');\n            }\n            else if (num[i][j] == 'G')\n            {\n                z.aa = i;\n                z.bb = j;\n                sub(z, 'G');\n            }\n            else if (num[i][j] == 'B')\n            {\n                z.aa = i;\n                z.bb = j;\n                sub(z, 'B');\n            }\n        }\n    }\n    cout << c << \" \";\n    c = 0;\n    for (int i = 1; i <= a; i++)\n    {\n        for (int j = 1; j <= a; j++)\n        {\n            if (num[i][j] == '1')\n            {\n                z.aa = i;\n                z.bb = j;\n                sum(z, '1');\n            }\n            else if (num[i][j] == '2')\n            {\n                z.aa = i;\n                z.bb = j;\n                sum(z, '2');\n            }\n        }\n    }\n    cout << c;\n\n    return 0;\n}"
    },
    {
        "titulo": "3696. Bienevales",
        "url": "https://omegaup.com/arena/problem/Bienevales/",
        "descripcion": "Como todo inicio de semestre y como todo buen \"estudihambre\". Karel debe ir a recoger sus bienevales a la temible fila. Como todos los años, la fila es enorme, le da 2 vueltas a toda la escuela y hace un calor tremendo. Por si fuera poco, el que está entregando los bienevales tiene una familia enorme y a todos sus primos los esta dejando formarse en el décimo lugar de la fila, sin importar que hayan mas primos detrás de el. Karel está muy molesto y para no perder la costumbre, ha decidido escribir un programa que simule lo que le pasa para perder el tiempo. Ayúdalo creando un programa que soporte 2 tipos de operaciones: La operación uno consiste en que llega una persona identificada con el número X. La operación 2 indica que han sido atendidas X personas de la fila.",
        "entrada": "En la primer linea, un número 1<=n<=500000 con la cantidad de consultas. En las siguientes n lineas 2 números separados por un espacio, O y X, donde O representa el tipo de operación y X el argumento de la operación.",
        "salida": "Una única línea con todos los números que fueron procesados y el orden en que estos fueron atendidos separados por un espacio.",
        "nivel": "Intermedio (difícil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Colas"
        ],
        "estructuras": [
            "long long",
            "queue<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d;\n    queue<int> falta;\n    cin >> a;\n    while (a--)\n    {\n        cin >> b >> c;\n        if (b == 2)\n        {\n            while (c-- && falta.size())\n            {\n                cout << falta.front() << \" \";\n                falta.pop();\n            }\n            continue;\n        }\n        if (c == 1 || (c % 2 == 0 && c != 2) || falta.size() < 10)\n        {\n            falta.push(c);\n            continue;\n        }\n        b = sqrt(c);\n        if ((b * b) == c)\n        {\n            falta.push(c);\n            continue;\n        }\n        b = 3;\n        while (b < sqrt(c))\n        {\n            if (c % b == 0)\n            {\n                falta.push(c);\n                b = 0;\n                break;\n            }\n            b += 2;\n        }\n        if (b == 0)\n        {\n            continue;\n        }\n        d = falta.size() - 9;\n        b = 9;\n        while (b--)\n        {\n            falta.push(falta.front());\n            falta.pop();\n        }\n        falta.push(c);\n        while (d--)\n        {\n            falta.push(falta.front());\n            falta.pop();\n        }\n    }\n    while (falta.size())\n    {\n        cout << falta.front() << \" \";\n        falta.pop();\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "6483. Bolsa de valores",
        "url": "https://omegaup.com/arena/problem/Bolsa-de-valores/",
        "descripcion": "Se compra una acción del mercado de valores de cierta compañía y se analiza su comportamiento a lo largo de una hora. Al inicio, la acción se mantiene estable, pero en determinado momento, el comportamiento de la acción comienza a variar. Compara el precio de la acción al principio y al final del tiempo para decidir si hubo ganancia o pérdida de valor y de cuánto fué ese cambio.",
        "entrada": "La primer línea contiene el valor inicial de la acción. La segunda línea recibe un número que decidirá cuántas veces cambió el comportamiento de la acción. Después, por cada vez que cambie el comportamiento, se reciben dos líneas, cada una conteniendo un número, la primera que indica en qué minuto cambió de comportamiento y la segunda, que indica el porcentaje de cambio de valor por minuto de la acción. Cada minuto a partir del tiempo asignado, hasta el siguiente cambio, la acción cambiará el porcentaje referido. Los cambios pueden iniciar en cualquier momento entre el minuto 0 y el 59. El cambio en el minuto 60, ya no se considera como parte de la hora indicada.",
        "salida": "Si la acción ganó valor, la frase \"LA ACCION GANA n%\", donde n, es el porcentaje de cambio con respecto al valor inicial, redondeado a dos decimales. Si la acción perdió valor, la frase \"LA ACCION PIERDE n%\", donde n, es el porcentaje de cambio en positivo con respecto al valor inicial, redondeado a dos decimales.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Vectores"
        ],
        "estructuras": [
            "long double",
            "vector<pair<int,int>>",
            "long long",
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long double a, b, c;\n    pair<int, int> num[100];\n    long long z, zz;\n    cin >> a >> zz;\n    c = a;\n    while (zz--)\n    {\n        cin >> z >> b;\n        if (z >= 0 && z <= 59)\n        {\n            num[z].first = b;\n            num[z].second = 1;\n        }\n    }\n    b = 0;\n    for (int i = 0; i <= 59; i++)\n    {\n        if (num[i].second)\n        {\n            b = num[i].first;\n        }\n        if (b == 0)\n        {\n            continue;\n        }\n        if (b > 0)\n        {\n            a += ((a / 100) * b);\n        }\n        else\n        {\n            a -= ((a / 100) * fabs(b));\n        }\n    }\n    if (a >= c)\n    {\n        b = c / 10000;\n        a /= b;\n        a -= 10000;\n        a /= 100;\n        cout << fixed << setprecision(2) << \"LA ACCION GANA \" << a << \"%\";\n    }\n    else\n    {\n        b = c / 10000;\n        a /= b;\n        a /= 100;\n        a = 100 - a;\n        cout << fixed << setprecision(2) << \"LA ACCION PIERDE \" << a << \"%\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "7955. Busca la Clave",
        "url": "https://omegaup.com/arena/problem/Busca-la-Clave-/",
        "descripcion": "María y Cristina necesitan comunicarse una clave numérica (un PIN), desde luego no desean que nadie se entere de la clave que se comunican. Desafortunadamente para ellas, es muy posible que alguien esté interceptando sus mensajes. Como ellas saben que esto es posible, idean un esquema de oclusión. Es decir, el que él número que desean comunicarse se esconde en una secuencia grande de números. Ellas codifican la información necesaria para encontrar el número en la misma secuencia de números. Esto es lo que hacen; primero se envían M números enteros, en desorden, después envían un número mas (N). La clave se esconde en la secuencia y es uno de los M números. Se trata del número que es el inmediato mayor a N. Su tarea consiste en escribir un programa para encontrar la clave oculta en el mensaje. Su programa recibe primero un número (M), después recibe M números enteros. Al final recibe otro número (N). Su programa debe imprimir la clave oculta. Por ejemplo suponga que María y Cristina se envían el siguiente mensaje 5 3 8 4 10 9 7. En este caso, la clave es 8 pues es el número (en la serie de cinco números) que es el inmediato mayor a 7.",
        "entrada": "Primera Entrada: Un numero 0<M que indique el numero de enteros a recibir. Segunda Entrada: El mensaje indicado por M numeros separados por espacios. Tercer Entrada: Numero 0<N que indique la condicion de la clave oculta.",
        "salida": "Aquellos numeros del mensaje que cumplan con la condicion",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores",
            "Ordenamiento"
        ],
        "estructuras": [
            "long long",
            "vector<int>",
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b;\n    vector<int> falta;\n    cin >> a;\n    while (a--)\n    {\n        cin >> b;\n        falta.push_back(b);\n    }\n    cin >> a;\n    sort(falta.begin(), falta.end());\n    for (int i = 0; i < falta.size(); i++)\n    {\n        if (falta[i] > a)\n        {\n            cout << falta[i];\n            return 0;\n        }\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "969. Intersecciones",
        "url": "https://omegaup.com/arena/problem/Intersecciones/",
        "descripcion": "Existe cierta ciudad donde el flujo del tránsito es muy controlado, sobre todo en las intersecciones de calles y avenidas. Algunas intersecciones están prohibidas, otras solo te permiten moverte de norte o sur, otras al este u oeste y algunas te permiten ir en cualquier dirección (N,S,E,O). Afortunadamente, cuentas con un mapa que indica a través de símbolos, como puedes moverte. Específicamente existen 4 símbolos: + indica que te puedes mover en cualquier dirección, - indica que te puedes mover únicamente al este u oeste a partir de tu ubicación, | indica que solo puedes moverte al norte o sur. '*' indica que está prohibido pasar por esa intersección.",
        "entrada": "En las primeras dos líneas los números R, C que denotan el numero de filas y columnas del mapa, respectivamente.En las siguientes R líneas, C caracteres que describen las intersecciones de la ciudad.",
        "salida": "Una línea con un número que denota el mínimo número de intersecciones por las que tienes que pasar para llegar a la esquina inferior derecha de la ciudad desde la esquina superior izquierda. Imprime -1 en caso de que no sea posible.",
        "nivel": "Intermedio (difícil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Búsqueda en amplitud",
            "Colas",
            "Matrices"
        ],
        "estructuras": [
            "long long",
            "struct",
            "int",
            "queue<int>",
            "vector<vector<char>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b;\n    struct sobra\n    {\n        int aa, bb, cc;\n    };\n    queue<sobra> falta;\n    char num[102][102];\n    sobra z;\n    cin >> a >> b;\n    for (int i = 1; i <= a; i++)\n    {\n        for (int j = 1; j <= b; j++)\n        {\n            cin >> num[i][j];\n        }\n    }\n    if (num[1][1] == '*')\n    {\n        cout << \"-1\";\n        return 0;\n    }\n    z.aa = 1;\n    z.bb = 1;\n    z.cc = 1;\n    falta.push(z);\n    while (falta.size())\n    {\n        z = falta.front();\n        falta.pop();\n        z.cc++;\n        if (num[z.aa][z.bb] == '+')\n        {\n            z.aa++;\n            if (z.aa == a && z.bb == b)\n            {\n                cout << z.cc;\n                return 0;\n            }\n            if (num[z.aa][z.bb] != '*')\n            {\n                falta.push(z);\n            }\n            z.aa -= 2;\n            if (z.aa == a && z.bb == b)\n            {\n                cout << z.cc;\n                return 0;\n            }\n            if (num[z.aa][z.bb] != '*')\n            {\n                falta.push(z);\n            }\n            z.aa++;\n            z.bb++;\n            if (z.aa == a && z.bb == b)\n            {\n                cout << z.cc;\n                return 0;\n            }\n            if (num[z.aa][z.bb] != '*')\n            {\n                falta.push(z);\n            }\n            z.bb -= 2;\n            if (z.aa == a && z.bb == b)\n            {\n                cout << z.cc;\n                return 0;\n            }\n            if (num[z.aa][z.bb] != '*')\n            {\n                falta.push(z);\n            }\n            z.bb++;\n        }\n        else if (num[z.aa][z.bb] == '-')\n        {\n            z.bb++;\n            if (z.aa == a && z.bb == b)\n            {\n                cout << z.cc;\n                return 0;\n            }\n            if (num[z.aa][z.bb] != '*')\n            {\n                falta.push(z);\n            }\n            z.bb -= 2;\n            if (z.aa == a && z.bb == b)\n            {\n                cout << z.cc;\n                return 0;\n            }\n            if (num[z.aa][z.bb] != '*')\n            {\n                falta.push(z);\n            }\n            z.bb++;\n        }\n        else if (num[z.aa][z.bb] == '|')\n        {\n            z.aa++;\n            if (z.aa == a && z.bb == b)\n            {\n                cout << z.cc;\n                return 0;\n            }\n            if (num[z.aa][z.bb] != '*')\n            {\n                falta.push(z);\n            }\n            z.aa -= 2;\n            if (z.aa == a && z.bb == b)\n            {\n                cout << z.cc;\n                return 0;\n            }\n            if (num[z.aa][z.bb] != '*')\n            {\n                falta.push(z);\n            }\n            z.aa++;\n        }\n        num[z.aa][z.bb] = '*';\n    }\n    cout << \"-1\";\n\n    return 0;\n}"
    },
    {
        "titulo": "8546. Coeficiente binomial recursivo",
        "url": "https://omegaup.com/arena/problem/Coeficiente-binomial-recursivo/",
        "descripcion": "El coeficiente binomial binom{N}{K} puede definirse de forma recursiva como binom{N}{K} = binom{N - 1}{K} + binom{N - 1}{K - 1} y binom{N}{0} = binom{N}{N} = 1. Escribe un programa que calcule el valor de y cuántas llamadas a función hace la implementación recursiva (incluyendo la llamada original).",
        "entrada": "Dos enteros N y K. Puedes suponer que 0<=K<=N<=30.",
        "salida": "Dos enteros que sean el valor de binom{N}{K} y el número de llamadas a función que realiza la implementación recursiva, respectivamente.",
        "nivel": "Intermedio (difícil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Recursión",
            "Análisis de recurrencias"
        ],
        "estructuras": [
            "unsigned long long",
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nunsigned long long a, b, c = 0, d;\n\nint num(int x, int y)\n{\n    c++;\n    if (x == y || y == 0)\n    {\n        return 1;\n    }\n    return num(x - 1, y) + num(x - 1, y - 1);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    cin >> a >> b;\n    d = num(a, b);\n    cout << d << \" \" << c;\n\n    return 0;\n}"
    },
    {
        "titulo": "4183. Contando Ovejas",
        "url": "https://omegaup.com/arena/problem/Contando-Ovejas/",
        "descripcion": "Bleatrix Trotter la oveja ha ideado una estrategia que le ayude a conciliar el sueño más rápido. En primer lugar, elige un número N. Entonces empieza nombrando N, 2N, 3N, , y así sucesivamente. Cada vez que nombra un número, piensa en todos sus dígitos y guarda un registro de los dígitos (0, 1, 2, 3, 4, 5, 6, 7, 8, y 9) que ha visto al menos una vez desde que inicio a nombrar. Una vez que ha visto cada uno de los diez dígitos al menos una vez, se quedará dormida. Bleatrix debe comenzar con N  y continuara siempre con (i+1)*N directamente después de i*N Por ejemplo, supongamos que Bleatrix elige N = 1692. ella contaría como sigue: N = 1692. Ahora ha visto a los dígitos 1, 2, 6, y 9; 2N =  3384. Ahora ya ha visto los dígitos 1, 2, 3, 4, 6, 8, y 9; 3N = = 5076. Ahora que ha visto los diez dígitos, se queda dormida. ¿Cuál es el último número que va a nombrar antes de dormirse? Si contará para siempre, mostrar INSOMNIA en su lugar.",
        "entrada": "La primera línea de la entrada da el número de casos de prueba T.T (1<=T<=100) lineas siguen cada una consta de un único entero N (0<=N<=106), el número que Bleatrix ha elegido.",
        "salida": "Para cada caso de prueba, la salida en una línea que contiene Case #x:y, donde x es el número del caso de prueba (comenzando en 1) y y  es el último número que Bleatrix nombrará antes de dormirse, de acuerdo con las reglas descritas en la descripción.",
        "nivel": "Intermedio (difícil) - Matemáticas en la programación",
        "categorias": [
            "Cálculo matemático",
            "Vectores"
        ],
        "estructuras": [
            "long long",
            "vector<int>",
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e;\n    int num[10];\n    cin >> a;\n    for (int i = 1; i <= a; i++)\n    {\n        cin >> b;\n        if (b == 0)\n        {\n            cout << \"Case #\" << i << \": INSOMNIA\\n\";\n            continue;\n        }\n        cout << \"Case #\" << i << \": \";\n        c = 0;\n        d = 10;\n        while (d)\n        {\n            c += b;\n            e = c;\n            while (e)\n            {\n                if (num[e % 10] == 0)\n                {\n                    num[e % 10]++;\n                    d--;\n                }\n                e /= 10;\n            }\n        }\n        cout << c << \"\\n\";\n        for (int i = 0; i < 10; i++)\n        {\n            num[i] = 0;\n        }\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "7785. Contenedores Nueva Jersey",
        "url": "https://omegaup.com/arena/problem/Contenedores-Nueva-Jersey/",
        "descripcion": "Luis trabaja en la terminal de carga de contenedores en Nueva Jersey (Estados Unidos) y se encarga de almacenar diferente objetos voluminosos pesados para su transporte por vía marítima. Luis tiene objetos que tiene que almacenar en  m contenedores, cada contenedor tiene un tamaño exactamente de k. Luis enumera los objetos del 1 al n en orden de izquierda a derecha, el tamaño del i-ésimo objeto es a_i Para almacenar los objetos Luis tiene una forma particular para acomodarlos dentro de los contenedores la cual se explica a continuación: Luis empieza con un contenedor vacío y para acomodar cada objeto los recorre de izquierda a derecha y si el i-ésimo objeto encaja en el contenedor actual (el tamaño restante del contenedor es mayor o igual que a_i) lo acomoda dentro del contenedor y el espacio restante disminuye en a_i De lo contrario, abre un nuevo contenedor vacío y continúa el proceso anterior. Si llega el momento en que Luis ya no tiene contenedores vacíos y hay al menos un objeto que no fue almacenado en ningún contenedor, entonces Luis no puede almacenar el conjunto de objetos elegido. Luis quiere saber el número máximo de objetos que puede almacenar en los contenedores con el proceso anterior. Para alcanzar esta meta, Luis descarta el objeto situado más a la izquierda del conjunto hasta que el conjunto restante de objetos pueda ser almacenado en los contenedores disponibles. La meta es decir el número máximo de objetos que Luis puede almacenar en los contenedores vacíos que tiene a su disposición. Cada vez que Luis intenta almacenar objetos en los contenedores, vaciará todos los contenedores que tiene antes de hacerlo (y el orden relativo del conjunto restante de objetos no cambiará).",
        "entrada": "La primera línea de entrada contiene 3 enteros n, m, k (1<=n, m<=2x10^5, 1<=k<=10^9) - el número de objetos, el número de contenedores y el tamaño de cada contenedor.  La segunda línea de la entrada contiene n enteros a_1,a_2,…,a_n (1<=a_i<=k), donde a_i es el tamaño del i-ésimo objeto.",
        "salida": "Imprimir el número máximo de los objetos que Luis puede almacenar usando el proceso descrito anteriormente.",
        "nivel": "Avanzado (fácil) - Programación competitiva",
        "categorias": [
            "Teoría de numeros",
            "Vectores"
        ],
        "estructuras": [
            "long long",
            "vector<int>",
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e, f = 0;\n    int num[200001];\n    cin >> a >> b >> c;\n    for (int i = 0; i < a; i++)\n    {\n        cin >> num[i];\n    }\n    d = b - 1;\n    e = c;\n    for (int i = a - 1; i >= 0; i--)\n    {\n        e -= num[i];\n        if (e < 0)\n        {\n            if (num[i] > c)\n            {\n                cout << (a - i) - 1;\n                return 0;\n            }\n            d--;\n            if (d < 0)\n            {\n                f = i;\n                break;\n            }\n            e = c;\n            e -= num[i];\n        }\n    }\n    e = c;\n    b--;\n    for (int i = f; i < a; i++)\n    {\n        e -= num[i];\n        if (e < 0)\n        {\n            b--;\n            if (b < 0)\n            {\n                cout << a - (f + 1);\n                return 0;\n            }\n            e = c;\n            e -= num[i];\n        }\n    }\n    cout << a - f;\n\n    return 0;\n}"
    },
    {
        "titulo": "2257. Conversión de Números Romanos",
        "url": "https://omegaup.com/arena/problem/Conversion-de-Nemeros-Romanos/",
        "descripcion": "Se te da un numero 1<=N<=3999, y deberás realiza la converción equivalente en números romanos. Aunque existen los limites, es necesarios que realices la validación correspondiente y en caso de no cumplir la validación deberás imprimir un mensaje idéntico al siguiente: LIMITE EXCEDIDO",
        "entrada": "Para este ejercicio, como entrada recibe únicamente un número entero.",
        "salida": "La salida deberá imprimir a consola el equivalente en romano de número proporcionado.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Cálculos aritméticos",
            "Ciclos"
        ],
        "estructuras": [
            "unsigned long long",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    unsigned long long a;\n    string z = \"\", zz;\n    cin >> a;\n    if (a < 1 || a > 3999)\n    {\n        cout << \"LIMITE EXCEDIDO\";\n        return 0;\n    }\n    if (a % 10)\n    {\n        switch (a % 10)\n        {\n        case 1:\n            zz = \"I\";\n            break;\n        case 2:\n            zz = \"II\";\n            break;\n        case 3:\n            zz = \"III\";\n            break;\n        case 4:\n            zz = \"IV\";\n            break;\n        case 5:\n            zz = \"V\";\n            break;\n        case 6:\n            zz = \"VI\";\n            break;\n        case 7:\n            zz = \"VII\";\n            break;\n        case 8:\n            zz = \"VIII\";\n            break;\n        case 9:\n            zz = \"IX\";\n            break;\n        }\n        z = zz + z;\n    }\n    a /= 10;\n    if (a % 10)\n    {\n        switch (a % 10)\n        {\n        case 1:\n            zz = \"X\";\n            break;\n        case 2:\n            zz = \"XX\";\n            break;\n        case 3:\n            zz = \"XXX\";\n            break;\n        case 4:\n            zz = \"XL\";\n            break;\n        case 5:\n            zz = \"L\";\n            break;\n        case 6:\n            zz = \"LX\";\n            break;\n        case 7:\n            zz = \"LXX\";\n            break;\n        case 8:\n            zz = \"LXXX\";\n            break;\n        case 9:\n            zz = \"XC\";\n            break;\n        }\n        z = zz + z;\n    }\n    a /= 10;\n    if (a % 10)\n    {\n        switch (a % 10)\n        {\n        case 1:\n            zz = \"C\";\n            break;\n        case 2:\n            zz = \"CC\";\n            break;\n        case 3:\n            zz = \"CCC\";\n            break;\n        case 4:\n            zz = \"CD\";\n            break;\n        case 5:\n            zz = \"D\";\n            break;\n        case 6:\n            zz = \"DC\";\n            break;\n        case 7:\n            zz = \"DCC\";\n            break;\n        case 8:\n            zz = \"DCCC\";\n            break;\n        case 9:\n            zz = \"CM\";\n            break;\n        }\n        z = zz + z;\n    }\n    a /= 10;\n    if (a % 10)\n    {\n        switch (a % 10)\n        {\n        case 1:\n            zz = \"M\";\n            break;\n        case 2:\n            zz = \"MM\";\n            break;\n        case 3:\n            zz = \"MMM\";\n            break;\n        }\n        z = zz + z;\n    }\n    cout << z;\n\n    return 0;\n}"
    },
    {
        "titulo": "4532. Cuadrados Pintados al reves",
        "url": "https://omegaup.com/arena/problem/Cuadrados-Pintados-al-reves/",
        "descripcion": "Escriba un programa que pida n números y los guarde en un arreglo. Luego debe escribir el cuadrado de cada número en orden inverso al que fueron introducidos.",
        "entrada": "La primera linea contiene un entero n que esta entre 1 y 100, le siguen n líneas con lo números del arreglo. solo se aceptan 100 elementos, *--",
        "salida": "El cuadrado de cada elemento del arreglo, desplegado en orden inverso al que fueron introducidos.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores",
            "Cálculos aritméticos",
            "Ciclos",
            "Pilas"
        ],
        "estructuras": [
            "long long",
            "stack<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b;\n    stack<int> falta;\n    cin >> a;\n    while (a--)\n    {\n        cin >> b;\n        b *= b;\n        falta.push(b);\n    }\n    while (falta.size())\n    {\n        cout << falta.top() << \"\\n\";\n        falta.pop();\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "4662. Cómo enviar Problemas",
        "url": "https://omegaup.com/arena/problem/Como-enviar-Problemas/",
        "descripcion": "Natalia es una estudiante entusiasta que le encanta asumir retos nuevos. Por ello ha decidido participar del Concurso Escolar de Programación. Pero nunca antes ha participado en nada similar, así que no sabe cómo sus respuestas son calificadas. Ella cree que habrá una persona que reciba su código, lo compile y lo ejecute manualmente para decidir si es correcto o no. Pero lo cierto es que todo eso lo realiza un sistema automático. Para ello, Natalia debe hacer que su programa lee datos de la entrada estándar y escriba datos en la salida estándar. Clarifiquemos con un ejemplo. Sea el siguiente problema: Dados 2 enteros a y b (1<=a,b<=1000000). Los enteros son presentados en una única línea, separados por un espacio. Imprime un único entero, la suma de a y b. Tu primera tarea es similar: calcula la suma de todos los números desde a hasta b.",
        "entrada": "La entrada consiste de una única línea que contiene 2 enteros a y b (a<=b), separados por un espacio. Para el grupo 1 (30 pts): 1<=a, b<=1000000, b=a+1. Para el grupo 2 (30 pts): 1<=a, b<=1000000. Para el grupo 3 (40 pts): 1<=a, b<=1000000000.",
        "salida": "Un único entero, la suma de todos los números desde a hasta b.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c;\n    cin >> a >> b;\n    a--;\n    c = (((b + 1) * b) / 2) - (((a + 1) * a) / 2);\n    cout << c;\n\n    return 0;\n}"
    },
    {
        "titulo": "2320. Desfile vacuno facil",
        "url": "https://omegaup.com/arena/problem/Desfile-vacuno/",
        "descripcion": "Habiendo oído que la última tendencia de moda vacuna era vacas con dos manchas en sus pieles, el Granjero Juan ha comprado un rebaño enero de vacas con dos manchas. Desafortunadamente, las tendencias de moda cambian muy rápidamente, y la moda más popular en estos días son las vacas con una sola mancha. GJ quiere hacer que sus vacas estén más a la moda pintando cada una de sus vacas de tal manera que sus dos manchas se junten en una sola. La piel de una vaca se representa por una cuadrícula N por M (1 <= N,M <= 50) de caracteres. Aquí, cada 'X' denota parte de una mancha. Dos 'X's pertenecen a la misma mancha si se puede ir de una a la otra a través de Xs adyacentes vertical u horizontalmente (la adyacencia en diagonal no se tiene en cuenta). De tal manera que la figura anterior tiene exactamente dos manchas. Todas las vacas en el rebaño de GJ tienen exactamente dos manchas. GJ quiere usar tan poca pintura como sea posible para juntar las dos manchas en una. En el ejemplo anterior, él puede hacer esto pintando únicamente tres caracteres adicionales con 'X's. Ayude a GJ a determinar el mínimo número de nuevas 'X's que él debe pintar con el propósito de juntar las dos manchas en una sola mancha grande.",
        "entrada": "Línea 1: Dos enteros separados por espacio, N y M. Líneas 2..1+N: Cada línea contiene una cadena de longitud M de 'X's y '.'s especificando una fila en el diseño de la piel de la vaca.",
        "salida": "Línea 1: El mínimo número de nuevas 'X's que deben ser añadidas al diseño de la entrada con el propósito de obtener una sola mancha.",
        "nivel": "Avanzado (difícil) - Programación competitiva",
        "categorias": [
            "Colas",
            "Matrices"
        ],
        "estructuras": [
            "long long",
            "vector<vector<char>>",
            "queue<pair<int,int>>",
            "vector<pair<int,int>>",
            "pair<int,int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n   cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  long long a, b, c=0, d=1000000;\n   char num[52][52];\n queue<pair<int,int>>falta;\n    vector<pair<int,int>>sub;\n pair<int,int> z;\n  cin>>a>>b;\n    for(auto i=1; i<=a; i++){\n      for(auto j=1; j<=b; j++){\n          cin>>num[i][j];\n       }\n }\n for(auto i=1; i<=a; i++){\n      for(auto j=1; j<=b; j++){\n          if(num[i][j]=='X' && c==0){\n               z.first=i;\n                z.second=j;\n               sub.push_back(z);\n             num[i][j]='.';\n                falta.push(z);\n                while(falta.size()){\n                  z=falta.front();\n                  falta.pop();\n                  z.first++;\n                    if(num[z.first][z.second]=='X'){\n                      sub.push_back(z);\n                     num[z.first][z.second]='.';\n                       falta.push(z);\n                    }\n                 z.first-=2;\n                   if(num[z.first][z.second]=='X'){\n                      sub.push_back(z);\n                     num[z.first][z.second]='.';\n                       falta.push(z);\n                    }\n                 z.first++;\n                    z.second++;\n                   if(num[z.first][z.second]=='X'){\n                      sub.push_back(z);\n                     num[z.first][z.second]='.';\n                       falta.push(z);\n                    }\n                 z.second-=2;\n                  if(num[z.first][z.second]=='X'){\n                      sub.push_back(z);\n                     num[z.first][z.second]='.';\n                       falta.push(z);\n                    }\n             }\n             c=1;\n          }\n         else if(num[i][j]=='X'){\n              z.first=i;\n                z.second=j;\n               for(auto k=0; k<sub.size(); k++){\n                 d=min(d,(long long)(fabs(i-sub[k].aa)+fabs(j-sub[k].second))-1);\n              }\n             num[i][j]='.';\n                falta.push(z);\n                while(falta.size()){\n                  z=falta.front();\n                  falta.pop();\n                  z.first++;\n                    if(num[z.first][z.second]=='X'){\n                      for(auto k=0; k<sub.size(); k++){\n                        d=min(d,(long long)(fabs(z.first-sub[k].aa)+fabs(z.second-sub[k].second))-1);\n                      }\n                     num[z.first][z.second]='.';\n                       falta.push(z);\n                    }\n                 z.first-=2;\n                   if(num[z.first][z.second]=='X'){\n                      for(auto k=0; k<sub.size(); k++){\n                        d=min(d,(long long)(fabs(z.first-sub[k].aa)+fabs(z.second-sub[k].second))-1);\n                      }\n                     num[z.first][z.second]='.';\n                       falta.push(z);\n                    }\n                 z.first++;\n                    z.second++;\n                   if(num[z.first][z.second]=='X'){\n                      for(auto k=0; k<sub.size(); k++){\n                        d=min(d,(long long)(fabs(z.first-sub[k].aa)+fabs(z.second-sub[k].second))-1);\n                      }\n                     num[z.first][z.second]='.';\n                       falta.push(z);\n                    }\n                 z.second-=2;\n                  if(num[z.first][z.second]=='X'){\n                      for(auto k=0; k<sub.size(); k++){\n                        d=min(d,(long long)(fabs(z.first-sub[k].aa)+fabs(z.second-sub[k].second))-1);\n                      }\n                     num[z.first][z.second]='.';\n                       falta.push(z);\n                    }\n             }\n             c=1;\n          }\n     }\n }\n cout<<d;\n  \n  return 0;\n}"
    },
    {
        "titulo": "8315. Desv.Est",
        "url": "https://omegaup.com/arena/problem/DesvEst/",
        "descripcion": "Calcular la desviación estandar de un conjunto de datos.",
        "entrada": "La entrada tendrá el número de elementos de la lista de datos y posteriormente dicha lista de datos de enteros positivos.",
        "salida": "La salida será el valor de la desviación estandar del conjunto de datos de entrada, redondeado a dos decimales.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Probabilidad",
            "Ciclos",
            "Cálculo matemático",
            "Vectores"
        ],
        "estructuras": [
            "long double",
            "vector<long double>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n   cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  long double a, b, c;\n  long double num[101];\n cin>>a;\n   for(auto i=0; i<a; i++){\n      cin>>num[i];\n      b+=num[i];\n    }\n b/=a;\n for(auto i=0; i<a; i++){\n      c+=pow((num[i]-b),2);\n }\n c/=a;\n c=sqrt(c);\n    cout<<fixed<<setprecision(2)<<c;\n  \n  return 0;\n}"
    },
    {
        "titulo": "4720. Divertidas Cadenas",
        "url": "https://omegaup.com/arena/problem/Divertidas-Cadenas/#problems",
        "descripcion": "A Ricardo no le gusta mucho leer, pero cuando lo hace disfruta leer cadenas donde no hay caracteres consecutivos iguales. Como no quiere aburrirse durante los sábados donde no hay Coding Rush ha decidido revisar cadenas de texto que se conforman únicamente de las letras A y B. Para Ricardo una cadena es aburrida cuando tiene caracteres consecutivos iguales y divertida en caso contrario. Para convertir todas las cadenas aburridas en divertidas sólo puede borrar letras. Tu tarea es determinar el número mínimo de letras a borrar para convertir una cadena en divertida.",
        "entrada": "Un número N indicando el número de cadenas que Ricardo va a leer. Después leerás N líneas.",
        "salida": "Para cada línea debes determinar el número mínimo de letras que Ricardo debe borrar para convertirla en una cadena divertida.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "long long",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n   cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  long long a, b;\n   string z;\n cin>>a;\n   while(a--){\n       cin>>z;\n       b=0;\n      for(auto i=1; i<z.size(); i++){\n            if(z[i]==z[i-1]){\n             b++;\n          }\n     }\n     cout<<b<<\"\\n\";\n }\n \n  return 0;\n}"
    },
    {
        "titulo": "3007. Divide Tres",
        "url": "https://omegaup.com/arena/problem/Divide-Tres/",
        "descripcion": "Un dato curioso sobre los números es que un número que es divisible entre tres, por ejemplo, 13707. Tiene la propiedad de que la suma de sus dígitos también es divisible entre tres, para éste caso en particular la suma es: 1+3+7+0+7=18, la cual es divisible entre tres. La UP (Unidad de Programadores) te pide que escribas un programa que indentifique si un número es divisible entre tres.",
        "entrada": "Un número n (1<=n<=10^1000)",
        "salida": "Imprimir \"SI es divisible\" en caso de que n sea divisible entre tres, en caso contrario imprimir \"NO es divisible\".",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "long long",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n   cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  long long b;\n  string z;\n cin>>z;\n   b=0;\n  for(auto i=0; i<z.size(); i++){\n       b+=(z[i]-48);\n }\n b%=3;\n if(b){\n        cout<<\"NO es divisible\";\n    }\n else{\n     cout<<\"SI es divisible\";\n    }\n \n  return 0;\n}"
    },
    {
        "titulo": "5525. Divide y sumarás",
        "url": "https://omegaup.com/arena/problem/Divide-y-sumaras/",
        "descripcion": "Dado un entero N, evalúa el valor de la suma [sum_{i=0}^{inf}floor(N/(2^i))]=floor(N/1)+floor(N/2)+floor(N/3)+floor(N/4)+... donde floor(N/(2^i)) es la parte entera de la división.",
        "entrada": "El entero N. Puedes suponer que 1<=N<=1000000",
        "salida": "Un entero que sea el valor de la suma.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Cálculos aritméticos",
            "Ciclos"
        ],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    int a, b=1, c=0;\n  cin>>a;\n   while(b<=a){\n      c=c+(a/b);\n        b=b*2;\n    }\n cout<<c;\n  \n  return 0;\n}"
    },
    {
        "titulo": "174. Divisibilidad",
        "url": "https://omegaup.com/arena/problem/divisibilidad/",
        "descripcion": "Es bien sabido que un número es divisible por 2 si y sólo si su último dígito (el menos significativo) es par. Un número es divisible por 3 si y sólo si la suma de sus dígitos es un múltiplo de 3. El criterio de divisibilidad por 7 es un poco más complicado: empezando por el último dígito, multiplicamos cada dígito de derecha a izquierda por 1,3,2,6,4,5,1,3,2,6,4,5,1,3,... y así sucesivamente hasta llegar al primer dígito, luego sumamos todos los productos y el número original es divisible por 7 si y sólo si la suma que obtuvimos es divisible por 7. En este problema, te daremos un entero positivo N que representa el número de dígitos que tiene el número, y te daremos también un número primo P. Tu trabajo es encontrar un criterio de divisibilidad por P para un número de N dígitos. Mas específicamente, debes asignar un factor a cada dígito tal que la suma de los productos de los dígitos por sus respectivos factores sea divisible por P si y sólo si el número de N dígitos es divisible por P. Para asegurarnos de que la solución sea única, vamos a agregar las siguientes condiciones: Todos los factores deben estar entre 0 Y P-1, inclusive. El factor para el último dígito debe ser siempre 1. El criterio de divisibilidad debe funcionar incluso si el número de N dígitos empieza con ceros. Escribe un programa que dados N y P, imprima los N factores asignados a los N dígitos, comenzando por el primer dígito (el de más a la izquierda).",
        "entrada": "En la primera linea los números N y P separados por un espacio.",
        "salida": "En la primera linea imprime los N factores asignados a los dígitos, de izquierda a derecha, separados por espacios.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Cálculo matemático"
        ],
        "estructuras": [
            "long long",
            "pow()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n   cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  long long a, b, c;\n    cin>>a>>b;\n    a--;\n  while(a){\n     c=pow(10,a);\n      c%=b;\n     cout<<c<<\" \";\n       a--;\n  }\n cout<<1;\n      \n  return 0;\n}"
    },
    {
        "titulo": "5221. La baraja de Andy",
        "url": "https://omegaup.com/arena/problem/La-baraja-de-Andy-c/",
        "descripcion": "Hace unos días, Andy estaba jugando cartas, al finalizar el juego le tocaba recogerlas, sin embargo se dio cuenta de que tiene N cartas en su baraja. Entonces ella se puso a pensar en cuántas formas distintas de ordenar la baraja había.",
        "entrada": "La primera linea con un número N indicando la cantidad de cartas que tiene su baraja.",
        "salida": "Un único número que exprese cuántas formas distintas de ordenar la baraja tiene.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Ciclos"
        ],
        "estructuras": [
            "unsigned long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    unsigned long long a, b=1;\n    cin>>a;\n    for(auto i=1; i<=a; i++){\n        b*=i;\n    }\n    cout<<b;\n\n    return 0;\n}"
    },
    {
        "titulo": "5584. Ahorrando Agua",
        "url": "https://omegaup.com/arena/problem/Ahorrando-Agua-ASINUS/",
        "descripcion": "Don Sabiniano se encuentra muy contento gracias a toda el agua que ha logrado ahorrar con su nuevo dispositivo que han creado los estudiantes del IPN. Ahora tiene que pensar en donde almacenará tanta agua que ha logrado ahorrar; por lo que decidió excavar unos ojos de agua. Don Sabiniano estuvo presente en la creación de cada ojo de agua y por lo tanto conoce como quedó cada uno, el terreno que los conforman y las irregularidades que tienen. Sin embargo, se le presenta una nueva problemática; el proceso de excavación ha sido muy rudimentario y la cantidad de agua que almacena cada ojo de agua es aparentemente incierta. Ayuda a Don Teodomiro a calcular la cantidad de agua que puede almacenar uno de estos ojos de agua. El agua ocupará aquel espacio disponible dentro del ojo de agua sin contar las secciones donde se encuentre alguna irregularidad.",
        "entrada": "El primer valor N que representa las secciones del ojo de agua, donde 3<=N<=10000. Los valores enteros subsecuentes k_1, k_2, ..., k_n representan las irregularidades de estas secciones, donde k>0 y (k_1=k_n)>0. Considera que un valor igual a 0 significa que en esa sección no existen irregularidades.",
        "salida": "La cantidad total de agua representada por cada unidad o espacio en la imagen con fondo azul.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Ciclos"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c=0, d;\n    cin>>a>>b;\n    for(auto i=1; i<a; i++){\n        cin>>d;\n        c+=b-d;\n    }\n    cout<<c;\n\n    return 0;\n}"
    },
    {
        "titulo": "5611. Lenguaje de la efe",
        "url": "https://omegaup.com/arena/problem/Lenguaje-de-la-efe-ASINUS/",
        "descripcion": "En uno de los episodios de los Simpsons, Bart y Lisa se encuentran peleado por el control de la televisión, al caer al piso la televisión sintoniza un programa para niños el cual parece agradar a la pequeña Maggie. Bart y Lisa intentan evitar que Marge deje a Maggie ver el show. Para conspirar entre ellos utilizan un lenguaje especial con el cual pretenden dejar a Marge fuera de la conversación. A pesar de sus esfuerzos Marge es muy lista y ya conoce cómo utilizar ese lenguaje. Sin embargo, no todos saben o conocen cómo hablar en ese misterioso lenguaje, por lo que te toca a ti; programador experto, ayudar al mundo a hablar como los hermanos Simpsons. En realidad, es bastantes sencillo, a cada palabra se le agrega una sílaba adicional dependiendo de las vocales que tenga: Si tiene 'a' se reemplaza por 'afa'. Si tiene 'e' se reemplaza por 'efe'. Si tiene 'i' se reemplaza por 'ifi'. Si tiene 'o' se reemplaza por 'ofo'. Si tiene 'u' se reemplaza por 'ufu'. Por ejemplo: La palabra Hola tiene dos vocales 'o' y 'a', se remplazará 'o' por 'ofo' y 'a' por 'afa', y el resultado es 'Hofolafa'.",
        "entrada": "Una línea de texto que será transformada al lenguaje misterioso de los hermanos Simpsons.",
        "salida": "La misma línea de texto de la entrada transformada.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas",
            "Ciclos"
        ],
        "estructuras": [
            "string",
            "getline()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    string z;\n    getline(cin,z);\n    for(auto i=0; i<z.size(); i++){\n        if(z[i]=='a'){\n            cout<<\"afa\";\n        }\n        else if(z[i]=='e'){\n            cout<<\"efe\";\n        }\n        else if(z[i]=='i'){\n            cout<<\"ifi\";\n        }\n        else if(z[i]=='o'){\n            cout<<\"ofo\";\n        }\n        else if(z[i]=='u'){\n            cout<<\"ufu\";\n        }\n        else{\n            cout<<z[i];\n        }\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "5515. Valles",
        "url": "https://omegaup.com/arena/problem/Valles/",
        "descripcion": "Los valles son pedazos de terreno rodeados por montañas. Dado el mapa de una isla escribe un programa que determine la cantidad de valles que existen en la isla. La isla se puede ver como una matriz de números enteros, donde las montañas son representadas con \"1\" y los terrenos planos con \"0\". Por lo que un valle es un 0 rodeado por 1's.",
        "entrada": "La primera línea contiene dos números n y m (1<=n,m<=20) indicando las dimensiones de la isla. Le siguen n líneas, cada una con m números separados por un espacio, indicando el mapa de la isla.",
        "salida": "La cantidad de valles en la isla.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Matrices",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "vector<vector<int>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c=0;\n    int num[22][22];\n    cin>>a>>b;\n    for(auto i=0; i<a; i++){\n        for(auto j=0; j<b; j++){\n            cin>>num[i][j];\n        }\n    }\n    a--;\n    b--;\n    for(auto i=1; i<a; i++){\n        for(auto j=1; j<b; j++){\n            if(num[i][j]==0 && num[i+1][j]==1 && num[i-1][j]==1 && num[i][j+1]==1 && num[i][j-1]==1){\n                c++;\n            }\n        }\n    }\n    cout<<c;\n    \n    return 0;\n}"
    },
    {
        "titulo": "7663. Picos y Valles",
        "url": "https://omegaup.com/arena/problem/Picos-y-Valles/",
        "descripcion": "El profesor MC se dió cuenta que en el paisaje de NLogonia hay un pico cada cien metros, y que siempre hay un valle en la mitad de la distancia entre dos picos. Esto significa que cada 50 metros hay un valle o un pico, a lo largo del paisaje, no puede haber un pico seguido de otro pico o dos valles consecutivos.",
        "entrada": "La entrada viene en dos líneas. La primera tiene el número N de mediciones del paisaje (1 < N <= 100). La segunda línea tiene N enteros: la altura Hi de cada medición (-10000 <= Hi <= 10000, para todo Hi, tal que 1 <= i <= N). Una medida se considera un pico si es más alto que la medida previa, y una medida se considera un valle si es más bajo que la medida previa.",
        "salida": "La salida consiste de una única línea. Si el paisaje tiene el mismo patrón que el paisaje de NLogonia se debe mostrar el número 1, en otro caso se debe mostrar el número 0.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores",
            "Ciclos"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e;\n    cin>>a;\n    if(a==1){\n        cin>>a;\n        cout<<1;return 0;\n    }\n    if(a==2){\n        cin>>a>>a;\n        cout<<1;return 0;\n    }\n    cin>>b>>c;\n    if(c==b){\n        d=0;\n    }\n    if(c>b){\n        e=1;\n    }\n    else{\n        e=0;\n    }\n    for(auto i=3; i<=a; i++){\n        b=c;\n        cin>>c;\n        e++;\n        e%=2;\n        if(c>b && e==0){\n            d=0;\n        }\n        if(b>c && e){\n            d=0;\n        }\n    }\n    cout<<d;\n    \n    return 0;\n}"
    },
    {
        "titulo": "4674. Reverse String",
        "url": "https://omegaup.com/arena/problem/Reverse-String/",
        "descripcion": "Uno de los voluntarios del CodingRush, Gildardo, le gusta ir a fiestas locas, sin embargo sus papás lo han regañado ya que constantemente termina muy mal. A pesar de lo que dijeron sus padres, Gildardo ha ido a una fiesta el último fin de semana y sus amigos, para ver que tan mal estaba le han dicho que dijera una palabra al revés. Ayuda a Gildardo a voltear la palabra que le digan sus amigos.",
        "entrada": "Primera y Única Linea: S, La cadena de texto que Gildardo tiene que invertir",
        "salida": "El String invertido",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Ciclos",
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);;\n    string z;\n    cin>>z;\n    for(auto i=z.size()-1; i>=0; i--){\n        cout<<z[i];\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "8422. COME GALLETAS",
        "url": "https://omegaup.com/arena/problem/COME-GALLETAS/",
        "descripcion": "A Pedro le gustan mucho las galletas y siempre va a comprar a la tienda de la esquina, cada paquete contiene 10 galletas, pero como el es un comprador frecuente, el vendedor le regala galletas cada numero par como lo muestra la siguiente secuencia: 10,11,10,12,10,13. son el ejemplo de galletas que contendría cada paquete si Pedro comprase 6. Ayuda a pedro a encontrar las galletas totales que compraría.",
        "entrada": "En una linea escribe el numero de paquetes de galletas que Pedro comprara.",
        "salida": "La salida contendrá la cantidad de galletas que pedro compro incluyendo las que le fueron regaladas.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "long double"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long double a, b=0;\n    cin>>a;\n    b+=(a*10);\n    a/=2;\n    b+=(((a+1)*a)/2);\n    cout<<b;\n\n    return 0;\n}"
    },
    {
        "titulo": "8429. TROCAS",
        "url": "https://omegaup.com/arena/problem/TROCAS/",
        "descripcion": "En la preparatoria CBTIS 217, se organizo una excursión. pero para ello, los maestras decidieron contratar trocas en lugar de un autobús y formar grupos de alumnos de cantidades indefinidas. tu misión sera repartir a todos los alumnos a un autobús, la única condición es que no se puedan separar grupos.",
        "entrada": "En una sola linea coloca el numero de integrantes de cada grupo, separados por un espacio.",
        "salida": "El numero de trocas necesario para transportar a todos los alumnos. A cada troca le caben máximo 6 alumnos.",
        "nivel": "Intermedio (medio) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Vectores",
            "Ordenamiento",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c = 0, d = 0, e = 0, f = 0;\n    vector<int> falta;\n    while (cin >> a)\n    {\n        falta.push_back(a);\n    }\n    sort(falta.begin(), falta.end());\n    if (falta[0] == 6)\n    {\n        cout << falta.size();\n        return 0;\n    }\n    a = 0;\n    b = falta.size() - 1;\n    while (b != a && falta[b] == 6)\n    {\n        c++;\n        b--;\n    }\n    while (falta[a] == 1 && falta[b] == 5)\n    {\n        c++;\n        a++;\n        b--;\n    }\n    if (a > b)\n    {\n        cout << c;\n        return 0;\n    }\n    while (falta[a] == 1)\n    {\n        d++;\n        a++;\n    }\n    if (a > b)\n    {\n        c += (d / 6);\n        d %= 6;\n        if (d)\n        {\n            c++;\n        }\n        cout << c;\n        return 0;\n    }\n    while (falta[b] == 5)\n    {\n        c++;\n        b--;\n    }\n    if (a > b)\n    {\n        cout << c;\n        return 0;\n    }\n    while (falta[a] == 2 && falta[b] == 4)\n    {\n        c++;\n        a++;\n        b--;\n    }\n    if (a > b)\n    {\n        c += (d / 6);\n        d %= 6;\n        if (d)\n        {\n            c++;\n        }\n        cout << c;\n        return 0;\n    }\n    while (falta[b] == 4 && d >= 2)\n    {\n        d -= 2;\n        b--;\n        c++;\n    }\n    if (a > b)\n    {\n        c += (d / 6);\n        d %= 6;\n        if (d)\n        {\n            c++;\n        }\n        cout << c;\n        return 0;\n    }\n    while (falta[b] == 4)\n    {\n        b--;\n        c++;\n    }\n    if (a > b)\n    {\n        c += (d / 6);\n        d %= 6;\n        if (d)\n        {\n            c++;\n        }\n        cout << c;\n        return 0;\n    }\n    while (falta[a] == 2)\n    {\n        f++;\n        a++;\n    }\n    if (a > b)\n    {\n        c += (f / 3);\n        f %= 3;\n        if (f)\n        {\n            d += (f * 2);\n        }\n        c += (d / 6);\n        d %= 6;\n        if (d)\n        {\n            c++;\n        }\n        cout << c;\n        return 0;\n    }\n    while (falta[b] == 3)\n    {\n        b--;\n        e++;\n    }\n    c += (e / 2);\n    e %= 2;\n    if (e && f && d)\n    {\n        f--;\n        d--;\n        c++;\n        e--;\n    }\n    if (e && f)\n    {\n        f--;\n        e--;\n        c++;\n    }\n    if (e && d)\n    {\n        if (d <= 3)\n        {\n            d = 0;\n        }\n        else\n        {\n            d -= 3;\n        }\n        e--;\n        c++;\n    }\n    if (e)\n    {\n        c++;\n        e--;\n    }\n    c += (d / 6);\n    d %= 6;\n    if (d)\n    {\n        c++;\n    }\n    cout << c;\n\n    return 0;\n}"
    },
    {
        "titulo": "7412. Promedios en intervalos",
        "url": "https://omegaup.com/arena/problem/Promedios-en-intervalos/",
        "descripcion": "Dado un registro de alumnos donde cada uno tiene un número de lista y una calificación, escribe un programa que pueda resolver la siguiente pregunta: ¿cuál es el promedio entero de las calificaciones de los alumnos cuyos números de lista están entre I y U inclusivos?",
        "entrada": "Un entero N seguido de N parejas de enteros L, C donde L es el número de lista de un alumno y C es su calificación. Posteriormente un entero M seguido de M parejas de enteros I y U. Puedes suponer que 0<=N<=10^5, que 0<=M, que, 0<=L<=10^9, que 0<=I<=U<N y que no hay números de lista repetidos, aunque puede haber números de lista faltantes.",
        "salida": "Para cada intervalo, un entero que sea el promedio entero de las calificaciones de los alumnos con números de lista en ese intervalo o bien, el entero -1 si no hay alumnos en ese intervalo.",
        "nivel": "Intermedio (difícil) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Búsqueda binaria",
            "Ordenamiento",
            "Ciclos",
            "Suma de prefijos"
        ],
        "estructuras": [
            "long long",
            "vector<pair<int, int>>",
            "auto"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e, f, g, h, l;\n    vector<pair<int, int>> num(100001);\n    cin >> a;\n    for (auto i = 0; i < a; i++)\n    {\n        cin >> num[i].first >> num[i].second;\n    }\n    sort(num.begin(), num.end());\n    for (auto i = 1; i < a; i++)\n    {\n        num[i].second += num[i - 1].second;\n    }\n    cin >> b;\n    while (b--)\n    {\n        cin >> c >> d;\n        c--;\n        if (d < num[0].first || c >= num[a - 1].first)\n        {\n            cout << \"-1\\n\";\n            continue;\n        }\n        e = 0;\n        f = a - 1;\n        l = -1;\n        while (e <= f)\n        {\n            g = (e + f) / 2;\n            if (num[g].first == d)\n            {\n                l = g;\n                break;\n            }\n            else if (num[g].first < d)\n            {\n                e = g + 1;\n                l = max(l, g);\n            }\n            else\n            {\n                f = g - 1;\n            }\n        }\n        if (c < num[0].first)\n        {\n            cout << num[l].second / (l + 1) << \"\\n\";\n            continue;\n        }\n        e = 0;\n        f = a - 1;\n        h = -1;\n        while (e <= f)\n        {\n            g = (e + f) / 2;\n            if (num[g].first == c)\n            {\n                h = g;\n                break;\n            }\n            else if (num[g].first < c)\n            {\n                e = g + 1;\n                h = max(h, g);\n            }\n            else\n            {\n                f = g - 1;\n            }\n        }\n        if (h == l)\n        {\n            cout << \"-1\\n\";\n            continue;\n        }\n        cout << (num[l].second - num[h].second) / (l - h) << \"\\n\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "8464. SUMAR HORAS (ETITC)",
        "url": "https://omegaup.com/arena/problem/SUMAR-HORAS-ETITC/",
        "descripcion": "Haga un programa que reciba dos horas en formato hh mm y que dé como respuesta la hora resultante de sumar las dos horas en ese formato. Las horas estarán entre 0 y 23 y los minutos entre 0 y 59.",
        "entrada": "Se ingresa el primer formato de hora minuto y posteriormente el segundo formato hora minuto.",
        "salida": "Como salida debe mostrar la suma de las dos horas.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d;\n    cin >> a >> b >> c >> d;\n    b += d;\n    if (b >= 60)\n    {\n        b -= 60;\n        a++;\n    }\n    a += c;\n    if (a >= 24)\n    {\n        a -= 24;\n    }\n    cout << a << \" \" << b;\n\n    return 0;\n}"
    },
    {
        "titulo": "847. Suma de 3 números",
        "url": "https://omegaup.com/arena/problem/Suma-de-3-numeros/",
        "descripcion": "",
        "entrada": "Recibe tres números enteros.",
        "salida": "Retorna el total de la suma de los 3 números",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Cálculos aritméticos"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c;\n    cin >> a >> b >> c;\n    cout << a + b + c;\n\n    return 0;\n}"
    },
    {
        "titulo": "6593. Los focos",
        "url": "https://omegaup.com/arena/problem/Los-focos/",
        "descripcion": "Se tienen n focos apagados, cada uno tiene su interruptor, una persona pasa y cambia el interruptor de todos los focos, una segunda persona pasa y cambia los interruptores de los focos 2, 4, 6, 8, etc. Hasta n, una tercera persona pasa y cambia los interruptores de 3, 6, 9, 12, etc... hasta n, una cuarta persona pasa y cambia los interruptores 4, 8, 12...etc y así sucesivamente hasta la persona n. Dado n, determina que interruptores quedan prendidos. Para 50 puntos 1<=n<=1000. Para 50 puntos 1<=n<=1000000000",
        "entrada": "Un entero n.",
        "salida": "El número de cada uno de los focos que quedan prendidos, separados por un salto de linea.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Ciclos"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b = 1;\n    cin >> a;\n    while (true)\n    {\n        if ((b * b) <= a)\n        {\n            cout << b * b << \"\\n\";\n        }\n        else\n        {\n            break;\n        }\n        b++;\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "4745. Glorietas Campechanas",
        "url": "https://omegaup.com/arena/problem/OMICAMP-Glorietas-Campechanas/",
        "descripcion": "El gobierno del estado de Campeche, manda cada cierto tiempo a podar las áreas verdes de las glorietas que están en toda la ciudad, para ello cuenta con muchos trabajadores, cada uno de ellos tiene su monto a cobrar por metro cuadrado de las áreas verdes, el problema que tiene el gobierno del estado es que no conoce el área circular de las glorietas, pero si conoce los radios. El radio N que abarcan desde el punto central de la glorieta hasta la orilla de la misma y el radio M que abarca desde el punto central hasta la orilla donde comienza las zonas verdes de la glorieta. Considerando que el radio N siempre va a hacer mayor que el radio M  El gobierno del estado de Campeche te contrata para calcular el monto a pagar por una glorieta contemplando que S es el precio por metro cuadrado que cobra un trabajador y los radios N y M que conoce el gobierno de las glorietas. Tu deber es crear un programa que calcule el monto a pagar por cada glorieta. Considerar que 1<=S<=1000000 y 0<=M<N<=1000000.",
        "entrada": "De entrada recibirás el costo S por metro cuadro, seguido de los radios N y M.",
        "salida": "Tu programa debe imprimir el monto que hay que pagar con dos decimales después del punto, por la glorieta a podar",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "unsigned long long",
            "long double",
            "pow()",
            "fixed",
            "setprecision()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    unsigned long long a, b, c, d;\n    long double z;\n    cin >> a >> b >> c;\n    d = ((pow(b, 2) * 31416) - (pow(c, 2) * 31416)) * a;\n    cout << fixed << setprecision(2) << \"$\";\n    if (d / 100000)\n        cout << d / 100000;\n    d %= 100000;\n    z = (long double)d / 10000;\n    cout << fixed << setprecision(2) << z;\n\n    return 0;\n}"
    },
    {
        "titulo": "5409. Barajeo de Cartas",
        "url": "https://omegaup.com/arena/problem/Shuffling-Cards-ASINUS/",
        "descripcion": "Charles y William han sido amigos desde ya hace un tiempo, ellos son conocidos por su espíritu competitivo. Cada fin de semana se reúnen para jugar cartas, y a pesar de ser buenos amigos, durante los juegos ninguno quiere perder. Usualmente discuten sobre la manera en la que las cartas son barajeadas, Charles diciendo que William siempre hace trampa porque el obtiene las mejores cartas al final de cada juego, mientras que William dice que Charles simplemente no es tan bueno. Ahora, es tu turno de ayudarlos con este pequeño problema, te toca a ti barajear las cartas. Cada una de las cartas serán representadas por un número entero (k), estas deberán ser barajeadas teniendo dos grupos o sets (s1, s2), y cada uno debe contener el mismo número de cartas (n). Para obtener la pila barajeada final, una carta de cada set o grupo deberá ser tomada, comenzando con una carta del primer conjunto y luego una del segundo conjunto, y continuando hasta que no haya alguna carta sobrante de los sets originales.",
        "entrada": "El número de cartas de cada set o mano dado por n. Cada una de las cartas k representadas por enteros.",
        "salida": "La pila final barajeada a partir de las cartas de las dos manos originales.",
        "nivel": "Intermedio (medio) - Análisis y diseño de algoritmos",
        "categorias": [
            "Ciclos",
            "Vectores"
        ],
        "estructuras": [
            "long long",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b;\n    vector<int> falta;\n    vector<int> faltas;\n    cin >> a;\n    for (auto i = 0; i < a; i++)\n    {\n        cin >> b;\n        falta.push_back(b);\n    }\n    for (auto i = 0; i < a; i++)\n    {\n        cin >> b;\n        faltas.push_back(b);\n    }\n    for (auto i = 0; i < a; i++)\n    {\n        cout << falta[i] << \" \" << faltas[i] << \" \";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "8375. Las cemitas programadoras",
        "url": "https://omegaup.com/arena/problem/Las-cemitas-programadoras/",
        "descripcion": "La crisis en el país esta fea y nuestro amigo Eduardo tiene que poner un negocio para poder vivir mas o menos bien. Como el vive en Puebla, puso un negocio de ricas cemitas caseras el cual empezó a recibir gente rápidamente. Lamentablemente se dio cuenta que los gastos eran bastantes entre las cemitas, las milanesas, el quesillo, el aguacate y el odioso papalo que nadie quiere y se cuestiono si el negocio iba a funcionar. Eduardo tiene anotado las ganancias y las perdidas pero no tiene tiempo para hacer las cuentas porque tiene que atender el changarro, asi que te pide tu ayuda para saber si el negocio es viable o no. Se te va a otorgar A y B donde A es el valor de las ganancias y B el valor de las perdidas y tu tendrás que determinar si el negocio va bien o mal.",
        "entrada": "A seguida de B.",
        "salida": "Si las ganancias superan las perdidas tendrás que imprimir sin comillas \"El negocio si va a jalar\" y después el valor de las ganancias. De lo contrario si las perdidas son mas grandes que las ganancias deberás imprimir sin comillas \"Dejalo ya esta muerto\" y después el valor de las perdidas.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Cálculos aritméticos"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b;\n    cin>>a>>b;\n    if(a>b){\n        cout<<\"El negocio si va a jalar \"<<a-b;\n    }\n    else{\n        cout<<\"Dejalo ya esta muerto \"<<b-a;\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "2648. Gastos",
        "url": "https://omegaup.com/arena/problem/Gastos/",
        "descripcion": "Dada una lista de gastos, calcula e imprime el total gastado y cuantos gastos se totalizaron.",
        "entrada": "Una línea con la lista de gastos, todos los enteros correspondientes a los gastos se separan con un espacio. Asume que la lista de gastos termina cunado se lee un cero.",
        "salida": "Dos enteros M, N separados por un espacio que denotan el total gastado y el número de gastos totalizados, respectivamente.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Ciclos",
            "Cálculos aritméticos",
            "Matrices"
        ],
        "estructuras": [
            "long long",
            "vector<vector<int>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b=0, c=0;\n    int num[1001][1001];\n    cin>>a;\n    while(a){\n        c+=a;\n        b++;\n        cin>>a;\n    }\n    cout<<c<<\" \"<<b;\n    \n    return 0;\n}"
    },
    {
        "titulo": "5074. Que fácil es dar cambio",
        "url": "https://omegaup.com/arena/problem/Que-facil-es-dar-cambio-emh/",
        "descripcion": "Atsa acaba de abrir una tienda de abarrotes en medio de la ciudad; después de unos días se dio cuenta que la cantidad de clientes que tenía era demasiada. Cierto día se dispuso a analizar cual podría ser la razón por la cual siempre tenía mucha clientela y se di cuenta que el problema no era que hubiera mucha gente sino que él tardaba mucho en dar el cambio, es decir, que cuando un cliente le pagaba el tardaba mucho en regresarle su cambio. Como Atsa quiere mejorar esta labor, decidió cambiar su forma de hacerlo. En la ciudad solo hay monedas de $10, $5, $2 y de $1 pesos; la nueva forma de dar el cambio será dar tantas monedas de $10 como sea posible, si hace falta dar más cambio dará la mayor cantidad de monedas de $5 que sea posible, si nuevamente es necesario dar cambio dará la mayor cantidad de monedas de $2 pesos y finalmente hará lo mismo con la moneda de $1.",
        "entrada": "Una única linea que contiene un número entero C que representa la cantidad en pesos que debe dar de cambio. (0<=N<=x^10)",
        "salida": "Una única línea con cuatro números separados por espacio que representen la cantidad de monedas de $10, $5, $2 y $1 respectivamente que debe dar para la cantidad de C.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Aritmética",
            "Condicionales"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a;\n    cin>>a;\n    cout<<a/10<<\" \"<<(a%10)/5<<\" \"<<((a%10)%5)/2<<\" \"<<(((a%10)%5)%2);\n    \n    return 0;\n}"
    },
    {
        "titulo": "8418. Probabilidad",
        "url": "https://omegaup.com/arena/problem/Probabilidad/",
        "descripcion": "En un pueblo llamado Moroleón. se organizo una rifa, en la cual Pedro y Jorge compraron una cantidad determinada de boletos. Si se sabe cual es la cantidad que se vendieron en total de boletos. ¿Puedes ayudarlos a sacar su probabilidad de ganar la rifa?.",
        "entrada": "La primera linea contendrá la cantidad de boletos comprados por jorge y pedro. y la segunda los boletos totales.",
        "salida": "La salida contendrá la probabilidad de ganar con solamente 2 números después del punto decimal.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "long double",
            "fixed",
            "setprecision()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long double a, b, c;\n    cin>>a>>b;\n    c=(100/b)*a;\n    cout<<fixed<<setprecision(2)<<\"La probabilidad es de %\"<<c;\n\n    return 0;\n}"
    },
    {
        "titulo": "5822. Raíces de un polinomio de segundo grado",
        "url": "https://omegaup.com/arena/problem/raices-p2/",
        "descripcion": "Anita está en su primer curso de programación, quiere combinar sus habilidades de programación y matemáticas. En esta ocasión le han pedido que calcule las raíces de polinomios de segundo grado usando la fórmula cuadrática. r+ = (-b + sqrt(b^2 - 4ac)) / (2a) y r- = (-b + sqrt(b^2 - 4ac)) / (2a). Anita únicamente está practicando con problemas en que existen las raíces son valores reales.",
        "entrada": "Recibirás tres valores reales, que corresponden a los coeficientes de un polinomio de segundo grado: a, b y c. Todas las soluciones estarán en el dominio de los reales.",
        "salida": "Mostrar los valores de las raíces para cada polinomio de entrada recibido en la entrada.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "long double",
            "sqrt()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long double a, b, c, d, e;\n    cin>>a>>b>>c;\n    d=(((-1)*b)+sqrt(pow(b,2)-(4*a*c)))/(2*a);\n    e=(((-1)*b)-sqrt(pow(b,2)-(4*a*c)))/(2*a);\n    cout<<fixed<<setprecision(4)<<\"Root +: \"<<d<<\"\\nRoot -: \"<<e;\n    \n    return 0;\n}"
    },
    {
        "titulo": "5821. Área de un triángulo",
        "url": "https://omegaup.com/arena/problem/area-triangulo-inout/",
        "descripcion": "En la escuela a Carlitos le han enseñado a calcular el área de un triángulo usando los valores de los lados. La maestra le ha indicado que lo primero que debe calcular es el valor: (S = (L1 + L2 + L3) / 2). El siguiente paso es aplicar la fórmula para calcular el área. area = (sqrt(s * (s - L1) * (s - L2) * (s - L3))). Carlitos está empezando sus cursos, por ello te pide que le apoyes escribiendo un programa que permita verificar si está haciendo bien sus cálculos.",
        "entrada": "Recibirás 3 valores de tipo real. Estos lados corresponden siempre a un triángulo válido. Los valores de entrada para cada lado son reales positivos mayores a 0 y menores a 20,000. Todas las entradas forman triángulos válidos.",
        "salida": "Mostrar cada uno de los lados leídos en la entrada y el área del triángulo. Considera 15 caracteres para imprimir cada número y cuatro decimales. Los detalles puedes consultarlos en los ejemplos.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "long double",
            "fixed",
            "setprecision()",
            "sqrt()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long double a, b, c, d, e;\n    cin>>a>>b>>c;\n    d=(a+b+c)/2;\n    e=sqrt(d*(d-a)*(d-b)*(d-c));\n    cout<<fixed<<setprecision(4)<<\"Side 1: \"<<a<<\"\\nSide 2: \"<<b<<\"\\nSide 3: \"<<c<<\"\\nArea : \"<<e;\n    \n    return 0;\n}"
    },
    {
        "titulo": "8347. 0 fortnite vs minecraft",
        "url": "https://omegaup.com/arena/problem/fvm/",
        "descripcion": "Habia una ves un niño que se llamaba Jesus, el jugaba mucho al minecraft, pero luego salio el fortnite, ese niño no tenia amigos, por que estaba todo el dia jugando o fortnite o minecraft, pero ese niño quiere saber en cuantos años va a tener su primera novia, ya que cada dia que juegue uno de estos juegos, aumentan los años en los que no tendra novia de esta manera: 1 dia de minecraft=4.27 años sin novia, 1 dia de fortnite=2.91 años sin novia.",
        "entrada": "linea 1: un entero que dice cuantos dias Jesus a jugado al mincecraft, linea 2: un entero que dice cuantos dias jugo al fortnite. jesus no es tan rata y no puede jugar mas de 1 000 000 dias en total.",
        "salida": "el numero exacto de cuantos años jesus no va a tener novia en el siguiente formato [jesus no va a tener novia por X anos] o en el caso de que no haya jugado a ninguno imprime [jesus va a ser feliz].",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "long double"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long double a, b, c;\n    cin>>a>>b;\n    c=(a*4.27)+(b*2.91);\n    if(c){\n        cout<<\"jesus no va a tener novia por \"<<c<<\" anos\";\n    }\n    else{\n        cout<<\"jesus va a ser feliz\";\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "5421. AnagramValidator",
        "url": "https://omegaup.com/arena/problem/AnagramValidator/",
        "descripcion": "Un anagrama de una frase es otra frase que contiene las mismas letras que la original, pero con las letras en diferente orden. Dadas dos frases, decidir si son anagramas una de la otra.",
        "entrada": "Dos líneas, cada una conteniendo una frase compuesta por letras y símbolos de puntuación.",
        "salida": "La frase \"Son anagramas\" si las dos frases son anagramas. La frase \"No son anagramas\" si las dos frases no son anagramas",
        "nivel": "Básico (difícil) - Introducción a la programación",
        "categorias": [
            "Vectores",
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "int",
            "string",
            "getline()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int num[30];\n    string z;\n    getline(cin,z);\n    for(auto i=0; i<z.size(); i++){\n        if(z[i]>='a' && z[i]<='z'){\n            num[z[i]-97]++;\n        }\n        else if(z[i]>='A' && z[i]<='Z'){\n            num[z[i]-65]++;\n        }\n    }\n    getline(cin,z);\n    for(auto i=0; i<z.size(); i++){\n        if(z[i]>='a' && z[i]<='z'){\n            num[z[i]-97]--;\n        }\n        else if(z[i]>='A' && z[i]<='Z'){\n            num[z[i]-65]--;\n        }\n    }\n    for(auto i=0; i<30; i++){\n        if(num[i]!=0){\n            cout<<\"No son anagramas\";return 0;\n        }\n    }\n    cout<<\"Son anagramas\";\n    \n    return 0;\n}\n"
    },
    {
        "titulo": "1301. Números Libres",
        "url": "https://omegaup.com/arena/problem/Numeros-Libres/",
        "descripcion": "Dados dos números square-free a y b, determina si su producto también es square-free. Decimos que un número x es square-free si para todo primo p, p^2 no divide a x. Por ejemplo, 6 es square free porque el cuadrado de ningún primo lo divide. En cambio, 12 sí, porque 2^2 = 4 sí lo divide.",
        "entrada": "En la primera linea contiene un entero N el numero de casos a resolver. En las siguientes N lineas, dos numeros enteros a y b. (1<=N<=15 y 1<=a,b<=1000) 30 puntos, (1<=N<=500 y 1<=a,b<= 2^31) 30 puntos y (1<=N<=500 y 1<= a,b<=2^63) 40 puntos.",
        "salida": "Para cada caso de prueba, decir \"SI\" (sin comillas) si el producto de a y b es square-free, de caso contrario \"NO\" (sin comillas).",
        "nivel": "Intermedio (medio) - Matemáticas en la programación",
        "categorias": [
            "Aritmética",
            "Ciclos",
            "Prueba de primalidad",
            "Generación primaria"
        ],
        "estructuras": [
            "long long",
            "__gcd()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d;\n    cin>>a;\n    while(a--){\n        cin>>b>>c;\n        d=__gcd(b,c);\n        if(d<=1){\n            cout<<\"SI\\n\";\n        }\n        else{\n            cout<<\"NO\\n\";\n        }\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "909. Capturando al gato",
        "url": "https://omegaup.com/arena/problem/L-OMI2011-Capturando-al-gato/",
        "descripcion": "Homero Simpson y su equipo de zorros (agentes secretos) se han dado a la tarea de capturar al criminal internacional conocido como el gato. El plan de Homero es crear un cerco de vigilancia alrededor del Museo de Springfield, próximo objetivo del criminal. Si se traza un círculo alrededor del museo existen N lugares adecuados para que un zorro ponga su puesto de vigilancia. Homero quiere poner el máximo número de zorros posibles alrededor del Museo, sin embargo hay una limitante. El método de comunicación entre los zorros (inventado por el mismo Homero) es el teléfono de hilo. Este teléfono consta de dos vasos unidos por un hilo el cual debe estar tenso para que funcione. El círculo de zorros estará comunicado por teléfonos de la siguiente forma: cada zorro tendrá dos teléfonos, uno para comunicarse con el zorro a su derecha y otro para comunicarse con el zorro a su izquierda. Para que la comunicación sea funcional, el círculo deberá estar cerrado. Homero no es un buen ingeniero y aunque puede hacer muchos teléfonos, requiere que el hilo de todos tenga la misma longitud. Ayuda a Homero a determinar cuál es el máximo número de zorros que puede colocar alrededor del Museo de modo que todos estén comunicados por teléfonos cuyo hilo sea de la misma longitud.",
        "entrada": "En la primera línea el número N, la cantidad de posiciones posibles para zorros En las siguientes N líneas un entero d_i que representa la distancia que hay entre el puesto i y el puesto i+1. El entero en la última de estas líneas representa la distancia del último puesto hacia el primero para cerrar el círculo. (1 <= N <= 5000) y (1<= sum(di, i=1 to N) <= 2 * 10^9). Subtask 1 (75%): (0<N<=10^3) y los casos no están agrupados. Subtask 2 (25%): No hay restricciones adicionales.",
        "salida": "Tu programa debe escribir a la pantalla un único número entero que representa la cantidad máxima de zorros que se pueden colocar.",
        "nivel": "Intermedio (fácil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Vectores",
            "Pilas",
            "Implementación"
        ],
        "estructuras": [
            "long long",
            "stack<int>",
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long a, b=0, c=0, d, e=1, f;\nint num[5001];\nstack<int>falta;\n\nint sub(int x){\n    int y=0, z=0;\n    for(int i=x; i<a; i++){\n        y+=num[i];\n        if(y==e){\n            z++;\n            y=0;\n        }\n        else if(y>e){\n            return 0;\n        }\n    }\n    for(int i=0; i<x; i++){\n        y+=num[i];\n        if(y==e){\n            z++;\n            y=0;\n        }\n        else if(y>e){\n            return 0;\n        }\n    }\n    \n    return z;\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    cin>>a;\n    for(int i=0; i<a; i++){\n        cin>>num[i];\n        b=max(b,(long long)num[i]);\n        c+=num[i];\n    }\n    while(e<sqrt(c)){\n        if(c%e==0){\n            falta.push(c/e);\n            if(e>=b){\n                d=0;\n                f=0;\n                for(int i=0; i<a; i++){\n                    d+=num[i];\n                    if(d==e){\n                        f++;\n                        d=0;\n                    }\n                    else if(d>e){\n                        f=-1;break;\n                    }\n                }\n                if(f!=-1){\n                    cout<<f;return 0;\n                }\n                d=0;\n                f=0;\n                for(int i=1; i<a; i++){\n                    d+=num[i];\n                    if(d==e){\n                        f++;\n                        d=0;\n                    }\n                    else if(d>e){\n                        f=-1;break;\n                    }\n                }\n                if(f!=-1){\n                    d+=num[0];\n                    if(d==e){\n                        f++;\n                        cout<<f;return 0;\n                    }\n                }\n                for(int j=2; j<=7; j++){\n                    f=sub(j);\n                    if(f){\n                        cout<<f;return 0;\n                    }\n                }\n            }\n        }\n        e++;\n    }\n    e=sqrt(c);\n    if((e*e)==c && e>=b){\n        d=0;\n        f=0;\n        for(int i=0; i<a; i++){\n            d+=num[i];\n            if(d==e){\n                f++;\n                d=0;\n            }\n            else if(d>e){\n                f=-1;break;\n            }\n        }\n        if(f!=-1){\n            cout<<f;return 0;\n        }\n        d=0;\n        f=0;\n        for(int i=1; i<a; i++){\n            d+=num[i];\n            if(d==e){\n                f++;\n                d=0;\n            }\n            else if(d>e){\n                f=-1;break;\n            }\n        }\n        if(f!=-1){\n            d+=num[0];\n            if(d==e){\n                f++;\n                cout<<f;return 0;\n            }\n        }\n        for(int j=2; j<=7; j++){\n            f=sub(j);\n            if(f){\n                cout<<f;return 0;\n            }\n        }\n    }\n    while(falta.size()!=1){\n        e=falta.top();\n        falta.pop();\n        if(e>=b){\n            d=0;\n            f=0;\n            for(int i=0; i<a; i++){\n                d+=num[i];\n                if(d==e){\n                    f++;\n                    d=0;\n                }\n                else if(d>e){\n                    f=-1;break;\n                }\n            }\n            if(f!=-1){\n                cout<<f;return 0;\n            }\n            d=0;\n            f=0;\n            for(int i=1; i<a; i++){\n                d+=num[i];\n                if(d==e){\n                    f++;\n                    d=0;\n                }\n                else if(d>e){\n                    f=-1;break;\n                }\n            }\n            if(f!=-1){\n                d+=num[0];\n                if(d==e){\n                    f++;\n                    cout<<f;return 0;\n                }\n            }\n            for(int j=2; j<=7; j++){\n                f=sub(j);\n                if(f){\n                    cout<<f;return 0;\n                }\n            }\n        }\n    }\n    cout<<1;\n\n    return 0;\n}"
    },
    {
        "titulo": "5287. El ratón que salta chueco",
        "url": "https://omegaup.com/arena/problem/El-raton-que-salta-chueco/",
        "descripcion": "Un ratón tiene lastimada su patita izquierda pero debe llegar a su madriguera lo más rápido posible antes de que el gato aparezca. La casa en la que viven los ratones y el gato es de dimensiones M x N, el ratón se encuentra actualmente en la posición (R_i,R_j) y la madriguera está en la posición (H_i,H_j). Como al ratón le cuesta trabajo caminar, sólo puede ejecutar cierto tipo de salto que lo desplaza simultáneamente F unidades al frente y D unidades a la derecha.  El ratón debe evitar chocar contra las paredes de la casa pero puede orientarse en cualquiera de las cuatro direcciones cardinales antes de dar cada salto. Escribe un programa que calcule cuál es la cantidad mínima de saltos que el ratón necesita para llegar a la madriguera.",
        "entrada": "Los ocho enteros M, N, F, D, R_i, R_j, H_i, H_j. Puedes suponer que 1<=M,N,F,D<=1000, 0<=R_i,H_i<M y 0<=R_j,H_j<N",
        "salida": "Un entero que sea la mínimo número de saltos que necesita dar el ratón para llegar a la madriguera o el entero -1 si no existe solución.",
        "nivel": "Intermedio (fácil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Búsqueda en amplitud",
            "Colas",
            "Matrices",
            "Ciclos"
        ],
        "estructuras": [
            "int",
            "struct",
            "long long",
            "vector<vector<int>>",
            "queue<struct>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct sobra{\n    int aa, bb, cc;\n};\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d;\n    vector<vector<int>>num(1001,vector<int>(1001,0));\n    queue<sobra>falta;\n    sobra z;\n    cin>>a>>b>>c>>d>>z.aa>>z.bb>>g>>h;\n    num[z.aa][z.bb]=1;\n    falta.push(z);\n    if(z.aa==g && z.bb==h){\n        cout<<\"0\";return 0;\n    }\n    while(falta.size()){\n        z=falta.front();\n        falta.pop();\n        z.cc++;\n        z.aa-=c;\n        z.bb+=d;\n        if(z.aa>=0 && z.aa<a && z.bb>=0 && z.bb<b && num[z.aa][z.bb]==0){\n            if(z.aa==g && z.bb==h){\n                cout<<z.cc;return 0;\n            }\n            num[z.aa][z.bb]=1;\n            falta.push(z);\n        }\n        z.aa+=c;\n        z.bb-=d;\n        z.bb+=c;\n        z.aa+=d;\n        if(z.aa>=0 && z.aa<a && z.bb>=0 && z.bb<b && num[z.aa][z.bb]==0){\n            if(z.aa==g && z.bb==h){\n                cout<<z.cc;return 0;\n            }\n            num[z.aa][z.bb]=1;\n            falta.push(z);\n        }\n        z.bb-=c;\n        z.aa-=d;\n        z.aa+=c;\n        z.bb-=d;\n        if(z.aa>=0 && z.aa<a && z.bb>=0 && z.bb<b && num[z.aa][z.bb]==0){\n            if(z.aa==g && z.bb==h){\n                cout<<z.cc;return 0;\n            }\n            num[z.aa][z.bb]=1;\n            falta.push(z);\n        }\n        z.aa-=c;\n        z.bb+=d;\n        z.bb-=c;\n        z.aa-=d;\n        if(z.aa>=0 && z.aa<a && z.bb>=0 && z.bb<b && num[z.aa][z.bb]==0){\n            if(z.aa==g && z.bb==h){\n                cout<<z.cc;return 0;\n            }\n            num[z.aa][z.bb]=1;\n            falta.push(z);\n        }\n    }\n    cout<<\"-1\";\n    \n    return 0;\n}"
    },
    {
        "titulo": "6913. Directorio Chihuahuense",
        "url": "https://omegaup.com/arena/problem/Directorio-Chihuahuense/",
        "descripcion": "Un amigo tuyo va a ir de vacaciones a Chihuahua y quiere saber cuáles son los lugares a los que pertenece cierta clave lada L.",
        "entrada": "Un número entero L que representa la clave lada.",
        "salida": "El lugar de donde es la clave lada.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a;\n    cin>>a;\n    switch(a){\n        case 614: cout<<\"Chihuahua\";break;\n        case 621: cout<<\"Saucillo\";break;\n        case 625: cout<<\"Cuauhtemoc\";break;\n        case 626: cout<<\"Coyame\";break;\n        case 627: cout<<\"Parral\";break;\n        case 628: cout<<\"Santa Barbara\";break;\n        case 629: cout<<\"Jimenez\";break;\n        case 635: cout<<\"Creel\";break;\n        case 636: cout<<\"Casas Grandes\";break;\n        case 639: cout<<\"Delicias\";break;\n        case 648: cout<<\"Camargo\";break;\n        case 649: cout<<\"Guachochi\";break;\n        case 652: cout<<\"Madera\";break;\n        case 656: cout<<\"Juarez\";break;\n        case 659: cout<<\"Bachiniva\";break;\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "5265. Términos pares de Fibonacci ",
        "url": "https://omegaup.com/arena/problem/Terminos-pares-de-Fibonacci-emh/",
        "descripcion": "Cada nuevo término en la sucesión de Fibonacci es generado por la adición de los dos términos anteriores. Comenzando con 1 y 2, los 10 primeros términos serían: 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, etc. Considerando los términos de la sucesión de Fibonacci cuyos valores no superan un cierto número dado, halla la suma de los términos cuyo valor es par.",
        "entrada": "Un único número entero positivo N, donde 1<=N<=4*(10^6).",
        "salida": "Imprime un único número que representa la suma de todos terminos pares cuyo valor es menor o igual a N",
        "nivel": "(fácil)",
        "categorias": [
            "Ciclos"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b=1, c=0, d=1, e=0;\n    cin>>a;\n    while(b<=a){\n        b=c+d;\n        if(b>a){\n            break;\n        }\n        if(b%2==0){\n            e+=b;\n        }\n        d=c;\n        c=b;\n    }\n    cout<<e;\n    \n    return 0;\n}"
    },
    {
        "titulo": "6425. Triangulos rectángulos",
        "url": "https://omegaup.com/arena/problem/DRMIGTriangulosRectangulos/",
        "descripcion": "Según el teorema de pitágoras, para cualquier triángulo rectángulo con catetos a y b e hipotenusa c, se cumple la condición = a^2+b^2=c^2. En este problema se dan tres números. Debes decir si con ellos se forma un triángulo rectángulo o no. Habrá casos que con las tres medidas proporcionadas ni siquiera se pueda formar un triángulo. Si este es el caso, también se debe identificar.",
        "entrada": "Tres entradas, cada una de ellas representando un número decimal.",
        "salida": "Una sola línea con la frase SI ES RECTANGULO si se puede formar un triángulo rectángulo con ellos. Si no se puede formar un triángulo rectángulo, escribir la frase NO ES RECTANGULO, y si no se puede formar un triángulo con las tres medidas, escribir la frase NI SIQUIERA ES TRIANGULO. La precisión con la que se deben comparar los decimales es 0.001",
        "nivel": "",
        "categorias": [
            ""
        ],
        "estructuras": [
            "long double",
            "pow()",
            "swap()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long double a, b, c, d;\n    cin>>a>>b>>c;\n    if(b>a){\n        swap(b,a);\n    }\n    if(c>a){\n        swap(c,a);\n    }\n    if(c>b){\n        swap(c,b);\n    }\n    if(a>=(b+c)){\n        cout<<\"NI SIQUIERA ES TRIANGULO\";return 0;\n    }\n    d=pow(a,2)-(pow(b,2)+pow(c,2));\n    if(d>=0 && d<=0.1){\n        cout<<\"SI ES RECTANGULO\";return 0;\n    }\n    cout<<\"NO ES RECTANGULO\";\n    \n    return 0;\n}"
    },
    {
        "titulo": "4537. Tres hermanos agricultores",
        "url": "https://omegaup.com/arena/problem/Tres-hermanos-agricultores/",
        "descripcion": "En una aldea lejana viven tres hermanos agricultores, cada uno posee un 4 hectareas de tierra y cada año cada uno siembra zanahorias, calabazas, frijol y lechuga en cada una de sus hectareas. Al final de año se reunen entre los tres para saber quien cosecho más de cada una de las verduras y cuantas verduras cosecharon cada uno.",
        "entrada": "La primera línea contiene 4 números separados por espacios con la cosecha de zanahorias, calabazas, frijol y lechuga del primer hermano. La segunda línea contiene 4 números separados por espacios con la cosecha de zanahorias, calabazas, frijol y lechuga del segundo hermano La tercera línea contiene 4 números separados por espacios con la cosecha de zanahorias, calabazas, frijol y lechuga del tercer hermano.",
        "salida": "La primera línea muestra el número de hermano que cosecho más zanahorias y la cantidad cosechada. La segunda muestra el número de hermano que cosecho más calabazas y la cantidad cosechada. La tercera línea muestra el número de hermano que cosecho más frijol y la cantidad cosechada. La cuarta línea muestra el número de hermano que cosecho más lechuga y la cantidad cosechada.",
        "nivel": "(fácil)",
        "categorias": [
            "Ciclos",
            "Matrices"
        ],
        "estructuras": [
            "long long",
            "vector<vector<int>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a=1, b=1, c=1, d=0, e=0, f=0, g=0, h=0, l=0, m=0, n, o, p=2, q;\n    vector<vector<int>>num;\n    cin>>num[0][0]>>num[1][0]>>num[2][0]>>num[3][0]>>num[0][1]>>num[1][1]>>num[2][1]>>num[3][1]>>num[0][2]>>num[1][2]>>num[2][2]>>num[3][2];\n    for(auto i=0; i<4; i++){\n        a=0;\n        b=0;\n        for(auto j=0; j<3; j++){\n            if(num[i][j]>a){\n                a=num[i][j];\n                b=j+1;\n            }\n        }\n        cout<<b<<\" \"<<a<<\"\\n\";\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "4064. Tomando Café",
        "url": "https://omegaup.com/arena/problem/DOCENTES-SIN-DORMIR-ASINUS/",
        "descripcion": "Los docentes del ASINUS INSTITUTE tienen problemas de desempeño, ya que no están durmiendo lo suficiente para enseñar de una forma óptima. Han descubierto que el café les brinda aquella energía que no están obteniendo al dormir, sin embargo no siempre consumen la misma cantidad, por ello, a pesar de que el café les ayuda, su nivel de desempeño varia mucho debido a la diferencia de éste que consumen. Las horas que deben dormir para estar con el 100% de energía son 8hrs. y con la experiencia se han dado cuenta que por cada hora que no duermen deben beber 1.5 tazas de café de Veracruz. Ayuda a los docentes a encontrar la cantidad exacta de tazas de café que necesitarán para tener el 100% de energía y dar lo mejor de sí en todas sus clases, tomando en cuenta las horas que durmieron.",
        "entrada": "El número de horas que durmió el docente.",
        "salida": "El número de tazas que requiere para tener el 100% de energía. Si el docente durmió 8 horas o más, no necesitará beber café a lo que se indicará: \"NO CAFE\".",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Cálculos aritméticos"
        ],
        "estructuras": [
            "long double"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long double a=1;\n    cin>>a;\n    if(a>=8){\n        cout<<\"NO CAFE\";\n    }\n    else{\n        cout<<(8-a)*1.5;\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "1795. Supermercado Difícil",
        "url": "https://omegaup.com/arena/problem/SupermercadoDificil/",
        "descripcion": "Juan Pérez ha ido al supermercado varias veces en el año y ha anotado en una lista los precios de los productos que ha comprado durante cada día. Sin embargo, mientras anotaba los precios de los productos también hacía anotaciones arbitrarias en su lista, como nombres de personas, canciones, o bien ponía cualquier cosa que se le ocurriera. Ayude a Juan Pérez a determinar el gasto que tuvo durante cada visita al supermercado ignorando las cosas que no son precios.",
        "entrada": "La entrada consiste de un número arbitrario de líneas de entrada. Cada línea contiene los precios de los productos que Juan Perez compró durante una visita al supermercado, separados por letras, espacios, tabulaciones y los signos de puntuación ',', '.', ';', ':', '-', '@', ')', '('.",
        "salida": "La suma de los precios de cada línea de la entrada. Puede suponer que la suma de la lista de los precios cabe en un entero de 32 bits con signo.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "string",
            "getline()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    long long a, b;\n    string z;\n    while(getline(cin,z)){\n        a=0;\n        b=0;\n        for(auto i=0; i<z.size(); i++){\n            if(z[i]>='0' && z[i]<='9'){\n                b*=10;\n                b+=(z[i]-48);\n            }\n            else{\n                a+=b;\n                b=0;\n            }\n        }\n        a+=b;\n        cout<<a<<\"\\n\";\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "2940. Robot Arm",
        "url": "https://omegaup.com/arena/problem/Robot-Arm/",
        "descripcion": "Estamos entusiasmados en la empresa, un brazo de robot nuevo ha sido ensamblado y esta conectado a nuestra plataforma listo para recibir las ordenes necesarias. Donde lo instalamos? Está dentro de nuestra maquina de sodas, cada soda en el sistema esta representada por un código numérico diferente. Esta maquina tiene 3 operaciones principales que necesitamos configurar lo antes posible. 1.- x insertar x: hace que la soda x sea insertada al final de toda la pila de sodas. 2.- sacar: saca la soda al final de toda la pila e imprime su código. 3.- invertir: este comando invierte una cantidad M de sodas al final de la pila. Por ejemplo si M es 3 y en la pila tenemos los enteros [8, 2, 1, 5, 4, 7, 3] al usar la operación la pila invierte el sub-array [4, 7, 3] y quedara [8, 2, 1, 5, 3, 7, 4] dejando al numero 4 al final de la pila. Si la pila contiene menos de M sodas invierte toda la pila. Este brazo nos ayudara proveer las sodas de manera que todos los empleados reciban la soda que deseen.",
        "entrada": "La entrada comienza con un numero entero T la cantidad de casos de prueba. Cada caso de prueba comienza con dos números enteros N y M la cantidad de operaciones que se realizaran y el numero de sodas que se invertirán al final de la cola con la operación “invertir” respectivamente. A continuación están T lineas con una operación cada una. Por cada operación se puede recibir una de las siguientes cadenas \"1 x\", \"2\" y \"3\", el comando \"1 x\" es para insertar donde x es el numero de la soda, el comando 2 es para sacar y el comando 3 es para invertir. Se garantiza que no se realizara una operación \"2 sacar\" si es que no hay valores en la pila.",
        "salida": "Imprimir por cada operación \"2\" el código numérico de la soda que salio de la pila.",
        "nivel": "",
        "categorias": [
            "Pilas",
            "Colas",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "stack<int>",
            "queue<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d;\n    stack<int>falta;\n    queue<int>faltas;\n    cin>>a;\n    while(a--){\n        cin>>b>>c;\n        while(falta.size()){\n            falta.pop();\n        }\n        while(b--){\n            cin>>d;\n            if(d==1){\n                cin>>d;\n                falta.push(d);\n            }\n            else if(d==2){\n                cout<<falta.top()<<\"\\n\";\n                falta.pop();\n            }\n            else{\n                d=c;\n                while(falta.size() && d){\n                    d--;\n                    faltas.push(falta.top());\n                    falta.pop();\n                }\n                while(faltas.size()){\n                    falta.push(faltas.front());\n                    faltas.pop();\n                }\n            }\n        }\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "3318. QirMontaña",
        "url": "https://omegaup.com/arena/problem/QirMontana/",
        "descripcion": "Nicte-Ha una niña de Felipe Carrillo Puerto, de fue de vacaciones al Estado de México, lo primero que observó fueron las bellas montañas de la sierra - ya que nunca las había visto - cuando comenzó a preguntarse: ¿Cuál montaña es la más ancha? Ella decidió tomar N medidas igualmente espaciadas de altura H_i secuencialmente a través del horizonte usando su nuevo Geoaltímetro de Larga Distancia. Una montaña se define como una secuencia consecutiva de valores H_i que aumentan (o permanecen igual) y luego disminuye (o permanece igual), por ejemplo: 2,3,3,5,4,4,1. Es posible que una montaña en el borde de su campo de visión únicamente aumente o disminuya en su altura, también. El ancho de una montaña es el número de medidas que abarque. Escribe un programa, que ayude a la niña Nicte-Ha a encontrar la montaña mas alta.",
        "entrada": "Línea 1: Un solo entero: N. Líneas 2..N+1: La línea i+1 contiene un solo entero: H_i",
        "salida": "Línea 1: Una sola línea con un solo entero que es el ancho de la montaña más ANCHA.",
        "nivel": "",
        "categorias": [
            "Vectores",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b=1, c, d;\n    vector<int>num(100001);\n    cin>>a;\n    for(auto i=0; i<a; i++){\n        cin>>num[i];\n    }\n    for(auto i=0; i<a; i++){\n        c=i-1;\n        d=1;\n        while(c>=0 && num[c]<=num[c+1]){\n            d++;\n            c--;\n        }\n        c=i+1;\n        while(c<a && num[c]<=num[c-1]){\n            d++;\n            c++;\n        }\n        if(d>b){\n            b=d;\n        }\n        i=c-1;\n    }\n    cout<<b;\n    \n    return 0;\n}"
    },
    {
        "titulo": "6995. Programando fórmulas raras",
        "url": "https://omegaup.com/arena/problem/Programando-formulas/",
        "descripcion": "Te gustan mucho las matemáticas pero no eres muy rápido haciendo los cálculos manualmente. Como estás aprendiendo a programar, crees que podrías solucionar este problema haciendo un programa que sea capaz de evaluar rápidamente ciertas expresiones aritméticas. Para probar tus habilidades, has dedicido escribir un programa que evalúe una fórmula que tú inventaste, la cual es: (x+x(y+z^2))/((x + PI)(y + PI)). Escribe un programa que calcule el resultado de evaluar la fórmula anterior.",
        "entrada": "Tres reales x,y,z. Puedes suponer que 0<=x,y,z<=1000.",
        "salida": "Un real que sea el valor de la fórmula evaluada. Tu programa se considerará correcto si el valor calculado es razonablemente cercano a la respuesta exacta.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Cálculos aritméticos"
        ],
        "estructuras": [
            "long double",
            "setprecision()",
            "pow()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long double a, b, c;\n    cin>>a>>b>>c;\n    cout<<fixed<<setprecision(6)<<(a+(a*(b+pow(c,2))))/((a+3.14159)*(b+3.14159));\n    \n    return 0;\n}"
    },
    {
        "titulo": "3695. Permutaciones-OMIJAL",
        "url": "https://omegaup.com/arena/problem/Permutaciones-OMIJAL/",
        "descripcion": "En matemáticas, una permutación es la variación del orden o de la disposición de los elementos de un conjunto. Por ejemplo, en el conjunto [1,2,3], cada ordenación posible de sus elementos, sin repetirlos, es una permutación. Existe un total de 6 permutaciones para estos elementos: \"1,2,3\", \"1,3,2\", \"2,1,3\", \"2,3,1\", \"3,1,2\" y \"3,2,1\". En este ejemplo las permutaciones están de manera ordenada, si les diéramos un valor a cada una según la posición que les corresponde en este orden serían de la siguiente forma: 1.- 1,2,3. 2.- 1,3,2. 3.- 2,1,3. 4.- 2,3,1. 5.- 3,1,2. 6.-3,2,1. Tu tarea, a pesar de esta mala redacción es escribir un programa que dada una permutación de los primeros N números enteros positivos encuentre cual es el número que le correspondería en la tabla de permutaciones ordenadas, al generar las permutaciones de estos N números de la manera demostrada.",
        "entrada": "La entrada consiste de dos líneas. La primera contiene el número N. La segunda línea contiene los N números separados por espacio. Para el 50% de los casos, 1<=N<=10. Para el 100% de los casos, 1<=N<=1000.",
        "salida": "Un solo número entero, el número de la permutación dada en la entrada. Como este número puede ser muy grande deberás imprimirlo módulo 1000000007.",
        "nivel": "",
        "categorias": [
            "Ciclos",
            "Ordenamiento",
            "Arboles",
            "Vectores"
        ],
        "estructuras": [
            "long long",
            "vector<long>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b=1, c=1;\n    vector<long>falta;\n    vector<long>faltas;\n    vector<long>num(1001);\n    cin>>a;\n    for(auto i=1; i<a; i++){\n        cin>>num[i-1];\n        b*=i;\n        b%=1000000007;\n        faltas.push_back(b);\n        falta.push_back(num[i-1]);\n    }\n    cin>>num[a-1];\n    falta.push_back(num[a-1]);\n    sort(falta.begin(),falta.end());\n    for(auto i=0; i<a-1; i++){\n        for(auto j=0; true; j++){\n            if(num[i]==falta[j]){\n                c+=(j*faltas[faltas.size()-1]);\n                c%=1000000007;\n                falta[j]=1000000007;break;\n            }\n        }\n        faltas.pop_back();\n        sort(falta.begin(),falta.end());\n        falta.pop_back();\n    }\n    cout<<c;\n    \n    return 0;\n}"
    },
    {
        "titulo": "6147. Permutaciones de la OPI",
        "url": "https://omegaup.com/arena/problem/Permutaciones-de-la-OPI/",
        "descripcion": "Para poder realizar el examen estatal de la OPI, los competidores fueron acomodados en diferentes aulas por grupos. En un determinado grupo, se le asignó a cada competidor una letra del alfabeto inglés, que no se repetiría con la de ningún otro competidor en el aula. Para poder ingresar al salón, los competidores deberían estar ordenados alfabéticamente según la letra asignada, sin embargo, el examen comenzó tan temprano y los competidores tenían tanto sueño que no lograron ordenarse adecuadamente. Al estar desordenados los participantes, notaron que formaban una cadena de caracteres que era una permutación de la cadena original (en la que estaban ordenados alfabéticamente) por lo que para poder despertar y prepararse para el examen, se pusieron a calcular qué número de permutación de la cadena original habían formado. Decimos que una permutación 'y' de una cadena sucede a una permutación cuando 'x' al ser ordenadas alfabéticamente no existe una permutación que pueda estar entre las dos. Dado un entero N que indica la cantidad de permutaciones a revisar, la cadena S de longitud M con las letras en desorden que se asignaron a los competidores y N permutaciones de la cadena original, indicar para cada permutación el orden en que se generaría a partir de la original.",
        "entrada": "El entero N seguido de la cadena S. Las siguientes N líneas indican las permutaciones a identificar. Las cadenas solo tendrán letras mayúsculas del alfabeto inglés y no habrá letras repetidas. 1<=M<=20, 1<=N<=20.",
        "salida": "Para cada permutación de la cadena S indicar el número de permutación que sería a partir de la cadena original.",
        "nivel": "",
        "categorias": [
            "Ciclos",
            "Ordenamiento",
            "Cadenas y caracteres",
            "Vectores"
        ],
        "estructuras": [
            "long long",
            "vector<char>",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b=1, c, d;\n    vector<char>falta;\n    vector<char>faltas;\n    string z, zz;\n    cin>>a>>z;\n    for(auto i=1; i<=z.size(); i++){\n        falta.push_back(z[i-1]);\n        b*=i;\n    }\n    b/=z.size();\n    sort(falta.begin(),falta.end());\n    while(a--){\n        faltas=falta;\n        c=b;\n        d=1;\n        cin>>zz;\n        for(auto i=0; i<zz.size(); i++){\n            for(auto j=0; j<faltas.size(); j++){\n                if(faltas[j]==zz[i]){\n                    d+=(j*c);\n                    faltas[j]='a';break;\n                }\n            }\n            sort(faltas.begin(),faltas.end());\n            faltas.pop_back();\n            if(faltas.size()){\n                c/=faltas.size();\n            }\n        }\n        cout<<d<<\"\\n\";\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "3913. Pares Intermedios",
        "url": "https://omegaup.com/arena/problem/Pares-Intermedios/",
        "descripcion": "El vendedor de Bonice DanielBun no sabe matemáticas y quiere aprender. Quiere saber cuantos números pares hay en un intervalo de dos números enteros. Recordó que si a los números pares se sumas dos unidades más, este se convierte en un número par, y que si a un número non le sumas dos unidades, este se convierte en un número non. Escribe un Programa que lea 2 números y escriba la cantidad de números pares que hay entre ambos. Si el intervalo inferior o el superior es par, también se cuenta.",
        "entrada": "Un entero n, representando el límite inferior, y un entero m, representando el límite superior.",
        "salida": "La cantidad de números pares que hay entre los dos límites.",
        "nivel": "",
        "categorias": [
            ""
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b;\n    cin>>a>>b;\n    if(b%2){\n        b--;\n    }\n    if(a%2){\n        a--;\n    }\n    else{\n        a-=2;\n    }\n    cout<<(b-a)/2;\n    \n    return 0;\n}"
    },
    {
        "titulo": "6963. Mensajes DRM",
        "url": "https://omegaup.com/arena/problem/Mensajes-DRM/",
        "descripcion": "La encriptación DRM es relativamente nueva . Dada una cadena encriptada (la cual llamaremos mensaje DRM) , la desencriptación consiste en tres simples pasos : Dividir , Rotar y Unir. Estos pasos se describirán usando el siguiente mensaje DRM como ejemplo , \"EWPGAJRB\": Divide - Primero , divide el mensaje a la mitad , obteniendo \"EWPG\" y \"AJRB\". Rota - Para cada mitad, calcula su valor de rotación, el cual se obtiene sumando el valor de cada carácter (A = 0 , B = 1 , ... , Z = 25). El valor de rotación de \"EWPG\" es 4 + 22 + 15 + 6 = 47. Rota cada elemento de \"EWPG\" 47 veces hacia adelante (pasando de A a Z en caso de ser necesario) para obtener una nueva cadena, \"ZRKB\". Haciendo lo mismo con la segunda mitad \"AJRB\", se obtiene \"BKSC\". Une - El último paso es unir la dos mitades obtenidas en el paso anterior, esto se lograra rotando cada carácter de la primera mitad el valor correspondiente del carácter en la segunda mitad. Para la primera posición, rotar 'Z' un total de 'B' veces, significa avanzar una sola vez, es decir, se obtiene 'A'. Continuando con este proceso para cada posición, se obtiene \"ABCD\", siendo este el mensaje ya descifrado.",
        "entrada": "La entrada consiste en una sola línea, una cadena de longitud L, que es el mensaje DRM que se va a descifrar. Todos los caracteres de la cadena son letras mayúsculas. L <=15000.",
        "salida": "Muestra el mensaje DRM ya descifrado.",
        "nivel": "Básico () - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a=0, b=0;\n    string z, zz=\"\", zzz=\"\";\n    cin>>z;\n    for(auto i=0; i<z.size()/2; i++){\n        zz=zz+z[i];\n        a+=(z[i]-65);\n    }\n    for(auto i=z.size()/2; i<z.size(); i++){\n        zzz=zzz+z[i];\n        b+=(z[i]-65);\n    }\n    a%=26;\n    b%=26;\n    for(auto i=0; i<zz.size(); i++){\n        zz[i]+=a;\n        if(zz[i]>'Z'){\n            zz[i]=64+(zz[i]-90);\n        }\n    }\n    for(auto i=0; i<zzz.size(); i++){\n        zzz[i]+=b;\n        if(zzz[i]>'Z'){\n            zzz[i]=64+(zzz[i]-90);\n        }\n    }\n    for(auto i=0; i<zz.size(); i++){\n        a=zzz[i]-65;\n        zz[i]+=a;\n        if(zz[i]>'Z'){\n            zz[i]=64+(zz[i]-90);\n        }\n        cout<<zz[i];\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "5407. Las hormigas",
        "url": "https://omegaup.com/arena/problem/Las-hormigas-ASINUS/",
        "descripcion": "Las hormigas son una especie muy bien organizada por tal motivo a pesar de ser tan pequeñas son capaces de sobrevivir a contextos algo extremos, sin embargo por su tamaño es un esfuerzo constante, en donde cada una de ellas hace lo que le corresponde, generando un sistema continuo y perfecto. Para poder sobrevivir, ellas salen todos los días, si así el clima lo permite, a conseguir comida o materiales para su vivienda, para ello, todos sabemos que suelen hacer largos caminos en donde una tras otra carga lo que le corresponde hasta llegar nuevamente al hormiguero, si el camino se interrumpe, hay encargadas de volver a encauzar el camino de todas las que vienen detrás. Una vez que llegan al hormiguero, son distribuidas según lo que cargaron durante su viaje, ya que para ellas cada cosa tiene una función especial, para ello, pueden cargar tres tipos de cosas: Piedras, Hojas, Restos de comida (alimento humano, semillas, insectos, etc). Cuando una hormiga trae piedras pequeñas se va al sótano del hormiguero, para construir nuevos cominos, cuando trae hojas va al piso 1, en el cual crecen los hongos que cultivan para comer y cuando trae alimento va al piso 2, el hormiguero tiene 2 pisos más que sirven para socializar y comer. En cada recorrido puede haber N hormigas, las cuales en su regreso serán clasificadas según el tipo de carga que trajeron consigo, 3 para las que van al sótano, 1 para las que van al primer piso y 2 para las que van al segundo piso. Así mismo en la entrada de cada piso hay una hormiga encargada del inventario, la cual contabiliza la cantidad de cargas que entraron. Sin embargo, es mucho trabajo tomando en cuenta el recorrido y el esfuerzo diario al cargar 8 veces su peso, para ello, ayuda diseñando un programa que le permita a las hormigas clasificar rápidamente las cargas y llevar un inventario exacto de lo que entró en cada viaje.",
        "entrada": "N como el número de hormigas que salieron al recorrido. La clasificación de cada hormiga (3, 1, 2) que se les da al regresar a cada una de ellas. El número de hormigas que salen al recorrido debe ser >0, de lo contrario se indicará ERROR. La clasificación sólo puede ser 3, 1 ó 2, por tal motivo si es diferente se indicará ERROR.",
        "salida": "El inventario de cada piso en orden de pisos, primero el sótano, después el piso 1 y después el piso 2.",
        "nivel": "(medio)",
        "categorias": [
            "Ciclos",
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "long double",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long double a, b=0, c=0, d=0;\n    string z;\n    cin>>a;\n    if(!a){\n        cout<<\"ERROR\";return 0;\n    }\n    while(a--){\n        cin>>z;\n        if(z==\"3\"){\n            b++;\n        }\n        else if(z==\"1\"){\n            c++;\n        }\n        else if(z==\"2\"){\n            d++;\n        }\n        else{\n            cout<<\"ERROR\";return 0;\n        }\n    }\n    cout<<b<<\"\\n\"<<c<<\"\\n\"<<d;\n    \n    return 0;\n}"
    },
    {
        "titulo": "4571. Formación para honores",
        "url": "https://omegaup.com/arena/problem/Formacion-para-honores/",
        "descripcion": "Como siempre después de un gran fin de semana regresamos a un nuevo lunes de actividades, y como siempre en todo lunes en las escuelas de educación básica se llevan a cabo honores a la bandera. En este caso te toca ser el prefecto y tienes acomodar al grupo de nuevo ingreso, como no sabes donde los van a ubicar el director te indicara la manera de formarlos. El director te dirá cuantos N alumnos hay en el grupo y las K filas de alumnos en que se deben formar, seguido N números que representan la estatura de los alumnos, como el director es muy estricto todos los alumnos deben de estar formados por estatura de izquierda a derecha y de adelante hacia atrás.",
        "entrada": "Un numero 1 <= N <= 1,000,000 que representa el numero de alumnos, en esta escuela los salones son muy grandes; seguido de k alumnos en fondo que deben de ser formados y finalmente 1 <= N números <= 1000000000 que representan la altura de los alumnos.",
        "salida": "Los N alumnos formados de K en fondo.",
        "nivel": "(fácil)",
        "categorias": [
            "Ordenamiento",
            "Ciclos",
            "Vectores"
        ],
        "estructuras": [
            "long long",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d;\n    vector<int>falta;\n    cin>>a>>b;\n    d=a;\n    while(d--){\n        cin>>c;\n        falta.push_back(c);\n    }\n    sort(falta.begin(),falta.end());\n    cout<<falta[0]<<\" \";\n    for(auto i=1; i<a; i++){\n        if(i%b==0){\n            cout<<\"\\n\";\n        }\n        cout<<falta[i]<<\" \";\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "2155. El cuarto oscurito",
        "url": "https://omegaup.com/arena/problem/El-cuarto-oscurito/",
        "descripcion": "Nuestro ya conocido héroe Tlakarelel ha sido capturado por el enemigo y encerrado en un enorme cuarto oscuro. Después de recobrar el conocimiento, descubrió (a tientas) que en la pared existían una gran cantidad de interruptores. Pensando que activaban la luz, comenzó a accionarlos uno tras otro desesperadamente, pero ninguna luz se encendió, al contrario, algunos ruidos se oyeron en el piso, como si algo se estuviera moviendo. Al accionar de nuevo los interruptores, se dio cuenta de que cada uno quitaba y ponía baldosas del piso alternadamente, es decir, si la baldosa no estaba la ponía y si estaba la quitaba. Cada interruptor activaba varias baldosas. Tlakarelel siguió buscando en la pared, y encontró que debajo de cada interruptor estaba escrito (en braile) cuáles baldosas activaba cada interruptor. Con esto Tlakarelel se regocijó, puesto que recordaba cuáles eran los interruptores que había presionado y ahora sabría cuales baldosas había quitado en su afán por prender la luz. Por el momento, no hay que salvar a Tlakarelel, sólo tienes que ayudarle a saber cuáles baldosas no se encuentran en el piso después de que presionó los interruptores.",
        "entrada": "En la primera línea los números b (8<=b<=3000), n (2<=n<=16) y m (2<=m<=b) donde b indica el número de baldosas que hay en el cuarto, n el número de interruptores que hay y m el número de baldosas que se activan al presionar un interruptor (todos los interruptores cambian el estado de la misma cantidad de baldosas). En cada una de las siguientes n líneas, habrá m números separados por un espacio, que indican las baldosas que se alternan al presionar el interruptor correspondiente. En la siguiente línea el número a (5<=a<=30000) de veces que Tlakarelel activó los interruptores. En la última línea, a úmeros separados por un espacio que corresponden al número de los interruptores que presionó nuestro héroe, enlistados en el orden en el que fueron efectuados. Considera que No hacía falta ninguna baldosa antes de que Tlakarelel empezara a accionar botones",
        "salida": "En la primera línea, el número de baldosas que faltaban a final (las que fueron quitadas). En la segunda línea, separados por espacios y ordenadas ascendentemente, las baldosas que hacen falta.",
        "nivel": "()",
        "categorias": [
            "Matrices",
            "Pilas"
        ],
        "estructuras": [
            "long long",
            "vector<vector<int>>",
            "vector<int>",
            "queue<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\n using namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e;\n    vector<vector<int>>num(17,vector<int>(3001));\n    vector<int>sub(3001);\n    vector<int>sum(17);\n    queue<int>falta;\n    cin>>a>>b>>c;\n    for(auto i=1; i<=b; i++){\n        for(auto j=0; j<c; j++){\n            cin>>num[i][j];\n        }\n    }\n    cin>>d;\n    while(d--){\n        cin>>e;\n        sum[e]++;\n    }\n    for(auto i=1; i<=b; i++){\n        if(sum[i]){\n            for(auto j=0; j<c; j++){\n                sub[num[i][j]]+=sum[i];\n            }\n        }\n    }\n    for(auto i=1; i<=a; i++){\n        if(sub[i]%2){\n            falta.push(i);\n        }\n    }\n    cout<<falta.size()<<\"\\n\";\n    while(falta.size()){\n        cout<<falta.front()<<\" \";\n        falta.pop();\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "8177. Aguas termales",
        "url": "https://omegaup.com/arena/problem/Aguas-termales/",
        "descripcion": "Después del último terremoto en la lejana región de Volcantepec, se descubrieron nuevas fuentes de aguas termales formando pequeñas lagunas en una región en que se pensaba construir un hotel ecológico. La noticia emocionó a los constructores, que decidieron utilizar las nuevas lagunas como parte de la arquitectura. Los ingenieros dividieron el sitio de construcción en una cuadrícula uniforme de manera que cada celda de la cuadrícula estuviera cubierta de agua o de tierra. La pregunta que debes contestar es la siguiente: Dada una fila y una columna de la celda, de qué tamaño es la laguna que la contiene. (El tamaño se mide por el número de celdas de agua contiguas. Las celdas diagonales se consideran contiguas.)",
        "entrada": "El primer renglón consiste en dós números enteros. El primer número entero representa la cantidad N e líneas que forman la cuadrícula. El segundo número representa la cantidad M celdas tiene cada línea. Las siguientes N líneas contienen una secuencia de M caracteres \"T\" y \"A\" donde la \"T\" representa que la celda está cubierta por tierra y la \"A\" representa que la celda está cubierta por agua. La última línea contiene dos números n m que representa la posición en fila y columna desde donde se medirá el lago.",
        "salida": "La frase \"El lago mide C  celdas\" donde C es el área del lago.",
        "nivel": "(medio)",
        "categorias": [
            "Representación de grafos",
            "Conectividad en grafos",
            "Pilas",
            "Matrices"
        ],
        "estructuras": [
            "vector<vector<char>>",
            "vector<char>",
            "queue<pair<int, int>>",
            "pair<int, int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e = 0;\n    vector<vector<char>> num(1001, vector<char>(1001));\n    queue<pair<int, int>> falta;\n    pair<int, int> z;\n    cin >> a >> b;\n    for (auto i = 1; i <= a; i++)\n    {\n        for (auto j = 1; j <= b; j++)\n        {\n            cin >> num[i][j];\n        }\n    }\n    cin >> c >> d;\n    if (num[c][d] == 'A')\n    {\n        z.first = c;\n        z.second = d;\n        falta.push(z);\n        num[c][d] = 'T';\n        e++;\n    }\n    while (falta.size())\n    {\n        z = falta.front();\n        falta.pop();\n        z.first++;\n        if (num[z.first][z.second] == 'A')\n        {\n            e++;\n            falta.push(z);\n            num[z.first][z.second] = 'T';\n        }\n        z.first -= 2;\n        if (num[z.first][z.second] == 'A')\n        {\n            e++;\n            falta.push(z);\n            num[z.first][z.second] = 'T';\n        }\n        z.first++;\n        z.second++;\n        if (num[z.first][z.second] == 'A')\n        {\n            e++;\n            falta.push(z);\n            num[z.first][z.second] = 'T';\n        }\n        z.second -= 2;\n        if (num[z.first][z.second] == 'A')\n        {\n            e++;\n            falta.push(z);\n            num[z.first][z.second] = 'T';\n        }\n        z.second += 2;\n        z.first++;\n        if (num[z.first][z.second] == 'A')\n        {\n            e++;\n            falta.push(z);\n            num[z.first][z.second] = 'T';\n        }\n        z.first -= 2;\n        z.second -= 2;\n        if (num[z.first][z.second] == 'A')\n        {\n            e++;\n            falta.push(z);\n            num[z.first][z.second] = 'T';\n        }\n        z.first += 2;\n        if (num[z.first][z.second] == 'A')\n        {\n            e++;\n            falta.push(z);\n            num[z.first][z.second] = 'T';\n        }\n        z.first -= 2;\n        z.second += 2;\n        if (num[z.first][z.second] == 'A')\n        {\n            e++;\n            falta.push(z);\n            num[z.first][z.second] = 'T';\n        }\n    }\n    cout << \"El lago mide \" << e << \" celdas\";\n\n    return 0;\n}"
    },
    {
        "titulo": "7896. Comprando agua",
        "url": "https://omegaup.com/arena/problem/Comprando-agua/",
        "descripcion": "Después de un divertido taller de la OMIAGS te das cuenta que llevas 5 horas sin tomar agua. Como sabes lo importante que es mantenerse hidratado, decides llegar a la tienda más cercana para comprar una botella de agua. Al llegar, observas que existen N marcas de agua, todas de diferente precio. Puesto que tienes que pagar tu camión de regreso a casa, quieres aquirir el producto de menor precio.",
        "entrada": "Un entero N (0<N<=10000), indicando la cantidad de marcas disponibles, seguido de N enteros, todos distintos, indicando los precios. Considera que los precios de cada marca son positivos y menores que 100000",
        "salida": "Imprimir el precio de la botella que vas a adquirir, que tiene que ser la de menor costo.",
        "nivel": "Intermedio (fácil) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Ciclos",
            "Ordenamiento"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c;\n    cin >> a >> b;\n    a--;\n    while (a--)\n    {\n        cin >> c;\n        b = min(b, c);\n    }\n    cout << b;\n\n    return 0;\n}"
    },
    {
        "titulo": "4976. El agua y el aceite",
        "url": "https://omegaup.com/arena/problem/El-agua-y-el-aceite/",
        "descripcion": "El maestro Santiago odia ver los números pares e impares juntos así que le pidió a sus alumnos de informática que hicieran un programa que los separara.",
        "entrada": "Un número N (0<=N<=20) y abajo N números",
        "salida": "Los números N pares seguido de los números N impares",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Ciclos",
            "Pilas"
        ],
        "estructuras": [
            "long long",
            "queue<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b;\n    queue<int> falta;\n    cin >> a;\n    while (a--)\n    {\n        cin >> b;\n        if (b % 2)\n        {\n            falta.push(b);\n        }\n        else\n        {\n            cout << b << \" \";\n        }\n    }\n    while (falta.size())\n    {\n        cout << falta.front() << \" \";\n        falta.pop();\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "1807. Las aguas de la muerte",
        "url": "https://omegaup.com/arena/problem/aguas/",
        "descripcion": "Una vez que Gilgamesh tuvo listos los remos que Urshanabí le solicitó, ellos emprendieron su viaje a través de las aguas de la muerte para visitar a Utanapíshtim y obtener el secreto de la vida eterna. Para atravesar las aguas de la muerte ellos deben recorrer una distancia de K kilómetros. La travesía es larga y Gilgamesh sólo puede remar cierta distancia D para luego tomar un descanso. A lo largo del camino existen algunas islas donde nuestro héroe puede descansar. El recorrido comienza en la coordenada 0 y termina en la coordenada K .Calcule el mínimo número de descansos que Gilgamesh debe tomar para llegar a su destino.",
        "entrada": "Tres enteros N, K y D que denotan el número de islas, la longitud del recorrido y la distancia que Gilgamesh puede remar sin descanso, seguidos de una línea con N enteros p_ique denotan las coordenadas de las N islas. Puede suponer que 1<=N<=100000, que p_(i-1) < p_i y que ( p_i - p_(i-1) <= D ) para todo 1<=i<=N+1",
        "salida": "Un entero que sea la menor cantidad de descansos que Gilgamesh tuvo que tomar.",
        "nivel": "Intermedio () - Estructuras de datos y Algoritmos",
        "categorias": [
            "Ciclos",
            "Búsqueda binaria",
            "Vectores"
        ],
        "estructuras": [
            "long long",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d = 0, e = 0, f = 0;\n    vector<int> num(100001);\n    cin >> a >> b >> c;\n    for (auto i = 0; i < a; i++)\n    {\n        cin >> num[i];\n    }\n    num[a] = b;\n    while (true)\n    {\n        e += c;\n        if (e >= b)\n        {\n            cout << f;\n            return 0;\n        }\n        for (d; d <= a; d++)\n        {\n            if (num[d] == e)\n            {\n                break;\n            }\n            else if (num[d] > e)\n            {\n                e = num[d - 1];\n                d--;\n                break;\n            }\n        }\n        f++;\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "8070. Mis quincenas se van como el agua",
        "url": "https://omegaup.com/arena/problem/Mis-quincenas-se-van-como-el-agu/",
        "descripcion": "En estos últimos meses me he percatado de que mis gastos mensuales han incrementado, por lo que he estado llevando el registro de los gastos diarios durante más de medio año. Me han contado que eres un excelente programador y con tu ayuda puedo encontrar ciertos patrones para modificar mi comportamiento económico, por el momento lo que me interesa es saber los 3 días consecutivos de la semana en los que he gastado más dinero durante todo el mes.",
        "entrada": "La primera linea contiene un entero N que representa el número de casos. 1 <= N <= 10 La segunda contiene un número y un string M y D. M es el número de días del mes (29, 30 o 31). D es el día de la semana en que inicia el mes (sin acentos); LUNES, MARTES, MIERCOLES, JUEVES, VIERNES. La siguiente linea contiene M números que representan el gasto diario.",
        "salida": "Imprime en una sola linea por caso en el formato día-A gasto, día-B gasto, día-C gasto",
        "nivel": "()",
        "categorias": [
            "Vectores",
            "Caracteres y cadenas",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "vector<int>",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e, f = 0, g;\n    vector<int> num(32);\n    string z;\n    cin >> a;\n    while (a--)\n    {\n        cin >> b >> z;\n        d = 0;\n        e = 0;\n        if (z == \"LUNES\")\n        {\n            c = 1;\n        }\n        else if (z == \"MARTES\")\n        {\n            c = 2;\n        }\n        else if (z == \"MIERCOLES\")\n        {\n            c = 3;\n        }\n        else if (z == \"JUEVES\")\n        {\n            c = 4;\n        }\n        else if (z == \"VIERNES\")\n        {\n            c = 5;\n        }\n        else if (z == \"SABADO\")\n        {\n            c = 6;\n        }\n        else\n        {\n            c = 7;\n        }\n        for (auto i = 0; i < b; i++)\n        {\n            cin >> num[i];\n            d += num[i];\n            if (i >= 3)\n            {\n                d -= num[i - 3];\n            }\n            if (d > e)\n            {\n                e = d;\n                f = i;\n            }\n        }\n        g = f - 2;\n        f += c;\n        f -= 2;\n        f %= 7;\n        switch (f)\n        {\n        case 0:\n            cout << \"DOMINGO \";\n            break;\n        case 1:\n            cout << \"LUNES \";\n            break;\n        case 2:\n            cout << \"MARTES \";\n            break;\n        case 3:\n            cout << \"MIERCOLES \";\n            break;\n        case 4:\n            cout << \"JUEVES \";\n            break;\n        case 5:\n            cout << \"VIERNES \";\n            break;\n        case 6:\n            cout << \"SABADO \";\n            break;\n        }\n        cout << num[g] << \", \";\n        f++;\n        f %= 7;\n        g++;\n        switch (f)\n        {\n        case 0:\n            cout << \"DOMINGO \";\n            break;\n        case 1:\n            cout << \"LUNES \";\n            break;\n        case 2:\n            cout << \"MARTES \";\n            break;\n        case 3:\n            cout << \"MIERCOLES \";\n            break;\n        case 4:\n            cout << \"JUEVES \";\n            break;\n        case 5:\n            cout << \"VIERNES \";\n            break;\n        case 6:\n            cout << \"SABADO \";\n            break;\n        }\n        cout << num[g] << \", \";\n        f++;\n        f %= 7;\n        g++;\n        switch (f)\n        {\n        case 0:\n            cout << \"DOMINGO \";\n            break;\n        case 1:\n            cout << \"LUNES \";\n            break;\n        case 2:\n            cout << \"MARTES \";\n            break;\n        case 3:\n            cout << \"MIERCOLES \";\n            break;\n        case 4:\n            cout << \"JUEVES \";\n            break;\n        case 5:\n            cout << \"VIERNES \";\n            break;\n        case 6:\n            cout << \"SABADO \";\n            break;\n        }\n        cout << num[g] << \"\\n\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "5633. iOI 2009 Garage",
        "url": "https://omegaup.com/arena/problem/iOI-2009-Garage/",
        "descripcion": "Un estacionamiento de autos tiene N espacios de estacionamiento, numerados de 1 a N.  El estacionamiento abre vacío y opera de la siguiente manera a través del día. Siempre que llega un auto, el asistente verifica si hay algún espacio libre. Si no hay ninguno, entonces el auto espera en la entrada hasta que un espacio esté libre. Si un espacio está libre, o en cuanto uno se libere, el auto se estacionará en el espacio libre. Si hay más de un espacio libre, el auto se estacionará en el espacio libre con el número menor. Si llegan más autos mientras algún auto está esperando, todos ellos se alinean en una cola en la entrada en el orden en que ellos llegaron. Entonces, cuando un espacio se libere, el primer auto en la cola (es decir, el que llegó más temprano) se estacionará allí. El costo de estacionar, en dólares, corresponde al peso del auto en kilogramos multiplicado por el precio específico del espacio donde se estacionó. El costo no depende de cuánto tiempo se quede un auto en el estacionamiento. El operador del estacionamiento sabe que hoy vienen M autos y él sabe el orden de sus llegadas y salidas. Ayúdele a calcular cuántos dólares ganará el estacionamiento el día de hoy. Escriba un programa que, dado los precios específicos de los espacios de estacionamiento, los pesos de los autos y el orden en el cual los autos llegan y se van, determine la ganancia total del estacionamiento en dólares. Para un número de casos de prueba, que suman 40 puntos, siempre habrá un espacio de estacionamiento libre para cada auto que llegue. En estos casos ningún auto tendrá que esperar por un espacio de estacionamiento.",
        "entrada": "Considera que N (1<=N<=100) es el número de espacios de estacionamiento. M (1<=M<=2000) es e número de autos. R_s (1<=R_s<=100) es el precio por usar el espacio de estacionamiento s en dólares por kilogramo. W_k (1<=W_k<=10000) es el peso del auto K en kilogramos. La primera línea contiene los enteros N y M, separados por un espacio. Las próximas N líneas describen los precios de los espacios de estacionamiento. La s-ésima de estas líneas contiene un entero simple R_s , el precio del espacio de estacionamiento número s en dólares por kilogramo. Las próximas M líneas describen el peso de los autos. Los autos son numerados desde 1 hasta M inclusive sin ningún orden particular. La k-ésima de estas M líneas contiene un solo entero W_i, el peso del auto K en kilogramos. Las próximas 2M líneas describen la entrada y salida de todos los autos en orden cronológico. Un entero positivo i indica que el auto número i llega al estacionamiento. Un entero negativo -i  indica que el auto número i sale del estacionamiento. Los autos no saldrán del estacionamiento antes de llegar, y todos los autos desde 1 hasta M inclusive aparecerán exactamente dos veces en la secuencia, una para la llegada y otra para la salida. Además, ningún auto saldrá del estacionamiento si no ha estacionado en él (es decir, ningún auto saldrá mientras esté esperando en la cola). ",
        "salida": "Su programa debe escribir a la salida estándar una sola línea conteniendo un solo entero: el número total de dólares que ganará el estacionamiento el día hoy.",
        "nivel": "Avanzado (fácil) - Programación competitiva",
        "categorias": [
            "Implementación",
            "Vectores",
            "Pilas",
            "Ciclos",
            "Ordenamiento"
        ],
        "estructuras": [
            "int",
            "long long",
            "vector<pair<int, int>>",
            "vector<int>",
            "queue<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool sum(int x, int y)\n{\n    if (x >= y)\n        return true;\n    return false;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c = 0, d, e, f, g = 0;\n    vector<pair<int, int>> num(101);\n    vector<pair<int, int>> sub(2001);\n    vector<int> falta;\n    queue<int> faltas;\n    cin >> a >> b;\n    for (auto i = 1; i <= a; i++)\n    {\n        cin >> num[i].first;\n        falta.push_back(i);\n    }\n    for (auto i = 1; i <= b; i++)\n    {\n        cin >> sub[i].first;\n    }\n    sort(falta.begin(), falta.end(), sum);\n    d = b * 2;\n    while (d--)\n    {\n        cin >> e;\n        if (e > 0)\n        {\n            if (falta.size() == 0)\n            {\n                faltas.push(e);\n                continue;\n            }\n            if (c)\n            {\n                sort(falta.begin(), falta.end(), sum);\n                c = 0;\n            }\n            f = falta[falta.size() - 1];\n            falta.pop_back();\n            num[f].second = 1;\n            g += (num[f].first * sub[e].first);\n            sub[e].second = f;\n        }\n        else\n        {\n            e = fabs(e);\n            if (faltas.size())\n            {\n                f = faltas.front();\n                faltas.pop();\n                g += (sub[f].first * num[sub[e].second].first);\n                sub[f].second = sub[e].second;\n            }\n            else\n            {\n                num[sub[e].second].second = 0;\n                falta.push_back(sub[e].second);\n                c = 1;\n            }\n        }\n    }\n    cout << g;\n\n    return 0;\n}"
    },
    {
        "titulo": "7783. Crucigrama",
        "url": "https://omegaup.com/arena/problem/Cruci/",
        "descripcion": "or semanas has estado resolviendo crucigramas. Ahora quieres ganar un poco de dinero vendiéndole crucigramas a los periódicos diarios de la región. Como no quieres perder tiempo haciéndolos a mano, vas a escribir un programa que los genere. Al programa le das 2 palabras: palabra A y palabra B. La palabra A la debe escribir horizontalmente, y la palabra B la debe escribir verticalmente; de tal manera que las palabras se puedan cruzar; esto es deben compartir exactamente una letra. La letra compartida debe ser la primera letra en A que aparece en B, mas preciso: debe ser la primera ocurrencia de la letra, en ambas palabras. Por ejemplo: dadas las palabras A = \"ABBA\" y B = \"CCBBD\", el programa debe generar, en este caso, las 5 líneas que se muestran en el ejemplo mas abajo.",
        "entrada": "La primera y única línea de entrada contiene dos palabras: A (1 <= longitud de A <= 30) y B (1 <= longitud de B <= 30); de no mas de 30 letras cada una, separadas por un solo espacio. Ambas palabras están escritas con letras mayúsculas del alfabeto español. En todos los casos habrá, al menos, una letra común en ambas palabras.",
        "salida": "Si la longitud de la palabra A es N, y la longitud de la palabra B es M. La salida deben ser M líneas con N caracteres cada linea. La figura que se forme con la salida debe contener a las 2 palabras cruzadas, como se describe en la explicación del problema (por eso se llama crucigrama). El resto de los caracteres, en cada línea, deben ser puntos (el carácter punto).",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Matrices",
            "Ciclos",
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "vector<vector<char>>",
            "vector<char>",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    vector<vector<char>> num(31, vector<char>(31));\n    string z, zz;\n    cin >> z >> zz;\n    for (auto i = 0; i < z.size(); i++)\n    {\n        for (auto j = 0; j < zz.size(); j++)\n        {\n            if (z[i] == zz[j])\n            {\n                for (auto k = 0; k < z.size(); k++)\n                {\n                    num[j][k] = z[k];\n                }\n                for (auto k = 0; k < zz.size(); k++)\n                {\n                    num[k][i] = zz[k];\n                }\n                for (auto k = 0; k < zz.size(); k++)\n                {\n                    for (auto r = 0; r < z.size(); r++)\n                    {\n                        if (num[k][r] == NULL)\n                        {\n                            num[k][r] = '.';\n                        }\n                        cout << num[k][r];\n                    }\n                    cout << \"\\n\";\n                }\n                return 0;\n            }\n        }\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "6384. Búsqueda de Patrones en Cadenas",
        "url": "https://omegaup.com/arena/problem/Busqueda-de-Patrones-en-Cadenas/",
        "descripcion": "El problema de reconocimiento de cadenas es encontrar todas las ocurrencias de un patrón dado P = p_1p_2…p_m en un texto amplio T = t_1t_2…t_n donde ambos, T y P son secuencias de caracteres a partir de un conjunto finito de caracteres. Dado las cadenas x, y y z, se dice que x es un prefijo de xy, un sufijo de yx y un factor de xyz Hay tres enfoques de búsqueda de patrones, para este problema se describe únicamente el método de búsqueda llamado “Búsqueda de Sufijos”. La búsqueda de sufijos, la cuál tiene una ventana de búsqueda del tamaño del patrón, es hecha hacia atrás a lo largo de la ventana de búsqueda considerando el sufijo más largo de la ventana que es también el sufijo del patrón. El algoritmo más famoso usando este método es el algoritmo Horspool, el cual se describe a continuación: Para cada posición de la ventana de búsqueda, se tiene que comparar su último carácter (simboloBeta en la figura)  con el último carácter del patrón. Si ellos son iguales, se verifica la ventana de búsqueda hacia atrás contra el patrón hasta que se encuentre el patrón completo o falle la igualación en un carácter (simboloSigma en la figura). Entonces, si hubo una coincidencia o no, se corre la ventana de acuerdo a la siguiente ocurrencia de la letra simboloBeta en el patrón.",
        "entrada": "La primera línea contiene el texto T, donde 1<=T<=100 palabras. La segunda línea contiene el patrón P, donde 1<=P<=25 caracteres.",
        "salida": "Imprimir la(s) posición(es) donde inicia(n) el/los patrón(es) en el texto. Nota: Usar \" _ \" para separar palabras. El programa debe aceptar las letras del alfabeto americano (minúsculas y mayúsculas) (no usar ñ ni acentos) y los 10 dígitos.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas",
            "Ciclos"
        ],
        "estructuras": [
            "string",
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    string z, zz;\n    long long a;\n    cin >> z >> zz;\n    for (auto i = 0; i <= z.size() - zz.size(); i++)\n    {\n        if (z[i] == zz[0])\n        {\n            a = 0;\n            for (auto j = 0; j < zz.size(); j++)\n            {\n                if (z[i + j] != zz[j])\n                {\n                    a = 1;\n                    break;\n                }\n            }\n            if (a == 0)\n            {\n                cout << i + 1 << \"\\n\";\n            }\n        }\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "5112. Los Patrones de Ralf",
        "url": "https://omegaup.com/arena/problem/The-Crazy-Del-Elevador/",
        "descripcion": "Ralf a averiado el elevador de un hotel. Tardaran una cantidad N de tiempo en llegar repararlo. Ralf se ha quedado observando el elevador y observa como se marca los pisos a los que va, bien, pues Ralf esta tan aburrido que en lo que arreglan el ascensor ha decidido anotar que pisos visita el elevador en su libreta. Al poco tiempo Ralf descubre que el elevador sigue un patrón, Ralf es un poco torpe y quiero encontrar el patrón mas corto por lo que hay que ayudarlo a encontrar el patrón mas chico.",
        "entrada": "En la primera linea un numero N (1<=N<=10000) que es la cantidad de tiempo que tardaran en arreglar el elevador, sabiendo que cada minuto que pasa es un piso que visita el elevador, seguido una cantidad M que denota la cantidad de pisos que hay en el hotel. En la siguiente linea los N_i (1<=N_i<=500) números que Ralf Anota en su libreta.",
        "salida": "El patrón mas pequeño.",
        "nivel": "()",
        "categorias": [
            "Vectores",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c;\n    vector<int> num(10001);\n    vector<int> falta;\n    cin >> a >> b;\n    for (auto i = 1; i <= a; i++)\n    {\n        cin >> num[i];\n    }\n    b = num[1];\n    falta.push_back(num[1]);\n    for (auto i = 2; i <= a; i++)\n    {\n        if (num[i] != b)\n        {\n            while (falta.size() != i)\n            {\n                falta.push_back(num[falta.size() + 1]);\n            }\n        }\n        else\n        {\n            c = 0;\n            for (auto j = 0; j < falta.size(); j++)\n            {\n                if (i + j > a)\n                {\n                    for (auto k = 1; k <= a; k++)\n                    {\n                        cout << num[k] << \" \";\n                    }\n                    return 0;\n                }\n                else if (num[i + j] != falta[j])\n                {\n                    c = 1;\n                    break;\n                }\n            }\n            if (c)\n            {\n                while (falta.size() != i)\n                {\n                    falta.push_back(num[falta.size() + 1]);\n                }\n            }\n            else\n            {\n                i += falta.size();\n                i--;\n            }\n        }\n    }\n    for (auto k = 0; k < falta.size(); k++)\n    {\n        cout << falta[k] << \" \";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "3971. Patron",
        "url": "https://omegaup.com/arena/problem/patron/",
        "descripcion": "El malvado Jose ha vuelto a el benevolo Octavio malvado y solo tu puedes revertirlo! El malvado Jose utilizo un sistema muy complejo para torturar a cualquiera que se atreva a revertir el efecto malvado de Octavio. El utilizo un sistema de patrones. Si puedes decir si cadena de numeros tiene un patron o no, el efecto se rompera, pero, si dices que no tiene un patron, pero si tiene un patron o viceversa, el efecto se quedara asi para siempre... Escribe un problema que, dados 5 numeros separados por espacio, imprime SI, si tiene un patron, o NO si no tiene. El patron solo puede tener un cambio, por ejemplo +1 y **2*. Nunca puede tener un patron de **2+1*, por mencionar un ejemplo. Todos los casos estaran agrupados, lo que significa que con un caso erroneo, no se otorgaran puntos. Para este programa, habra 5 casos de prueba.",
        "entrada": "5  numeros, separados por espacio. Considera que los numeros varian entre 1 y 100",
        "salida": "Imprime SI o NO dependiendo de si hay un patron o no.",
        "nivel": "()",
        "categorias": [
            "Ciclos"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e, f;\n    cin >> a >> b >> c >> d >> e;\n    if (b > a)\n    {\n        f = b - a;\n        while (true)\n        {\n            if (c - b != f)\n            {\n                break;\n            }\n            if (d - c != f)\n            {\n                break;\n            }\n            if (e - d != f)\n            {\n                break;\n            }\n            cout << \"SI\";\n            return 0;\n        }\n        f = b / a;\n        while (true)\n        {\n            if (c / b != f)\n            {\n                break;\n            }\n            if (d / c != f)\n            {\n                break;\n            }\n            if (e / d != f)\n            {\n                break;\n            }\n            cout << \"SI\";\n            return 0;\n        }\n        cout << \"NO\";\n        return 0;\n    }\n    else\n    {\n        f = a - b;\n        while (true)\n        {\n            if (b - c != f)\n            {\n                break;\n            }\n            if (c - d != f)\n            {\n                break;\n            }\n            if (d - e != f)\n            {\n                break;\n            }\n            cout << \"SI\";\n            return 0;\n        }\n        f = a / b;\n        while (true)\n        {\n            if (b / c != f)\n            {\n                break;\n            }\n            if (c / d != f)\n            {\n                break;\n            }\n            if (d / e != f)\n            {\n                break;\n            }\n            cout << \"SI\";\n            return 0;\n        }\n        cout << \"NO\";\n        return 0;\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "1749. La muralla interminable de Humbaba",
        "url": "https://omegaup.com/arena/problem/muralla_humbaba/",
        "descripcion": "Gilgamesh y Enkidu han decidido ir en busca de una nueva aventura por lo que se proponen enfrentar a Humbaba, cuidador del bosque de los cedros. Sin embargo, para poder llegar a donde se esconde Humbaba deben encontrar la entrada a la muralla que rodea dicho bosque. Antes de encontrar la entrada a la muralla, Gilgamesh y Enkidu deben determinar la cantidad de muros que la forman. Para ello, se han dado cuenta de que cada muro de la muralla se encuentra pintado de color blanco o negro. Con esta información, nuestros héroes rodearon la muralla. Después de un rato, saben que han dado al menos una vuelta completa y que tienen el registro de los colores de cada muro que se vieron en su recorrido, pero no saben si terminaron en el mismo lugar donde iniciaron. Escribe un programa que determine la cantidad mínima de muros que puede tener la muralla.",
        "entrada": "Una cadena M. El caracter M_i es N si el color del muro visto es negro o B si es blanco. Puedes suponer que M tiene entre 1 y 100000 caracteres.",
        "salida": "Un entero que es la cantidad mínima de muros que puede tener la muralla",
        "nivel": "Avanzado () - Programación competitiva",
        "categorias": [
            "Caracteres y cadenas",
            "Vectores",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "vector<int>",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c;\n    vector<int> num(100001);\n    vector<int> falta;\n    string z;\n    cin >> z;\n    a = z.size();\n    for (auto i = 1; i <= a; i++)\n    {\n        if (z[i - 1] == 'B')\n        {\n            num[i] = 2;\n        }\n        else\n        {\n            num[i] = 1;\n        }\n    }\n    b = num[1];\n    falta.push_back(num[1]);\n    for (auto i = 2; i <= a; i++)\n    {\n        if (num[i] != b)\n        {\n            while (falta.size() != i)\n            {\n                falta.push_back(num[falta.size() + 1]);\n            }\n        }\n        else\n        {\n            c = 0;\n            for (auto j = 0; j < falta.size(); j++)\n            {\n                if (i + j > a)\n                {\n                    cout << falta.size();\n                    return 0;\n                }\n                else if (num[i + j] != falta[j])\n                {\n                    c = 1;\n                    break;\n                }\n            }\n            if (c)\n            {\n                while (falta.size() != i)\n                {\n                    falta.push_back(num[falta.size() + 1]);\n                }\n            }\n            else\n            {\n                i += falta.size();\n                i--;\n            }\n        }\n    }\n    cout << falta.size();\n\n    return 0;\n}"
    },
    {
        "titulo": "7954. Banqueros Injustos",
        "url": "https://omegaup.com/arena/problem/Banqueros-Injustos-/",
        "descripcion": "A un banco llegan clientes a depositar (D) y retirar (R), el banquero avaro le ha dado instrucciones a todos sus empleados de tomar los depósitos de inmediato. Sin embargo, ningún empleado debe atender una operación de retiro si no hasta que el banquero de la orden de atender (A). Una vez dada la orden, los retiros se atienden mientras haya dinero suficiente para atenderlos. El dinero que el banco tiene disponible para atender los retiros viene todo de los depósitos. Los retiros se atienden en orden estricto de menor a mayor. El banco permanece en operaciones hasta que se encuentra la instrucción específica de fin de operaciones (F). Por ejemplo, suponga que al inicio de operaciones, llegan al banco una solicitud de depósito por $20, seguida de una solicitud de retiro por $30 y luego la instrucción de atender los retiros (D 20 R 30 A). En este caso, los empleados no podrán darle al cliente sus $30 porque el dinero disponible ($20) no es suficiente para atender la petición de retiro ($30). Veamos el siguiente otro caso, al inicio de operaciones, llegan al banco un depósito por $10, un retiro por $25, un depósito de $20, un retiro de $15 y luego la orden de atender los retiros (D 10 R 25 D 20 R 15 A). En este caso, se atenderá solamente el retiro de $15 pues los retiros pendientes se atienden de menor y mayor y solo mientras haya dinero suficiente. En este caso, después de atender el retiro por $15, el banco solo tiene disponibles $15, que es menor que el monto del retiro restante de $25. Se pide escribir un programa que lea todas estas solicitudes e imprima el orden en el que se atienden los retiros. Al final de operaciones del banco, se imprime el saldo disponible y la suma de los retiros que quedaron pendientes de atender. Notas La letra A indica que es tiempo de atender los retiros posibles La letra F indica el final de operaciones del banco. Considera que el número total de operaciones nunca será mayor a 1,000,000, los montos de depósito y retiro siempre se expresan como números enteros positivos y los montos de depósito y retiro serán siempre menores a 10,000",
        "entrada": "Todas las solicitudes mencionadas.",
        "salida": "Una impresión de el orden en el que se atienden los retiros. Al final de operaciones del banco, se imprime el saldo disponible y la suma de los retiros que quedaron pendientes de atender.",
        "nivel": "(fácil)",
        "categorias": [
            "Ciclos",
            "Vectores",
            "Ordenamiento"
        ],
        "estructuras": [
            "int",
            "long long",
            "vector<int>",
            "char"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool num(int x, int y)\n{\n    if (x >= y)\n        return true;\n    return false;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a = 0, b;\n    vector<int> falta;\n    char z;\n    cin >> z;\n    while (z != 'F')\n    {\n        if (z == 'A')\n        {\n            sort(falta.begin(), falta.end(), num);\n            while (falta.size() && falta[falta.size() - 1] <= a)\n            {\n                cout << falta[falta.size() - 1] << \"\\n\";\n                a -= falta[falta.size() - 1];\n                falta.pop_back();\n            }\n        }\n        else if (z == 'D')\n        {\n            cin >> b;\n            a += b;\n        }\n        else\n        {\n            cin >> b;\n            falta.push_back(b);\n        }\n        cin >> z;\n    }\n    cout << a << \"\\n\";\n    a = 0;\n    while (falta.size())\n    {\n        a += falta[falta.size() - 1];\n        falta.pop_back();\n    }\n    cout << a;\n\n    return 0;\n}"
    },
    {
        "titulo": "4389. Construccion de un Triángulo",
        "url": "https://omegaup.com/arena/problem/DRMIGTriangulo/",
        "descripcion": "Un triángulo es construído con tres líneas rectas, que forman sus lados. Pero no cualquier conjunto de tres líneas puede formar un triángulo. Dadas las longitudes de tres líneas rectas, determinar si es posible formar un triángulo con ellas.",
        "entrada": "Tres entradas que representan cada una un número decimal. Cada número corresponde a la longitud de una línea recta.",
        "salida": "La palabra \"SI\" si se puede formar un triángulo con esos tres lados o la palabra \"NO\" si no es posible formarlo.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Cálculos aritméticos"
        ],
        "estructuras": [
            "long double"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long double a, b, c;\n    cin >> a >> b >> c;\n    if (b > a)\n    {\n        swap(a, b);\n    }\n    if (c > a)\n    {\n        swap(a, c);\n    }\n    if (c > b)\n    {\n        swap(c, b);\n    }\n    if (b + c <= a)\n    {\n        cout << \"NO\";\n        return 0;\n    }\n    cout << \"SI\";\n\n    return 0;\n}"
    },
    {
        "titulo": "4330. DRMIGCriba",
        "url": "https://omegaup.com/arena/problem/DRMIGCriba/",
        "descripcion": "Imprimir una tabla de unos y ceros correspondiente a la criba de Eratóstenes, donde cada línea tiene 10 dígitos correspondientes a la decena adecuada, separados por espacio. La primera línea contine la criba del 0 al 9. La segunda línea del 10 al 19, etcétera. El 1 corresponde a no ser primo, y el 0 corresponde a sí ser primo.",
        "entrada": "Un número entero positivo múltiplo de 10 mayor a 10 y menor a 1000",
        "salida": "La impresión de la tabla.",
        "nivel": "()",
        "categorias": [
            "Vectores",
            "Ciclos"
        ],
        "estructuras": [
            "vector<int>",
            "long double"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong double a;\nvector<int> num = {1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1};\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    cin >> a;\n    for (auto i = 0; i < a / 10; i++)\n    {\n        for (auto j = 0; j < 10; j++)\n        {\n            cout << num[(i * 10) + j] << \" \";\n        }\n        cout << \"\\n\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "5830. Determina carácter",
        "url": "https://omegaup.com/arena/problem/Determina-caracter/",
        "descripcion": "Hacer un programa que reciba un carácter, diga si es una letra mayúscula(ASCII del 65 al 90), una letra minúscula (ASCII del 97 al 122),o bien otro carácter.",
        "entrada": "Un carácter.",
        "salida": "Si es mayúscula imprimir MAYUSCULA, si es minúscula imprimir MINUSCULA, si no es una letra imprimir OTRO.",
        "nivel": "(fácil)",
        "categorias": [
            ""
        ],
        "estructuras": [
            "char"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    ;\n    char z;\n    cin >> z;\n    if (z >= 'a' && z <= 'z')\n    {\n        cout << \"MINUSCULA\";\n    }\n    else if (z >= 'A' && z <= 'Z')\n    {\n        cout << \"MAYUSCULA\";\n    }\n    else\n    {\n        cout << \"OTRO\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "6982. Metros de Carretera",
        "url": "https://omegaup.com/arena/problem/Metros-de-Carretera/",
        "descripcion": "Tu buen amigo Rany ha conseguido un nuevo empleo, este consiste en pintar una carretera, pero Rany como ya es costumbre pinta de una manera muy rara. Su manera de pintar se consiste en pintar 1 metro de carretera el día 1, pintar 2 metros desde el punto anterior el día 2, pintar 3 metros el día 3, así hasta pintar k metros más en el día k. A Rany le pagarán por día pero el distraído de tu amigo olvidó cuantos días trabajo, lo único que recuerda son los N metros totales que pinto. Ayudalo a averiguar cuantos días trabajo con base a los N metros que pinto.",
        "entrada": "Un único entero N representando los metros totales que pinto. (1<=N<6*10^9)",
        "salida": "La cantidad de días que Rany trabajo.",
        "nivel": "",
        "categorias": [
            ""
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c;\n    cin>>a;\n    b=sqrt(a*2)-1;\n    while(true){\n        c=((b+1)*b)/2;\n        if(a==c){\n            cout<<b;return 0;\n        }\n        b++;\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "4348. Perímetro de asteriscos",
        "url": "https://omegaup.com/arena/problem/RECT_PERIM_ASTERISCOS/",
        "descripcion": "Escribe un programa que permita desplegar un rectángulo que consista de un perímetro formado por asteriscos. El rectángulo mide h asteriscos de alto y w asteriscos de ancho. Por ejemplo, el siguiente rectángulo tiene estas medidas: h=5 y w=10. Es importante notar lo siguiente: Los asteriscos de las dos líneas horizontales están separados entre sí por un espacio en blanco. El área central del rectángulo está compuesto únicamente de espacios en blanco. No debe haber espacios en blanco al final de cualquiera de los renglones. En otras palabras, el último carácter antes de cada salto de línea debe ser un asterisco. Tengan mucho cuidado con este punto pues es muy fácil pasarlo por alto ya que es algo que no es visible a simple vista.",
        "entrada": "La entrada consiste de dos líneas. La primera línea es el entero h, y la segunda línea es el entero w. (1<=h<=100), (1<=w<=100)",
        "salida": "La salida consiste del rectángulo correspondiente.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Loops"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b;\n    cin>>a>>b;\n    for(auto i=0; i<a; i++){\n        for(auto j=0; j<b; j++){\n            if(i==0 || j==0 || i==a-1 || j==b-1){\n                cout<<\"*\";\n            }\n            else{\n                cout<<\" \";\n            }\n            if(j!=b-1){\n                cout<<\" \";\n            }\n        }\n        cout<<\"\\n\";\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "8309. Perímetro de poligono",
        "url": "https://omegaup.com/arena/problem/Perimetro-de-poligono/",
        "descripcion": "Un ingeniero está tratando de calcular el perímetro de una figura de múltiples lados y desea que le ayudemos creando un programa para dicha tarea. El desea que el programa pueda leer múltiples números que representan la longitud de cada uno de los lados y terminar con un cero. Sin embargo, el teclado de su computadora está fallando y de vez en cuanto escribe - (signos negativos, convenientemente solo antes de escribir números). El ingeniero desea que el programa está preparado para estos errores y corrija dichos números negativos.",
        "entrada": "La entrada tendrá varios numeros enteros positivos y negativos, siendo el último un cero. La cantidad de números será menor a 100. Los números serán enteros positivos y negativos.",
        "salida": "La salida será el valor de la suma de los lados de la figura, cambiando los valores negativos a positivos.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Loops",
            "Aritmética"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b=0;\n    cin>>a;\n    while(a){\n        b+=fabs(a);\n        cin>>a;\n    }\n    cout<<b;\n    \n    return 0;\n}"
    },
    {
        "titulo": "6269. El calendario de la cuenta larga",
        "url": "https://omegaup.com/arena/problem/Calendario-cuenta-larga/",
        "descripcion": "Los mayas usaban tres calendarios, pero en este ejercicio nos concentraremos solamente en el calendario choltún, o calendario de la cuenta larga. En éste, un día se llama kin, 20 kines forman un uinal, 18 uinales forman un tun, 20 tunes forman un katún y 20 katunes forman un baktún (también existen periodos de tiempo más grandes, pero no nos ocuparemos de ellos). Una fecha se especifica como el número b de baktunes, seguido del número k de katunes, el número t de tunes, el número u de uinales y el número d de kines ocurridos a partir de una fecha inicial llamada 0.0.0.0.0 que corresponde al 11 de agosto del año 3113 antes de nuestra era, según el calendario gregoriano. Si sabemos el número n de días transcurridos a partir de esa fecha, se puede calcular fácilmente la fecha correspondiente del calendario choltún. Por ejemplo, si han transcurrido 314 159 265 días a partir de la fecha inicial, entonces la fecha correspondiente es 2181.13.4.11.5, es decir b=2181, k=13, t =4, u=11, d=5.",
        "entrada": "Consiste de un número entero n que tendrá un valor entre 0 y 2 000 000 000.",
        "salida": "Consiste de cinco números enteros, b, k, t, u, d, separados por espacios.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Aritmética"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e;\n    cin>>a;\n    b=a%20;\n    a/=20;\n    c=a%18;\n    a/=18;\n    d=a%20;\n    a/=20;\n    e=a%20;\n    a/=20;\n    cout<<a<<\" \"<<e<<\" \"<<d<<\" \"<<c<<\" \"<<b;\n    \n    return 0;\n}"
    },
    {
        "titulo": "1101. Nutrientes",
        "url": "https://omegaup.com/arena/problem/Nutrientes/",
        "descripcion": "Existe cierto árbol que a diferencia de los árboles comunes, que nutren sus hojas y tallos a través de su raiz, éste nutre su raíz con los nutrientes que sus hojas recogen del medio ambiente. Dicho árbol nace de una forma muy particular, exactamente igual que como se construye un árbol binario de búsqueda. inicialmente hay un brote que será la raiz del árbol, enseguida, suceden brotes secuencialmente de tamaño Ti y buscan su lugar en el árbol de acuerdo a su tamaño (tal como se inserta en un ABB). . Cada brote i, nace con Gi nutrientes. Una vez que el árbol termina de crecer, Empieza el proceso de nutrir desde las hojas hacia la raiz. Una raiz solo se nutre de aquella hoja o rama que tenga la mayor cantidad de nutrientes. Dada la descripción de crecimiento del árbol y los nutrientes de cada brote, escribe un programa que calcule el máximo de nutrientes que recibe la raiz.",
        "entrada": "En la primera línea un entero N que representa la cantidad brotes. En cada una de las siguientes N líneas, los enteros T y G que representan el tamaño del brote y la cantidad de nutrientes que tiene, respectivamente. Puedes estar seguro que nunca habrá dos brotes del mismo tamaño. (1 <= N <=1000 1 <= Ti<= 1000 1 <= Gi <= 100).",
        "salida": "Un entero seguido de un salto de línea que indique el máximo número de nutrientes que la raiz puede absorber. Explicación de la salida: Con la descripción de la entrada se construye el siguiente árbol. El máximo de nutrientes se logra a partir de la hoja de tamaño 6 que nutre a su raiz con 10 nutrientes, de tal manera que la raiz de tamaño 7 tendrá 18 nutrientes (los suyos mas los de su hoja con más nutrientes 10+8) . Este nodo a su vez, nutre a su raiz con 18 nutrientes de tal manera que la raiz del arbol tendrá finalmente 20 nutrientes. Existen otras maneras de nutrir a la raiz, sin embargo, la descrita proporciona la máxima cantidad de nutrientes.",
        "nivel": "Avanzado (medio) - Programación competitiva",
        "categorias": [
            "Recorrido de árboles",
            "Árbol de búsqueda binaria"
        ],
        "estructuras": [
            "int",
            "long long"
        ],
        "codigo": "\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct sobra{\n    int aa, bb, cc, dd;\n};\nsobra num[1001];\n\nint sub(int x){\n    int y=0;\n    if(num[x].bb!=-1){\n        y=sub(num[x].bb);\n    }\n    if(num[x].cc!=-1){\n        y=max(y,sub(num[x].cc));\n    }\n    return y+num[x].dd;\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b;\n    cin>>a>>num[0].aa>>num[0].dd;\n    num[0].bb=-1;\n    num[0].cc=-1;\n    for(auto i=1; i<a; i++){\n        cin>>num[i].aa>>num[i].dd;\n        b=0;\n        num[i].bb=-1;\n        num[i].cc=-1;\n        while(true){\n            if(num[i].aa>num[b].aa && num[b].cc==-1){\n                num[b].cc=i;break;\n            }\n            else if(num[i].aa>num[b].aa){\n                b=num[b].cc;\n            }\n            else if(num[i].aa<num[b].aa && num[b].bb==-1){\n                num[b].bb=i;break;\n            }\n            else{\n                b=num[b].bb;\n            }\n        }\n    }\n    cout<<sub(0);\n    \n    return 0;\n}"
    },
    {
        "titulo": "7050. Cálculos condicionales",
        "url": "https://omegaup.com/arena/problem/Calculos-condicionales/",
        "descripcion": "Eres muy bueno evaluando fórmulas y realizando cálculos directos, pero te cuesta trabajo decidir en qué situaciones se deben hacer qué operaciones. Un compañero te sugirió un ejercicio de cálculo mental que consiste en, dado un número inicial N, realizar las siguientes operaciones en el orden indicado y con aritmética entera: 1.Si el valor actual de N es par, divídelo entre 2. En caso contrario, súmale 1. 2.Si el valor actual de N tiene tres o más cifras, divídelo entre 100. Pero si tiene exactamente dos cifras, divídelo entre 10. 3.Si el valor actual de N es un múltiplo de tres, réstale uno. Escribe un programa que te ayude a calcular el valor final de N y el número de veces que N fue modificado.",
        "entrada": "Un entero N. Puedes suponer que 1<=N<=1000.",
        "salida": "Dos enteros que correspondan con el valor final de N y el número de veces que N fue modificado respectivamente.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Aritmética",
            "Condicionales"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a=1, b=1;\n    cin>>a;\n    if(a%2){\n        a++;\n    }\n    else{\n        a/=2;\n    }\n    if(a>=100){\n        a/=100;\n        b++;\n    }\n    else if(a>=10){\n        a/=10;\n        b++;\n    }\n    if(a%3==0){\n        a--;\n        b++;\n    }\n    cout<<a<<\" \"<<b;\n    \n    return 0;\n}"
    },
    {
        "titulo": "7107. Cálculos iterativos",
        "url": "https://omegaup.com/arena/problem/Calculos-iterativos/",
        "descripcion": "Dado un entero N con valor inicial 0, modifícalo realizando los siguientes pasos en el orden indicado: Súmale al valor actual de N todos los números impares que existen de 1 a A. Réstale al valor actual de N todas las potencias de 2 que existen de 1 a B. Si el valor actual de N es un múltiplo de C, divídelo entre C hasta que deje de serlo.",
        "entrada": "Tres enteros A, B, C. Puedes suponer que 2<=A,B,C<=1000.",
        "salida": "Un entero que sea el valor final de N.",
        "nivel": "",
        "categorias": [
            "Aritmética",
            "Loops"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d;\n    cin>>a>>b>>c;\n    if(a%2){\n        a++;\n    }\n    d=pow(a/2,2);\n    while(e<=b){\n        d-=e;\n        e*=2;\n    }\n    while(d%c==0){\n        d/=c;\n    }\n    cout<<d;\n    \n    return 0;\n}"
    },
    {
        "titulo": "7001. Cálculos mentales competitivos",
        "url": "https://omegaup.com/arena/problem/Calculos-mentales-competitivos/",
        "descripcion": "Tu mejor amigo y tú siempre sacan la mejor calificación en matemáticas (y además acaban los exámenes al mismo tiempo), por lo que siempre han tenido la duda de quién es el mejor haciendo cálculos. Un día, un compañero de ambos los retó a que jugaran un reto de cálculo mental; el que lo resolviera primero sería el mejor en matemáticas de la escuela. El reto consiste en, dado un número inicial R: Calcular el resultado de R+5. Al resultado anterior, elevarlo al cuadrado. Al resultado anterior, dividirlo entre un tercio del número original R. Al resultado anterior, elevarlo al cubo. Como el título de ser el mejor de matemáticas en la escuela es sumamente importante, tendrás un día para practicar. Escribe un programa que te ayude a verificar los resultados que vas realizando a cada paso.",
        "entrada": "Un real R. Puedes suponer que (1<=R<=20).",
        "salida": "Cinco reales separados por espacios, donde el primer real es el número original y los siguientes cuatro son los resultados obtenidos después de aplicar cada paso en sucesión. Tu programa se considerará correcto si los valores calculados son razonablemente cercanos a las respuestas exactas.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Aritmética",
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "string",
            "getline()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    string z;\n    getline(cin,z);\n    for(long i=z.size()-1; i>=0; i--){\n        cout<<z[i];\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "8671. Cálculo de la mediana",
        "url": "https://omegaup.com/arena/problem/Calculo-de-la-mediana/",
        "descripcion": "Escribe un programa que lea una secuencia de N enteros distintos A = a_0,a_1,...,a_(n-1) y que determine el valor de la mediana de A así como su índice.",
        "entrada": "Un entero N seguido de los N enteros de A. Puedes suponer que N es impar y menor que 10^5.",
        "salida": "Dos enteros que sean el valor de la mediana de A y su índice.",
        "nivel": "",
        "categorias": [
            "Vectores",
            "Loops",
            "Ordenamiento"
        ],
        "estructuras": [
            "long long",
            "vector<pair<int,int>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a;\n    vector<pair<int,int>>num(100001);\n    cin>>a;\n    for(auto i=0; i<a; i++){\n        cin>>num[i].first;\n        num[i].second=i;\n    }\n    sort(num,num+a);\n    cout<<num[a/2].first<<\" \"<<num[a/2].second;\n    \n    return 0;\n}"
    },
    {
        "titulo": "8672. Sumando con pilas",
        "url": "https://omegaup.com/arena/problem/Sumando-con-pilas/",
        "descripcion": "Escribe un programa que comience con una pila P de enteros inicialmente vacía y que ejecute una lista de las siguientes operaciones: AGREGA v: Agregar a P. Por ejemplo, si P=(3,1,4) y v = 5 entonces P = (3,1,4,5). CONSUME: Quitar los dos últimos elementos de P, calcular su suma y agregarla a P. Por ejemplo, si P=(3,1,4) entonces P=(3,5). IMPRIME: Imprimir el último elemento de P. Por ejemplo, si P=(3,1,4) entonces se debe imprimir 4.",
        "entrada": "Un entero N seguido de las N operaciones a realizar sobre P. Puedes suponer que (0<=N<=10^5) y que nunca se pedirá consumir o imprimir un elemento que no existe.",
        "salida": "Cada para operación de impresión, el valor del entero correspondiente.",
        "nivel": "Intermedio (fácil) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Aritmética",
            "Loops",
            "Pilas",
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "long long",
            "stack<int>",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b;\n    stack<int>falta;\n    string z;\n    cin>>a;\n    while(a--){\n        cin>>z;\n        if(z==\"AGREGA\"){\n            cin>>b;\n            falta.push(b);\n        }\n        else if(z==\"CONSUME\"){\n            b=falta.top();\n            falta.pop();\n            falta.top()+=b;\n        }\n        else{\n            cout<<falta.top()<<\"\\n\";\n        }\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "8673. Nodos alcanzables",
        "url": "https://omegaup.com/arena/problem/Nodos-alcanzables/",
        "descripcion": "Dados N nodos numerados del 0 al N-1 donde cada uno tiene un enlace a su siguiente nodo, escribe un programa que determine si existe una forma de llegar del nodo 0 al nodo N-1.",
        "entrada": "Dos enteros N, M seguidos de M parejas de enteros X, Y que denotan un enlace del nodo X al Y. Pueden existir nodos que no tengan un nodo siguiente. Puedes suponer que (1<=M<=N<=100).",
        "salida": "El valor 1 si existe una forma de llegar del nodo 0 al N-1 y el valor 0 en otro caso.",
        "nivel": "Intermedio (fácil) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Listas ligadas",
            "Loops"
        ],
        "estructuras": [
            "long long",
            "vector<>",
            "queue<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct sobra{\n        int aa, bb, cc;\n    };\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d;\n    vector<sobra>num(101);\n    queue<int>falta;\n    cin>>a>>b;\n    a--;\n    for(auto i=0; i<b; i++){\n        cin>>num[i].aa>>num[i].bb;\n        if(num[i].aa==0){\n            if(num[i].bb==a){\n                a=-1;\n            }\n            else{\n                c=num[i].bb;\n                falta.push(c);\n            }\n            num[i].cc=1;\n        }\n    }\n    if(a==-1){\n        cout<<\"1\";return 0;\n    }\n    while(falta.size()){\n        c=falta.size();\n        falta.pop();\n        for(auto i=0; i<b; i++){\n            if(num[i].aa==c && num[i].cc==0){\n                if(num[i].bb==a){\n                    cout<<\"1\";return 0;\n                }\n                d=num[i].bb;\n                falta.push(d);\n                num[i].cc=1;\n            }\n        }\n    }\n    cout<<\"0\";\n    \n    return 0;\n}"
    },
    {
        "titulo": "910. L-OMI2011-La guardia negra",
        "url": "https://omegaup.com/arena/problem/L-OMI2011-La-guardia-negra/",
        "descripcion": "Según la canción del fuego y el hielo, la guardia de los centinelas negros ha defendido al reino de Westeros de las amenazas del norte durante los últimos 8,000 años. A últimas fechas un gran número de huestes enemigas se ha venido concentrando en la frontera norte de Westeros. El comandante de la guardia, Lord Snow, ha mandado llamar por ti para que le ayudes a planear la defensa. La guardia tiene representado el campamento enemigo como una cuadrícula de M filas por N columnas, en cada casilla de la cuadrícula hay un número s_{i,j} que representa la cantidad de soldados enemigos en esa casilla. La guardia cuenta con una catapulta capaz de lanzar un proyectil explosivo a cualquier lugar de esta cuadrícula. Al explotar, el proyectil eliminará a todos los soldados enemigos que se encuentren a una distancia menor o igual a un número d_i que depende del proyectil en cuestión. La distancia entre dos casillas se define como la suma del valor absoluto de la diferencia de sus columnas mas el valor absoluto de la diferencia de sus filas. El comandante de la guardia quiere que desarrolles un programa para calcular la cantidad de soldados que eliminaría un proyectil específico si fuera lanzado en una cierta casilla. Escribe un programa que dada la cuadrícula del campamento, el número de soldados en cada casilla, el número de proyectiles, la distancia de alcance de cada uno y el lugar donde quieres lanzarlo, calcule el número de enemigos que serán eliminados con cada proyectil.",
        "entrada": "Tu programa debe leer del teclado la siguiente información: En la primer línea los números M y N que representan el número de filas y columnas del campamento. En cada una de las siguientes M líneas hay N números enteros (s_{i,j}) separados por un espacio que representan los soldados en cada casilla del campamento. En la siguiente línea el número P de proyectiles que tiene la guardia. En las últimas P líneas hay 3 enteros separados por espacios en cada una que representan la fila y columna donde se lanzará un proyectil y la distancia de alcance del mismo. Tanto las filas como las columnas inician numeradas a partir del 0 y hasta M-1 y N-1 respectivamente. La fila 0 es la fila superior y la columna 0 es la columna hasta la izquierda. Puedes estar seguro de que los proyectiles serán lanzados de tal forma que su alcance no exceda el campamento, es decir, ninguna explosión llegará a una casilla que este fuera de la cuadrícula. (1<=M,N<= 1000), (0<=s_{i,j}<=1000000000), (1<=P<=100000), (0<=di<=500), Para este problema los casos de prueba se agruparán en 3 grupos distintos. Para obtener los puntos de un grupo es necesario que tu programa resuelva correctamente TODOS los casos de ese grupo, de otra forma obtendrás 0 puntos por ese grupo aun cuando hayas resuelto correctamente algunos de los casos. RESTRICCIONES ESPECIALES PARA EL GRUPO 1 (Valor del grupo, 25 puntos): (1<=M, N<=100, 1<=P<=100,0<=s_{i,j}<=10^5 y 0<=di<=50). RESTRICCIONES ESPECIALES PARA EL GRUPO 2 (Valor del grupo, 50 puntos): (1<=M,N<=10^3, 1<=P<=10^3, 0<=s_{i,j}<=10^6 y 0<=di <=500). RESTRICCIONES ESPECIALES PARA EL GRUPO 3 (Valor del grupo, 25 puntos): Las restricciones para el grupo 3 son las especificadas en la primera sección de límites. ",
        "salida": "Tu programa deberá escribir a la pantalla P líneas con un número cada una. La i-ésima línea debe contener la cantidad de enemigos que serían eliminados al lanzar el proyectil i.",
        "nivel": "",
        "categorias": [
            ""
        ],
        "estructuras": [
            "long long",
            "vector<vector<int>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e, f, g, h;\n    vector<vector<int>>num(1001,vector<int>(1001,0));\n    cin>>a>>b;\n    for(auto i=1; i<=a; i++){\n        for(auto j=1; j<=b; j++){\n            cin>>num[i][j];\n            num[i][j]+=num[i][j-1];\n        }\n    }\n    cin>>c;\n    while(c--){\n        cin>>d>>e>>f;\n        d++;\n        e++;\n        g=num[d][e+f]-num[d][(e-f)-1];\n        h=1;\n        f--;\n        while(f>=0){\n            g+=(num[d-h][e+f]-num[d-h][(e-f)-1]);\n            g+=(num[d+h][e+f]-num[d+h][(e-f)-1]);\n            f--;\n            h++;\n        }\n        cout<<g<<\"\\n\";\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "5837. Diario de tu hermano",
        "url": "https://omegaup.com/arena/problem/Diario-de-tu-hermano/",
        "descripcion": "Has encontrado el diario de tu hermano y quieres revelar sus oscuros secretos a sus amigos pero tienes un problema: ¡todo el diario está al revés! Para poder leerlo (y mostrárselo a sus amigos) necesitas voltear todos los caracteres que se encuentran en el diario.",
        "entrada": "Un string S que representa el diario de tu hermano.",
        "salida": "Un string Z que representa el diario volteado de tu hermano.",
        "nivel": "",
        "categorias": [
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "getline()",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e, f, g, h;\n    vector<vector<int>>num(1001,vector<int>(1001,0));\n    cin>>a>>b;\n    for(auto i=1; i<=a; i++){\n        for(auto j=1; j<=b; j++){\n            cin>>num[i][j];\n            num[i][j]+=num[i][j-1];\n        }\n    }\n    cin>>c;\n    while(c--){\n        cin>>d>>e>>f;\n        d++;\n        e++;\n        g=num[d][e+f]-num[d][(e-f)-1];\n        h=1;\n        f--;\n        while(f>=0){\n            g+=(num[d-h][e+f]-num[d-h][(e-f)-1]);\n            g+=(num[d+h][e+f]-num[d+h][(e-f)-1]);\n            f--;\n            h++;\n        }\n        cout<<g<<\"\\n\";\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "423. Dos Veces",
        "url": "https://omegaup.com/arena/problem/Formateando-las-letras/",
        "descripcion": "Meta: Leer una línea con caracteres tanto de minúsculas como de mayúsculas e imprimirlos dos veces, una con todo cambiado a mayúsculas y otro con todo convertido a minúsculas. En ocasiones es deseable poder transformar un texto a mayúsculas o también a minúsculas. En este ejercicio haremos eso.",
        "entrada": "Vas a leer por líneas hasta que se llegue al fin de archivo.",
        "salida": "Por cada línea que leas, debes imprimirla dos veces. La primera formateando todas las letras a mayúsculas y en la otra todas a minúsculas.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Loops",
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "string",
            "getline()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    string z;\n    while(getline(cin,z)){\n        for(long i=0; i<z.size(); i++){\n            if(z[i]>='a' && z[i]<='z'){\n                z[i]-=32;\n            }\n            cout<<z[i];\n        }\n        cout<<\"\\n\";\n        for(long i=0; i<z.size(); i++){\n            if(z[i]>='A' && z[i]<='Z'){\n                z[i]+=32;\n            }\n            cout<<z[i];\n        }\n        cout<<\"\\n\";\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "7066. El tablero en forma de dona",
        "url": "https://omegaup.com/arena/problem/El-tablero-en-forma-de-dona/",
        "descripcion": "Después de jugar un juego de ajedrez con uno de tus amigos se te ocurrió una idea extraña. ¿Qué sucedería si pudieras enrollar el tablero de manera que los bordes del tablero estuvieran conectados?. Es decir el borde izquierdo estaría conectado con el borde derecho y el borde superior estaría conectado con el borde inferior. !El resultado sería un tablero de ajedrez en forma de dona! Cualquier pieza que se moviera más alla de alguno de los bordes del tablero acabaría por pasar al borde opuesto. Esto debería ocurrir incluso si el tablero fuera más pequeño o más grande de lo normal. Para probar tu idea tomaste una hoja de papel y dibujaste un tablero de ajedrez asignando una coordenada a cada casilla, empezando por la esquina superior izquierda a la que le asignaste la coordenada (0, 0). Una vez hecho esto enrollaste el tablero para dejarlo en forma de dona y ver que sucedía con el movimiento de una pieza.",
        "entrada": "Seis enteros W, H, X, Y, R, S que denotan el ancho W y alto H del tablero, la coordenada inicial (X,Y) de la pieza, el número de casillas R que la pieza se mueve de manera horizontal y el número de casillas S que se mueve de manera vertical. Puedes asumir que (1<=W, H<=10, X<=W, Y<=H) y que (-20<=R, S<=20). Asuma que la pieza se mueve primero en la dirección horizontal y después en la dirección vertical.",
        "salida": "Dos enteros que represental las coordenadas finales de la pieza.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Entrada y salida",
            "Aritmética",
            "Loops"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e, f;\n    cin>>a>>b>>c>>d>>e>>f;\n    c+=e;\n    d+=f;\n    if(a!=1){\n        c%=a;\n    }\n    else{\n        c=0;\n    }\n    if(b!=1){\n        d%=b;\n    }\n    else{\n        d=0;\n    }\n    if(c<0){\n        c=a+c;\n    }\n    if(d<0){\n        d=b+d;\n    }\n    cout<<c<<\" \"<<d;\n    \n    return 0;\n}"
    },
    {
        "titulo": "7002. Evaluando fórmulas en sucesión",
        "url": "https://omegaup.com/arena/problem/Evaluando-formulas-en-sucesion/",
        "descripcion": "Cada vez eres mejor en matemáticas y ahora estás practicando con múltiples fórmulas en sucesión. Es decir, el resultado de una fórmula lo usarás para evaluar otra fórmula y así sucesivamente hasta obtener el resultado final. Como estás aprendiendo a programar, crees que podrías ayudarte de programas de computadora para facilitar tu labor. Las fórmulas con las que trabajarás esta vez son: y = (x + 5) / (2 * (x + 1)), z = (y^2 + x * (x - 2 * y)) / (x * y). Escribe un programa que calcule el valor de z dado x.",
        "entrada": "Un real x. Puedes suponer que (1<=x<=100).",
        "salida": "Un real que sea el valor de z. El valor se considerará correcto si está razonablemente cercano a la respuesta exacta.",
        "nivel": "Intermedio (fácil) - Matemáticas en la programación",
        "categorias": [
            "Aritmética"
        ],
        "estructuras": [
            "long double"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long double a, b, c;\n    cin>>a;\n    b=(a+5)/(2*(a+1));\n    c=(pow(b,2)+(a*(a-(2*b))))/(a*b);\n    cout<<c;\n    \n    return 0;\n}"
    },
    {
        "titulo": "5251. Sumas Distanciadas",
        "url": "https://omegaup.com/arena/problem/Sumas-Distanciadas/",
        "descripcion": "Se te da una secuencia S de N enteros y tu trabajo es encontrar cuales son los resultados de algunas sumas distanciadas. Una suma distanciada se defiene con 3 enteros A, B, C donde: A (1<=A<=N) es la posición incial en S. B (1<=B<=N-1) es la distancia. C (1<=A + (C-1) * B<=N) es cuántos números tienes que considerar. Por ejemplo S={1, 2, 3, 4, 5} y la suma distanciada dada por A = 1, B = 2, C = 3 es equivalente a S[1] + S[3] + S[5] = 1 + 3 + 5 = 9. De igual manear el caso A = 2, B = 3, C = 2 es igual a S[2] + S[5] = 2 + 5 = 7.",
        "entrada": "La primera linea consiste en un número N. Las siguientes N lineas contendrán un entero S_i. La siguiente linea contendrá un entero Q. Las siguientes Q lineas contendrán tres enteros A, B, C.",
        "salida": "Q lineas, cada una con un entero, respuesta de la suma Q-ésima.",
        "nivel": "()",
        "categorias": [
            "Vectores",
            "Ciclos"
        ],
        "estructuras": [
            "unsigned long long",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    unsigned long long a, b, c, d, e;\n    vector<int> num(100001, 0);\n    cin>>a;\n    for(auto i=1; i<=a; i++){\n        cin>>num[i];\n    }\n    cin>>a;\n    while(a--){\n        cin>>b>>c>>d;\n        e=0;\n        while(d--){\n            e+=num[b];\n            b+=c;\n        }\n        cout<<e<<\"\\n\";\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "3771. Sumando",
        "url": "https://omegaup.com/arena/problem/Sumando/",
        "descripcion": "Problema simple, dado una lista de N números enteros en el rango -1000000<=A_i<=1000000 se quiere encontrar la subsecuencia tal que su suma sea lo mayor posible. Una subsecuencia es una sublista de números adyacentes entre si, por ejemplo dada la lista: 1 2 3 4 5 6 7. 1 2 3 es una subsecuencia. 1 2 3 4 5 6 7 es una subsecuencia. 2 3 4 es una subsecuencia. 1 3 6 no es una subsecuencia. Escribe un programa que dada una lista de N números positivos y negativos encuentre cuál es la suma de la subsecuencia con mayor suma.",
        "entrada": "La primera línea tendrá un número N (1<=N<=1000000). La segunda línea contiene N números enteros separados por un espacio.",
        "salida": "Un solo número entero, la suma mas grande que se puede obtener de una subsecuencia de la lista dada.",
        "nivel": "Intermedio (medio) - Análisis y diseño de algoritmos",
        "categorias": [
            "Programación dinámica",
            "Ciclos"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c = 0, d = 0, e = 0, f = 0;\n    cin >> a;\n    while (a--)\n    {\n        cin >> b;\n        c += b;\n        if (c > d)\n        {\n            d = c;\n        }\n        if (c < e)\n        {\n            e = c;\n        }\n        f = max(f, d - e);\n    }\n    cout << f;\n\n    return 0;\n}"
    },
    {
        "titulo": "5036. Sumando Alumnos",
        "url": "https://omegaup.com/arena/problem/OMICAMP-Sumando-Alumnos/",
        "descripcion": "Tu preparatoria te contrata para desarrollar un sistema de control de alumnos, pero dentro de las funciones del sistema te piden algo en particular, Es una función donde se efectuaran P preguntas, que calculara dentro de un total de S Aulas un rango de A hasta B, el número y la media de alumnos. Crear un programa que almacene la cantidad de alumnos por salón y que responda a cada pregunta solicitada, la cantidad de alumnos y la media de alumnos entre los salones.",
        "entrada": "En la primera línea un valor entero S (2<=S<=1000000), que representará la cantidad de salones que hay en tu escuela, en las siguientes S líneas recibirás N A (1<=N A<=100) que representará el número de alumnos por cada salón, en la siguiente línea recibirá P (1<=P<=1000) que representa la cantidad de preguntas efectuadas al programa, y siguiente P líneas recibirá dos valores A y B (1<=A,B<=S) el cual es el rango de un salón a otro donde tu programa deberá calcular cuántos alumnos hay y la media.",
        "salida": "Tu programa deberá imprimir P líneas con la cantidad de alumnos y el promedio de alumnos que hay en los salones se parados por un espacio.",
        "nivel": "()",
        "categorias": [
            "Vectores",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "vector<int>",
            "long double"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c = 0, d;\n    vector<int> num(1000000, 0);\n    long double z;\n    cin >> a;\n    for (auto i = 1; i <= a; i++)\n    {\n        cin >> b;\n        c += b;\n        num[i] = c;\n    }\n    cin >> a;\n    while (a--)\n    {\n        cin >> b >> c;\n        d = num[c] - num[b - 1];\n        z = (double)d / ((c - b) + 1);\n        cout << d << \" \" << z << \"\\n\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "5891. Sumando horas",
        "url": "https://omegaup.com/arena/problem/sumando-horas/",
        "descripcion": "Por haber puente y además trabajar semana inglesa, Brandon sólo ha trabajado tres días, sin embargo a él le pagan por la cantidad de tiempo que trabajan en total las máquinas que tiene a su cargo. Para este problema tendrás que sumar la cantidad de tiempo que trabajaron las máquinas cada uno de los tres días, y mostrar el total en un formato de h:mm:ss.",
        "entrada": "La entrada son tres cantidades de tiempo de la forma h:mm:ss, un tiempo en cada línea, con 0<=h<=150 y 00<=mm,ss<=59. Ten en cuenta que h puede representarse con hasta tres dígitos; mm y ss siempre se representan con 2 dígitos.",
        "salida": "Es un único valor h:mm:ss con los mismos criterios para la entrada, es decir, h puede tener hasta 3 dígitos y mm y ss siempre serán de 2 dígitos. ",
        "nivel": "Básico () - Introducción a la programación",
        "categorias": [
            "Cálculos aritméticos",
            "Vectores",
            "Cadenas y caracteres",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "vector<int>",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c = 0;\n    vector<int> num(11, 0);\n    string z, zz, zzz;\n    cin >> z >> zz >> zzz;\n    if (zz.size() > z.size())\n    {\n        swap(z, zz);\n    }\n    if (zzz.size() > z.size())\n    {\n        swap(z, zzz);\n    }\n    if (zzz.size() > zz.size())\n    {\n        swap(zz, zzz);\n    }\n    a = ((z[z.size() - 1] + zz[zz.size() - 1] + zzz[zzz.size() - 1]) - 144) + b;\n    b = a / 10;\n    a %= 10;\n    num[c] = a;\n    c++;\n    a = ((z[z.size() - 2] + zz[zz.size() - 2] + zzz[zzz.size() - 2]) - 144) + b;\n    b = a / 6;\n    a %= 6;\n    num[c] = a;\n    c++;\n    a = ((z[z.size() - 4] + zz[zz.size() - 4] + zzz[zzz.size() - 4]) - 144) + b;\n    b = a / 10;\n    a %= 10;\n    num[c] = a;\n    c++;\n    a = ((z[z.size() - 5] + zz[zz.size() - 5] + zzz[zzz.size() - 5]) - 144) + b;\n    b = a / 6;\n    a %= 6;\n    num[c] = a;\n    c++;\n    for (auto i = z.size() - 7, j = zz.size() - 7, k = zzz.size() - 7; k > -1; i--, j--, k--)\n    {\n        if (z[i] == ':')\n        {\n            i--;\n            j--;\n            k--;\n        }\n        a = ((z[i] + zz[j] + zzz[k]) - 144) + b;\n        b = a / 10;\n        a %= 10;\n        num[c] = a;\n        c++;\n        if (!k && j)\n        {\n            i--;\n            j--;\n            for (auto yy = 0; j > -1; i--, j--)\n            {\n                a = ((z[i] + zz[j]) - 96) + b;\n                b = a / 10;\n                a %= 10;\n                num[c] = a;\n                c++;\n                if (!j && i)\n                {\n                    i--;\n                    for (auto yyy = 0; i > -1; i--)\n                    {\n                        a = (z[i] - 48) + b;\n                        b = a / 10;\n                        a %= 10;\n                        num[c] = a;\n                        c++;\n                    }\n                }\n            }\n        }\n        else if (!k && i)\n        {\n            i--;\n            for (auto yyy = 0; i > -1; i--)\n            {\n                a = (z[i] - 48) + b;\n                b = a / 10;\n                a %= 10;\n                num[c] = a;\n                c++;\n            }\n        }\n    }\n    if (b)\n    {\n        num[c] = b;\n    }\n    for (auto i = 11; i >= 6; i--)\n    {\n        if (num[i])\n        {\n            cout << num[i];\n        }\n    }\n    cout << num[5] << num[4] << \":\" << num[3] << num[2] << \":\" << num[1] << num[0];\n\n    return 0;\n}"
    },
    {
        "titulo": "5523. Los Taquitos",
        "url": "https://omegaup.com/arena/problem/Los-Taquitos/",
        "descripcion": "Ángel y sus amigos acostumbran a ir cada día al puesto de taquitos fuera de su escuela. En el puesto de tacos podemos encontrar N salsas diferentes, cada una con una intensidad de picante a_i. Además, los amigos de Ángel suman M personas, cada uno con una capacidad de aguante de picante b_j. El plan de hoy es completar un reto especial que los vendedores de tacos han propuesto : Si cada uno de los M amigos pueden probar cada una de las N  salsas mientras se comen sus tacos, obtendrán una membresía de tacos gratis por un mes. Dentro del reto existe una pequeña restricción, una vez que pruebas una salsa, no la puedes volver a probar. Todos están dispuestos a entrar al reto, aunque hay un factor importante en esta situación: Si una persona con aguante b_j come un taco con salsa de intesidad a_i, si los valores difieren la persona adquirirá un disgusto de  |a_i - b_j| el cual es acumulativo. Como podrás darte cuenta, el disgusto total de sus amigos sumado D se puede expresarse como: D =  sum_{i=1}^{N} sum_{j=1}^{M} | a_i - b_j |. Ángel se quiere prevenir y desea conocer disgusto total de sus amigos que tendrá que aguantar durante el día al final del reto.",
        "entrada": "En la primera línea N y M (1<=N,M<=10^5). En la segunda línea enteros a_i indicando las N  intensidades de las salsas. En la tercera línea otros M enteros b_j (1<=a_i,b_j<=10^5) indicando los niveles de aguante de picante de los amigos de Ángel.",
        "salida": "La cantidad de disgusto total D de los amigos de Ángel al final del reto.",
        "nivel": "()",
        "categorias": [
            "Vectores",
            "Ordenamiento",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c = 0, d = 0, e = 0, f = 0;\n    vector<int> num(100000, 0);\n    vector<int> sub(100000, 0);\n    cin >> a >> b;\n    for (auto i = 0; i < a; i++)\n    {\n        cin >> num[i];\n    }\n    for (auto i = 0; i < b; i++)\n    {\n        cin >> sub[i];\n        d += sub[i];\n    }\n    sort(num.begin(), num.end());\n    sort(sub.begin(), sub.end());\n    for (auto i = 0; i < b; i++)\n    {\n        while (sub[i] >= num[c])\n        {\n            e += (abs(((b - i) * num[c]) - d) + abs((i * num[c]) - f));\n            c++;\n            if (c == a)\n            {\n                cout << e;\n                return 0;\n            }\n        }\n        d -= sub[i];\n        f += sub[i];\n        if (i == b - 1)\n        {\n            i++;\n            while (c != a)\n            {\n                e += (abs(((b - i) * num[c]) - d) + abs((i * num[c]) - f));\n                c++;\n            }\n            cout << e;\n            return 0;\n        }\n    }\n    cout << e;\n\n    return 0;\n}"
    },
    {
        "titulo": "4256. Problema C",
        "url": "https://omegaup.com/arena/problem/Problema-C/",
        "descripcion": "Roy tiene una cadena S de longitud N. La cadena S está hecha de letras minúsculas. A Roy le gustan las cadenas ordenadas, por lo tanto, se pregunta cómo se ordenan muchas sub-cadenas de S. Dada la cadena S , su tarea consiste en contar el número de sub-cadenas ordenadas de S. Una cadena S está ordenada lexicográficamente si  S_i<=(S_i+1) donde 1<=i<=N-1 (considere la indexación desde 1).",
        "entrada": "La primera línea del caso de prueba es un número T (0<T<1000) que representa la cantidad de casos de prueba. Cada caso de prueba inicia con una línea con un entero N (1<=N<=1000000) que representa la longitud de la cadena. Luego sigue una línea con una cadena S de longitud N.",
        "salida": "Por cada caso se debe imprimir la cantidad de sub­cadenas ordenadas.",
        "nivel": "()",
        "categorias": [
            "Colas",
            "Cadenas y caracteres",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "queue<int>",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d;\n    queue<int> falta;\n    string z;\n    cin >> a;\n    while (a--)\n    {\n        cin >> b >> z;\n        d = b;\n        for (auto i = 0; i < z.size() - 1; ++i)\n        {\n            falta.push(i + 1);\n        }\n        while (falta.size())\n        {\n            c = falta.front();\n            falta.pop();\n            if (z[c] >= z[c - 1])\n            {\n                d++;\n                if ((c + 1) < z.size())\n                {\n                    falta.push(c + 1);\n                }\n            }\n        }\n        cout << d << \"\\n\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "377. Divisores",
        "url": "https://omegaup.com/arena/problem/Divisores/",
        "descripcion": "Durante tu camino al concurso Coding Rush ITAM, había mucho tráfico y como estabas muy aburrido te pusiste a ver los números en las placas de los coches y a calcular sus divisores primos. Después de lo que aprendiste hoy, sabes que calcular los divisores primos de un número es más fácil si lo programas. Recuerda que un número es divisor del otro si cuando realizas la operación de división, no hay residuo. * 5 no es divisor de 12. * 2 sí es divisor de 12.",
        "entrada": "Leerás N (0<=N<=3000) líneas, en cada una de ellas habrá un número.",
        "salida": "Por cada línea leída, debes imprimir los divisores primos que tiene separados por un espacio en orden ascendente sin repetir ningún divisor.",
        "nivel": "()",
        "categorias": [
            "Ciclos"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long b;\n    while (cin >> b)\n    {\n        if (b % 2 == 0)\n        {\n            cout << \"2 \";\n        }\n        if (b % 3 == 0)\n        {\n            cout << \"3 \";\n        }\n        if (b % 5 == 0)\n        {\n            cout << \"5 \";\n        }\n        if (b % 7 == 0)\n        {\n            cout << \"7 \";\n        }\n        cout << \"\\n\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "779. Ancho de un Árbol",
        "url": "https://omegaup.com/arena/problem/Ancho-de-un-arbol/",
        "descripcion": "Supon que deseas dibujar un arbol binario en una cuadricula cuyas columnas estan numeradas de acuerdo a las siguientes reglas: Todos los nodos en un mismo nivel deberan estar en la misma fila. Cada columna de la cuadricula puede tener solamente un nodo. Los nodos en el subarbol izquierdo de un nodo deberan ser dibujados en una columna a la izquierda del mismo, al igual los nodos del subarbol derecho deberan ser dibujados en columnas a la derecha del mismo. Al dibujar el arbol no debe quedar ninguna columna sin nodo entre la columna mas a la izquierda y mas a la derecha del dibujo. El ancho de un nivel se puede obtener restando el numero de la columna derecha menos la columna izquierda del mismo mas uno. La raiz del arbol se considera el nivel 1. La siguiente figura muestra un arbol binario dibujado de acuerdo a la siguiente regla. El ancho del primer nivel es uno mientras que el ancho del segundo es 13, el tercer, cuarto, quindo y sexto nivel tienen los anchos 18, 18, 13 y 12 respectivamente. Debes crear un programa que al dibujar un arbol de esta forma calcule cual es el nivel mas ancho del arbol, si dos niveles tienen el ancho maximo, como en el caso del ejemplo el nivel 3 y el 4, entonces debes tomar el nivel con menor numero.",
        "entrada": "Tu programa debera leer del teclado los siguientes datos, la primera linea contendra un numero N (1<=N<=1000) entre 1 y 1,000 que indica el numero de nodos del arbol. Cada una de las siguientes N lineas contiene 3 enteros, denotando 3 nodos, donde el primer numero indica un nodo, el segundo y tercer numeros de la linea indican el nodo izquierdo y derecho del nodo respectivamente. Cada nodo esta numerado del 1 al N.  Si hay un nodo que no tenga hijos, entonces su hijo tendra el numero -1. El nodo raiz tiene el numero 1.",
        "salida": "Tu programa debera escribir a la pantalla dos numeros en una linea separados por un espacio, el primer numero indica el nivel con el ancho maximo, mientras que el segundo numero indica el ancho del nivel. Si hay mas de un nivel con el ancho maximo imprime el nivel de menor numero.",
        "nivel": "(medio)",
        "categorias": [
            "Vectores",
            "Ciclos"
        ],
        "estructuras": [
            "vector<pair<long long, long long>>",
            "int",
            "vector<>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long a, b = 1, c = 0, d = 1;\nvector<pair<long long, long long>> sub(1001, {0, 0});\n\nstruct sobra\n{\n    int aa, bb, cc;\n};\n\nvector<sobra> num(1001);\n\nint sum(int z)\n{\n    if (num[z].bb != -1)\n    {\n        b++;\n        sum(num[z].bb);\n    }\n    if (!sub[b].first)\n    {\n        sub[b].first = d;\n        sub[b].second = d;\n    }\n    else\n    {\n        sub[b].second = d;\n    }\n    d++;\n    if (num[z].cc != -1)\n    {\n        b++;\n        sum(num[z].cc);\n    }\n    b--;\n    return 0;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    cin >> a;\n    for (auto i = 1; i <= a; i++)\n    {\n        cin >> num[i].aa >> num[i].bb >> num[i].cc;\n    }\n    sum(1);\n    for (auto i = 1; i <= a; i++)\n    {\n        b = ((sub[i].second - sub[i].first) + 1);\n        if (b > c)\n        {\n            c = b;\n            d = i;\n        }\n    }\n    cout << d << \" \" << c;\n\n    return 0;\n}"
    },
    {
        "titulo": "5412. Fer escapando",
        "url": "https://omegaup.com/arena/problem/Fer-escapando/",
        "descripcion": "Fernando estaba viajando en el tiempo cuando terminó siendo perseguido por un robot en el futuro. ¡Oh no! Afortunadamente, Fer programó su máquina del tiempo para teletransportarlo después de T segundos. Fer avanza a una velocidad constante de V metros por segundo. En contraste, el robot avanzará C_i metros del segundo i al i+1, donde C_i puede variar de segundo a segundo. Ayuda a Fer a escapar, es decir, a que en cualquier segundo entero Q tal que 0<=Q<=T, Fer siempre esté adelante del robot por lo menos un metro.",
        "entrada": "Tres enteros T (0<T<=10^5), R y F (0<R<F<=100) que corresponden con el tiempo que durará la persecución, la posición de inicial del robot y la posición inicial de Fer. Las posiciones de Fer y del robot se ubican en una recta numérica. La siguiente línea contiene T enteros que corresponden con los valores de C_i (0<=C_i<=10^4).",
        "salida": "Un entero no negativo que es la velocidad mínima V que Fer necesita tener para poder escapar.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Ciclos"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d = 0, e;\n    cin >> a >> b >> c;\n    for (auto i = 1; i <= a; i++)\n    {\n        cin >> e;\n        b += e;\n        c += d;\n        while (b >= c)\n        {\n            d++;\n            c += i;\n        }\n    }\n    cout << d;\n\n    return 0;\n}"
    },
    {
        "titulo": "8178. Cesar y el modulo",
        "url": "https://omegaup.com/arena/problem/David-y-el-modulo-ETITC/",
        "descripcion": "Cesar acaba de recibir una clase de matemáticas. En esta su profesor le enseñó que se puede saber si un número es múltiplo de otro siempre y cuando a/b tenga como residuo 0 siendo ‘a’ el número en cuestión por el que se quiere saber si es múltiplo de ‘b’. Su profesor le dejó la siguiente tarea: Al sumar los dos números ‘a’ y ‘b’ se quiere saber si es múltiplo de ‘s’. Lastimosamente Cesar tiene un profesor llamado Ardila que lo hace escribir como mil hojas examen para un 3. Ayuda a Cesar a resolver su tarea de matemáticas, pues no tiene tiempo y quiere dormir.",
        "entrada": "Ingresan 3 números a, b y s (0<=a,b,s<=10^11). Los dos primeros representan la suma y s será el número del cual se revisa ser múltiplo.",
        "salida": "Si la suma es múltiplo de s mostrar \"SI\" (exceptuando las comillas) y \"NO\" de lo contrario (exceptuando las comillas).",
        "nivel": "Intermedio (fácil) - Matemáticas en la programación",
        "categorias": [
            "Aritmética modular",
            "Implementación"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c;\n    cin >> a >> b >> c;\n    if ((a + b) % c)\n    {\n        cout << \"NO\";\n    }\n    else\n    {\n        cout << \"SI\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "6910. pH",
        "url": "https://omegaup.com/arena/problem/pH/",
        "descripcion": "El Sr. pH te ha pedido calcular si su valor n representa un Ácido, Base o Neutro, es por esto, que pide tu ayuda. ¿Te crees capaz?",
        "entrada": "Deberás ingresar un número entero n, dónde n representa al valor del pH.",
        "salida": "La palabra Acido, Base o Neutro dependiendo de los valores del pH, en caso de que el valor del pH no exista imprime Are you kidding me?.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Cálculos aritméticos",
            "..."
        ],
        "estructuras": [
            "long double"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long double a;\n    cin >> a;\n    if (a > -1 && a < 7)\n    {\n        cout << \"Acido\";\n    }\n    else if (a >= 7 && a < 8)\n    {\n        cout << \"Neutro\";\n    }\n    else if (a <= 14 && a > -1)\n    {\n        cout << \"Base\";\n    }\n    else\n    {\n        cout << \"Are you kidding me?\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "2194. Shift cipher",
        "url": "https://omegaup.com/arena/problem/ShiftCipher/",
        "descripcion": "Debes haber oido de una antigua manera de encriptacion llama Caesar cipher o 'shift cipher'. Esto es, dado el texto y un numero D,tu podrias remplazar cada caracter c en el texto con otro caracter el cual esta D lugares despues de c en el alfabeto. (El alfabeto tomado en cuenta incluye las letras contenidas en un teclado norteamericano). Por ejemplo, si D = 2, tu podrias remplazar 'a' con 'c', remplazar 'b' con 'd', ... remplazar 'y' con 'a', y remplazar 'z' con 'b'. Dado el texto y un entero D, tu podras generar el cipher(texto encriptado).",
        "entrada": "La primera linea es un entero T, El numero de casos de prueba. Cada caso contiene solo una linea, consiste del texto y de un numero D (D<26), separados por un espacio. Asume que hay solo letras minusculas, y el tamaño del texto no es mayor a 100.",
        "salida": "Genera un linea para cada caso, indicando el cipher(texto encriptado).",
        "nivel": "Básico () - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c;\n    string z;\n    cin >> a;\n    while (a--)\n    {\n        cin >> z >> b;\n        b %= 26;\n        for (auto i = 0; i < z.size(); i++)\n        {\n            c = z[i];\n            c += b;\n            if (c > 122)\n            {\n                c -= 26;\n            }\n            z[i] = c;\n            cout << z[i];\n        }\n        cout << \"\\n\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "5991. Encuentra el teléfono",
        "url": "https://omegaup.com/arena/problem/find-the-telephone/",
        "descripcion": "En algunos lugares, es común recordar un número de teléfono asociando sus dígitos a letras. De esta forma, la expresión MY LOVE significa 69 5683. Por supuesto que hay algunos problemas, porque algunos números de teléfono no pueden formar una palabra o una frase y los dígitos 1 y 0 no están asociados a ninguna letra. Tu tarea es leer una expresión y encontrar el número de teléfono correspondiente según la tabla a continuación. LetrasNúmeros ABC2DEF3GHI4JKL5MNO6PQRS7TUV8WXYZ9. Una expresión se compone exclusivamente de las letras mayúsculas (A-Z), guiones (-) y los números 1 y 0.",
        "entrada": "Una única línea con una expresión con un máximo de 30 caracteres.",
        "salida": "Mostrar el número correspondiente.",
        "nivel": "()",
        "categorias": [
            "Caracteres y cadenas",
            "Ciclos"
        ],
        "estructuras": [
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    string z;\n    cin >> z;\n    for (auto i = 0; i < z.size(); i++)\n    {\n        if (z[i] < 'A' || z[i] > 'Z')\n        {\n            cout << z[i];\n            continue;\n        }\n        if (z[i] <= 'C')\n        {\n            cout << \"2\";\n        }\n        else if (z[i] <= 'F')\n        {\n            cout << \"3\";\n        }\n        else if (z[i] <= 'I')\n        {\n            cout << \"4\";\n        }\n        else if (z[i] <= 'L')\n        {\n            cout << \"5\";\n        }\n        else if (z[i] <= 'O')\n        {\n            cout << \"6\";\n        }\n        else if (z[i] <= 'S')\n        {\n            cout << \"7\";\n        }\n        else if (z[i] <= 'V')\n        {\n            cout << \"8\";\n        }\n        else\n        {\n            cout << \"9\";\n        }\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "8003. ¿Qué es lo que hace un taxista?",
        "url": "https://omegaup.com/arena/problem/Que-es-lo-que-hace-un-taxista/",
        "descripcion": "Ricardo es un taxista oriundo de Aguascuadrientes, una hermosa ciudad famosa por tener forma de cuadrícula. Esto hace que sólo pueda ir de una celda a aquellas con las que comparte borde. Es decir, sólo se puede mover en cuatro direcciones: arriba, abajo, izquierda y derecha. Cada día a Ricardo le llega un itinerario que muestra a qué celdas deberá de ir y en qué orden. La primera celda a la que tiene que ir está marcada con un 1, la siguiente con un 2, y así sucesivamente. La celda en que vive Ricardo está marcada con un un 0. Ricardo siempre empieza el día en su casa y lo termina ahí. Se te asegura que visitará todas las celdas (todas están numeradas). El vehículo en que viaja Ricardo consume 1  litro de combustible yendo de una celda a otra adyacente. Sabiendo esto, quiere que le ayudes a saber cuál es la menor cantidad posible de combustible en litros que puede usar durar su jornada. Escribe un programa que le ayude a Ricardo a saber cuál es la menor cantidad de combustible que puede usar durante su jornada.",
        "entrada": "En la primera línea habrá dos enteros R y C (1<=R,C<=1000),  que representan la cantidad de renglones y columnas que hay en Aguascadrientes respectivamente. Se te asegura que R o C son mayores o iguales a 2. Después habrá R renglones, cada uno con C  enteros, con el número asignado en el itinerario de Ricardo para la celda en el R-ésimo renglón y la C-ésima columna.",
        "salida": "Un solo entero, representando la menor cantidad de combustible que puede usar Ricardo.",
        "nivel": "...",
        "categorias": [
            "Matrices",
            "Vectores",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "vector<pair<int, int>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d = 0;\n    vector<pair<int, int>> num(1000001, {0, 0});\n    cin >> a >> b;\n    for (auto i = 0; i < a; i++)\n    {\n        for (auto j = 0; j < b; j++)\n        {\n            cin >> c;\n            num[c].first = i;\n            num[c].second = j;\n        }\n    }\n    for (auto i = 1; i < a * b; i++)\n    {\n        d += abs(num[i].first - num[i - 1].first);\n        d += abs(num[i].second - num[i - 1].second);\n    }\n    d += abs(num[0].first - num[(a * b) - 1].first);\n    d += abs(num[0].second - num[(a * b) - 1].second);\n    cout << d;\n\n    return 0;\n}"
    },
    {
        "titulo": "4604. Haches",
        "url": "https://omegaup.com/arena/problem/Haches/",
        "descripcion": "Cuenta cuántas palabras inicial con la letra hache, ya sea mayúscula o minúscula, en determinada frase.",
        "entrada": "Una frase compuesta por a lo más 100 caracteres.",
        "salida": "La frase \"N haches\" donde N es la cantidad de palabras que inician con 'H' o 'h' dentro de la frase.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Ciclos",
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "long long",
            "string",
            "getline()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a = 0;\n    string z;\n    getline(cin, z);\n    for (auto i = 1; i < z.size(); i++)\n    {\n        if (z[i] == ' ' && (z[i + 1] == 'h' || z[i + 1] == 'H'))\n        {\n            a++;\n        }\n    }\n    if (z[0] == 'h' || z[0] == 'H')\n    {\n        a++;\n    }\n    cout << a << \" haches\";\n\n    return 0;\n}"
    },
    {
        "titulo": "4897. Pivote",
        "url": "https://omegaup.com/arena/problem/Pivote_UP/",
        "descripcion": "Dado un arreglo X de n números, x_0,...,x_{n-1} escribe un programa que coloque un elemento del arreglo llamado \"pivote\" en alguna posición, y reordene el arreglo en base a dicho pivote, de tal manera que los elementos a su izquierda sean menores, y los elementos a su derechea sean mayores o iguales. Por ejemplo, suponga el siguiente arreglo: X = 2,4,6,1,3,9,5,7. Si tomamos el número 7 como pivote, un reordamiento válido sería: 3,1,2,5,6,7,9,8. Cómo se puede observar, todos los elementos a la izquierda de 7, son menores a 7, y los elementos a la derecha son mayores a 7, por lo cual es reordamiento válido.",
        "entrada": "La primera línea contiene un número n (2<=n<1000), indicando el número de elementos en el arreglo. Le siguen n numeros en el rango de [0,10^6], que representan a los elementos del arreglo",
        "salida": "En la primera línea imprimir dos números, n y k, indicando la cantidad de elementos en el arreglo y la posición final del pivote. Le siguen n línea, cada uno con los elementos del arreglo reordenado.",
        "nivel": "Intermedio (fácil) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Ciclos",
            "Ordenamiento",
            "Vectores"
        ],
        "estructuras": [
            "long long",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b;\n    vector<int> falta;\n    vector<int> faltas;\n    vector<int> num(1000001, 0);\n    cin >> a;\n    for (auto i = 0; i < a; i++)\n    {\n        cin >> num[i];\n    }\n    b = num[a - 1];\n    for (auto i = 0; i < a - 1; i++)\n    {\n        if (num[i] < b)\n        {\n            falta.push_back(num[i]);\n        }\n        else\n        {\n            faltas.push_back(num[i]);\n        }\n    }\n    cout << a << \" \" << falta.size() << \"\\n\";\n    for (auto i = 0; i < falta.size(); i++)\n    {\n        cout << falta[i] << \"\\n\";\n    }\n    cout << b << \"\\n\";\n    for (auto i = 0; i < faltas.size(); i++)\n    {\n        cout << faltas[i] << \"\\n\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "7389. Si o No en caso se repita",
        "url": "https://omegaup.com/arena/problem/Si-o-No-en-caso-se-repita/",
        "descripcion": "Realiza un programa que solicite tres números e imprima Si o No si algún número se repite.",
        "entrada": "Escribe tres números enteros a, b y c",
        "salida": "Sí ó No, en caso que algún número se repita.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            ""
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c;\n    cin >> a >> b >> c;\n    if (a == b || a == c || b == c)\n    {\n        cout << \"Si\";\n    }\n    else\n    {\n        cout << \"No\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "8525. Alejando la bomba del origen",
        "url": "https://omegaup.com/arena/problem/Alejando-la-bomba-del-origen/",
        "descripcion": "Hay N robots en la recta y una bomba en el origen: tu objetivo es usar los robots para alejar la bomba lo más posible del origen, sin importar si es a la derecha o a la izquierda. Cada robot cuenta con una posición inicial , una cantidad de energía E y gasta una unidad de energía para recorrer una unidad de distancia sobre la recta. Cuando un robot alcanza la bomba, éste puede cargarla y llevársela (el robot gasta la misma cantidad de energía caminando con o sin la bomba); el robot puede soltar la bomba en cualquier momento o bien, soltarla hasta que se acabe su energía y ya no pueda avanzar más. Si fuera posible, otro robot puede ir a recoger la bomba en la posición en la que quedó para seguir alejándola del origen. Los robots pueden programarse en cualquier orden. Escribe un programa que determine a cuánta distancia del origen puede alejarse la bomba si se usan los robots de manera óptima.",
        "entrada": "Un entero N seguido de N parejas de enteros P, E que determinan la posición y energía de cada robot. Puedes suponer que 0<=N<=10, -100<=P<=100 y 0<=E<=100.",
        "salida": "Un entero positivo que sea la magnitud de la distancia con respecto al origen a la que puede alejarse la bomba.",
        "nivel": "Intermedio (fácil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Fuerza bruta",
            "Permutaciones",
            "Vectores",
            "Colas",
            "Ciclos",
            "Ordenamiento"
        ],
        "estructuras": [
            "long long",
            "vector<pair<int, int>>",
            "queue<pair<int, int>>",
            "pair<int, int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e, f, g;\n    vector<pair<int, int>> num(20, {0, 0});\n    queue<pair<int, int>> falta;\n    pair<int, int> z;\n    cin >> a;\n    for (auto i = 0; i < a; i++)\n    {\n        cin >> num[i].first >> num[i].second;\n    }\n    sort(num.begin(), num.end());\n    for (auto i = 0; i < a; i++)\n    {\n        if (num[i].second > abs(num[i].first))\n        {\n            b = abs(num[i].first) - num[i].second;\n            for (auto j = a - 1; j > -1; j--)\n            {\n                if (j == i)\n                {\n                    continue;\n                }\n                e = falta.size();\n                while (e--)\n                {\n                    z = falta.front();\n                    falta.pop();\n                    if (z.first >= b)\n                    {\n                        c = z.first - z.second;\n                        b = min(c, b);\n                    }\n                    else\n                    {\n                        d = b - z.first;\n                        if (z.second > d)\n                        {\n                            d = z.second - d;\n                            b -= d;\n                        }\n                        else\n                        {\n                            falta.push(z);\n                        }\n                    }\n                }\n                if (num[j].first >= b)\n                {\n                    c = num[j].first - num[j].second;\n                    b = min(c, b);\n                }\n                else\n                {\n                    d = b - num[j].first;\n                    if (num[j].second > d)\n                    {\n                        d = num[j].second - d;\n                        b -= d;\n                    }\n                    else\n                    {\n                        z.first = num[j].first;\n                        z.second = num[j].second;\n                        falta.push(z);\n                    }\n                }\n            }\n            e = falta.size();\n            while (e--)\n            {\n                z = falta.front();\n                falta.pop();\n                if (z.first >= b)\n                {\n                    c = z.first - z.second;\n                    b = min(c, b);\n                }\n                else\n                {\n                    d = b - z.first;\n                    if (z.second > d)\n                    {\n                        d = z.second - d;\n                        b -= d;\n                    }\n                    else\n                    {\n                        falta.push(z);\n                    }\n                }\n            }\n            g = abs(b);\n            f = max(f, g);\n            b = num[i].second - abs(num[i].first);\n            for (auto j = 0; j < a; j++)\n            {\n                if (j == i)\n                {\n                    continue;\n                }\n                e = falta.size();\n                while (e--)\n                {\n                    z = falta.front();\n                    falta.pop();\n                    if (z.first <= b)\n                    {\n                        c = z.first + z.second;\n                        b = max(c, b);\n                    }\n                    else\n                    {\n                        d = z.first - b;\n                        if (z.second > d)\n                        {\n                            d = z.second - d;\n                            b += d;\n                        }\n                        else\n                        {\n                            falta.push(z);\n                        }\n                    }\n                }\n                if (num[j].first <= b)\n                {\n                    c = num[j].first + num[j].second;\n                    b = max(c, b);\n                }\n                else\n                {\n                    d = num[j].first - b;\n                    if (num[j].second > d)\n                    {\n                        d = num[j].second - d;\n                        b += d;\n                    }\n                    else\n                    {\n                        z.first = num[j].first;\n                        z.second = num[j].second;\n                        falta.push(z);\n                    }\n                }\n            }\n            e = falta.size();\n            while (e--)\n            {\n                z = falta.front();\n                falta.pop();\n                if (z.first <= b)\n                {\n                    c = z.first + z.second;\n                    b = max(c, b);\n                }\n                else\n                {\n                    d = z.first - b;\n                    if (z.second > d)\n                    {\n                        d = z.second - d;\n                        b += d;\n                    }\n                }\n            }\n            f = max(f, b);\n        }\n    }\n    cout << f;\n\n    return 0;\n}"
    },
    {
        "titulo": "8450. El amigable Hombre Araña",
        "url": "https://omegaup.com/arena/problem/OMI-2019-Spider-Man/",
        "descripcion": "En últimos meses las acciones de Stark Industries han caído, los empleados de esta empresa están desanimados. Para subir la moral, Tony Stark, CEO de Stark Industries, le pidió ayuda a Spiderman. A cambio Tony Stark le diseñará un nuevo traje. Spiderman debe escalar la Torre Stark y saludar a tantos empleados distintos como pueda. La torre tiene N pisos y en cada piso hay M ventanas. Cada ventana permite ver el interior de la oficina de un empleado diferente (los empleados siempre están en sus oficinas). Sin embargo, Spiderman olvidó desayunar así que sólo tiene K energía. Spiderman sólo puede moverse de forma vertical o de forma horizontal. Cuando se mueve de una ventana a otra horizontalmente gasta X energía y cuando se mueve verticalmente gasta Y energía. Ayuda a Spiderman a saber cuál es la mayor cantidad de empleados distintos a los que podrá saludar. Spiderman inicia en la primer ventana de la izquierda del primer piso.",
        "entrada": "En una sola línea 5 enteros: N, M, K, X y Y (1 <= N,M,K,X,Y < 2^31). Estos enteros representan representan el número de pisos, el número de ventanas por piso, la energía inicial, el costo de moverse horizontalmente y el costo de moverse verticalmente, respectivamente.",
        "salida": "Un entero que indica la máxima cantidad de empleados distintos a los que puede saludar Spiderma",
        "nivel": "(medio)",
        "categorias": [
            ""
        ],
        "estructuras": [
            "unsigned long long int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    unsigned long long int a, b, c, d, e, f, g;\n    cin >> a >> b >> c >> d >> e;\n    if (d > c && e > c)\n    {\n        cout << 1;\n        return 0;\n    }\n    if (d <= e)\n    {\n        f = (a * (b - 1) * d) + ((a - 1) * e);\n        if (c >= f)\n        {\n            cout << a * b;\n            return 0;\n        }\n        f = ((b - 1) * d) + e;\n        g = (c / f) * b;\n        c %= f;\n        f = c / d;\n        b--;\n        g += min(f, b);\n        cout << g + 1;\n        return 0;\n    }\n    f = (b * (a - 1) * e) + ((b - 1) * d);\n    if (c >= f)\n    {\n        cout << a * b;\n        return 0;\n    }\n    f = ((a - 1) * e) + d;\n    g = (c / f) * a;\n    c %= f;\n    f = c / e;\n    a--;\n    g += min(f, a);\n    cout << g + 1;\n    return 0;\n\n    return 0;\n}"
    },
    {
        "titulo": "5978. El mejor programador",
        "url": "https://omegaup.com/arena/problem/Comparacion-programadores/",
        "descripcion": "Santiago decidió hacer un programa capaz de decir el mejor de dos programadores conforme su calificación en sus practicas, curiosamente no hubo empates. Dado dos programadores con su calificaciones decir el nombre del mejor.",
        "entrada": "-Primera linea: Un nombre del primer programador y un entero A que que simboliza sus puntos. -Segunda linea: Un nombre del primer programador y un entero B que simboliza sus puntos. Considera que Nombres<5000 caracteres y que 0<=A,B<=2^31.",
        "salida": "Nombre del mejor programador",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Cálculos aritméticos",
            "Cadenas y caracteres"
        ],
        "estructuras": [
            "long long",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b;\n    string z, zz;\n    cin >> z >> a >> zz >> b;\n    if (a > b)\n    {\n        cout << z;\n    }\n    else\n    {\n        cout << zz;\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "4548. La fila de guardias de la Reina Roja",
        "url": "https://omegaup.com/arena/problem/Guardias-de-la-Reina-Roja/",
        "descripcion": "Los guardias de la Reina Roja siempre deben estar atentos a sus exigencias. Recordemos que cada guardia es en realidad una carta de baraja, con un número del 1 al 13 y uno de cuatro tipos. Últimamente se le ocurrió a la Reina Roja que cuando veía un grupo de guardias, estos debían formar una fila de una manera especial: Cada dos guardias consecutivos en la fila deben compartir el mismo número o el mismo tipo. Como esto no siempre se puede, el grupo de guardias intenta formar la fila más larga posible que cumpla estas condiciones. Por supuesto, los que no queden en la fila ¡perderán la cabeza!",
        "entrada": "Un entero M seguido de la descripción de M cartas distintas. Cada carta está descrita por una pareja de enteros N, Tque denotan su número y tipo respectivamente. Puedes suponer que 1<=M<=18, que 1<=N<=13 y que 1<=T<=4.",
        "salida": "Un entero que sea la cantidad más grande de guardias que se pueden formar en la fila.",
        "nivel": "Intermedio (difícil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Vectores",
            "Ciclos",
            "Memorización",
            "Búsqueda con retroceso",
            "Ordenamiento"
        ],
        "estructuras": [
            "int",
            "vector<pair<int, int>>",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint a, b = 0, c;\nvector<pair<int, int>> num(36, {0, 0});\nvector<int> sub(36, 0);\n\nint falta(int z)\n{\n    int zz = num[z].first, zzz = num[z].second;\n    for (auto i = 0; i < a; i++)\n    {\n        if (!sub[i] && num[i].first == zz)\n        {\n            b++;\n            c = max(c, b);\n            if (b == a)\n            {\n                return 0;\n            }\n            sub[i] = 1;\n            falta(i);\n            if (b == a)\n            {\n                return 0;\n            }\n            b--;\n            sub[i] = 0;\n        }\n    }\n    for (auto i = 0; i < a; i++)\n    {\n        if (!sub[i] && num[i].second == zzz)\n        {\n            b++;\n            c = max(c, b);\n            if (b == a)\n            {\n                return 0;\n            }\n            sub[i] = 1;\n            falta(i);\n            if (b == a)\n            {\n                return 0;\n            }\n            b--;\n            sub[i] = 0;\n        }\n    }\n    return 0;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    cin >> a;\n    for (auto i = 0; i < a; i++)\n    {\n        cin >> num[i].first >> num[i].second;\n    }\n    sort(num.begin(), num.end());\n    for (auto i = 0; i < a; i++)\n    {\n        sub[i] = 1;\n        b++;\n        c = max(c, b);\n        falta(i);\n        sub[i] = 0;\n        if (b == a)\n        {\n            break;\n        }\n        b--;\n    }\n    cout << c;\n\n    return 0;\n}"
    },
    {
        "titulo": "4554. occ16nsfd22b",
        "url": "https://omegaup.com/arena/problem/occ16nsfd22b/",
        "descripcion": "Haga un programa que reciba un número n y a continuación una lista de n números. Y que a continuación la reemplace por una que resulta de sumar las parejas adyacentes, note que la lista resultante tiene un elmento menos que el anterior. Este proceso se debe repetir hasta que solamente quede un número. El programa debe imprimir ese número.",
        "entrada": "",
        "salida": "",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Ciclos",
            "Vectores"
        ],
        "estructuras": [
            "long long",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a;\n    vector<int> num(1000000, 0);\n    cin >> a;\n    for (auto i = 0; i < a; i++)\n    {\n        cin >> num[i];\n    }\n    for (auto i = a - 2; i > -1; i--)\n    {\n        for (auto j = 0; j <= i; j++)\n        {\n            num[j] += num[j + 1];\n        }\n    }\n    cout << num[0];\n\n    return 0;\n}"
    },
    {
        "titulo": "...",
        "url": "...",
        "descripcion": "...",
        "entrada": "...",
        "salida": "...",
        "nivel": "...",
        "categorias": [
            "...",
            "..."
        ],
        "estructuras": [
            "..."
        ],
        "codigo": "..."
    },
    "Problemas totales: 221",
    "Avanzado (difícil) - Programación competitiva: 4",
    "Avanzado (medio) - Temas especializados: 1",
    "Avanzado (medio) - Programación competitiva: 3",
    "Avanzado (fácil) - Programación competitiva: 7",
    "Intermedio (difícil) - Estructuras de datos y Algoritmos: 5",
    "Intermedio (difícil) - Análisis y diseño de algoritmos: 14",
    "Intermedio (difícil) - Matemáticas en la programación: 7",
    "Intermedio (medio) - Estructuras de datos y Algoritmos: 3",
    "Intermedio (medio) - Análisis y diseño de algoritmos: 12",
    "Intermedio (medio) - Matemáticas en la programación: 5",
    "Intermedio (fácil) - Estructuras de datos y Algoritmos: 3",
    "Intermedio (fácil) - Análisis y diseño de algoritmos: 5",
    "Básico (difícil) - Introducción a la programación: 17",
    "Básico (medio) - Introducción a la programación: 33",
    "Básico (fácil) - Introducción a la programación: 41"
]