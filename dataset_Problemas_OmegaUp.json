[
    {
        "titulo": "11656. Laberinto final",
        "url": "https://omegaup.com/arena/problem/Laberinto-final/",
        "descripcion": "El Malvado Robot OMI ha bloqueado las salidas del templo mientras entrenaban, entonces la prueba final será escapar del templo.El templo se puede ver como una matriz de N X M en donde esta representado por un \".\" un camino libre y una \"X\" una pared, con la posibilidad de hacer movimientos de tipo (i-1,j),(i,j+1),(i+1,j)y(i,j-1). Para esta prueba desarrollaron el poder de bola de fuego que les permite destruir paredes, sin embargo, no pueden destruir más de k paredes, si no el templo se derrumbaría y todos morirían :(. Ayuda a los programadores mayas a encontrar el camino más corto a la salida del templo representada por un \"M\" su posición en la matriz y una \"S\" la posición de la salida.",
        "entrada": "Tres enteros N, M y k seguido de N líneas con M caracteres de tipo \".\", \"X\", \"M\" y \"S\" descritas anteriormente.",
        "salida": "Un único número que sea el número de pasos del camino más corto con las condiciones ya mencionadas. En caso de que no exista camino posible imprime \"F\" sin comillas para darle tus respetos a los programadores mayas.",
        "nivel": "Avanzado (difícil) - Programación competitiva",
        "categorias": [
            "Matrices",
            "Colas",
            "Búsqueda en amplitud"
        ],
        "estructuras": [
            "int",
            "vector<vector<char>>",
            "vector<vector<int>>",
            "queue<struct>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef struct{\n    int aa, bb, cc, dd;\n}sobra;\n\nint a, b, c, d, e, f, g, h, l;\nchar num[102][102];\nint sub[102][102];\nqueue<sobra>falta;\nsobra z;\n\nint main(){\n  cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  cin>>a>>b>>c;\n for(auto i=0; i<a; ++i){\n       for(auto j=0; j<b; ++j){\n           cin>>num[i][j];\n           if(num[i][j]=='M'){\n               z.aa=i;\n               z.bb=j;\n               z.cc=c;\n               z.dd=0;\n               falta.push(z);\n                sub[i][j]=1;\n          }\n     }\n }\n while(falta.size()){\n      z=falta.front();\n      falta.pop();\n      z.dd++;\n       z.aa--;\n       if(z.aa>-1){\n          if(num[z.aa][z.bb]=='.' and !sub[z.aa][z.bb]){\n                falta.push(z);\n                sub[z.aa][z.bb]=z.dd;\n         }\n         else if(num[z.aa][z.bb]=='.' and z.dd<sub[z.aa][z.bb]){\n               falta.push(z);\n                sub[z.aa][z.bb]=z.dd;\n         }\n         else if(num[z.aa][z.bb]=='X' and z.cc and !sub[z.aa][z.bb]){\n              z.cc--;\n               falta.push(z);\n                z.cc++;\n               sub[z.aa][z.bb]=z.dd;\n         }\n         else if(num[z.aa][z.bb]=='X' and z.cc and z.dd<sub[z.aa][z.bb]){\n              z.cc--;\n               falta.push(z);\n                z.cc++;\n               sub[z.aa][z.bb]=z.dd;\n         }\n         else if(num[z.aa][z.bb]=='S'){\n                cout<<z.dd;return 0;\n          }\n     }\n     z.aa+=2;\n      if(z.aa<a){\n           if(num[z.aa][z.bb]=='.' and !sub[z.aa][z.bb]){\n                falta.push(z);\n                sub[z.aa][z.bb]=z.dd;\n         }\n         else if(num[z.aa][z.bb]=='.' and z.dd<sub[z.aa][z.bb]){\n               falta.push(z);\n                sub[z.aa][z.bb]=z.dd;\n         }\n         else if(num[z.aa][z.bb]=='X' and z.cc and !sub[z.aa][z.bb]){\n              z.cc--;\n               falta.push(z);\n                z.cc++;\n               sub[z.aa][z.bb]=z.dd;\n         }\n         else if(num[z.aa][z.bb]=='X' and z.cc and z.dd<sub[z.aa][z.bb]){\n              z.cc--;\n               falta.push(z);\n                z.cc++;\n               sub[z.aa][z.bb]=z.dd;\n         }\n         else if(num[z.aa][z.bb]=='S'){\n                cout<<z.dd;return 0;\n          }\n     }\n     z.aa--;\n       z.bb--;\n       if(z.bb>-1){\n          if(num[z.aa][z.bb]=='.' and !sub[z.aa][z.bb]){\n                falta.push(z);\n                sub[z.aa][z.bb]=z.dd;\n         }\n         else if(num[z.aa][z.bb]=='.' and z.dd<sub[z.aa][z.bb]){\n               falta.push(z);\n                sub[z.aa][z.bb]=z.dd;\n         }\n         else if(num[z.aa][z.bb]=='X' and z.cc and !sub[z.aa][z.bb]){\n              z.cc--;\n               falta.push(z);\n                z.cc++;\n               sub[z.aa][z.bb]=z.dd;\n         }\n         else if(num[z.aa][z.bb]=='X' and z.cc and z.dd<sub[z.aa][z.bb]){\n              z.cc--;\n               falta.push(z);\n                z.cc++;\n               sub[z.aa][z.bb]=z.dd;\n         }\n         else if(num[z.aa][z.bb]=='S'){\n                cout<<z.dd;return 0;\n          }\n     }\n     z.bb+=2;\n      if(z.bb<b){\n           if(num[z.aa][z.bb]=='.' and !sub[z.aa][z.bb]){\n                falta.push(z);\n                sub[z.aa][z.bb]=z.dd;\n         }\n         else if(num[z.aa][z.bb]=='.' and z.dd<sub[z.aa][z.bb]){\n               falta.push(z);\n                sub[z.aa][z.bb]=z.dd;\n         }\n         else if(num[z.aa][z.bb]=='X' and z.cc and !sub[z.aa][z.bb]){\n              z.cc--;\n               falta.push(z);\n                z.cc++;\n               sub[z.aa][z.bb]=z.dd;\n         }\n         else if(num[z.aa][z.bb]=='X' and z.cc and z.dd<sub[z.aa][z.bb]){\n              z.cc--;\n               falta.push(z);\n                z.cc++;\n               sub[z.aa][z.bb]=z.dd;\n         }\n         else if(num[z.aa][z.bb]=='S'){\n                cout<<z.dd;return 0;\n          }\n     }\n }\n cout<<\"F\";\n\n    return 0;\n}\n"
    },
    {
        "titulo": "10234. Los discos de la recursión",
        "url": "https://omegaup.com/arena/problem/Los-discos-de-la-recursion/",
        "descripcion": "Para todos los que hayan tomado clases de recursión con el profesor de programacion competitiva saben que le gusta explicar la recursión como una pila de discos (probablemente se pregunten que son los discos, pero eso no es de interés ahora). En una pila de disco uno pone un disco encima de otro y cuando los quieres sacar empiezas por el ultimo que metiste. Lamentablemente un día que el profesor explicaba este tema se le rompió uno de los discos que llevaba y es cuando se percató que cada disco tiene una resistencia, si a un disco le pones más discos de los que resiste se rompe. Por ejemplo, supongamos que tenemos disco de resistencia 3, 2, 1, 1. La mejor forma de ordenarlos es la siguiente: No podemos poner el de resistencia 2 abajo porque no resistiría los otros 3 discos arriba de él y lo mismo para el de 1 resistencia. Ángel le intereso tanto esto que se empezó a preguntar dado ciertos discos ¿Cuánto es el mínimo número de pilas que se puede hacer tal que no se rompa ningún disco? Y como buen programador decidiste ayudarlo en esta complicada tarea. Dado n discos con resistencias r_i decir cuánto es el mínimo número de pilas necesarias para que ningún disco se rompa.",
        "entrada": "En la primera línea un entero n (0<n<=10^6) representando la cantidad de discos. Seguido de n números r_i (0<=r_i<=10^6) que representan las resistencias de cada disco.",
        "salida": "Un único número entero que representa la cantidad mínima de pilas necesarias.",
        "nivel": "Avanzado (difícil) - Programación competitiva",
        "categorias": [
            "Vectores",
            "Ordenamiento",
            "Listas doblemente ligadas"
        ],
        "estructuras": [
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct lazos{\n    int val, prev, next;\n};\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int a, b, c=0, d, e=0, f;\n    cin>>a;\n    vector<int>ar(a);\n    for(auto i=0; i<a; i++){\n        cin>>ar[i];\n    }\n    sort(ar.begin(),ar.end());\n    vector<lazos>arr(a+1);\n    for(auto i=0; i<a; i++){\n        arr[i].val=ar[i];\n        arr[i].prev=i-1;\n        arr[i].next=i+1;\n    }\n    arr[a].val=-1;\n    arr[a].prev=a-1;\n    arr[a].next=-1;\n    while(arr[c].val!=-1){\n        e++;\n        d=c=arr[c].next;\n        arr[d].prev=-1;\n        f=1;\n        for(; arr[d].val!=-1; d=arr[d].next){\n            if(arr[d].val>=f){\n                f++;\n                if(c==d){\n                    c=arr[c].next;\n                }\n                else{\n                    arr[arr[d].prev].next=arr[d].next;\n                }\n                arr[arr[d].next].prev=arr[d].prev;\n            }\n        }\n    }\n    cout<<e;\n    \n    return 0;\n}\n"
    },
    {
        "titulo": "296. Decepción",
        "url": "https://omegaup.com/arena/problem/decepcion/",
        "descripcion": "Dado un entero n, se forma una fila de n torres con alturas desde 1 hasta n centímetros, ninguna altura aparece más de una vez. Se quieren conocer todas las permutaciones de esta fila tal que viendo la fila de frente solo se vean F torres diferentes y vista por detrás solo se vean B torres. Se dice que podemos ver una torre con altura H si no hay otra torre delante de ella (con respecto a nuestra visión) con altura mayor a H.",
        "entrada": "Tres enteros separados por espacios: n, F y B (1<=n,F,B<=13).",
        "salida": "Un entero que representa el número de permutaciones que cumplen con las condiciones establecidas.",
        "nivel": "Avanzado (difícil) - Programación competitiva",
        "categorias": [
            "Matrices",
            "Programación dinámica",
            "Teoría de numeros"
        ],
        "estructuras": [
            "int",
            "vector<vector<int>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    vector<vector<int>>choose(15,vector<int>(15));\n    vector<vector<int>>stirling(15,vector<int>(15));\n    int N, F, B;\n    cin>>N>>F>>B;\n    for (int i = 0; i < 15; i++){\n        choose[i][0] = choose[i][i] = 1;\n        for (int j = 1; j < i; j++){\n            choose[i][j] = choose[i-1][j-1] + choose[i-1][j];\n        }\n    }\n    stirling[0][0] = 1;\n    for (int i = 1; i <= N; i++){\n        for (int j = 1; j <= i; j++){\n            stirling[i][j] = stirling[i-1][j-1] + (i-1) * stirling[i-1][j];\n        }\n    }\n    int ans = 0;\n    for (int i = 0; i < N; i++){\n        ans += choose[N-1][i] * stirling[i][F-1] * stirling[N-i-1][B-1];\n    }\n    cout<<ans;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "148. Bloques",
        "url": "https://omegaup.com/arena/problem/bloques/",
        "descripcion": "Link, el héroe del tiempo, se encuentra en la Caverna de hielo. Está en un gran laberinto helado, formado por espacios libres (representados con puntos '.') y espacios bloqueados (representados con numerales '#'). En una de las posiciones libres, en un cuadro por debajo del nivel del suelo de los demás espacios libres, hay un gran botón que mientras es presionado (subiendo Link en él) abre una salida por la que puede escapar, pero al dejar de presionarlo vuelve a cerrar la salida. Sin embargo, eso no es obstáculo para nuestro héroe, pues ha encontrado dos grandes bloques de hielo que le permitirán escapar. Los bloques de hielo son pesados, por lo que para moverlos Link necesita estar en un espacio libre (opuesto a la dirección en la que el bloque se moverá). Por ejemplo, si a la izquierda del bloque el espacio esta libre puedes moverlo hacia la derecha. Sin embargo, como el laberinto está helado, los bloques se mueven en una forma muy peculiar. Al comenzar a desplazarse en una dirección los bloques siguen avanzando hasta toparse con un espacio bloqueado (ya sea un '#' o el otro bloque de hielo) o hasta llegar al botón. Tu objetivo es ayudar a Link a determinar la menor cantidad posible de movimientos de bloque necesarios para llevar uno de los bloques de hielo al botón para poder escapar. Un movimiento consiste en el empujón inicial que Link le da y que lo hace llegar hasta donde se tope con un espacio bloqueado. Consideraciones: #1. El laberinto consistirá de n*n cuadros, donde 5<=n<=40. #2. Se garantiza que las orillas del laberinto consisten únicamente de '#'. #3. Se garantiza que habrá exactamente dos bloques de hielo en el laberinto, indicados por la letra B. Cuando un bloque esté en un cuadrado este se considerará bloqueado (es decir, un bloque no puede atravesar al otro bloque). #4. Se garantiza que habrá exactamente un botón en el laberinto, señalado con la letra 'A'. Este cuadrado está libre (desde él puedes empujar bloque si los hay en las posiciones contiguas). #5. Puedes asumir que tu puedes llegar a cualquier posición libre del laberinto en todo momento, aún si está rodeada por posiciones bloqueadas. #6. Se garantiza que es posible siempre llevar un bloque al botón. #7. Puedes mover los bloques en el orden que quieras.",
        "entrada": "La primera línea tendrá un entero n (5<=n<=40) que indica el tamaño del laberinto. Las siguientes n líneas serán la descripción del laberinto.",
        "salida": "Un único número, la mínima cantidad de movimientos de desplazamiento de bloque (descritos previamente) necesarios para llevar uno de ellos al botón.",
        "nivel": "Avanzado (difícil) - Programación competitiva",
        "categorias": [
            "Matrices",
            "Búsqueda en amplitud"
        ],
        "estructuras": [
            "long long",
            "vector<vector<char>>",
            "vector<vector<long long>>",
            "vector<vector<vector<vector<bool>>>>"
        ],
        "codigo": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nlong long num[5][1000000];\nlong long sum[2][4];\nbool nums[42][42][42][42];\nchar subs[44][44];\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b=1, c, d, e, f, g, h, l, m, n, o, p=0, q, r, s;\n    sum[0][2]=sum[1][0]=1;\n    sum[0][3]=sum[1][1]=-1;\n    cin>>a;\n    for(auto i=0; i<a; i++){\n        for(auto j=0; j<a; j++){\n            cin>>subs[i][j];\n            if(subs[i][j]=='B'){\n                subs[i][j]='.';\n                if(p){\n                    r=i;\n                    s=j;\n                }\n                else{\n                    p=i;\n                    q=j;\n                }\n            }\n        }\n   }\n   num[0][0]=p;\n   num[1][0]=q;\n   num[2][0]=r;\n   num[3][0]=s;\n   nums[p][q][r][s]=true;\n   nums[r][s][p][q]=true;\n   while(c<b){\n        h=num[0][c];\n        m=num[1][c];\n        l=num[2][c];\n        n=num[3][c];\n        for(auto i=0; i<4; i++){\n            d=h;\n            e=m;\n            f=sum[0][i];\n            g=sum[1][i];\n            if((d-f==l && e-g==n) || subs[d-f][e-g]=='#'){\n                continue;\n            }\n            while((d+f!=l || e+g!=n) && subs[d+f][e+g]=='.'){\n                d+=f;\n                e+=g;\n            }\n            if(((d+f==l && e+g==n) || subs[d+f][e+g]=='#') && nums[d][e][l][n]==false){\n                nums[d][e][l][n]=true;\n                nums[l][n][d][e]=true;\n                num[0][b]=d;\n                num[1][b]=e;\n                num[2][b]=l;\n                num[3][b]=n;\n                num[4][b]=num[4][c]+1;\n                b++;\n            }\n            else if(subs[d+f][e+g]=='A'){\n                num[4][b]=num[4][c]+1;\n                o=c;\n                c=b+1;break;\n            }\n        }\n        if(c>b){\n            c=o;break;\n        }\n        for(auto i=0; i<4; i++){\n            d=l;\n            e=n;\n            f=sum[0][i];\n            g=sum[1][i];\n            if(subs[d-f][e-g]=='#' || (d-f==h && e-g==m))continue;\n            while(subs[d+f][e+g]=='.' && (d+f!=h || e+g!=m)){\n                d+=f;\n                e+=g;\n            }\n            if((subs[d+f][e+g]=='#' || (d+f==h && e+g==m)) && nums[h][m][d][e]==false){\n                nums[h][m][d][e]=true;\n                nums[h][m][d][e]=true;\n                num[0][b]=h;\n                num[1][b]=m;\n                num[2][b]=d;\n                num[3][b]=e;\n                num[4][b]=num[4][c]+1;\n                b++;\n            }\n            else if(subs[d+f][e+g]=='A'){\n                num[4][b]=num[4][c]+1;\n                o=c;\n                c=b+1;break;\n            }\n        }\n        if(c>b){\n            c=o;break;\n        }\n        c++;\n    }\n    cout<<num[4][c]+1;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "336. Mapas de bits",
        "url": "https://omegaup.com/arena/problem/Mapas-de-bits/",
        "descripcion": "Un mapa de bits es una estructura de datos que se utiliza en muchas áreas de la computación . En gráficas por computadora, por ejemplo, un mapa de bits puede representar una imagen donde un 1 representa un pixel negro y un 0 representa un píxel blanco. Considera las siguientes dos maneras de representar un mapa de bits rectangular: Con la primera forma, simplemente se representa como una matriz bidimensional de 1s y 0s . La segunda manera se basa en una técnica de descomposición . En primer lugar, se considera todo el mapa de bits. Si todos los bits dentro del mapa son 1, entonces 1 es la salida. Si todos los bits son 0, entonces la salida es 0. De lo contrario, se escribe una D como salida, y luego el mapa de bits se divide en cuatro partes ( como se describe a continuación ) , y cada una de las partes se procesa de la misma manera que el mapa de bits original. La primera sección en ser procesada es la parte superior izquierda, luego la superior derecha, después la inferior izquierda, y por último la inferior derecha. Cuando un mapa de bits tiene un número par de filas y un número par de columnas, todas las secciones tienen las mismas dimensiones. Cuando el número de columnas es impar, las secciones de la izquierda tienen una columna más que las de la derecha. Cuando el número de filas es impar las secciones superior izquierda y superior derecha tienen una fila más que las partes inferiores. Toma en cuenta que si una región que tiene una sola fila o una columna se divide, habrá dos mitades como resultado, la mitad superior se procesa primero. De igual forma cuando una sola columna se divide, sólo hay dos secciones donde la mitad izquierda se procesa antes que la derecha. Escribe un programa que lea un mapa de bits en una forma y lo transforme en la otra forma.",
        "entrada": "La entrada consistirá en un mapa de bits. Comienza con una línea que da su formato (\"B\" o \"D\") y sus dimensiones en filas y columnas. Ninguna dimensión será mayor que 2000. La siguiente línea contiene la secuencia de caracteres (\"1\", \"0\" y \"D\") que representan el mapa de bits, sin espacios. Un mapa de bits de tipo \"B\" se escribirá de izquierda a derecha y de arriba a abajo.",
        "salida": "La salida consistirá en un mapa de bits. La primera línea describe el formato al que estás traduciendo y el número de filas y de columnas. La siguiente línea debe contener la cadena de caracteres que represente al mapa de bits.",
        "nivel": "Avanzado (medio) - Temas especializados",
        "categorias": [
            "Caracteres y cadenas",
            "Recursión",
            "Compresión de datos"
        ],
        "estructuras": [
            "bool",
            "int",
            "char",
            "string",
            "vector<vector<char>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring BtoD(vector<vector<char>> &mapa, int i, int j, int filas, int columnas) {\n    if(!filas || !columnas){\n        return \"\";\n    }\n    bool todosUnos = true, todosCeros = true;\n    for (int r = i; r < i + filas; ++r) {\n        for (int c = j; c < j + columnas; ++c) {\n            if (mapa[r][c] == '0') todosUnos = false;\n            if (mapa[r][c] == '1') todosCeros = false;\n        }\n    }\n    if (todosUnos) return \"1\";\n    if (todosCeros) return \"0\";\n    string resultado = \"D\";\n    int mitadFilas = filas / 2 + (filas % 2);\n    int mitadColumnas = columnas / 2 + (columnas % 2);\n    resultado += BtoD(mapa, i, j, mitadFilas, mitadColumnas);\n    resultado += BtoD(mapa, i, j + mitadColumnas, mitadFilas, columnas - mitadColumnas);\n    resultado += BtoD(mapa, i + mitadFilas, j, filas - mitadFilas, mitadColumnas);\n    resultado += BtoD(mapa, i + mitadFilas, j + mitadColumnas, filas - mitadFilas, columnas - mitadColumnas);\n    return resultado;\n}\n\nstring DtoB(string &mapa, int &pos, int filas, int columnas) {\n    if(!filas || !columnas){\n        return \"\";\n    }\n    char bit = mapa[pos++];\n    if (bit != 'D') {\n        return string(filas * columnas, bit);\n    }\n    int mitadFilas = filas / 2 + (filas % 2);\n    int mitadColumnas = columnas / 2 + (columnas % 2);\n    string parte1 = DtoB(mapa, pos, mitadFilas, mitadColumnas);\n    string parte2 = DtoB(mapa, pos, mitadFilas, columnas - mitadColumnas);\n    string parte3 = DtoB(mapa, pos, filas - mitadFilas, mitadColumnas);\n    string parte4 = DtoB(mapa, pos, filas - mitadFilas, columnas - mitadColumnas);\n    string resultado;\n    for (int i = 0; i < mitadFilas; ++i) {\n        resultado += parte1.substr(i * mitadColumnas, mitadColumnas) + parte2.substr(i * (columnas - mitadColumnas), columnas - mitadColumnas);\n    }\n    for (int i = 0; i < filas - mitadFilas; ++i) {\n        resultado += parte3.substr(i * mitadColumnas, mitadColumnas) + parte4.substr(i * (columnas - mitadColumnas), columnas - mitadColumnas);\n    }\n    return resultado;\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    char formato;\n    int filas, columnas;\n    cin >> formato >> filas >> columnas;\n    string mapa;\n    cin >> mapa;\n    if (formato == 'B') {\n        vector<vector<char>> mapaMatriz(filas, vector<char>(columnas));\n        for (int i = 0; i < filas; ++i) {\n            for (int j = 0; j < columnas; ++j) {\n                mapaMatriz[i][j] = mapa[i * columnas + j];\n            }\n        }\n        cout << \"D \" << filas << \" \" << columnas << endl;\n        cout << BtoD(mapaMatriz, 0, 0, filas, columnas) << endl;\n    } else {\n        int pos = 0;\n        cout << \"B \" << filas << \" \" << columnas << endl;\n        cout << DtoB(mapa, pos, filas, columnas) << endl;\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "6881. Gasolineras",
        "url": "https://omegaup.com/arena/problem/Gasolineras/",
        "descripcion": "En un círculo hay N gasolineras. Las gasolineras están numeradas de 0 a (N-1) inclusive. Tienes la siguiente información respecto a las gasolineras: La cantidad de gasolina que esa gasolinera en particular da, y. La distancia de esa gasolinera a la siguiente gasolinera en kilometros. Inicialmente, tienes un carro con un tanque de capacidad infinita y sin gasolina. Quieres hacer un recorrido que pase por todas las gasolineras. Debes empezar el recorrido en cualquiera de las gasolineras. Calcula la gasolinera con menor numeración donde la camioneta podrá completar el círculo. Considera que la camioneta se detendrá en cada gasolinera y tomará toda la gasolina que tenga. La camioneta se moverá un kilómetro por cada litro de gasolina.",
        "entrada": "En la primera línea un entero, N. Las siguientes N líneas contienen un par de enteros cada una, la cantidad de gasolinera que ofrece esa gasolinera y la distancia entre esa gasolinera y la siguiente.",
        "salida": "Un solo entero, un entero que será el mínimo índice en el cual se puede empezar el recorrido.",
        "nivel": "Avanzado (medio) - Programación competitiva",
        "categorias": [
            "Vectores",
            "Técnica de dos apuntadores",
            "Colas"
        ],
        "estructuras": [
            "long long",
            "vector<long long>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n     cout.tie(0);\n      long long a, b, c, d, e, f=1, g, h;\n   vector<long long>num;\n     cin>>a;\n   for(auto i=0; i<a; i++){\n       cin>>b>>e;\n        num.push_back(b-e);\n   }\n b=1;\n  e=num[0];\n while(b<a){\n       if(e>=0){\n         b++;\n          d=(d+1)%a;\n            e+=num[d];\n        }\n     else{\n         b--;\n          e-=num[c];\n            c=(c+1)%a;\n        }\n }\n cout<<c;\n      \n  return 0;\n}\n"
    },
    {
        "titulo": "10867. Antivirus",
        "url": "https://omegaup.com/arena/problem/Antivirus/",
        "descripcion": "El famoso virus de CODEVID-10011 a llegado a los laboratorios de informática de Bachilleres 2, un profesor asustado de que este virus afecte a todas las computadoras del laboratorio te pidió tu ayuda para que elimines a todos los números infectados. A un número k le puedes aplicar la operación ANALIZAR: que consiste en reemplazar el número por la suma del cuadrado de sus dígitos. Por ejemplo, si tenemos el número 13 y le aplicamos la operación ANALIZAR nos quedaría: 1^2+3^2=10. Luego a este número le podemos volver aplicar la operación ANALIZAR y así sucesivamente. Se dice que K es un número infectado si después de cierta cantidad de operaciones ANALIZAR el número es 1. El profesor no conoce con precisión la ubicación de estos números por tanto te dará t números y tu tarea será encontrar el siguiente número infectado más pequeño.",
        "entrada": "La primera línea de entrada es un entero t (1<=t<=10^6), seguido de t líneas con un entero k (0<=k<=10^6).",
        "salida": "La única línea de salida para cada k_i consiste en el siguiente número infectado más pequeño para el número dado k_i. Si el entero k_i, es un número infectado en sí mismo, entonces, el siguiente número infectado más pequeño debe imprimirse como salida.",
        "nivel": "Avanzado (medio) - Programación competitiva",
        "categorias": [
            "Vectores",
            "Cálculo matemático",
            "Programación dinámica"
        ],
        "estructuras": [
            "bool",
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<short>estado(1000004,-1);\n\n// Funcion para calcular la suma del cuadrado de los digitos\nint analizar(int num) {\n    int suma = 0;\n while (num > 0) {\n     int digito = num % 10;\n        suma += digito * digito;\n      num /= 10;\n    }\n return suma;\n}\n\n// Funcion recursiva para determinar si un numero es infectado\nbool es_infectado(int num) {\n    if(estado[num]!=-1){\n      return estado[num];\n   }\n estado[num]=0;\n    estado[num]=es_infectado(analizar(num));\n  return estado[num];\n}\n\nint main() {\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  estado[1]=1;\n  int t;\n    cin >> t;\n while (t--) {\n     int k;\n        cin >> k;\n     k++;\n      // Busqueda del siguiente numero infectado\n        while (!es_infectado(k)) {\n            k++;\n      }\n     cout << k << \"\\n\";\n }\n\n   return 0;\n}\n"
    },
    {
        "titulo": "4800. Juanito y los primos",
        "url": "https://omegaup.com/arena/problem/Juanito-y-los-primos/",
        "descripcion": "Dado un entero \\delta, decir si \\delta es primo o no.",
        "entrada": "La entrada consiste en un solo entero \\delta (1<=\\delta<=10^18) que representa la puntuación de Juanito.",
        "salida": "Si \\delta no es primo, imprimir \"no es primo\", en caso contrario imprimir \"si es primo\".",
        "nivel": "Avanzado (medio) - Programación competitiva",
        "categorias": [
            "Teoría de numeros"
        ],
        "estructuras": [
            "bool",
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n// Funcion para determinar si un numero es primo\nbool esPrimo(ll delta) {\n    if (delta <= 1) return false;\n    if (delta <= 3) return true;\n    if (delta % 2 == 0 || delta % 3 == 0) return false;\n    for (ll i = 5; i * i <= delta; i += 6) {\n        if (delta % i == 0 || delta % (i + 2) == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    ll delta;\n    cin >> delta;\n    if (esPrimo(delta)) {\n        cout << \"si es primo\" << endl;\n    } else {\n        cout << \"no es primo\" << endl;\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "11799. Numeración Maya",
        "url": "https://omegaup.com/arena/problem/Numeracion-Maya/",
        "descripcion": "El lenguaje de Maya++ esta codificado vigesimal (es decir, base 20). Esta numeración esta dada por los siguientes simbolos y sus valores de la numeración decimal: ?=0, *=1, -=5. Recordemos que en la numeración maya si la cantidad de * modulo 5 es igual a 0 se sustituye los * por un -. A continuación mostramos algunas equivalencias con el sistema decimal: ?/=0, */=1, **/=2, -/=5, --/=10, --*/=11, ?/*/=20, */*/=21. Escribe un programa que convierte un número entero de sistema decimal a una cadena que representa su valor en la númeración maya dado con las condiciones anteriores y viceversa.",
        "entrada": "En la primera línea un entero T que indica el tipo de converción que vas hacer (1 -decimal a numeración maya, 2 -numeración maya a decimal), en la segunda línea un entero n o una cadena s dependiendo del tipo de conversión.",
        "salida": "La cadena s que representa a x si T=1, o el entero x que representa a s si T=2.",
        "nivel": "Avanzado (fácil) - Programación competitiva",
        "categorias": [
            "Caracteres y cadenas",
            "Cálculo matemático"
        ],
        "estructuras": [
            "long long",
            "vector<long long>",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  long long a, b=14, c, d, e, f, g, h;\n  long long num[]={1, 20, 400, 8000, 160000, 3200000, 64000000, 1280000000, 25600000000, 512000000000, 10240000000000, 204800000000000, 4096000000000000, 81920000000000000, 1638400000000000000};\n  string z, x;\n  cin>>a;\n   if(a==1){\n     cin>>a;\n       if(!a){\n           cout<<\"?/\";return 0;\n        }\n     while(num[b]>a){\n          b--;\n      }\n     for(; b>=0; --b){\n         c=a/num[b];\n           switch(c){\n                case 0: z=\"?/\"+z;break;\n             case 1: z=\"*/\"+z;break;\n             case 2: z=\"**/\"+z;break;\n                case 3: z=\"***/\"+z;break;\n               case 4: z=\"****/\"+z;break;\n              case 5: z=\"-/\"+z;break;\n             case 6: z=\"-*/\"+z;break;\n                case 7: z=\"-**/\"+z;break;\n               case 8: z=\"-***/\"+z;break;\n              case 9: z=\"-****/\"+z;break;\n             case 10: z=\"--/\"+z;break;\n               case 11: z=\"--*/\"+z;break;\n              case 12: z=\"--**/\"+z;break;\n             case 13: z=\"--***/\"+z;break;\n                case 14: z=\"--****/\"+z;break;\n               case 15: z=\"---/\"+z;break;\n              case 16: z=\"---*/\"+z;break;\n             case 17: z=\"---**/\"+z;break;\n                case 18: z=\"---***/\"+z;break;\n               case 19: z=\"---****/\"+z;break;\n          }\n         a%=num[b];\n        }\n     cout<<z;\n  }\n else{\n     cin>>z;\n       for(auto i=0; i<z.size(); ++i){\n            if(z[i]=='/'){\n                if(x==\"?\"){\n                 b=0;\n              }\n             else if(x==\"*\"){\n                    b=1;\n              }\n             else if(x==\"**\"){\n                   b=2;\n              }\n             else if(x==\"***\"){\n                  b=3;\n              }\n             else if(x==\"****\"){\n                 b=4;\n              }\n             else if(x==\"-\"){\n                    b=5;\n              }\n             else if(x==\"-*\"){\n                   b=6;\n              }\n             else if(x==\"-**\"){\n                  b=7;\n              }\n             else if(x==\"-***\"){\n                 b=8;\n              }\n             else if(x==\"-****\"){\n                    b=9;\n              }\n             else if(x==\"--\"){\n                   b=10;\n             }\n             else if(x==\"--*\"){\n                  b=11;\n             }\n             else if(x==\"--**\"){\n                 b=12;\n             }\n             else if(x==\"--***\"){\n                    b=13;\n             }\n             else if(x==\"--****\"){\n                   b=14;\n             }\n             else if(x==\"---\"){\n                  b=15;\n             }\n             else if(x==\"---*\"){\n                 b=16;\n             }\n             else if(x==\"---**\"){\n                    b=17;\n             }\n             else if(x==\"---***\"){\n                   b=18;\n             }\n             else if(x==\"---****\"){\n                  b=19;\n             }\n             c+=num[d]*b;\n              d++;\n              x=\"\";\n           }\n         else{\n             x=x+z[i];\n         }\n     }\n     cout<<c;\n  }\n\n   return 0;\n}\n"
    },
    {
        "titulo": "11649. Tabla de ganar",
        "url": "https://omegaup.com/arena/problem/Tabla-de-ganar/",
        "descripcion": "Jugaran el juego de \"Tabla de ganar\" el cual consiste en un tablero de N X N en donde pueden existir o no piedras en el tablero cumpliendo la siguiente condición. Si existe una piedra en la coordenada (i,j) no puede existir otra piedra en esa misma fila i y columna j. El juego consiste que dado el tablero de N X N: Se jugará por turnos en donde se colocarán piedras en el tablero respetando la condición antes mencionada. El primer turno será siempre del hombre misterioso. Cuando en el turno de un jugador ya no se pueda poner piedras, este habrá perdido. Dado un número t de partidas que van a jugar teniendo cada una un tablero diferente, ayuda a los programadores mayas a saber quién ganará la partida. Se te asegura que los dos jugadores jugaran de manera óptima.",
        "entrada": "Un número t, el número de partidas. Para cada partida un número N, el tamaño del tablero, seguido de N cadenas de caracteres de tamaño N que contiene dígitos en donde si es 1, significa que en esa coordenada hay una piedra y si es 0 significa que esta vacia.",
        "salida": "Para cada una de las partidas muestra \"Hombre misterioso\" o \"Programadores mayas\" sin comillas, según quien haya ganado la partida.",
        "nivel": "Avanzado (fácil) - Programación competitiva",
        "categorias": [
            "Teoría de juegos"
        ],
        "estructuras": [
            "char",
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  int a, b, c, e, f, g, h;\n  char d;\n   cin>>a;\n   while(a--){\n       cin>>b;\n       c=0;\n      e=b;\n      b*=b;\n     while(b--){\n           cin>>d;\n           c+=(int)d-48;\n     }\n     cout<<(((e-c)%2)?\"Hombre misterioso\\n\":\"Programadores mayas\\n\");\n    }\n \n  return 0;\n}\n"
    },
    {
        "titulo": "11597. Primer combate",
        "url": "https://omegaup.com/arena/problem/Primer-combate/",
        "descripcion": "La batalla se desenvolvera en una barranca de longitud N. Los programadores mayas inicialmente estan en la posición 1, representado con la letra M, el Malvado Robot OMI en la posición 2 representado por la letra R y los espacios vacios de la barranca represetados por la letra O. La batalla sucede de la siguiente manera: Los programadores mayas buscan llevar al Malvado Robot OMI hasta la posición N para tirarlo de la barranca avanzaNdo 1 posición en cada segundo del combate. El Malvado Robot OMI cuando está en cualquier posición 1<=j<=N y los programadores mayas se encuentran en la posición de j-1 utiliza su poder de teletransportar, que consiste en teletransportar a los programadores mayas a la posición número 1 y genera una explosión que lo impulsa a la posición j+1. Por ejemplo, para N=5 el combate se ve de la siguiente manera deacuerdo a su duración en segundos: MROOO, MOROO, OMROO, MOORO, OMORO, OOMRO, MOOOR, OMOOR, OOMOR, OOOMR. Para tener ventaja respecto al Malvado Robot OMI, se quiere saber en que posición estarían los programadores mayas y el Malvado Robot OMI en el segundo K. Se te darán varios casos de este problema, para ser más concisos tendrás que resolver T casos. En cada caso se te dará la longitud de la barranca y el segundo que se quiere saber la posición. Para cada caso deberás responder como se vería la batalla en el segundo dado.",
        "entrada": "Se te dara T casos de prueba con dos enteros cada uno, N_i y K_i.",
        "salida": "T líneas separadas por un salto de línea con dos enteros cada una. a_i y b_i, la posición de los programadores mayas y la posición del Malvado Robot Maya en el segundo K_i.",
        "nivel": "Avanzado (fácil) - Programación competitiva",
        "categorias": [
            "Cálculo matemático"
        ],
        "estructuras": [
            "long long",
            "sqrt()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  long long a, b, c, d, e, f, g, h;\n cin>>a;\n   while(a--){\n       cin>>b>>c;\n        b=c*2;\n        b=sqrt(b);\n        b=max((long long)0,b-3);\n      while((b+1)*b/2<c){\n           b++;\n      }\n     c-=(b-1)*b/2;\n     if(c){\n            cout<<c<<\" \"<<b+1<<\"\\n\";\n     }\n     else{\n         cout<<b<<\" \"<<b+1<<\"\\n\";\n     }\n }\n \n  return 0;\n}\n"
    },
    {
        "titulo": "11153. Primer divisor",
        "url": "https://omegaup.com/arena/problem/Primer-divisor/",
        "descripcion": "Un estudiante esta estudiando teoria de números y le sorprendio las propiedades de los divisores. Para dos enteros positivos a y b, a es un divisor de b si y solo si existe un entero c tal que a*c=b. Para n>=2 denotaremos la función f(n) que nos da como resultado el divisor positivo más pequeño de n, excepto 1. Por ejemplo, f(7)=7, f(10)=2, f(35)=5. El estudiante queria poner un problema en el examen con estas características pero le parecía muy facil, entonces se le ocurrio que al entero n se le puede agregar f(n), esto lo puede hacer varias veces, obteniendo asi lo siguiente: n, n_1=n+f(n), n_2=n_1+f(n_1), n_3=n_2+f(n_2), ..., n_k=n_(k-1)+f(n_(k-1)). Por ejemplo, si tuvieramos a n=5 el valor de n_1 seria igual a 5+5=10, si n=6, tendriamos n_1=6+2=8. Al estudiante le gusto mucho la nueva operación, entonces te pedira encontrar el k-esimo valor de n para t casos de prueba. Por ejemplo, si n=5 y k=2 tenemos que n_1=5+5=10, n_2=10+2=12. Encuentra el valor de n_k para los t casos.",
        "entrada": "Se te dara un número t (1<=t<=10^5), seguido de eso t líneas con dos enteros n (2<=n<=10^6) y k (1<=k<=10^8).",
        "salida": "Seran t numeros separados por un salto de línea con el valor de n_k.",
        "nivel": "Avanzado (fácil) - Programación competitiva",
        "categorias": [
            "Teoría de numeros"
        ],
        "estructuras": [
            "int",
            "sqrt()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint binario(int b, int c){\n //Optimizacion; Inicia en el 3, ya que se descarto al 2 como uno de sus divisores\n int d=3, raiz=sqrt(b);\n    while(d<=raiz){\n       if(b%d==0){\n           break;\n        }\n     //Optimizacion: Avanza de 2 en 2, ya que el 2 (que ya se descarto) es el unico primo par\n      d+=2;\n }\n return ((b%d==0)?b+d+--c*2:b*2+--c*2);\n}\n\nint main(){\n      cin.tie(0);\n   ios_base::sync_with_stdio(0);\n     cout.tie(0);\n      int a, b, c;\n      cin>>a;\n   while(a--){\n       cin>>b>>c;\n        cout<<((b%2)?binario(b,c):b+c*2)<<\"\\n\";\n    }\n \n  return 0;\n}\n"
    },
    {
        "titulo": "11152. Calculadora Binaria",
        "url": "https://omegaup.com/arena/problem/Calculadora-Binaria/",
        "descripcion": "Un estudiante quiere crear una calculadora especial, la cual haga problemas en binario, el problema es que él no sabe binario, entonces te pide tu ayuda para crear una calculadora. Recordemos que un número binario esta compuesto por las potencias de 2, por ejemplo, si tenemos el número k=100101, el valor del números es igual a 2^0*1+2^1*0+2^2*1+2^3*0+2^4*0+2^5*1, definamos a n como la ultima posicion de nuestro número binario, siendo la primera 0. De esta manera podemos decir que k_0=1, k_1=0, k_2=1, ..., k_n=1. La calculadora funciona con dos números A y B, realiza 3 tipos de operaciones. 1: Es la suma de todas las i que cumple con la siguiente condición: A_i=B_i=1. 2: Es la suma de todas las i que cumple con la siguiente condición: A_i=B_i=0. 3: Es la suma de todas las i que cumplen con la siguiente condición: A_i!=B_i. Las operaciones se realizan para todas las 0<=i<=max(n_A,n_B). Tu tarea sera crear la calculadora para dos números enteros a y b con las operaciones 1, 2 y 3.",
        "entrada": "Se te daran los números A, B y t (1<=t<=3), siendo A y B los valores a los cuales se les aplicara la operación de tipo t.",
        "salida": "Un unico número entero el cual sera el resultado de la operación de tipo t con los números A y B.",
        "nivel": "Avanzado (fácil) - Programación competitiva",
        "categorias": [
            "Caracteres y cadenas",
            "Cálculo matemático"
        ],
        "estructuras": [
            "long long",
            "char",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid binario(int ax, string &bx){\n  char z;\n   while(ax){\n        z=48+ax%2;\n        bx=z+bx;\n      ax/=2;\n    }\n}\n\nint main(){\n   cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  long long a, b, c, d=0, e, i, j;\n  string x, y;\n  cin>>a>>b>>c;\n binario(a,x);\n binario(b,y);\n e=(x.size()<y.size())?1:2;\n    while(fabs(x.size()-y.size())){\n       (e==1)?x=\"0\"+x:y=\"0\"+y;\n   }\n for(i=j=x.size()-1; i>=0; i=j=j-1){\n       x[i]-=48;\n     y[j]-=48;\n     ((c==1 && x[i] && y[j]) || (c==2 && !x[i] && !y[j]) || (c==3 && x[i]-y[j]))?d+=x.size()-1-i:d+=0;\n }\n cout<<d;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "239. Dos Alfiles",
        "url": "https://omegaup.com/arena/problem/DosAlfiles/",
        "descripcion": "Como es bien sabido en las familias de los reyes, el rey blanco y el rey negro, han estado en guerras desde hace siglos, no se sabe aun por que nunca termina su larga contienda, esta vez ellos desean enfrentarse solo con sus alfiles. Como siempre, se enfrentaran en un terreno típico, lleno de cuadrados (tablero de ajedrez), los terrenos de batalla los hay de diferentes tamaños pero siempre son cuadrados. Tu como un consejero real, le debes de informar a tu rey, quien es el rey que tiene mas probabilidades de ganar (el rey que posee en el tablero el mayor numero de piezas). Y cuantas de estas pacificas piezas debes de enviar. Considerando que los alfiles, son piezas de las cuales no les gusta mucho la guerra, es mas, ningún alfil tanto negro como blanco desean atacarse entre si, por lo que debes de enviar el numero correcto de piezas de ajedrez, de manera que ningún alfil ataque a otro alfil aun siendo del mismo bando debes decir cual es el maximo numero de alfiles a enviar por rey, de lo contrario serás perseguido por la santa inquisición.",
        "entrada": "Un entero N (1<=N<=2^64) que indica el tamaño del tablero de ajedrez (N*N).",
        "salida": "Un entero A que indica la cantidad de alfiles que deba de enviar cada rey para la contienda, si un rey envia mas alfiles se toma en cuenta el maximo numero de alfiles que envie el rey que pueda enviar mas piezas. (en el caso de que el numero de piezas de los alfiles sea impares, se le da la ventaja segun el tablero en el que se encuentre, si N es par, se le da la ventaja al rey negro, si N es impar, al rey blanco) ademas debes informar sobre las K (K modulo 10) formas posibles en que puedes acomodar los alfiles. Despues, una cadena C que diga \"TABLAS\" si las probabilidades de ganar son iguales para los dos reyes, o \"KW\" si el rey blanco tiene mas probabilidades de ganar, o \"KB\" en el caso que el rey negro tenga mas posibilidades.",
        "nivel": "Avanzado (fácil) - Programación competitiva",
        "categorias": [
            "Teoría de numeros"
        ],
        "estructuras": [
            "unsigned long long",
            "pow()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nunsigned long long alfiles(unsigned long long n) {\n    return n-1;//(n + max(0ULL, n - 2) ) / 2\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    unsigned long long n;\n    cin >> n;\n    if(n==1){\n        cout<<\"1 1 KW\";return 0;\n    }\n    unsigned long long totalAlfiles = alfiles(n);\n    unsigned long long k = (unsigned long long)pow(2,n%4) % 10;\n    if(k==1){\n        k=6;\n    }\n    cout << totalAlfiles << \" \" << k << \" \";\n    if (totalAlfiles*2 % 2 == 0) {\n        cout << \"TABLAS\\n\";\n    } else {\n        if (n % 2 == 0) {\n            cout << \"KB\\n\";\n        } else {\n            cout << \"KW\\n\";\n        }\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "169. Metro",
        "url": "https://omegaup.com/arena/problem/metro/",
        "descripcion": "En el mushroom kingdom desean crear una red de líneas de tren subterráneo que conecte todo el reino. El mushroom kingdom cuenta con n (3<=n<=30000) estaciones numeradas de 1 a n, las cuales deben conectarse con vías. Para ello, se han realizado estudios que permitieron calcular cuál sería el costo c (1<=c<=1000) de conectar la estación i con la estación j (1<=i,j<=n, con i distinto de j) para m (2<=m<=200000) pares de estaciones i,j. Como se quiere hacer un uso eficiente de los recursos, te han encomendado la creación de un programa que determine cuál es el costo mínimo de unir todas las estaciones, es decir, cuál es el menor costo posible para construir vías que permitan llegar desde cualquier estación a cualquier otra. Debes tomar en cuenta las siguientes consideraciones: #1. Siempre será posible conectar todas las estaciones con los pares i,j dados en la entrada. #2. Si el par i,j aparece en la entrada, no aparecerá el par j,i ni habrá repeticiones.",
        "entrada": "La primera línea de la entrada tendrá 2 enteros n (3<=n<=30000) y m (2<=m<=200000), el número de estaciones y el número de posibles tramos a construir. Las siguientes m líneas contendrán la descripción de un posible tramo con 3 enteros i, j y c (1<=c<=1000), donde i y j (1<=i,j<=n) son las estaciones a conectarse y c es el costo que tendría su construcción.",
        "salida": "Un único número, el menor costo resultante de conectar todas las estaciones.",
        "nivel": "Avanzado (fácil) - Programación competitiva",
        "categorias": [
            "Vectores",
            "Ordenamiento",
            "Recursión",
            "Grafos"
        ],
        "estructuras": [
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Edge {\n    int u, v, w;\n    bool operator<(const Edge& other) const {\n        return w < other.w;\n    }\n};\n\nvector<Edge> edges;\nvector<int> parent;\n\nint find(int x) {\n    if (parent[x] != x) {\n        parent[x] = find(parent[x]);\n    }\n    return parent[x];\n}\n\nvoid unionSets(int x, int y) {\n    int rootX = find(x);\n    int rootY = find(y);\n    parent[rootX] = rootY;\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int n, m;\n    cin >> n >> m;\n    edges.resize(m);\n    parent.resize(n + 1);\n    for (int i = 0; i < m; ++i) {\n        cin >> edges[i].u >> edges[i].v >> edges[i].w;\n    }\n    sort(edges.begin(), edges.end());\n    for (int i = 1; i <= n; ++i) {\n        parent[i] = i;\n    }\n    int totalCost = 0;\n    for (const Edge& edge : edges) {\n        if (find(edge.u) != find(edge.v)) {\n            unionSets(edge.u, edge.v);\n            totalCost += edge.w;\n        }\n    }\n    cout << totalCost << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "19753. Estudiando las Ruinas",
        "url": "https://omegaup.com/arena/problem/Estudiando-las-Ruinas/",
        "descripcion": "La Universidad, donde Santy gobierna, es tan antigua que muchos la consideran una ruina. Existen partes que ya no tienen ni suelo. Santy, como buen director, ha decidido restaurar el lugar. Un alumno ha hecho un mapa del lugar, por suerte el perímetro de la universidad se encuentra intacto gracias a unas luces colocadas alrededor. Pero por dentro hay huecos que hay que cubrir. Tu tarea consiste únicamente en contar la cantidad de huecos que hay en las ruinas. El mapa del lugar consiste en una matriz de N x M que contiene unos y ceros, donde un cero representa una zona vacía y un uno una parte completa de las ruinas. El perímetro de las ruinas se encuentra intacto, por lo que podemos distinguir el área exterior de las partes vacías de las ruinas por el área delimitada por los unos.",
        "entrada": "Dos enteros i<=N,M<=1000 que representan las dimensiones del mapa. Luego, los elementos a_(i,j)=0,1 del mapa, donde 0 representa un lugar fuera de las ruinas o un lugar a restaurar, y un 1 una zona firme de las ruinas.",
        "salida": "Deberás imprimir la cantidad de lugares a restaurar dentro de las ruinas.",
        "nivel": "Intermedio (difícil) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Matrices",
            "Búsqueda en amplitud"
        ],
        "estructuras": [
            "int",
            "pair<int,int>",
            "vector<pair<int,int>>",
            "vector<vector<int>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int a, b, c, e, f, g, h, n,m;\n    cin>>n>>m;\n    vector<vector<int>> escuela(n+2,vector<int>(m+2,0));\n    for(auto i = 1; i<=n;i++){\n        for(auto j=1;j<=m;j++){\n            cin>>a;\n            if(a){\n                escuela[i][j]=0;\n            }\n            else{\n                escuela[i][j]=1;\n                b++;\n            }\n        }\n    }\n    vector<pair<int,int> >z;\n    pair<int,int>zz;\n    for(auto i = 1; i<=n;i++){\n        if(escuela[i][1]==1){\n            b--;\n            escuela[i][1]=0;\n            z.push_back({i,1});\n        }\n        if(escuela[i][m]==1){\n            b--;\n            escuela[i][m]=0;\n            z.push_back({i,m});\n        }\n            \n    }\n    for(auto i = 1; i<=m;i++){\n        if(escuela[1][i]==1){\n            b--;\n            escuela[1][i]=0;\n            z.push_back({1,i});\n        }\n        if(escuela[n][i]==1){\n            b--;\n            escuela[n][i]=0;\n            z.push_back({n,i});\n        }\n    }\n    while(z.size()){\n        zz=z.back();\n        z.pop_back();\n        int i=zz.first, j=zz.second;\n            if(escuela[i-1][j]){\n                b--;\n                escuela[i-1][j]=0;\n                z.push_back({i-1,j});\n            }\n            if(escuela[i+1][j]){\n                b--;\n                escuela[i+1][j]=0;\n                z.push_back({i+1,j});\n            }\n            if(escuela[i][j-1]){\n                b--;\n                escuela[i][j-1]=0;\n                z.push_back({i,j-1});\n            }\n            if(escuela[i][j+1]){\n                b--;\n                escuela[i][j+1]=0;\n                z.push_back({i,j+1});\n            }\n    }\n    cout<<b;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "141. Oro",
        "url": "https://omegaup.com/arena/problem/oro/",
        "descripcion": "Una compañía de venta de oro necesita tu ayuda para saber cuál es el menor exceso que puede tener. La compañía tiene registradas N rocas que contienen oro. Para obtener ese oro la compañía tiene que elegir algunas rocas y destruirlas quedándose con el oro que contenían. El problema es que tener exceso de oro implica tener que resguardarlo y eso es muy costoso.",
        "entrada": "N (1<=N<=20) y B (1<=B<=[sum_{i=0}^{N-1}O_i]). El número de rocas y el total de oro requerido, respectivamente. N líneas, cada una con un entero O_i (1<=O_i<=10^6) que es la cantidad de oro que tiene cada roca.",
        "salida": "Un solo entero con el exceso mínimo de oro, dado que se obtuvieron B unidades de oro.",
        "nivel": "Intermedio (difícil) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Vectores",
            "Colas",
            "Ordenamiento",
            "Búsqueda en amplitud"
        ],
        "estructuras": [
            "long long",
            "vector<long long>",
            "pair<long long,long long>",
            "queue<pair<long long,long long>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c=1000001;\n    queue<pair<long long,long long>>falta;\n    pair<long long,long long> z;\n    cin>>a>>b;\n    vector<long long>num(a);\n    for(auto i=0; i<a; i++){\n        cin>>num[i];\n    }\n    sort(num.begin(),num.end());\n    for(auto i=a-1; i>0; i--){\n        if(num[i]>=b){\n            c=num[i];\n        }\n        else{\n            z.first=num[i];\n            z.second=i;\n            falta.push(z);\n        }\n    }\n    if(num[0]>=b){\n        c=num[0];\n    }\n    while(falta.size()){\n        z=falta.front();\n        falta.pop();\n        for(auto i=z.second-1; i>0; i--){\n            z.first+=num[i];\n            if(c>z.first && z.first>=b){\n                c=z.first;\n            }\n            else if(z.first<b){\n                z.second=i;\n                falta.push(z);\n            }\n            z.first-=num[i];\n        }\n        z.first+=num[0];\n        if(c>z.first && z.first>=b){\n            c=z.first;\n        }\n    }\n    cout<<c-b;\n \n    return 0;\n}\n"
    },
    {
        "titulo": "1342. Nieves y el merge-sort",
        "url": "https://omegaup.com/arena/problem/Nieves-y-el-merge-sort/",
        "descripcion": "El merge-sort es un algoritmo que ordena, ya sea creciente o decreciente, un arreglo. La idea viene de partir el arreglo a ordenar en 2 subarreglos del mismo tamaño, ordenarlos y luego unir estos 2 subarreglos de tal forma que el arreglo unido siga ordenado. Para unir éstos dos subarreglos se mete cada uno en una cola(*), se va comparando cada elemento inicial de las 2 colas, se decide cual es el menor (o mayor) y se agrega dicho elemento al arreglo ordenado (y se elimina el elemento de la cola corespondiente). Esto se hace hasta que no queden elementos en las colas. Para ordenar los subarreglos se puede usar, recursivamente, el merge-sort. La recursión acaba cuando se llega a subarreglos triviales (de tamaño 1). Un ejemplo: (8 7 6 5 4 3 2 1) <- arreglo a ordenar. (8 7 6 5) -- (4 3 2 1) <- subarreglos. (5 6 7 8) -- (1 2 3 4) <- se ordenan (recursion) y se meten a sus respectivas colas, donde los primero elementos a comparar serán el (5) y el (1), por lo tanto se va a escoger el elemento (1); luego el (5) con el (2), luego el (5) con el (3)... quedando: (1 2 3 4 5 6 7 8).; Nieves (el viejo), después de tantos años sin programar, decidio implementar éste algoritmo para ordenar un arreglo de manera creciente. Sin embargo cometió un error a la hora de meter los subarreglos ordenados a las colas: El subarreglo izquierdo si lo metió a una cola, sin embargo el subarreglo derecho lo metió a una pila(**). El resto del algoritmo lo siguió al pie de la letra. Usando el mismo ejemplo, a la hora de unir los subarreglos, se compararía el elemento (5) con el elemento (4); luego el elemento (5) con el (3), luego el (5) con el (2)... quedando: (4 3 2 1 5 6 7 8). Tu labor será imitar el código de Nieves para ayudarle en un futuro no muy lejano. (**) La cola es una estructura de datos llamada FIFO = First In First Out (primero en llegar, primero en salir). (*) La pila es una estructura de datos llamada FILO = First In Last Out (primero en llegar, último en salir).",
        "entrada": "Primera línea: n (0<n<=65536, n siemore sera una potencia de 2), la cantidad de elementos a ordenar. Segunda línea: x_1, x_2, ..., x_n, los x_i (0<=x_i<=10^7) elementos a ordenar separados por un espacio.",
        "salida": "Los n números separados por un espacio y ordenados según el algoritmo de Nieves.",
        "nivel": "Intermedio (difícil) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Vectores",
            "Ordenamiento"
        ],
        "estructuras": [
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid merge(vector<int>& arr, int l, int m, int r) {\n    int n1 = m - l + 1;\n    int n2 = r - m;\n    vector<int> L(n1), R(n2);\n    for (int i = 0; i < n1; i++)\n        L[i] = arr[l + i];\n    for (int j = 0; j < n2; j++)\n        R[j] = arr[m + 1 + j];\n    int i = 0, j = n2 - 1, k = l; \n    while (i < n1 && j >= 0) {\n        if (L[i] <= R[j]) {\n            arr[k] = L[i];\n            i++;\n        } else {\n            arr[k] = R[j];\n            j--;\n        }\n        k++;\n    }\n    while (i < n1) {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n    while (j >= 0) {\n        arr[k] = R[j];\n        j--;\n        k++;\n    }\n}\n\nvoid mergeSort(vector<int>& arr, int l, int r) {\n    if (l < r) {\n        int m = l + (r - l) / 2;\n        mergeSort(arr, l, m);\n        mergeSort(arr, m + 1, r);\n        merge(arr, l, m, r);\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int n;\n    cin >> n;\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n    mergeSort(arr, 0, n - 1);\n    for (int i = 0; i < n; i++) {\n        cout << arr[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "1300. Suma Manhattan",
        "url": "https://omegaup.com/arena/problem/Suma-Manhattan/",
        "descripcion": "Dada una lista S de N puntos en el plano cartesiano, calcula la suma de las distancias Manhattan entre todas las parejas posibles de puntos. En otras palabras, calcula el valor de la siguiente expresión: [sum_{i=0}^{N-2}[sum_{j=i+1}^{N-1}manhattan(S_i,S_j)]], la cual es de complejidad cuadratica, recuerda que la distancia Manhattan entre dos puntos manhattan((p_1,p_2),(q_1,q_2)) es |p_1-q_1|+|p_2-q_2|, donde |x| representa el valor absoluto de x.",
        "entrada": "En la primer línea un entero N (N<=500000, por lo que 500000^2 seria muy grande), la cantidad de puntos. En las siguientes N líneas, dos enteros x_i y y_i (-10^8<=x_i,y_i<=10^8) representando las coordenadas de un punto.",
        "salida": "Un sólo entero: el resultado de evaluar la expresión requerida. Imprime el resultado módulo 1000000007 (10^9+7).",
        "nivel": "Intermedio (difícil) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Vectores",
            "Ordenamiento",
            "Aritmética modular",
            "Cálculo matemático"
        ],
        "estructuras": [
            "int",
            "vector<vector<int>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n \nusing namespace std;\n\nint MOD=1000000007, N;\n \nint solve(int *p){\n    int i, ret=0;\n    sort(p,p+N);\n    for(i=0; i<N; i++){\n        ret=(ret+(long long)p[i]*(2*i-N+1))%MOD;\n    }\n    return ret+(ret<0?MOD:0);\n}\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int MAXN=500010;\n    cin>>N;\n    vector<vector<int>>(2,vector<int>(N+1));\n    for(auto i=0; i<N; i++){\n        cin>>points[0][i]>>points[1][i];\n    }\n    cout<<(solve(points[0])+solve(points[1]))%MOD;\n}\n"
    },
    {
        "titulo": "7920. Incrementando intervalos",
        "url": "https://omegaup.com/arena/problem/Incrementando-intervalos/",
        "descripcion": "Cuentas con un arreglo de N enteros que valen 0 inicialmente. Se te darán M intervalos con extremos I,F y para cada uno deberás incrementar los elementos del arreglo que están de la posición I a la posición F, sin incluir esta última. ¿Qué valor tendrán los elementos del arreglo después de procesar todos los intervalos?",
        "entrada": "Dos enteros N,M seguido de M parejas de enteros I,F que denotan los extremos de cada intervalo. Puedes suponer que 0<=N,M<=100000 y que 0<=I<=F<=N.",
        "salida": "Los N enteros del arreglo después de procesar todos los intervalos.",
        "nivel": "Intermedio (difícil) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Vectores",
            "Técnica de diferencias",
            "Suma de prefijos"
        ],
        "estructuras": [
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 100005; \nint arr[MAXN]; \n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int N, M;\n    cin >> N >> M;\n    // Aplicar la t?nica de diferencias\n    for(auto i = 0; i < M; i++) {\n        int I, F;\n        cin >> I >> F;\n        arr[I]++; \n        arr[F]--; \n    }\n    // Reconstruir el arreglo sumando las diferencias\n    for(auto i = 1; i < N; i++) {\n        arr[i] += arr[i - 1];\n    }\n    // Imprimir el arreglo resultante\n    for(auto i = 0; i < N; i++) {\n        cout << arr[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "10839. Equipo de Basket",
        "url": "https://omegaup.com/arena/problem/Equipo-de-Basquet/",
        "descripcion": "Se te dará una lista de N enteros que representan la altura de las personas y el orden en el que están formados. Deberás decir cuantos equipos de K personas puedes formar tal que estén todos juntos (una secuencia contigua) y que todos tengan alturas distintas.",
        "entrada": "Un número N que indica el número de personas y K que es la cantidad de personas que se necesitan para el equipo. Luego, la lista de N números A_i que representan la altura de las personas.",
        "salida": "Un único entero que representa la cantidad de equipos buenos que se pueden formar.",
        "nivel": "Intermedio (difícil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Vectores",
            "Tablas de dispersión",
            "Ventana deslizante"
        ],
        "estructuras": [
            "int",
            "vector<int>",
            "set<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    ios::sync_with_stdio(0);\n  cin.tie(0);\n   cout.tie(0);\n  int n, m, a, b, c=0, d, e, f, g, h;\n   vector<int>ar(100000,0);\n  set<int>ar2;\n  cin>>n>>m;\n    for(auto i=0; i<n; i++){\n      cin>>ar[i];\n   }\n a=0;\n  d=0;\n  while(a<n){\n       if(ar2.count(ar[a])){\n         while(ar[d]!=ar[a]){\n              ar2.erase(ar[d]);\n             d++;\n          }\n         d++;\n      }\n     else{\n         ar2.insert(ar[a]);\n        }\n     a++;\n      if(a-d>=m){\n           c++;\n      }\n     else if(a-d>m){\n           ar2.erase(ar[d]);\n     }\n }\n cout<<c;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "11817. Escolta",
        "url": "https://omegaup.com/arena/problem/Escolta/",
        "descripcion": "Dadas las estaturas de los estudiantes de cada grupo, debes elegir un estudiante por grupo tal que la diferencia entre el más alto y el más pequeño de los que elijas sea la mínima posible.",
        "entrada": "En la primera línea se darán 3 enteros N, M y K los cuales representa el tamaño de los grupos. En la segunda, tercera y cuarta línea se darán los conjuntos a, b y c, respectivamente, los cuales contendrán las estaturas de los estudiantes de cada grupo.",
        "salida": "Una única línea con 3 enteros que representen la altura de los alumnos que se debe elegir por grupo que cumpla la condición anteriormente descrita. Si hay más de una solución imprime cualquiera.",
        "nivel": "Intermedio (difícil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Vectores",
            "Colas",
            "Ordenamiento"
        ],
        "estructuras": [
            "int",
            "queue<int>",
            "pair<int,int>",
            "vector<pair<int,int>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef struct{\n    long long aa, bb, cc, dd;\n}sobras;\n\nlong long a, b, c, d, e, f, g, h;\nvector<pair<long long,long long> >falta;\nqueue<long long>aa;\nqueue<long long>bb;\nqueue<long long>cc;\nsobras sub;\n\nint main(){\n cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  cin>>a>>b>>c;\n while(a--){\n       cin>>d;\n       falta.push_back(make_pair(d,1));\n  }\n while(b--){\n       cin>>d;\n       falta.push_back(make_pair(d,2));\n  }\n while(c--){\n       cin>>d;\n       falta.push_back(make_pair(d,3));\n  }\n sort(falta.begin(),falta.end());\n  for(auto i=0; i<falta.size(); ++i){\n        switch(falta[i].second){\n          case 1: aa.push(i);break;\n         case 2: bb.push(i);break;\n         case 3: cc.push(i);break;\n     }\n }\n sub.dd=1000000000;\n    while(aa.size() && bb.size() && cc.size()){\n       a=min(min(falta[aa.front()].first,falta[bb.front()].first),falta[cc.front()].first);\n      b=max(max(falta[aa.front()].first,falta[bb.front()].first),falta[cc.front()].first);\n      if(b-a<sub.dd){\n           sub.dd=b-a;\n           sub.aa=aa.front();\n            sub.bb=bb.front();\n            sub.cc=cc.front();\n        }\n     if(aa.front()<=bb.front() && aa.front()<=cc.front()){\n         aa.pop();\n     }\n     else if(bb.front()<=aa.front() && bb.front()<=cc.front()){\n            bb.pop();\n     }\n     else if(cc.front()<=aa.front() && cc.front()<=bb.front()){\n            cc.pop();\n     }\n }\n cout<<falta[sub.aa].first<<\" \"<<falta[sub.bb].first<<\" \"<<falta[sub.cc].first;\n\n  return 0;\n}\n"
    },
    {
        "titulo": "11599. Ordenando tareas",
        "url": "https://omegaup.com/arena/problem/Ordenando-tareas/",
        "descripcion": "A los chicos de Yucatán se les conoce por ser muy cumplidos con sus tareas. El sistema que se tiene dentro del estados ha ido funcionando bien a lo largo de la olimpiada y se maneja de la siguiente forma: Cada problema esta numerado del 1 al 10^6. Cada vez que alguien empieza a resolver un problema ingresa su número en una plataforma y una vez que acabe de resolverlo (o intentar resolverlo) ingresa el número, pero en negativo. Por ejemplo, si se empezó a resolver el problema 5, se acabó y luego se empezó con el problema 1 y se terminó; la salida de la plataforma se vería algo como: [5,-5,1,-1]. Santy puso unas reglas para el ingreso de los datos en la plataforma: Por día, se debe intentar resolver por lo menos un problema. No se puede dejar de intentar un problema si ni siquiera se empezó. Al final del día todos los problemas que se empezaron deben estar terminados (no puedes desvelarte un día entero resolviendo problemas). Cada problema solo se puede intentar máximo 1 vez por día. Algunos ejemplos de días puedes ser: [5,1,-5,-1] Caso correcto. [5,-5,1,-1] Caso correcto.[5,1,-5] Dia incorrecto: El 1 se empezó ese día, pero nunca acabo. [5,-1,-5] Dia incorrecto: Se termino el problema 1 sin siquiera empezarlo. [5,-5,5,-5] Dia incorrecto: Se intento un problema más de una vez el mismo día. Los chicos de Yucatán ya habían pasado varios días sin que Santy los revise. Cuando de la nada un portal sale y succiona varias cosas cercanas, entre las cosas que el portal se llevo fue la maquina encargada de llevar el control de los días. Ellos no sabían muy bien que hacer, había personas al otro lado del portal pidiéndoles que los acompañen. Sin embargo, ellos sabían que si Santy llegaba y no veía el trabajo que habían hecho se iba a enojar. Lo que se descompuso fue la máquina que llevaba la sección de días, pero las entradas aún estaban allí. Es decir, si teníamos dos días [5,-5],[1,5,-5,-1] ahora sin la maquina perdida tenemos solos 5,-5,1,5,-5,-1. Los chicos de Yucatán saben que Santy no se enojara siempre y cuando haya un patrón lógico en la entrada (esto es que se cumplas las condiciones dichas anteriormente por día). Ayuda a los chicos de Yucatán encontrar alguna forma de partir las entradas en días válidos. Se te dará la lista de entradas que se tiene y deberás de decir una forma valida de partir los días. La forma es válida si cada día satisface las condiciones dichas anteriormente.",
        "entrada": "Un número n indicando el número de entradas. Seguido se te dará la lista de entradas que son enteros entre 1 y 10^6 ya sea negativos o positivos.",
        "salida": "Un número d indicando el número de días en los cuales partiste lo anterior. Tendrás que dar una lista de d números r_i, cada número representa el número de días que abarca el i-esimo día. Imprimir un -1 en caso de que no sea posible partir en un día valido.",
        "nivel": "Intermedio (difícil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Vectores"
        ],
        "estructuras": [
            "int",
            "vector<int>",
            "vector<pair<int,int>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(9);\n cout.tie(0);\n  int a, b, c, d, e, f, g, h;\n   vector<pair<int,int> >num(1000002,{0,0});\n vector<int>sub;\n   vector<int>sum;\n   cin>>a;\n   while(a--){\n       cin>>b;\n       c++;\n      if(b>0){\n          if(num[b].first){\n             while(a--){\n                   cin>>b;\n               }\n             cout<<-1;return 0;\n            }\n         if(num[b].second && d){\n               while(a--){\n                   cin>>b;\n               }\n             cout<<-1;return 0;\n            }\n         else{\n             d++;\n              sum.push_back(b);\n             num[b].first++;\n               num[b].second++;\n          }\n     }\n     else{\n         b=fabs(b);\n            if(!num[b].first){\n                while(a--){\n                   cin>>b;\n               }\n             cout<<-1;return 0;\n            }\n         else{\n             d--;\n              num[b].first--;\n               if(!d){\n                   while(sum.size()){\n                        num[sum[sum.size()-1]].second=0;\n                      sum.pop_back();\n                   }\n                 sub.push_back(c);\n                 c=0;\n              }\n         }\n     }\n }\n if(d){\n        cout<<-1;\n }\n else{\n     cout<<sub.size()<<\"\\n\";\n        for(auto i=0; i<sub.size(); ++i){\n          cout<<sub[i]<<\" \";\n      }\n }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "8415. Display Led",
        "url": "https://omegaup.com/arena/problem/Display-Led/",
        "descripcion": "Las pantallas de led se conforman de una gran cantidad de puntos individuales que al encenderse y apagarse pueden mostrar imágenes de alta calidad. Los leds tienden a fallar, por lo que existe un dispositivo capaz de tomar una lectura de datos que indica los leds que ya no funcionan. Realizar un programa que lea la información del estatus de la pantalla led e indique cual es el tamaño del área más grande de las que fallan y cuál es el tamaño de área más pequeña. Es posible que todos los leds fallen pero también es posible que no exista ningún led descompuesto. Este tipo de pantallas siempre genera fallas en tamaños rectangulares y además esas área de fallas son perfectamente distinguibles, nunca se tocan unas con otras de manera vertical ni horizontal (en diagonal si podrían llegar a tocarse). En las lecturas de una pantalla led, las \"X\" indican un led que falla, mientras que los \"0\" (cero) indican un led que funciona correctamente.",
        "entrada": "En la primera línea aparecerá el número de renglones R (1<=R<=300) y el número de columnas C (1<=C<=300) de la pantalla led separados por un espacio en blanco. A continuación, aparecerán R líneas de C caracteres cada una de ellas representando con la pantalla led. Este grupo de caracteres solo incluye la X o el 0, donde la X representa un led descompuesto y el 0 representa un led que funciona correctamente.",
        "salida": "En la primera línea debe aparecer un entero indicando el tamaño del área más grande de leds descompuestos. La segunda línea, un entero que representa el tamaño del área más pequeña de leds descompuestos. Puede que no existan leds descompuestos, en cuyo caso, tanto el área más grande como el área más pequeña será 0 (cero).",
        "nivel": "Intermedio (difícil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Matrices",
            "Componentes Conexas",
            "Búsqueda en profundidad",
            "Recursión"
        ],
        "estructuras": [
            "int",
            "char",
            "bool",
            "INT_MAX"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint R, C;\nchar pantalla[305][305];\nbool visitado[305][305];\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\nint floodFill(int i, int j) {\n if (i < 0 || i >= R || j < 0 || j >= C || pantalla[i][j] == '0' || visitado[i][j]) {\n      return 0;\n }\n visitado[i][j] = true;\n    int tamano = 1;\n   for (int k = 0; k < 4; ++k) {\n     tamano += floodFill(i + dx[k], j + dy[k]);\n    }\n return tamano;\n}\n\nint main() {\n cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  cin >> R >> C;\n    for (int i = 0; i < R; ++i) {3\n     cin >> pantalla[i];\n   }\n int maxArea = 0, minArea = INT_MAX;\n   for (int i = 0; i < R; ++i) {\n     for (int j = 0; j < C; ++j) {\n         if (pantalla[i][j] == 'X' && !visitado[i][j]) {\n               int tamano = floodFill(i, j);\n             maxArea = max(maxArea, tamano);\n               minArea = min(minArea, tamano);\n           }\n     }\n }\n if (minArea == INT_MAX) {\n     minArea = 0;\n  }\n cout << maxArea << endl;\n  cout << minArea << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "7401. Clipping de lineas",
        "url": "https://omegaup.com/arena/problem/Clipping-de-lineas/",
        "descripcion": "Encontrar qué pedazo de un segmento queda dentro de un area rectangular dada.",
        "entrada": "Ocho números decimales, separados por espacios. Los primeros cuatro números delimitan el area rectangular (x_min, y_min, x_max, y_max) los siguientes dos números especifican el punto de inicio de la línea (x_1,y_1) y los últimos dos, el punto final (x_2,y_2).",
        "salida": "La salida debe contener cuatro números decimales separados por espacio, donde los dos primeros deben ser las coordenadas (x,y) del punto inicial y los últimos las coordenadas (x,y) del punto final. Cada número debe estar redondeado a dos decimales. En caso de que la línea no intersecte con el rectángulo, se debe escribir la palabra NADA.",
        "nivel": "Intermedio (difícil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Cálculo matemático"
        ],
        "estructuras": [
            "double",
            "fixed",
            "setprecision()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Point {\n    double x, y;\n};\n\nPoint intersection(Point p1, Point p2, Point min_xy, Point max_xy) {\n    double t_min = 0, t_max = 1;\n    for (int i = 0; i < 2; i++) {\n        double t1 = (min_xy.x - p1.x) / (p2.x - p1.x);\n        double t2 = (max_xy.x - p1.x) / (p2.x - p1.x);\n        if (i == 1) {\n            t1 = (min_xy.y - p1.y) / (p2.y - p1.y);\n            t2 = (max_xy.y - p1.y) / (p2.y - p1.y);\n        }\n        if (t1 > t2) {\n            swap(t1, t2);\n        }\n        t_min = max(t_min, t1);\n        t_max = min(t_max, t2);\n    }\n    if (t_min <= t_max && t_min >= 0 && t_min <= 1 && t_max >= 0 && t_max <= 1) {\n        return {p1.x + t_min * (p2.x - p1.x), p1.y + t_min * (p2.y - p1.y)};\n    } else {\n        return {-1, -1};\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    cout << fixed << setprecision(2);\n    Point min_xy, max_xy, p1, p2;\n    cin >> min_xy.x >> min_xy.y >> max_xy.x >> max_xy.y >> p1.x >> p1.y >> p2.x >> p2.y;\n    Point p1_clipped = intersection(p1, p2, min_xy, max_xy);\n    Point p2_clipped = intersection(p2, p1, min_xy, max_xy);\n    if (p1_clipped.x != -1 && p2_clipped.x != -1) {\n        cout << p1_clipped.x << \" \" << p1_clipped.y << \" \" << p2_clipped.x << \" \" << p2_clipped.y << endl;\n    } else {\n        cout << \"NADA\" << endl;\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "116. Curiosity",
        "url": "https://omegaup.com/arena/problem/curiosity/",
        "descripcion": "El robot de exploración Curiosity ha llegado por fin a Marte, la NASA te ha pedido que le ayudes a resolver un problema con su sistema de navegación. El lugar donde se encuentra Curiosity se representa como una cuadrícula de N x M, NASA quiere mover su robot de la posición inicial (X_i,Y_i) a una posición final (X_f,Y_f). Curiosity solo tiene programados K diferentes tipos de movimientos los cuales están representados en una matriz de K elementos [X_1,Y_1, ]...[X_K,Y_k] donde cada par [X,Y] representan el número de cuadros que se mueve en cada uno de los ejes. En cada paso Curiosity puede ejecutar cualquiera de estos movimientos siempre y cuando no se salga de la cuadrícula. Tu tarea consiste en dada la posición inicial de Curiosity determinar cuál es el número mínimo de pasos que necesita ejecutar para llegar a su posición final.",
        "entrada": "En la primer línea tendrás los números N, M (1<=N,M<=1000) y K (1<=K<=10). En la siguiente línea tendrás dos enteros que representan la posición inicial de curiosity (las coordenadas van desde 1,1 hasta n,m). En la tercer línea dos enteros que representan la posición final deseada. Las siguientes K líneas contienen un par de enteros que indican cada movimiento posible.",
        "salida": "Un solo entero representando el número mínimo de pasos para llegar a la posición final, en caso de que no sea posible llegar debes imprimir -1.",
        "nivel": "Intermedio (difícil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Matrices",
            "Colas",
            "Búsqueda en amplitud"
        ],
        "estructuras": [
            "bool",
            "int",
            "vector<pair<int,int>>",
            "vector<vector<bool>>",
            "queue<struct>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Cell {\n    int x, y, dist;\n};\n\nbool isValid(int x, int y, int N, int M) {\n    return (x >= 1 && x <= N && y >= 1 && y <= M);\n}\n\nint minSteps(int N, int M, int xi, int yi, int xf, int yf, vector<pair<int, int>>& moves) {\n    vector<vector<bool>> visited(N + 1, vector<bool>(M + 1, false));\n    queue<Cell> q;\n    q.push({xi, yi, 0});\n    visited[xi][yi] = true;\n    while (!q.empty()) {\n        Cell curr = q.front();\n        q.pop();\n        if (curr.x == xf && curr.y == yf) {\n            return curr.dist;\n        }\n        for (auto move : moves) {\n            int nextX = curr.x + move.first;\n            int nextY = curr.y + move.second;\n            if (isValid(nextX, nextY, N, M) && !visited[nextX][nextY]) {\n                visited[nextX][nextY] = true;\n                q.push({nextX, nextY, curr.dist + 1});\n            }\n        }\n    }\n    return -1; // No se encontro un camino\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int N, M, K;\n    cin >> N >> M >> K;\n    int xi, yi, xf, yf;\n    cin >> xi >> yi >> xf >> yf;\n    vector<pair<int, int>> moves(K);\n    for (int i = 0; i < K; ++i) {\n        cin >> moves[i].first >> moves[i].second;\n    }\n    int result = minSteps(N, M, xi, yi, xf, yf, moves);\n    cout << result << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "341. Concierto del Doctor",
        "url": "https://omegaup.com/arena/problem/Concierto-de-Dr-Lira/",
        "descripcion": "Un doctor está aprendiendo a tocar la guitarra para darle un concierto a sus minions y quiere evitar tocar todas las canciones al mismo volumen para no aburrirlos, por lo cual decidió cambiar el volumen de la guitarra antes de cada canción. Antes de que inicie el concierto, el doctor hizo una lista de los cambios de volumen que vas a aplicar antes de cada canción. Para cada valor, el doctor puede ya sea subir el volumen o bajarlo. El doctor ha pedido tu ayuda para calcular cuál podría ser el volumen máximo que puede usar para tocar su última canción. Para evitar dejar sordos a sus minions, el doctor te pide que nunca se exceda un valor máximo permitido. De igual forma, el doctor también ha decidido usar un valor inicial para el volumen. En ningún momento el volumen puede ser menor a 0. Si no hay forma de tocar la lista con los cambios indicados por el doctor sin exceder el valor máximo permitido o con un volumen menor a 0, escribe -1.",
        "entrada": "La primer línea contendrá N (1<=N<=50), el número de cambios de volumen. La segunda línea contendrá N enteros N_i (1<=N_i<=1000), el i-esimo elemento representa el valor del cambio de volumen que se puede aplicar antes de la i-ésima canción. La tercer línea contendrá dos enteros: B y M que representa el volúmen inicial y el máximo permitido.",
        "salida": "El volumen máximo que puede usar para tocar su última canción, o -1 si en algun punto se excede el valor maximo permitido o se vuelve negativo.",
        "nivel": "Intermedio (difícil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Vectores",
            "Matrices",
            "Programación dinámica"
        ],
        "estructuras": [
            "int",
            "vector<int>",
            "vector<vector<bool>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int N, B, M;\n    cin >> N;\n    vector<int> cambios(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> cambios[i];\n    }\n    cin >> B >> M;\n    // dp[i][j] indica si es posible alcanzar el volumen j despu? de i canciones\n    vector<vector<bool>> dp(N + 1, vector<bool>(M + 1, false));\n    // Inicializaci?: el volumen inicial es alcanzable\n    dp[0][B] = true;\n    for (int i = 1; i <= N; ++i) {\n        for (int j = 0; j <= M; ++j) {\n            if (dp[i - 1][j]) {\n                // Intentar subir el volumen\n                if (j + cambios[i - 1] <= M) {\n                    dp[i][j + cambios[i - 1]] = true;\n                }\n                // Intentar bajar el volumen\n                if (j - cambios[i - 1] >= 0) {\n                    dp[i][j - cambios[i - 1]] = true;\n                }\n            }\n        }\n    }\n    // Encontrar el volumen m?imo alcanzable para la ?ltima canci?\n    int volumen_maximo = -1;\n    for (int j = M; j >= 0; --j) {\n        if (dp[N][j]) {\n            volumen_maximo = j;\n            break;\n        }\n    }\n    cout << volumen_maximo << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "159. Problema",
        "url": "https://omegaup.com/arena/problem/subsecuencias/",
        "descripcion": "Dada una secuencia de n números S=S_1,S_2,...,S_n queremos partir esta secuencia en dos sub-secuencias A y B de manera que la diferencia entre la suma de los elementos de A y la suma de los elementos de B sea la mínima posible. Es decir, las secuencias A y B deben satisfacer que: #1. Todos los elementos en A pertenecen a la secuencia S. #2. Todos los elementos en B pertenecen en la secuencia S. #3. Todos los elementos de la secuencia S pertenecen a A o pertenecen a B, pero no a ambos. #4. De entre todos los pares de sub-secuencias que satisfacen las 3 propiedades anteriores, la diferencia entre la suma de los elementos de A y la suma de los elementos de B es la mínima posible.",
        "entrada": "En la primera línea se encuentra un entero n (2<=n<=1000). En la segunda línea habrá n enteros S_i (1<=S_i<=20000) separados por espacios representando los elementos de la secuencia S (Teniendo en cuenta que la suma de todos los elementos de la secuencia original será a lo más igual a 20000).",
        "salida": "Un entero representando la diferencia mínima entre la suma de los elementos de una partición de S como se describe arriba. Nótese que la salida siempre será un número entero no-negativo.",
        "nivel": "Intermedio (difícil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Vectores",
            "Programación dinámica"
        ],
        "estructuras": [
            "int",
            "vector<int>",
            "vector<bool>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int n;\n    cin >> n;\n    vector<int> S(n);\n    int sumaTotal = 0;\n    for (int i = 0; i < n; ++i) {\n        cin >> S[i];\n        sumaTotal += S[i];\n    }\n    // Usamos DP para calcular todas las posibles sumas de subconjuntos\n    vector<bool> posible(sumaTotal + 1, false);\n    posible[0] = true; \n    for (int i = 0; i < n; ++i) {\n        for (int j = sumaTotal; j >= S[i]; --j) {\n            if (posible[j - S[i]]) {\n                posible[j] = true;\n            }\n        }\n    }\n    // Encontrar la suma m? cercana a la mitad de la suma total\n    int minDiferencia = sumaTotal;\n    for (int i = sumaTotal / 2; i >= 0; --i) {\n        if (posible[i]) {\n            minDiferencia = sumaTotal - 2 * i;\n            break;\n        }\n    }\n    cout << minDiferencia << endl;\n\n    return 0;\n"
    },
    {
        "titulo": "88. Engranes",
        "url": "https://omegaup.com/arena/problem/engranes/",
        "descripcion": "Se tienen dos engranes A y B, acoplados (dientes consecutivos de A tocan valles consecutivos de B) con N y M dientes, respectivamente. Los dientes de A están numerados del 0 al N-1, y los valles de B están numerados del 0 al M-1. Inicialmente, el diente 0 de A está tocando el valle 0 de B, en el primer paso el diente 1 tocará el valle 1 y así sucesivamente. Cada uno de los N dientes del engrane A está pintado con alguno de los k colores distintos, numerados del 0 al k-1, donde k<=A. Al girar, los dientes del engrane A tocan los valles (el espacio entre dientes) del engrane B, y al hacer contacto pintan el valle con el color del diente de A que lo tocó (si ya estaba pintado, el color anterior queda completamente cubierto del nuevo color). El color de los dientes de A nunca cambia, sólo cambia el color de los valles de B. Si después de mucho tiempo de estar girando, un valle j del engrane B nunca más cambia de color, decimos que ese valle es \"estable\". De otro modo, decimos que ese valle es \"inestable\". Dados los números N, M, k y el color de cada uno de los dientes del engrane A, determina si el j-esimo valle del engrane B es estable o inestable, para una lista de T valles de interés L_1, L_2, ..., L_T.",
        "entrada": "En la primera linea los números N (2<=N<=10^6), M (N<=M<=10^15), k. En la segunda linea, N números separados por espacios indicando el color de cada diente del engrane A. En la tercera linea, el número T (1<=T<=1000) de valles de interés. En la cuarta linea, la lista L_1, L_2, ..., L_T (0<=L_i) de valles de interés.",
        "salida": "Para cada elemento L de la lista de interés, imprime un dígito binario (0,1), donde 0 significa que el valle número L_i es inestable, y 1 significa que es estable.",
        "nivel": "Intermedio (difícil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Vectores",
            "Recursión"
        ],
        "estructuras": [
            "bool",
            "int",
            "long long",
            "vector<bool>",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long a, b, c, d, e, f;\nvector<int>num(1000002,0);\nvector<bool>sub(1000002,false), sum(1000002,false);\n\nlong long nums(long long x, long long y){\n    if(x==0)return y;\n    return nums(y%x,x);\n}\n  \nbool subs(long long g){\n    int h=g%c, l=num[h], m=a%c;\n    bool n=true;\n    if(sub[h]){\n        return sum[h];\n    }\n    for(auto i=1; i<b; i++){\n        h=(h+m)%c;\n        if(num[h]!=l){\n            n=false;break;\n        }\n    }\n    h=g%c;\n    sum[h]=n;\n    sub[h]=true;\n    for(auto i=1; i<b; i++){\n        h=(h+m)%c;\n        sum[h]=n;\n        sub[h]=true;\n    }\n  \n    return n;\n}\n  \nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    cin>>c>>a>>f;\n    for(auto i=0; i<c; i++){\n        cin>>num[i];\n    }\n    cin>>e;\n    b=c/nums(c,a);\n    for(auto i=0; i<e; i++){\n        cin>>d;\n        if(subs(d)){\n            cout<<\"1\";\n        }\n        else{\n            cout<<\"0\";\n        }\n    }\n    cout<<\"\\n\";\n    \n    return 0;\n}\n"
    },
    {
        "titulo": "160. Pulseras",
        "url": "https://omegaup.com/arena/problem/pulseras/",
        "descripcion": "Deseas averiguar cuántas pulseras diferentes pueden crearse con la siguientes consideraciones: #1. Una pulsera es una secuencia de cuentas blancas o negras, con un inicio y un final (los extremos que se atan). #2. No puede haber dos cuentas negras juntas. Esto aplica también para la inicial y la final, pues al atarla quedaran una a lado de la otra. #3. La longitud de la secuencia será 3<=n<=1000000.; Como el número de pulseras puede ser muy grande, solo deseas averiguar su congruencia módulo 1000000007 (10^9+7).",
        "entrada": "La primera y única línea tendrá un entero n (3<=n<=1000000) que indica el tamaño de las pulseras.",
        "salida": "Un único número, la cantidad de diferentes pulseras que se pueden formar de longitud n módulo 1000000007.",
        "nivel": "Intermedio (difícil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Vectores",
            "Cálculo matemático",
            "Aritmética modular",
            "Programación dinámica"
        ],
        "estructuras": [
            "int",
            "long long",
            "vector<long long>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long MOD = 1000000007;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int n;\n    cin >> n;\n    vector<long long> dp(n + 1);\n    dp[0] = 1; // Caso base: una pulsera vac?\n    dp[1] = 1; // Caso base: una pulsera con una cuenta (blanca o negra)\n    for (int i = 2; i <= n; ++i) {\n        dp[i] = (dp[i - 1] + dp[i - 2]) % MOD; \n    }\n    // Posibles configuraciones de inicio y fin\n    long long resultado = (dp[n] + dp[n - 2]) % MOD; \n    cout << resultado << \"\\n\";\n\n    return 0;\n}\n"
    },
    {
        "titulo": "118. Minecraft",
        "url": "https://omegaup.com/arena/problem/minecraft/",
        "descripcion": "Algunos de ustedes han jugado minecraft y saben que es un juego bastante simple, destruyes y colocas bloques a placer tratando de saciar tu ocio. En este problema partimos de un mapa con diversos bloques pero para facilitarte la tarea hemos decidido darte un mapa en 2D y al igual que en minecraft hay bloques con distintas durezas. La idea es que busques el tiempo mínimo que te tomará llegar de un punto a otro, los únicos movimientos que puedes hacer son verticales y horizontales, no te puedes desplazar en diagonal. Si una casilla se encuentra vacía, entonces solo te tomará una unidad de tiempo caminar por ahí, en caso de que se encuentre un bloque se te indicará la cantidad X de tiempo que te tomará destruir el bloque antes de que puedas caminar por ahí si es que el bloque se puede destruir (por lo que te tomará X+1 unidades de tiempo caminar por ahí), en caso contrario se te indicará que dicho bloque no puede ser destruido.",
        "entrada": "Un mapa descrito con caracteres donde '#' significa un bloque indestructible, '.' un bloque vacío, y los dígitos del '1' al '9' bloques que toman de 1 a 9 unidades de tiempo destruir respectivamente. Además una posición inicial y una posición final a la que debes llegar, en el caso de que la posición final no se encuentre libre, deberás primero destruir el bloque que se encuentre en dicha posición. La posición inicial siempre estará libre. La entrada vendrá de la siguiente forma: #1. Dos enteros N y M (5<=N,M<=500) que indican la cantidad de filas y columnas del mapa respectivamente. #2. Dos números f_0 y c_0 que indican la posición inicial en la que te encuentras. #3. Dos números f_1 y c_1 que indican la posición final a la que debes llegar. #4. N líneas con M caracteres describiendo el mapa, empezando por la posición (1,1).",
        "salida": "El tiempo mínimo en el que te transportas del punto inicial al punto final.",
        "nivel": "Intermedio (difícil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Matrices",
            "Grafos",
            "Búsqueda en amplitud",
            "Colas"
        ],
        "estructuras": [
            "bool",
            "int",
            "string",
            "vector<vector<bool>>",
            "vector<vector<int>>",
            "queue<pair<int, int>>",
            "vector<pair<int, int>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N, M;\nvector<vector<int>> mapa;\nvector<vector<bool>> visitado;\nint f_inicial, c_inicial;\nint f_final, c_final;\n\nint bfs() {\n    queue<pair<int, int>> q;\n    q.push({f_inicial, c_inicial});\n    visitado[f_inicial][c_inicial] = true;\n    vector<pair<int, int>> movimientos = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    vector<vector<int>> distancia(N, vector<int>(M, 1e9));\n    distancia[f_inicial][c_inicial] = 0;\n    bool bandera=false;\n    while (!q.empty()) {\n        int f_actual = q.front().first;\n        int c_actual = q.front().second;\n        q.pop();\n        if (f_actual == f_final && c_actual == c_final) {\n            bandera=true;continue;\n        }\n        for (auto& mov : movimientos) {\n            int f_siguiente = f_actual + mov.first;\n            int c_siguiente = c_actual + mov.second;\n            if (f_siguiente >= 0 && f_siguiente < N && c_siguiente >= 0 && c_siguiente < M) {\n                if (mapa[f_siguiente][c_siguiente] != -1) {\n                    if (distancia[f_siguiente][c_siguiente] > distancia[f_actual][c_actual] + mapa[f_siguiente][c_siguiente] + 1) {\n                        distancia[f_siguiente][c_siguiente] = distancia[f_actual][c_actual] + mapa[f_siguiente][c_siguiente] + 1;\n                        q.push({f_siguiente, c_siguiente});\n                        visitado[f_siguiente][c_siguiente] = true;\n                    }\n                }\n            }\n        }\n    }\n    if(bandera){\n        return distancia[f_final][c_final];\n    }\n    return -1;\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    cin >> N >> M;\n    cin >> f_inicial >> c_inicial;\n    cin >> f_final >> c_final;\n    f_inicial--;\n    c_inicial--;\n    f_final--;\n    c_final--;\n    mapa.assign(N, vector<int>(M, 0));\n    visitado.assign(N, vector<bool>(M, false));\n    for (int i = 0; i < N; i++) {\n        string linea;\n        cin >> linea;\n        for (int j = 0; j < M; j++) {\n            if (linea[j] == '#') {\n                mapa[i][j] = -1; \n            } else if (linea[j] == '.') {\n                mapa[i][j] = 0; \n            } else {\n                mapa[i][j] = linea[j] - '0'; \n            }\n        }\n    }\n    int tiempo_minimo = bfs();\n    cout << tiempo_minimo << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "258. Super Nieves Bros",
        "url": "https://omegaup.com/arena/problem/super-nieves-bros/",
        "descripcion": "El juego es una cuadrícula de N x M. Algunas celdas de la cuadrícula tienen una plataforma en la cual Plasma Nieves se puede parar. Todas las celdas del renglón del fondo del mapa siempre tienen una plataforma. Los renglones del mapa están numerados del 1 al N empezando desde arriba (por lo que todas las celdas del renglon numerado con N tienen una plataforma) y las columnas están numeradas del 1 al M empezando desde la izquierda. Exactamente una de las celdas contiene una puerta y Plasma Nieves necesita llegar ahí. Inicialmente, nuestro héroe se encuentra posicionado en el piso (el renglón de más abajo). Plasma Nieves se puede mover horizontalmente hacia los 2 lados adyacentes si ambos contienen una plataforma. Plasma Nieves también cuenta con una escalera que puede usar para subir o bajar de renglón. Si la escalera es de longitud L, Plasma Nieves puede moverse entre dos celdas (i_1,j) y (i_2,j) si ambas contienen una plataforma y |i_1-i_2|<=L (el valor absoluto de la diferencia entre las alturas es menor o igual a la longitud de la escalera). Plasma Nieves es muy fuerte y hábil, así que puede cargar la escalera a donde vaya y usarla múltiples veces. Debido a que la escalera es muy costosa de obtener, Plasma Nieves necesita que le ayudes a determinar cuál es el tamaño mínimo de escalera L que necesita tal que puede llegar del piso a la puerta. Por razones que no podemos comprender, Plasma Nieves no puede brincar hacía abajo, por lo que forzosamente tiene que usar la escalera para bajar a alguna posicion valida alcansable por la misma.",
        "entrada": "En la primer línea habrá dos enteros N y M (1<=N,M<=50), representando el número de renglones y columnas. En la segunda línea habrá dos enteros R y C (los cuales siempre estarán dentro de la cuadrícula), indicando el renglón y la columna donde se encuentra la puerta (la cual siempre estárá en una plataforma). Después habrá N líneas con M caracteres cada uno. Las 'X' representan las plataformas y los '.' espacios vacíos.",
        "salida": "El tamaño mínimo de la escalera que se necesita para llegar del piso a la puerta. Escribe 0 si se puede solucionar sin escalera.",
        "nivel": "Intermedio (difícil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Grafos",
            "Búsqueda en amplitud"
        ],
        "estructuras": [
            "int",
            "vector<vector<char>>",
            "vector<vector<bool>>",
            "pair<int, int>",
            "queue<pair<int, int>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, m, r, c, ans;\nvector<vector<char>> grid;\nvector<vector<bool>> visited;\npair<int, int> start, door;\nqueue<pair<int, int>> q;\n\nbool isValid(int x, int y){\n    return (x >= 0 && x < n && y >= 0 && y < m && grid[x][y] == 'X' && !visited[x][y]);\n}\n\nvoid bfs(int l){\n    while(!q.empty()){\n        pair<int, int> curr = q.front();\n        q.pop();\n        int x = curr.first;\n        int y = curr.second;\n        if(curr == door){\n            return;\n        }\n        // Movement with the ladder\n        for(auto i = max(0, x - l); i <= min(n - 1, x + l); i++){\n            if(isValid(i, y)){\n                visited[i][y] = true;\n                q.push({i, y});\n            }\n        }\n        // Horizontal movement\n        if(isValid(x, y - 1)){\n            visited[x][y - 1] = true;\n            q.push({x, y - 1});\n        }\n        if(isValid(x, y + 1)){\n            visited[x][y + 1] = true;\n            q.push({x, y + 1});\n        }\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    cin >> n >> m;\n    cin >> r >> c;\n    door = {r - 1, c - 1}; \n    grid.assign(n, vector<char>(m));\n    visited.assign(n, vector<bool>(m, false));\n    for(auto i = 0; i < n; i++){\n        for(auto j = 0; j < m; j++){\n            cin >> grid[i][j];\n            if(i == n - 1 && grid[i][j] == 'X'){\n                start = {i, j};\n            }\n        }\n    }\n    if(start == door){\n        cout << \"0\\n\";\n        return 0;\n    }\n    for(auto l = 0; l <= n; l++){\n        q.push(start);\n        visited.assign(n, vector<bool>(m, false));\n        visited[start.first][start.second] = true;\n        bfs(l);\n        if(visited[door.first][door.second]){\n            ans = l;\n            break;\n        }\n    }\n    cout << ans << \"\\n\";\n\n    return 0;\n}\n"
    },
    {
        "titulo": "236. La Venganza de Silvio",
        "url": "https://omegaup.com/arena/problem/VenganzaDeSilvio/",
        "descripcion": "Silvio Rodríguez Domínguez (San Antonio de los Baños, 29 de noviembre de 1946) es un cantautor, guitarrista y poeta cubano, exponente característico de la música de su país surgida con la Revolución cubana, conocida como la Nueva Trova Cubana, que comparte con otros reconocidos cantautores tales como Pablo Milanés, Noel Nicola y Vicente Feliú. Después de la gran decepción que sufrió al poner su pizzería, juró cobrar venganza sobre los olímpicos. Ahora decidió torturar al Agente Solid Nieves, obligándolo a hacer cuentas increíblemente tediosas mientras escucha sus éxitos de antaño, como \"Quick puede no ser Quick\". Le dio un entero N, el cual debía elevar a la M-ésima potencia, y prometió que lo dejaría libre si contestaba correctamente. Siendo muy listo, Silvio eligió una M muy grande para que el Agente Solid Nieves nunca lograra terminar, y además se la dio en base 2. Por si no fuera suficiente, pidió que la respuesta se la diera módulo m. Ayuda al Agente Solid Nieves a contestar la pregunta de Silvio para poder escapar.",
        "entrada": "En la primer línea, dos enteros, N y m. En la segunda línea, la representación en binario de M.",
        "salida": "Un entero, N^M(mod m), de donde N, M y m (m!=0) son enteros no negativos. Ademas: N,m<2^31 y M<=2^1000001.",
        "nivel": "Intermedio (difícil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Caracteres y cadenas",
            "Aritmética modular",
            "Exponenciación binaria"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll exp_binaria(ll base, string exponente, ll modulo) {\n    ll resultado = 1;\n    ll base_actual = base % modulo;\n    for (int i = exponente.length() - 1; i >= 0; --i) {\n        if (exponente[i] == '1') {\n            resultado = (resultado * base_actual) % modulo;\n        }\n        base_actual = (base_actual * base_actual) % modulo;\n    }\n    return resultado;\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    ll N, m;\n    string M;\n    cin >> N >> m;\n    cin >> M;\n    cout << exp_binaria(N, M, m) << \"\\n\";\n\n    return 0;\n}\n"
    },
    {
        "titulo": "8319. El Trabajador Novato",
        "url": "https://omegaup.com/arena/problem/El-Trabajador-Novato/",
        "descripcion": "Un establecimiento de paquetería se dedica a entregar la correspondencia de sus clientes principales a través de un empleado de confianza. La paquetería siempre tiene personal calificado que realiza este trabajo. Cierto día, la paquetería quiso jugar una broma a un trabajador joven recién contratado para darle la novatada de bienvenida. La broma consistía en que el trabajador joven debería llevar X correspondencia a uno de los clientes, y éste al recibirla le haría pensar que se equivocó de cliente, así que lo mandaría visitar a otro cliente (que el destinatario tiene en común con la paquetería), y así. Los clientes de la paquetería (en complicidad) quieren evitar situaciones incomodas, así que no le pedirán al trabajador novato que visite al mismo cliente (incluido regresar a la paquetería) dos veces. La paquetería sabe cuánto cuesta el viaje para ir con sus clientes y el viaje entre dos clientes que se conocen y quiere saber ¿Cuál es la cantidad máxima de dinero que gastará en viajes por la broma que le jugará a su trabajador novato? La paquetería y sus clientes están etiquetados de 0 a n-1, y su red de conexiones forma un árbol. En otras palabras, cada dos de los clientes a,b se conocen entre sí, posiblemente de manera indirecta (hay una secuencia de clientes comenzando desde a y terminando en b, de tal forma que cada dos clientes consecutivos en la secuencia se conocen directamente), y hay exactamente n-1 pares de clientes que se conocen directamente o conocen a la paquetería. A la paquetería se le asigna el número 0.",
        "entrada": "La primera línea de la entrada contiene el número n de clientes, incluyendo a la paquetería, (3<=n<=100). Las siguientes n-1 líneas contienen tres enteros separados por espacios u, v y c (0<=u,v<=n-1,1<=c<=10^4), lo que significa que u y v son clientes (que se conocen directamente o conocen la paquetería) y el costo por viajar entre u y v es c. Se debe garantizar que la red social de la entrada forma un árbol.",
        "salida": "La salida es un único entero - la suma máxima de costos.",
        "nivel": "Intermedio (difícil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Vectores",
            "Arboles",
            "Búsqueda en profundidad",
            "Recursión"
        ],
        "estructuras": [
            "vector<pair<int>>",
            "pair<int>",
            "long long",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<pair<int>>num[101];\nlong long a, b, c, d;\nint nums[101];\npair<int> z;\n\nvoid sub(int x){\n    for(auto i=0; i<num[x].size(); i++){\n        if(!nums[num[x][i].first]){\n            c+=num[x][i].second;\n            b=max(b,c);\n            nums[num[x][i].first]=1;\n            sub(num[x][i].first);\n            nums[num[x][i].first]=0;\n            c-=num[x][i].second;\n        }\n    }\n    return;\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    cin>>a;\n    for(auto i=1; i<a; i++){\n        cin>>b>>c>>d;\n        z.first=c;\n        z.second=d;\n        num[b].push_back(z);\n        z.first=b;\n        num[c].push_back(z);\n    }\n    b=c=0;\n    nums[0]=1;\n    sub(0);\n    cout<<b;\n    \n    return 0;\n}"
    },
    {
        "titulo": "11824. Limonadas",
        "url": "https://omegaup.com/arena/problem/Limonadas/",
        "descripcion": "Naty tiene una fábrica de limonadas y necesita vender una cantidad \"X\" de litros, ella recolecta el agua de lluvia directamente de las fosas que se forman en su terreno. Escribe un programa que conociendo los \"X\" litros de limonada que deberá vender Naty y el relieve de su terreno, le indique cuantos litros de agua debe comprar para poder preparar sus limonadas. En caso que recolecte mas agua de la que necesita, deberás imprimir el total de litros de agua que le sobran.",
        "entrada": "En la primera línea el número 0<X<=10^9 que representa la cantidad de limonada que Naty debe vender. En la segunda línea al valor 0<N<10^6 indicando el relieve del terreno de Naty. En la tercera línea \"N\" valores enteros 0<H<10^5 qué representa la altura del terreno de Naty.",
        "salida": "Una sola línea indicando la cantidad de litros de agua que le hacen falta a Naty para poder vender los \"X\" litros de limonada o la cantidad de litros que le sobraron. (Se te asegura que el resultado cabe en un entero signado de 32 bits).",
        "nivel": "Intermedio (difícil) - Matemáticas en la programación",
        "categorias": [
            "Vectores",
            "Técnica de dos apuntadores"
        ],
        "estructuras": [
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  int a, b, c, d, e, f, g, h;\n   vector<int>num(1000001,0);\n    cin>>a>>b;\n    for(auto i=0; i<b; ++i){\n       cin>>num[i];\n  }\n c=0;\n  while(c<b-1 && num[c]<num[c+1]){\n      c++;\n  }\n if(c+1==b){\n       cout<<a;return 0;\n }\n d=b-1;\n    while(d>0 && num[d]<num[d-1]){\n        d--;\n  }\n if(d==0){\n     cout<<a;return 0;\n }\n while(c<d){\n       if(num[c]<=num[d]){\n           e=num[c];\n         c++;\n          while(num[c]<e){\n              f+=(e-num[c]);\n                c++;\n          }\n     }\n     else{\n         e=num[d];\n         d--;\n          while(num[d]<e){\n              f+=(e-num[d]);\n                d--;\n          }\n     }\n }\n cout<<abs(a-f);\n\n return 0;\n}\n"
    },
    {
        "titulo": "11382. Bienestar Azteca",
        "url": "https://omegaup.com/arena/problem/Bienestar-Azteca/",
        "descripcion": "La página de Bienestar Azteca se encuentra saturada pero tu necesitas de la beca para poder ir a la OMI Zacatecas 2020 entonces tus amigos programadores te comentaron que en la escuela de Bachilleres 2 se encuentra un internet tan potente que te permite entrar a la página antes que nadie, solo que tienes que estar situado en un punto y mirando a una dirección en concreto. Tus amigos programadores no te dieron las coordenadas de esa posición ni la dirección que tienes que mirar, pero te dieron las siguientes indicaciones para poder encontrarlo. Inicias en la coordenada (1,1). Te moveras en forma de espiral con esta secuencia de dierecciones: este, sur, oeste y norte. Avanzas en una dirección hasta que te encuentres una casilla por la que ya hayas pasado o el límite de la escuela, cuando esto pase, cambias de dirección. Cuando ya no te puedes mover hacia ningun lado esa es la coordenada y la dirección es la ultima dirección que usaste para llegar a esa coordenada. Por ejemplo, cuando N=3 y M=3, iniciamos en la coordenada (1,1), nos movemos hacia el Este hasta la coordenada (1,3), como nos encontramos con el límite de la escuela cambiamos la dirección hacia el Sur hasta la coordenada (3,3), cambiamos nuevamente de dirección hacia el Oeste hasta las coordenadas (3,1) porque nos encontramos con el límite, cambiamos una vez más la dirección hacia el Norte y nos ubicamos en la coordenada (2,1), como nos encontramos una casilla que ya habíamos visitado reiniciamos la secuencia de direcciones y nos movemos hacia el Este, siendo nuestra ultima coordenada (2,2) mirando hacia la dirección del Este. Encuentra las coordenadas exactas en la que te debe ubicar y la dirección a la que debes mirar para poder entrar a la página de bienestar azteca.",
        "entrada": "Dos números N y M que son el tamaño de la escuela.",
        "salida": "Dos números x y y que son las coordenadas que debes estar situado y una caracter s que puede ser E(este), S(sur), O(oeste) o N(norte) que es la dirección a la que debes mirar en esas coordenadas.",
        "nivel": "Intermedio (difícil) - Matemáticas en la programación",
        "categorias": [
            "Cálculo matemático"
        ],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  int a, b, c, d, e, f, g, h;\n   cin>>a>>b;\n    if(a==b){\n     if(a%2){\n          cout<<(a/2)+1<<\" \"<<(a/2)+1<<\" E\";\n        }\n     else{\n         cout<<(a/2)+1<<\" \"<<a/2<<\" O\";\n        }\n }\n else if(a%2==0 && b%2==0){\n        if(b<a){\n          cout<<(min(a,b)/2)+1<<\" \"<<(min(a,b)/2)<<\" N\";\n        }\n     else{\n         cout<<(min(a,b)/2)+1<<\" \"<<(min(a,b)/2)<<\" O\";\n        }\n }\n else if(a%2 && b%2){\n      if(a<b){\n          cout<<(min(a,b)/2)+1<<\" \"<<max(a,b)-(min(a,b)/2)<<\" E\";\n       }\n     else{\n         cout<<max(a,b)-(min(a,b)/2)<<\" \"<<(min(a,b)/2)+1<<\" S\";\n       }\n }\n else if(min(a,b)%2){\n      if(a<b){\n          cout<<(min(a,b)/2)+1<<\" \"<<max(a,b)-(min(a,b)/2)<<\" E\";\n       }\n     else{\n         cout<<max(a,b)-(min(a,b)/2)<<\" \"<<(min(a,b)/2)+1<<\" S\";\n       }\n }\n else{\n     if(a<b){\n          cout<<(min(a,b)/2)+1<<\" \"<<(min(a,b)/2)<<\" O\";\n        }\n     else{\n         cout<<(min(a,b)/2)+1<<\" \"<<(min(a,b)/2)<<\" N\";\n        }\n }\n \n  return 0;\n}\n"
    },
    {
        "titulo": "11389. Polvo de Sahara",
        "url": "https://omegaup.com/arena/problem/Polvo-de-Sahara/",
        "descripcion": "El polvo de Sahara, el desierto más grande del mundo ha llegado a América, este polvo tiene componentes quimicos que pueden generar alergias e incluso la muerte si es respirado, la CIA (Centro de Investigación Arenoso) ha hecho una investigación a profundidad y tiene una lista de N países, que va de 1 hasta N, los cuales estan marcados con números claves. Si la clave del país i-ésimo es potencia de 2, significa que ese país tiene alto riesgo de ser afectados por este polvo. Tu tarea sera encontrar cuantos países se encuentran en alto riesgo ante el polvo de Sahara y cuales son estos países para advertirles lo antes posible.",
        "entrada": "Un entero N que es el número de países seguido de N números, el i-ésimo valor es la clave del i-ésimo país.",
        "salida": "Un entero K que es el número de países con alto riesgo seguido de un salto de l[inea con K números separados por un espacio los cuales son los países.",
        "nivel": "Intermedio (difícil) - Matemáticas en la programación",
        "categorias": [
            "Vectores",
            "Cálculo matemático",
            "Manipulación de bits"
        ],
        "estructuras": [
            "long long",
            "vector<long long>",
            "~",
            "&"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  long long a, b, c, d, e, f, g, h;\n vector<long long>num;\n cin>>a;\n   for(auto i=1; i<=a; i++){\n      cin>>b;\n       if(b-(b&~(b-1))==0){\n          num.push_back(i);\n     }\n }\n cout<<num.size()<<\"\\n\";\n    for(auto i=0; i<num.size(); i++){\n      cout<<num[i]<<\" \";\n  }\n \n  return 0;\n}\n"
    },
    {
        "titulo": "8057. El autor no se molestó en escribir un título",
        "url": "https://omegaup.com/arena/problem/No-se-molesto-en-escribir-uno/",
        "descripcion": "Te enfadaste de agregarle historias a tus problemas porque nadie los resuelve. Por eso escribiste un problema con la siguiente redacción: Dado un número w y otro número n, decir si para todos los números enteros p y q distintos mayores a 1 y menores o iguales a n se cumple que: w mod p != w mod q.",
        "entrada": "Dos números w y n (1<=w,n<=10^18).",
        "salida": "Imprimir \"Si\" si se cumple la condicion, y \"No\" si existen p y q que no lo cumplan.",
        "nivel": "Intermedio (difícil) - Matemáticas en la programación",
        "categorias": [
            "Tablas de dispersión",
            "Teoría de numeros"
        ],
        "estructuras": [
            "long long",
            "set<long long>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n   cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  long long w, n;\n   cin >> w >> n;\n    if (n > w+1) {\n        cout << \"No\\n\"; \n       return 0;\n }\n set<long long> residuos;\n  for (long long p = 2; p <= n; ++p) {\n      long long residuo = w % p;\n        if (residuos.count(residuo)) {\n            cout << \"No\\n\";\n            return 0;\n     }\n     residuos.insert(residuo);\n }\n cout << \"Si\\n\"; \n\n return 0;\n}\n"
    },
    {
        "titulo": "9411. Suma Números",
        "url": "https://omegaup.com/arena/problem/Suma-Numeros/",
        "descripcion": "Las disputas entre Isaac y Godofredo continúan. Ambos quieren ser reconocidos como los mejores para resolver acertijos matemáticos. Esta rivalidad parecería ya tener siglos, se trata de definir quien es el primero en los cálculos. En esta ocasión Godofredo ha sido retado por Isaac. El reto consiste en sumar los dígitos de los números en una serie definida por dos números enteros hasta que el resultado final tenga solo un dígito. Por ejemplo, la serie definida por los enteros 99 y 103 es la siguiente; 99, 100, 101, 102 y 103. La suma de los dígitos de estos números es (9 + 9) + (1 + 0 + 0) + (1 + 0 + 1) + (1 + 0 + 2) + (1 + 0 + 3) = 28. Sin embargo, 28 aun tiene dos dígitos, por lo que hay que sumarlos de nuevo. La suma es 2 + 8 = 10. Como el resultado aun tiene mas de un dígito, estos se vuelven a sumar. 1 + 0 = 1. Finalmente nos detenemos pues el resultado tiene solamente 1 dígito. Godofredo le ha pedido ayuda a su amigo Alan, que sabe mucho de este tipo de enigmas. Alan le asegura a Godofredo que este problema se puede resolver fácilmente con la ayuda de una computadora. Después de esto Alan se retira, pues tiene que hacer una prueba. Así, que Godofredo necesita tu ayuda para resolver el reto que Isaac le ha puesto.",
        "entrada": "Para ayudarle a Godofredo, es necesario escribir un programa que lea un número entero N (1<=N<=1000), seguido por N pares de números enteros a y b (1<=a<b<=1000), de donde el número leído primero siempre será menor al segundo número.",
        "salida": "Por cada par, indica la suma de los dígitos de la secuencia de números definida por el par, hasta que la cantidad de dígitos en la suma sea solo 1.",
        "nivel": "Intermedio (difícil) - Matemáticas en la programación",
        "categorias": [
            "Teoría de numeros"
        ],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n// Funcion para calcular la suma de los digitos de un n?mero\nint sumaDigitos(int num) {\n    int suma = 0;\n    while (num > 0) {\n        suma += num % 10;\n        num /= 10;\n    }\n    return suma;\n}\n\n// Funcion para calcular la raiz digital (suma de digitos recursiva hasta un solo d?ito)\nint raizDigital(int num) {\n    int resultado = num;\n    while (resultado > 9) {\n        resultado = sumaDigitos(resultado);\n    }\n    return resultado;\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int N;\n    cin >> N;\n    for (int i = 0; i < N; ++i) {\n        int a, b;\n        cin >> a >> b;\n        // Optimizacion: Calculamos la raiz digital de la suma del rango\n        // en lugar de sumar los digitos de cada numero individualmente.\n        int sumaRango = (b * (b + 1) / 2) - (a * (a - 1) / 2);\n        cout << raizDigital(sumaRango) << endl;\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "10344. Coronavirus",
        "url": "https://omegaup.com/arena/problem/Coronavirus/",
        "descripcion": "Ultimamente el coronavirus ha sido un virus con gran efecto alrededor de todo el mundo, el problema con este virus es que no se había encontrada una cura ¡Hasta el día de hoy! Milagrosamente en la Organización de Mundos Intergalacticos (OMI) se ha encontrado una forma de combatir contra tan temible virus. Lo malo es que es un proceso un poco costoso. El coronavirus se ha visto (no efectos de la vida real) que cambia la secuencia de ADN en tu cuerpo, por tanto, la cura que se ha ideado es volver a los genes como estabán antes. Existen dos tipos de genes diremos \"1\" y \"0\". Los genes normalmente están intercalados, es decir, después de un 1 siempre va un 0 y después de un 0 siempre va ir un 1. Esto quiere decir que los genes deben tener la forma ... 0 1 0 1 0 1 ..., entonces el coronavirus afecta esto y cambia unos genes. Se ha creado una maquina que puede hacer 2 operaciones: #1. Intercambiar la posición de dos genes. Es decir, si yo tengo 1 1 0 0; podemos intercambiar el de la ultima posicion con el de la primera para que quede 0 1 0 1. #2. Cambiar un gen completo, es decir, si tenemos 1 1 1; podemos cambiar el gen de en medio por un 0. Como cada vez que la maquina hace una operación genera cierto costo, nosotros queremos minimizar el número de movimientos. Dada una cadena genetica (representado por n números 0 o 1) decir cuál es la minima cantidad necesaria de movimientos para generar una secuencia normal (que después de cada 0 haya un 1 y viceversa).",
        "entrada": "En la primera linea un número n (1<=n<=10^6) que representa el tamaño de la cadena genetica. En la siguiente linea n números separados por un espacio representando la cadena genetica.",
        "salida": "Un único número entero que representa la cantidad mínima de movimientos a realizar.",
        "nivel": "Intermedio (difícil) - Matemáticas en la programación",
        "categorias": [
            "Cálculo matemático"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c=0, d=0, e=0;\n    cin>>a;\n    for(auto i=1; i<=a; i++){\n        cin>>b;\n        if(i%2 && b){\n            c++;\n        }\n        else if(i%2==0 && !b){\n            d++;\n        }\n        e+=b;\n    }\n    if(!(a%2)){\n        if(c+d<=a-c-d){\n            c+=d;\n        }\n        else{\n            c=a-c-d;\n        }\n        cout<<abs(a/2-e)+(c-abs(a/2-e))/2;\n    }\n    else if(c+d<a-c-d){\n        c+=d;\n        cout<<abs(a/2-e)+(c-abs(a/2-e))/2;\n    }\n    else{\n        c=a-c-d;\n        cout<<abs((a/2)+1-e)+(c-abs((a/2)+1-e))/2;\n    }\n    \n    return 0;\n}\n"
    },
    {
        "titulo": "4276. Loggy y la Navidad",
        "url": "https://omegaup.com/arena/problem/Loggy-y-la-Navidad/",
        "descripcion": "Loggy, el castor programador, está muy contento por la llegada de la Navidad en su ciudad. Todos están poniendo sus arboles, y Loggy no es la excepción. El decidió constuir un árbol binario el cuál tendrá su raíz hasta el techo de su casa. Para este problema podemos definir un árbol binario como una colección de nodos conectados entre sí. El nodo que se encuentra más arriba es llamado raíz, cada nodo puede tener 0, 1 o 2 nodos más que cuelgan de él llamados hijos. Los nodos que no tienen hijos son llamadas hojas. Además, cada nodo tiene exactamente un padre, excepto por la raíz que no tiene padre. Loggy compró una caja de L esferas. Las esferas solo las pondrá en las hojas del árbol. El desea que en el árbol que contruya pueda usar todas las esferas para decorar todas las hojas (una esfera por hoja). Sin embargo, Loggy está limitado por la altura de su casa, así que la altura del árbol no puede ser mayor que la altura H de su casa. La altura de un árbol es la cantidad de aristas por las que hay que pasar para ir de la raíz a su hoja más lejana. Además, Loggy quiere que su árbol sea lo más bonito posible y además cumpla la condición de las esferas y las hojas. Un árbol A es más bonito que un árbol B si A tiene más nodos que B. Dada la altura de la casa de Loggy y la cantidad de esferas en la caja que compró, ayudale a saber la cantidad de nodos que tendrá el árbol más bonito que cumpla con la condición de usar todas las esferas en cada una de las hojas y su altura no pase de la altura de la casa de Loggy.",
        "entrada": "En la primera y única línea tendrás 2 enteros : H y L. La altura de la casa de Loggy y el número de esferas en la caja respectivamente.",
        "salida": "Un único entero N que representa la cantidad de nodos que tendrá el árbol más bonito.",
        "nivel": "Intermedio (difícil) - Matemáticas en la programación",
        "categorias": [
            "Cálculo matemático"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long nodosParaHojas(long long H, long long L) {\n    long long hojasActuales = 1;\n    long long nodos = 0;\n    long long altura = -1;\n    while (altura < H && hojasActuales < L) {\n        nodos += hojasActuales;\n        hojasActuales *= 2;\n        altura++;\n    }\n    return nodos+(H-altura)*L;\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long H, L;\n    cin >> H >> L;\n    cout << nodosParaHojas(H, L) << \"\\n\";\n\n    return 0;\n}\n"
    },
    {
        "titulo": "6272. Los libros de Santy 2",
        "url": "https://omegaup.com/arena/problem/Los-libros-de-Santy-2/",
        "descripcion": "Un estudiante especifico tiene muchos libros, los cuales tienen un numero como identificador y todos son distintos, lo malo es que su hermana menor se los desordeno todos. Además mañana ese estudiante entra a la escuela y necesita tener todos sus libros ordenados, al igual que debe tener una forma rápida de buscar aquellos que necesite. Así que decidió hacer un programa que le diga la posición de sus libros después de ordenarlos de menor a mayor. Dado un arreglo de N números no ordenados que representan los libros, decir en que posición se encuentran Q de esos libros después de ser ordenados.",
        "entrada": "Primera linea: N y Q (0<N,Q<=10^4) que representan el numero de libros que hay y los que quiere conocer su posición. Segunda linea: N números A_i (0<=A_i<=10^17) que representa el ID de cada libro. Tercera linea: Q números B_i (Cada B_i pertenece al conjunto A_i) que representa el ID de cada libro que busca.",
        "salida": "Una linea con Q números separados por un espacio representando la posición de cada libro después de ser ordenado; donde el numero 1 responde a B_1 (i responde a B_i) teniendo en cuenta que esta indexado desde 0. Nota: Este estudiante a veces puede ser muy tonto y pedir el mismo libro más de una vez.",
        "nivel": "Intermedio (medio) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Vectores",
            "Ordenamiento",
            "Tablas de dispersión"
        ],
        "estructuras": [
            "int",
            "long long",
            "vector<long long>",
            "unordered_map<long long, int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int N, Q;\n    cin >> N >> Q;\n    vector<long long> libros(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> libros[i];\n    }\n    // Creamos una copia para ordenar y encontrar las posiciones\n    vector<long long> librosOrdenados = libros;\n    sort(librosOrdenados.begin(), librosOrdenados.end());\n    // Guardamos las posiciones en un mapa\n    unordered_map<long long, int> posiciones;\n    for (int i = 0; i < N; ++i) {\n        posiciones[librosOrdenados[i]] = i;\n    }\n    // Buscamos las posiciones de los libros solicitados\n    for (int i = 0; i < Q; ++i) {\n        long long libroBuscado;\n        cin >> libroBuscado;\n        cout << posiciones[libroBuscado] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "1348. Planetas",
        "url": "https://omegaup.com/arena/problem/Planetas/",
        "descripcion": "En una galaxia existen N planetas alineados en una recta. Cada planeta tiene una única posición X_i y ningún par de planetas comparten una posición. Quieres poner un meteorito, pero sabes que los planetas tienen gravedad y ejercen una fuerza sobre el meteorito igual a 1/|X_i-M| donde M es la posicion del meteorito. Tu tarea consiste en decir todos los puntos en los cuales si pones el meteorito, nunca chocará con un planeta. El meteorito no choca si su trayectoria no lo hace ocupar la misma posición que un planeta. Recuerda que la aceleración de un objeto es proporcional a la fuerza neta (es decir, la suma de las fuerzas) sobre él, por lo que el meteorito no chocará si su fuerza neta izquierda difiere por muy poco de su fuerza neta derecha.",
        "entrada": "En la primer línea, N (1<=N<=1000), el número de planetas. En la segunda línea N enteros X_i (-10000<=X_i<=10000) diciendo las coordenadas de los planetas.",
        "salida": "En la primer línea, K, el número de puntos en el cual el meteorito no causa daños a algún planeta. En la siguiente línea K números, las posiciones en los cuales no hace daño, con una precisión de 10^-3 y ordenados de forma creciente.",
        "nivel": "Intermedio (medio) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Vectores",
            "Ordenamiento",
            "Búsqueda binaria"
        ],
        "estructuras": [
            "int",
            "double",
            "vector<int>",
            "vector<double>",
            "fixed",
            "setprecision()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ndouble calcularFuerza(double m, int x) {\n    return 1.0 / abs(x - m);\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int n;\n    cin >> n;\n    vector<int> planetas(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> planetas[i];\n    }\n    sort(planetas.begin(), planetas.end());\n    vector<double> posicionesSeguras;\n    for (int i = 0; i < n - 1; ++i) {\n        double l = planetas[i], r = planetas[i + 1];\n        for (int j = 0; j < 500; ++j) { // B?squeda binaria\n            double m = (l + r) / 2;\n            double fuerzaIzquierda = 0, fuerzaDerecha = 0;\n            for (int k = 0; k <= i; ++k) {\n                fuerzaIzquierda += calcularFuerza(m, planetas[k]);\n            }\n            for (int k = i + 1; k < n; ++k) {\n                fuerzaDerecha += calcularFuerza(m, planetas[k]);\n            }\n            if (abs(r - l) < 1e-6) { // Punto de equilibrio\n                posicionesSeguras.push_back(m);\n                break;\n            } else if (fuerzaIzquierda > fuerzaDerecha) {\n                l = m;\n            } else {\n                r = m;\n            }\n        }\n    }\n    cout << posicionesSeguras.size() << \"\\n\";\n    cout << fixed << setprecision(3);\n    for (double pos : posicionesSeguras) {\n        cout << pos << \" \";\n    }\n    cout << \"\\n\";\n\n    return 0;\n}\n"
    },
    {
        "titulo": "5020. El cuervo y la jarra",
        "url": "https://omegaup.com/arena/problem/El-cuervo-y-la-jarra/",
        "descripcion": "Un cuervo sediento encontró una jarra con un poco de agua, pero no la suficiente como para alcanzar a beberla con su corto pico. En lo que meditaba acerca de su mala fortuna, el cuervo comenzó a caminar y encontró un camino de piedritas. Al cuervo entonces se le ocurrió un plan: elegirá una piedrita del camino y empezará a meter ésta y todas las piedritas de adelante dentro la jarra, una tras otra, hasta lograr que el agua suba lo suficiente para poder alcanzarla con su pico. No todas las piedritas tienen el mismo volumen: las más grandes contribuyen más a subir el nivel del agua. Si el cuervo comienza tirando la piedrita K y necesita que las piedritas a meter en la jarra sumen un volumen mínimo de V, ¿cuál es la última piedrita que necesita tirar?",
        "entrada": "Un entero N seguido de los N volúmenes P_0,...,P_{n-1} de las piedritas. Posteriormente un entero M seguido de M preguntas descritas por los enteros V, K donde V es el volumen mínimo de piedritas que el cuervo debe tirar dentro de la jarra y K es el índice de la primera piedrita elegida por el cuervo. Puedes suponer que (1<=N<=10^5), (1<=M<=10^5), (1<=P_i<=10^4), (1<=V<=10^9) y (0<=K<N).",
        "salida": "Para cada pregunta, el menor índice (J<N) tal que P_K+P_(K+1)+...+P_J>=V. En caso de que no exista tal índice, imprimir el valor de N.",
        "nivel": "Intermedio (medio) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Vectores",
            "Suma de prefijos",
            "Búsqueda binaria"
        ],
        "estructuras": [
            "long long",
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long a, b, c, d, e, f, g, h, l;\n\nint num[100002];\n\nvoid sub(){\n    if(c>num[a]){\n        cout<<a;return;\n    }\n    if(c<=num[d]){\n        cout<<d-1;return;\n    }\n    e=0;\n    f=a;\n    h=0;\n    l=a;\n    while(e<=f){\n        g=(e+f)/2;\n        if(num[g]==c){\n            cout<<g-1;return;\n        }\n        else if(num[g]>c){\n            l=min(l,g);\n            f=g-1;\n        }\n        else{\n            h=max(h,g);\n            e=g+1;\n        }\n    }\n    cout<<l-1;return;\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    cin>>a;\n    for(auto i=1; i<=a; i++){\n        cin>>num[i];\n        num[i]+=num[i-1];\n    }\n    cin>>b;\n    while(b--){\n        cin>>c>>d;\n        d++;\n        c+=num[d-1];\n        sub();\n        cout<<\"\\n\";\n    }\n    \n    return 0;\n}\n"
    },
    {
        "titulo": "16556. Fábrica de Globos",
        "url": "https://omegaup.com/arena/problem/Fabrica-de-Globos/",
        "descripcion": "Tienen una maquina la cual pone el precio a las bolsas, pero últimamente ha estado fallando y esto ocasiona que, la máquina, aumente o disminuya el precio de cada una. Desafortunadamente aún no encuentran la falla de la máquina, pero saben los cambios que realizará. Hay N bolsas, las cuales están en una fila horizontal numeradas de 1 al N. La máquina hará P cambios en el precio, uno después de otro, los cuales se identifican por los siguientes datos: Un carácter C que puede ser A o D, que indica si Aumentó o Disminuyó el precio. Dos números: X y Y. Representan que, de la bolsa X a la Y, la máquina cambió su precio (1<=X<=Y<=N). Un número G, el número que sumó o restó al precio de cada bolsa (1<=G<=10^9).",
        "entrada": "En la primera línea dos números N y K. El número de bolsas que hay y el precio mínimo que cada bolsa debe tener. En la segunda línea un número P. La cantidad de cambios en los precios que realizó la máquina. Las siguientes P lineas contienen un carácter C y tres números: X, Y y G. Corresponden a los datos de la operación de la máquina.",
        "salida": "Una única línea que contenga un entero: La cantidad de bolsas cuyo precio es menor a K pesos.",
        "nivel": "Intermedio (medio) - Análisis y diseño de algoritmos",
        "categorias": [
            "Vectores",
            "Suma de prefijos"
        ],
        "estructuras": [
            "char",
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint main(){\n   ios::sync_with_stdio(false);\n  cin.tie(0),cout.tie(0);\n   ll n, m, a, b, c, d, e=0, f=0, g, h;\n  vector<ll>ar(100002,0);\n   cin>>n>>m>>a;\n char x;\n   while(a--){\n       cin>>x>>b>>c>>d;\n      if(x=='D'){\n           d*=-1;\n        }\n     ar[b]+=d;\n     ar[c+1]-=d;\n   }\n n++;\n  for(auto i=1; i<n; i++){\n      e+=ar[i];\n     if(e<m){\n          f++;\n      }\n }\n cout<<f;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "19589. Buscando Pokemones",
        "url": "https://omegaup.com/arena/problem/Buscando-Pokemones/",
        "descripcion": "Ash es el entrenador Pokémon más reconocido de toda la historia. Pero no todo entrenador Pokémon reconocido puede superar el desafío que tenga delante. Actualmente, Ash se encuentra frente a una hilera de N arbustos. El arbusto i contiene al Pokémon x_i, representado por una letra del alfabeto inglés, y desde el arbusto i te puedes mover al i+1 y al i-1, excepto en los extremos para los cuales ya no hay más arbustos. Una vez que entras en un arbusto, debes moverte a lo largo de la hilera y al salir no puedes volver a entrar de nuevo. Ash quiere saber cuál es la menor cantidad de movimientos que debe hacer para atrapar la mayor cantidad de Pokémon distintos posible.",
        "entrada": "Se te dará un número 1<=N<=10^5 indicando la cantidad de arbustos en la hilera, en la siguiente línea se te dará una cadena de caracteres de tamaño N representando los Pokémon que hay en cada arbusto.",
        "salida": "Deberás imprimir la cantidad mínima de movimientos que Ash debe realizar dentro de los arbustos para alcanzar el objetivo.",
        "nivel": "Intermedio (medio) - Análisis y diseño de algoritmos",
        "categorias": [
            "Caracteres y cadenas",
            "Tablas de dispersión",
            "Ventana deslizante"
        ],
        "estructuras": [
            "int",
            "char",
            "string",
            "set<char>",
            "map<char,int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    ios::sync_with_stdio(0);\n  cin.tie(0);\n   cout.tie(0);\n  int n, m, a, b, c, d, e, f, g, h;\n vector<char>ar(100000);\n   unordered_set<char>ar2;\n   unordered_map<char,int>ar3;\n   cin>>n;\n   for(auto i=0; i<n; i++){\n      cin>>ar[i];\n       ar2.insert(ar[i]);\n        ar3[ar[i]]=0;\n }\n a=ar2.size();\n ar2.clear();\n  c=0;\n  while(ar2.size()<a){\n      ar2.insert(ar[c]);\n        ar3[ar[c]]++;\n     c++;\n  }\n d=0;\n  while(ar3[ar[d]]>1){\n      ar3[ar[d]]--;\n     d++;\n  }\n b=c-d;\n    for(; c<n;){\n      ar3[ar[c]]++;\n     c++;\n      while(ar3[ar[d]]>1){\n          ar3[ar[d]]--;\n         d++;\n      }\n     b=min(b,c-d);\n }\n cout<<b;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "7734. Dándole fuerza a los Vengadores",
        "url": "https://omegaup.com/arena/problem/Fuerza-a-los-Vengadores/",
        "descripcion": "La batalla entre ambos equipos (vengadores y enemigos) esta balanceada en cuanto integrantes. Ambos tienen N miembros en su equipo y cada miembro cuenta con una fuerza F_i. Para saber que equipo va ganar se calculan los Puntos de victoria. Los puntos de victoria que tiene cada equipo se calcula de la siguiente forma: tomas a cada miembro de los vengadores A_i (1<=i<=N) y comparas la fuerza de todos contra cada uno de los integrantes del equipo de Thanos T_j (1<=j<=N). Si la fuerza del vengador es mayor, los vengadores ganan un punto, si es igual nadie recibe punto y si es menor el equipo de Thanos recibe un punto. Haces la comparación para cada posible par de A_i y T_j para obtener los puntos en total. Si el equipo de los vengares tiene más puntos significa que ellos ganan, si esto sucede debes imprimir \"Avengers\" y por cuantos puntos ganan. De lo contrario significa que Felipe debe actuar para darle más puntos de victoria a los vengadores, así que debes imprimir \"Thanos\" y un número indicando el mínimo número de puntos que necesitan los vengadores para ganarle al equipo de Thanos.",
        "entrada": "Un único número entero N que el indica el número de integrantes que tiene cada equipos. En la siguiente linea N números enteros positivos separados por un espacio representando la fuerza de cada integrante de los vengadores. En la siguiente linea N números enteros positivos separados por un espacio representando la fuerza de cada integrante del grupo de Thanos",
        "salida": "Una palabra \"Thanos\" o \"Avengers\" dependiendo de quien gane. En otra linea un entero S representando lo dicho en el problema.",
        "nivel": "Intermedio (medio) - Análisis y diseño de algoritmos",
        "categorias": [
            "Vectores",
            "Ordenamiento",
            "Técnica de dos apuntadores"
        ],
        "estructuras": [
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    ios::sync_with_stdio(0);\n  cin.tie(0);\n   cout.tie(0);\n  int n, m, a=0, b=0, c, d, e, f, g, h;\n    vector<int>ar(500001), ar2(500001);\n   cin>>n;\n   for(auto i=0; i<n; i++){\n      cin>>ar[i];\n   }\n for(auto i=0; i<n; i++){\n      cin>>ar2[i];\n  }\n sort(ar,ar+n);\n    sort(ar2,ar2+n);\n  ar2[n]=100000001;\n ar[n]=100000001;\n  for(auto i=0; i<n;){\n      d=ar[i];\n      e=i+1;\n        while(ar[e]==d){\n          e++;\n      }\n     while(ar2[a]<d){\n          a++;\n      }\n     b+=a*(e-i);\n       while(ar2[a]==d){\n         a++;\n      }\n     b-=(n-a)*(e-i);\n       i=e;\n  }\n if(b>0){\n      cout<<\"Avengers\\n\"<<b;\n }\n else{\n     cout<<\"Thanos\\n\"<<-b+1;\n    }\n\n   return 0;\n}\n"
    },
    {
        "titulo": "13000. Pareja que suma K",
        "url": "https://omegaup.com/arena/problem/SumaParejaK/",
        "descripcion": "Dado un arreglo de tamaño N, con elementos a_1,...,a_n decir si existe un pareja (a_i,a_j) tal que a_i+a_j=k para k dado y además i!=j.",
        "entrada": "El número N, la cantidad de elementos del arreglo. Los elementos a_1,...,a_n en la siguiente linea. Y después el número k que se quiere formar.",
        "salida": "En caso de existir la suma, sacar la pareja (a_i,a_j) tal que min(a_i,a_j) sea lo menor posible. Deberás imprimir la pareja de menor a mayor. En caso de que no exista imprimir (0,0).",
        "nivel": "Intermedio (medio) - Análisis y diseño de algoritmos",
        "categorias": [
            "Vectores",
            "Ordenamiento",
            "Técnica de dos apuntadores"
        ],
        "estructuras": [
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint main(){\n   ios::sync_with_stdio(0);\n  cin.tie(0);\n   cout.tie(0);\n  ll n, m, a=0, b, c, d, e, f, g, h;\n    vector<ll>ar(1000000,0);\n  cin>>n;\n   for(auto i=0; i<n; i++){\n      cin>>ar[i];\n   }\n cin>>m;\n   sort(ar,ar+n);\n    b=n-1;\n    while(a<b){\n       c=ar[a]+ar[b];\n        if(c==m){\n         cout<<ar[a]<<\" \"<<ar[b];break;\n      }\n     else if(c>m){\n         b--;\n      }\n     else{\n         a++;\n      }\n }\n if(a>=b){\n     cout<<\"0 0\";\n    }\n\n   return 0;\n}\n"
    },
    {
        "titulo": "11838. Feria de negocios",
        "url": "https://omegaup.com/arena/problem/OMI-CDMX-EDOMEX-2020-Negocios/",
        "descripcion": "N personas se encuentran en una feria de N negocios. La i-ésima persona está inicialmente en el i-ésimo puesto. Inicialmente, cada persona cuenta con una cantidad de dinero para invertir de C_i pesos. En cada puesto se puede invertir desde 1 hasta P_i pesos. Las personas en la feria no son expertas en finanzas y su estrategia es la siguiente: En cada puesto invierten tanto dinero como puedan, es decir, el mínimo entre el dinero que les quede y el máximo permitido (P_i) de ese puesto. Luego de invertir en un puesto, avanzan al puesto siguiente. Si ya no hay más puestos o si se les acaba el dinero, se retiran de la feria. Tu tarea es contestar la siguiente pregunta: ¿cuánto dinero recolectó cada puesto?",
        "entrada": "En la primera línea un entero N, el número de personas y puestos en la feria. En la segunda línea N enteros C_1,C_2,C_3,...,C_N, el dinero inicial de la i-ésima persona. En la tercera línea N enteros P_1,P_2,P_3,...,P_N, el precio de la acción del i-ésimo negocio.",
        "salida": "Una sola línea con N enteros, donde el i-ésimo entero representa la cantidad de dinero que recolectó el i-ésimo negocio.",
        "nivel": "Intermedio (medio) - Análisis y diseño de algoritmos",
        "categorias": [
            "Vectores",
            "Suma de prefijos",
            "Búsqueda binaria"
        ],
        "estructuras": [
            "long long",
            "vector<long long>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef struct{\n    long long aa, bb, cc, dd, ee;\n}sobra;\nlong long a, b, c, d, e, f, g, h;\nsobra num[100002];\n\nint main(){\n  cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  cin>>a;\n   for(auto i=1; i<=a; ++i){\n      cin>>num[i].aa;\n   }\n for(auto i=1; i<=a; ++i){\n      cin>>num[i].ee;\n       num[i].bb=num[i].ee+num[i-1].bb;\n  }\n for(auto i=1; i<=a; ++i){\n      if(num[a].bb-num[i-1].bb<=num[i].aa){\n         num[i].cc++;\n          num[i].cc+=num[i-1].cc;\n           cout<<num[i].cc*num[i].ee+num[i].dd<<\" \";continue;\n      }\n     if(num[i].aa<num[i].ee){\n          num[i].cc+=num[i-1].cc;\n           cout<<num[i].cc*num[i].ee+num[i].aa+num[i].dd<<\" \";continue;\n        }\n     b=i;\n      c=a;\n      while(b<=c){\n          d=(b+c)/2;\n            if(num[d].bb-num[i-1].bb<=num[i].aa){\n             e=d;\n              b=d+1;\n            }\n         else{\n             c=d-1;\n            }\n     }\n     while(num[e+1].bb-num[i-1].bb<=num[i].aa){\n            e++;\n      }\n     num[i].cc++;\n      num[i].cc+=num[i-1].cc;\n       num[e+1].cc--;\n        num[e+1].dd+=num[i].aa-num[e].bb+num[i-1].bb;\n     //cout<<\"-\"<<num[e+1].dd<<\" \"<<e+1<<\" \"<<num[i].cc<<\"-\\n\";\n       cout<<(num[i].cc*num[i].ee)+num[i].dd<<\" \";\n }\n\n   return 0;\n}\n"
    },
    {
        "titulo": "11840. Trajineras",
        "url": "https://omegaup.com/arena/problem/Trajineras/",
        "descripcion": "Dada la carga máxima L de la trajinera y los pesos a_i de los N integrantes de la familia de Karel en el orden en el que se formaron, debes ayudar a Karel a encontrar el máximo número k tal que cualesquier grupo continuo de k familiares que se elija de la fila no se excederá la capacidad L de la trajinera.",
        "entrada": "En la primera línea dos enteros N y L, que representan la cantidad de robots en la familia de Karel y la carga máxima de las trajineras, respectivamente. En la segunda línea N valores enteros a_i qué representa el peso del i-ésimo robot en la fila.",
        "salida": "Una sola línea con un entero indicando el máximo K tal que ningún grupo de K robots continuos en la fila exceda la carga máxima. Observa que el máximo K puede ser 0.",
        "nivel": "Intermedio (medio) - Análisis y diseño de algoritmos",
        "categorias": [
            "Vectores",
            "Suma de prefijos",
            "Ventana deslizante",
            "Técnica de dos apuntadores"
        ],
        "estructuras": [
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  int a, b, c, d, e, f, g, h;\n   vector<int>num(100002,0);\n cin>>a>>b;\n    for(auto i=1; i<=a; ++i){\n      cin>>num[i];\n      if(num[i]>b){\n         i++;\n          while(i<=a){\n              cin>>num[i];\n              i++;\n          }\n         cout<<0;return 0;\n     }\n     num[i]+=num[i-1];\n }\n if(num[a]<b){\n     cout<<a;return 0;\n }\n c=a-1;\n    d=a-1;\n    while(d<=a){\n      while(num[d]-num[d-c]>b){\n         d--;\n          c--;\n      }\n     while(d<=a && num[d]-num[d-c]<=b){\n            d++;\n      }\n }\n cout<<c;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "11391. Torre 5G",
        "url": "https://omegaup.com/arena/problem/Torre-5G/",
        "descripcion": "La torre 5G se coloca en un posición y tiene un alcance circular, en donde K es el radio del circulo, tu vives en un vecindario muy particular que tiene forma de circunferencia con N casas, cada una tiene n_i personas que viven en ella. Debido a la mala fama que tiene la torre 5G tienes que contratar el servicio en una posicion donde la suma de las personas que viven en las casas que estan dentro del rango de la torre sea la mínima a cualquier otra posición del vecindario porque así reduciras la probabilidad de que las personas se enteren de la existencia de la torre 5G. Tu tarea sera encontrar la posición idónea de la torre con la mínima suma de persona que viven dentro del rango.",
        "entrada": "Dos enteros N y K que son el número de casas del vecindario y el radio de la torre 5G, seguido de N números que representa las personas que viven en la i-ésima casa.",
        "salida": "Un solo entero que representa la suma mínima de personas que viven dentro del rango de la torre 5G.",
        "nivel": "Intermedio (medio) - Análisis y diseño de algoritmos",
        "categorias": [
            "Vectores",
            "Ventana deslizante"
        ],
        "estructuras": [
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  int a, b, c, d, e, f, g, h;\n   vector<int>num;\n   cin>>a>>b;\n    for(auto i=0; i<=b*2; i++){\n        cin>>c;\n       d+=c;\n     num.push_back(c);\n }\n e=d;\n  for(auto i=(b*2)+1; i<a; i++){\n     cin>>c;\n       d+=c-num[i-((b*2)+1)];\n        num.push_back(c);\n     e=min(e,d);\n   }\n for(auto i=a; i<a+b*2; i++){\n       d+=num[i-a]-num[i-((b*2)+1)];\n     e=min(e,d);\n   }\n cout<<e;\n  \n  return 0;\n}\n"
    },
    {
        "titulo": "9532. RooTriangulos",
        "url": "https://omegaup.com/arena/problem/RooTriangulos/",
        "descripcion": "El perímetro de un triángulo con aristas de largo a, b, c es a+b+c. Tienes varios palos de diferentes longitudes. Puedes construir un triángulo con aristas de largo x<=y<=z si y sólo si x+y>z.",
        "entrada": "La primer línea de entrada contendrá el número N (3<=N<=50) de elementos. La segunda línea contendrá los N_i (1<=N_i<=1000) elementos separados por un espacio.",
        "salida": "Regresa el máximo perímetro posible de un triángulo que puede ser construido con los palos que tienes a tus disposición. Cada lado del triángulo debe ser construido usando un sólo palo. Tampoco puedes romper los palos existentes. Regresa -1 si el triángulo no puede ser construido.",
        "nivel": "Intermedio (medio) - Análisis y diseño de algoritmos",
        "categorias": [
            "Vectores",
            "Ordenamiento",
            "Técnica de dos apuntadores"
        ],
        "estructuras": [
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int N;\n    cin >> N;\n    vector<int> palos(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> palos[i];\n    }\n    sort(palos.begin(), palos.end());\n    int maxPerimetro = -1;\n    for (int i = N - 1; i >= 2; --i) {\n        if (palos[i - 1] + palos[i - 2] > palos[i]) {\n            maxPerimetro = palos[i] + palos[i - 1] + palos[i - 2];\n            break; // Encontramos el triangulo valido con mayor perimetro\n        }\n    }\n    cout << maxPerimetro << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "9530. RooPibipollo",
        "url": "https://omegaup.com/arena/problem/RooPibipollo/",
        "descripcion": "Zots es un pequeño niño maya que a diario ayuda a su mama a vender pibipollos, los cuales transporta en su sabucan (morral o bolsa) y solo se le permite meter 2 pibipollos en una sola bolsa ya que sino se aplastan. Desgraciadamente solo tiene un sabucan. Para que dos pibipollos puedan entrar en su sabucan se requiere que la suma de sus longitudes no sea mayor a la longitud de la bolsa, dos o más pibipollos pueden tener la misma longitud. Se te pide que hagas un programa que diga cuantos pares de pibipollos pueden entrar en un determinado sabucan.",
        "entrada": "En la primera línea hay 2 números enteros, el primer número N indica el número de pibipollos que tiene que vender Zots, este número puede ir desde el valor de 2 hasta el valor de 20,000. El segundo número será el tamaño del sabucan, en las siguientes N líneas están las longitudes de los pibipollos. Las longitud de los pibipollos varía de desde 1 hasta 1,000,000. El sabucan siempre medirá menos de 10,000,000.",
        "salida": "Tu programa deberá entregar un solo número entero que contenga la cantidad de parejas de pibipollos que pueden entrar en el sabucan.",
        "nivel": "Intermedio (medio) - Análisis y diseño de algoritmos",
        "categorias": [
            "Vectores",
            "Ordenamiento",
            "Técnica de dos apuntadores"
        ],
        "estructuras": [
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int N, tamanoSabucan;\n    cin >> N >> tamanoSabucan;\n    vector<int> longitudesPibipollos(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> longitudesPibipollos[i];\n    }\n    sort(longitudesPibipollos.begin(), longitudesPibipollos.end());\n    int parejas = 0;\n    int izquierda = 0;\n    int derecha = N - 1;\n    while (izquierda < derecha) {\n        if (longitudesPibipollos[izquierda] + longitudesPibipollos[derecha] <= tamanoSabucan) {\n            parejas += derecha - izquierda; \n            ++izquierda;\n        } else {\n            --derecha;\n        }\n    }\n    cout << parejas << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "314. Xbox Live Points",
        "url": "https://omegaup.com/arena/problem/Xbox-Live-Points/",
        "descripcion": "Con la salida del nuevo Xbox One, la compañía está llevando a cabo una campaña para promocionar el nuevo producto. Para ello quiere obsequiar puntos para Xbox Live de una manera muy peculiar. Primero, se van a elegir al azar N cajas muy bonitas, que en su interior contienen un número anotado en un papelito, ese número indica la cantidad de puntos que te van a regalar si eliges esa caja. Para hacer las cosas más interesantes, te dicen que ese número puede ser tanto positivo, negativo o cero. Pero descuida, te aseguran que si eliges bien, nunca te llevarás puntos en contra. Después, las N cajas van a ser colocadas en una fila y podrás tomar la cantidad de cajas que quieras siempre y cuando sean cajas consecutivas. Luego, te darán la oportunidad de saber de antemano el valor que tienen las cajas para que, un segundo después, tomes las cajas que más te gusten (o que más puntos te den) respetando la restricción. Cada número estará entre -100 y 100. Como buen olímpico, quieres maximizar el número de puntos y para ello vas a escribir un programa que te diga cuál es ese máximo número de puntos que puedes conseguir en esta gran oportunidad. Dados N números, decir cuál es el máximo de puntos que puedes escoger cumpliendo con las condiciones.",
        "entrada": "Línea 1: Un número N (1<=N<=1000000) que representa el número de cajas. Línea 2: N números, donde el i-ésimo número representa los puntos en la caja i (-100<=N_i<=100).",
        "salida": "Línea 1: Un número que diga cuál es la suma máxima de puntos que puedes obtener.",
        "nivel": "Intermedio (medio) - Análisis y diseño de algoritmos",
        "categorias": [
            "Vectores",
            "Programación dinámica"
        ],
        "estructuras": [
            "int",
            "long long",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int N;\n    cin >> N;\n    vector<int> puntos(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> puntos[i];\n    }\n    long long suma_actual = 0;\n    long long suma_maxima = puntos[0];\n    for (int i = 0; i < N; ++i) {\n        suma_actual += puntos[i];\n        suma_maxima = max(suma_maxima, suma_actual);\n        if (suma_actual < 0) {\n            suma_actual = 0;\n        }\n    }\n    cout << suma_maxima << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "1357. Carretera",
        "url": "https://omegaup.com/arena/problem/carretera/",
        "descripcion": "Desde el techo de tu casa puedes ver una larga carretera (de hecho, infinita), con N carros cruzando en ambos sentidos a distintas velocidades. Como tienes un severo problema con las redes sociales, te interesaría tomarle una foto a todos los carros que están cruzando, pero te gustaría poder hacerle la mayor cantidad de zoom. Para ello, estás dispuesto a esperar tanto tiempo sea necesario para que el cuadro que tu fotografía requiere para capturar los N carros sea lo más pequeño posible. Hay suficientes carriles en la carretera para que no choquen nunca los carros al pasarse entre sí.",
        "entrada": "En la primer línea, N (1<=N<=10^5), la cantidad de carros. En las siguientes N líneas, dos enteros, x_i y v_i (|x_i|,|v_i|<=10^5), la posición inicial (en metros) y la velocidad (en metros por segundo) del i-ésimo carro. Los carros no cambian nunca su velocidad. El signo de la velocidad indica la dirección del carro.",
        "salida": "El ancho mínimo posible de una fotografía que cubra a los N carros. Tu respuesta se considerará correcta si tiene un error relativo menor a 10^-6.",
        "nivel": "Intermedio (medio) - Análisis y diseño de algoritmos",
        "categorias": [
            "Vectores",
            "Búsqueda binaria"
        ],
        "estructuras": [
            "int",
            "double",
            "vector<struct>",
            "fixed",
            "setprecision()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Car {\n    double x, v;\n};\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int N;\n    cin >> N;\n    vector<Car> cars(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> cars[i].x >> cars[i].v;\n    }\n    auto get_width = [&](double time) {\n        double min_pos = 1e9, max_pos = -1e9;\n        for (int i = 0; i < N; ++i) {\n            double pos = cars[i].x + cars[i].v * time;\n            min_pos = min(min_pos, pos);\n            max_pos = max(max_pos, pos);\n        }\n        return max_pos - min_pos;\n    };\n    double left = 0, right = 1e5; // Rango inicial de tiempo\n    double eps = 1e-9; // Precisi? deseada\n    while (right - left > eps) {\n        double mid = (left + right) / 2;\n        if (get_width(mid) < get_width(mid + eps)) {\n            right = mid;\n        } else {\n            left = mid;\n        }\n    }\n    cout << fixed << setprecision(7) << get_width(left) << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "8524. Exponenciación con multiplicaciones y divisiones",
        "url": "https://omegaup.com/arena/problem/Exponenciacion-con-multiplicacio/",
        "descripcion": "Escribe un programa que calcule en cuántos pasos puedes calcular la potencia entera A^B, si comienzas en X=1 y sólo tienes disponibles las siguientes tres operaciones: multiplicar X por A, dividir X entre A y elevar X al cuadrado. En los tres casos, el antiguo valor de X se pierde y sólo puede usarse el nuevo valor.",
        "entrada": "Un entero B. Puedes suponer que 0<=B<=20.",
        "salida": "La menor cantidad de pasos que necesitas para calcular A^B según lo descrito.",
        "nivel": "Intermedio (medio) - Análisis y diseño de algoritmos",
        "categorias": [
            "Vectores",
            "Cálculo matemático",
            "Búsqueda en amplitud"
        ],
        "estructuras": [
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint calcularPasos(int b) {\n    vector<int> dp(b + 1, INT_MAX);\n    dp[0] = 0; \n    dp[1] = 1; \n    for (int i = 2; i <= b; ++i) {\n        dp[i] = min(dp[i], dp[i - 1] + 1); // Multiplicar por A\n        if (i % 2 == 0) {\n            dp[i] = min(dp[i], dp[i / 2] + 1); // Elevar al cuadrado\n        }\n        if (i % 3 == 0) {\n            dp[i] = min(dp[i], dp[i / 3] + 2); // Dividir entre A y elevar al cuadrado \n        }\n    }\n    return dp[b];\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int b;\n    cin >> b;\n    cout << calcularPasos(b) << endl;\n\n    return 0;\n"
    },
    {
        "titulo": "19593. A Más B",
        "url": "https://omegaup.com/arena/problem/A-Mas-B-big/",
        "descripcion": "Dar la respuesta de la suma de dos numeros A+B.",
        "entrada": "Dos numeros enteros A y B (1<=A,B<=10^10^5).",
        "salida": "Un entero que sea la respuesta a A+B.",
        "nivel": "Intermedio (medio) - Matemáticas en la programación",
        "categorias": [
            "Caracteres y cadenas",
            "Números grandes"
        ],
        "estructuras": [
            "int",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    ios::sync_with_stdio(0);\n  cin.tie(0);\n   cout.tie(0);\n  int n, m, a, b, c, d, e, f, g, h;\n vector<char>ar(100005);\n   string s,r;\n   cin>>s>>r;\n    c=0;\n  d=0;\n  for(a=s.size()-1, b=r.size()-1; (a>-1 && b>-1); a--, b--){\n        ar[c]=((int)s[a]+(int)r[b]+(int)d-96)%10+48;\n      d=((int)s[a]+(int)r[b]+(int)d-96)/10;\n     c++;\n  }\n while(a>-1){\n      ar[c]=((int)s[a]+d-48)%10+48;\n     d=((int)s[a]+d-48)/10;\n        a--;\n      c++;\n  }\n while(b>-1){\n      ar[c]=((int)r[b]+d-48)%10+48;\n     d=((int)r[b]+d-48)/10;\n        b--;\n      c++;\n  }\n if(d){\n        cout<<d;\n  }\n while(--c>-1){\n        cout<<ar[c];\n  }\n\n   return 0;\n}\n"
    },
    {
        "titulo": "10823. Atsa y el torneo de programación",
        "url": "https://omegaup.com/arena/problem/atsa-copa-fut/",
        "descripcion": "Una persona quiere organizar una copa individual de programación. En el torneo participarán N personas, que competirán en eventos 1 vs 1, de tal forma que al final cada competidor se habrá enfrentado con todos los demás. Todos los encuentros serán mostrados en transmisiones en vivo. La persona quiere saber que tanto alcance tendrán todas las transmisiones. Debido a que algunos competidores son más populares que otros sus encuentros tendrán más alcance. Se tiene un registro del nivel de popularidad de cada concursante. El nivel del concursante i se puede expresar como un valor P_i. El encuentro entre los concursantes a y b tendrá un alcance P_a*P_b. Formalmente, la persona quiere calcular [sum_{i=1}^{N}[sum_{j=i+1}^{N}P_i*P_j]].",
        "entrada": "La primera línea contiene N (1<=N<=10^5). La segunda línea contiene los N valores de P_i (1<=P_i<=10^3).",
        "salida": "Una sola linea con el alcance total.",
        "nivel": "Intermedio (medio) - Matemáticas en la programación",
        "categorias": [
            "Vectores",
            "Cálculo matemático"
        ],
        "estructuras": [
            "long long",
            "vector<long long>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n   cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  int N;\n    cin >> N;\n vector<long long> P(N);\n   for (int i = 0; i < N; ++i) {\n     cin >> P[i];\n  }\n long long alcance_total = 0;\n  long long suma_actual = 0;\n    // Optimizacion: Calculamos la suma en tiempo O(N)\n for (int i = N - 1; i >= 0; --i) {\n        alcance_total += P[i] * suma_actual;\n      suma_actual += P[i];\n  }\n cout << alcance_total << endl;\n\n  return 0;\n}\n"
    },
    {
        "titulo": "6532. Karel y los quebrados",
        "url": "https://omegaup.com/arena/problem/Karel-y-los-quebrados/",
        "descripcion": "Karel sabe que para cada fracción 1/k (k>0) siempre puede encontrar dos enteros positivos \"x\" \"y\" tales que: 1/k=1/x+1/y. A Karel le interesa mucho los quebrados, por lo que te ha pedido que para un numero k le ayudes a encontrar cuantos pares de números enteros \"x\" y \"y\" existen que cumplan con lo anterior.",
        "entrada": "Un único número entero k (0<k<=10^4).",
        "salida": "En la primera linea de salida un numero n que representa la cantidad de pares (x,y), En la segunda linea una lista ordenada de los valores (x,y).",
        "nivel": "Intermedio (medio) - Matemáticas en la programación",
        "categorias": [
            "Teoría de numeros"
        ],
        "estructuras": [
            "int",
            "vector<pair<int,int>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n   cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  int k;\n    cin >> k;\n vector<pair<int, int>> soluciones;\n    // Para encontrar las soluciones (x, y) de la ecuacion 1/k = 1/x + 1/y,\n    // podemos despejar y obteniendo: y = k*x / (x-k)\n // Iteramos sobre los posibles valores de x, desde k+1 hasta 2k.\n  // Este rango se elige para asegurar que x > k y que y sea positivo.\n  for (int x = k + 1; x <= 2 * k; ++x) {\n        // Verificamos si y es un entero positivo\n     if (k * x % (x - k) == 0 && k * x / (x - k) > 0) {\n            int y = k * x / (x - k);\n          soluciones.push_back({y,x});\n      }\n }\n // Imprimimos la cantidad de soluciones encontradas\n   cout << soluciones.size() << endl;\n    // Imprimimos las soluciones (x, y) en el formato especificado\n    for (auto& sol : soluciones) {\n        cout << \"1/\" << k << \" = 1/\" << sol.first << \" + 1/\" << sol.second << endl;\n }\n\n   return 0;\n}\n"
    },
    {
        "titulo": "7813. DCM Euclides",
        "url": "https://omegaup.com/arena/problem/DCM-Euclides/",
        "descripcion": "Escribe un programa que calcule el divisor común máximo de dos enteros.",
        "entrada": "Una línea con 2 enteros a y b separados por un espacio (1<=a,b<=10^7).",
        "salida": "Un entero: el divisor común máximo de los enteros.",
        "nivel": "Intermedio (medio) - Matemáticas en la programación",
        "categorias": [
            "Teoría de numeros"
        ],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int a, b;\n    cin >> a >> b;\n    // Implementaci? del algoritmo de Euclides\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    cout << a << endl; \n\n    return 0;\n}\n"
    },
    {
        "titulo": "2817. Agente A, El Héroe Nacional",
        "url": "https://omegaup.com/arena/problem/Agente-A-El-Heroe-Nacional/",
        "descripcion": "El Agente A está en una misión secreta y ha conseguido robar el arma secreta enemiga, si consigue desactivarla será un héroe nacional, sin embargo, ha sido descubierto, y ahora el malvado Doctor B y su ejército lo están buscando para \"encargarse\" de él, el Agente A se ha visto rodeado y sabe que su fin está cerca, sabe que en exactamente t minutos antes de que el Doctor B y su ejército lleguen hasta él, el arma secreta del Doctor B tiene un elaborado sistema de seguridad, el arma cuenta con N filtros de seguridad, en cada filtro de seguridad, se muestran inicialmente en una pantalla 2 números: a_inicial y b_inicial; la labor de inteligencia del Agente A le ha permitido saber que en cada filtro de seguridad debe volver a los 2 números 0 mediante algunos movimientos válidos, el arma no le permite realizar movimientos inválidos, un movimiento válido consiste en: #1. A los números en la pantalla (a_actual y b_actual) restarles un divisor que tengan en común esos números (los que se muestran en la pantalla en ese momento) y que a su vez divida a a_inicial o a b_inicial (los números iniciales que se mostraron en la pantalla). #2. Si alguno de los números actuales en la pantalla es 0 volver 0 al otro.; Una vez que hace un movimiento válido debe esperar 1 minuto para poder hacer otro, por esto el agente tomó su cronómetro y lo inicio en t, el agente A sólo puede hacer un movimiento si el cronómetro no ha llegado a 0. Ayúdale al Agente A a convertirse en héroe nacional.",
        "entrada": "En la primera línea el número N (1<=N<=100000) el número de filtros de seguridad. En la siguiente línea el número t (1<=t<=2^63) la cantidad de tiempo que el Agente A tiene antes de que el Doctor B se \"encargue\" de él. En las siguientes N líneas 2 números a y b (1<=a,b<=1000000) describiendo un filtro de seguridad.",
        "salida": "Si no puede superar los N filtros de seguridad antes de que el Doctor B le atrape imprime: \"El Agente A no sera heroe nacional, el Doctor B destruira su pais\". En caso contrario imprime 1 número: La mínima cantidad de tiempo que le toma al Agente A desactivar el arma.",
        "nivel": "Intermedio (medio) - Matemáticas en la programación",
        "categorias": [
            "Cálculo matemático"
        ],
        "estructuras": [
            "long long",
            "__gcd()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e, f=0;\n    cin>>c>>e;\n    while(c--){\n        cin>>a>>b;\n        d=__gcd(a,b);\n        if(d==1){\n            f+=min(a,b)+1;continue;\n        }\n        while(a && b){\n            a-=d;\n            b-=d;\n            f++;\n            if((!b && a) || (!a && b)){\n                f++;break;\n            }\n        }\n        if(f-1>e){\n            cout<<\"El Agente A no sera heroe nacional, el Doctor B destruira su pais\";return 0;\n        }\n    }\n    if(f-1>e)cout<<\"El Agente A no sera heroe nacional, el Doctor B destruira su pais\";\n    else cout<<f-1;\n    \n    return 0;\n}\n"
    },
    {
        "titulo": "6354. La Risa en Vacaciones 2",
        "url": "https://omegaup.com/arena/problem/La-Risa-en-Vacaciones-2/",
        "descripcion": "Existen 30 ciudades, numeradas del 0 al 29. Estás a punto de salir de vacaciones, en las cuales visitarás una o más de éstas ciudades. En el trabajo te estan preguntando constantemente que ciudades visitarás, pero tu no quieres decirles, para que no te vayan a encontrar y a molestar con asuntos de trabajo durante tus vacaciones. Pero tampoco eres buena para decir mentiras. Para lidiar con este problema has ideado una forma de codificar tu itinerario para tus vacaciones que consiste en representar las ciudades como bits en un número binario. Si visitas la ciudad k, entonces el bit k tendrá un 1, sino tendrá un 0. Por ejemplo, si visitas las ciudades 2 y 3, esto equivale al número 1100, que representa el número 12. Entonces si alguién te pregunta que ciudades visitaras, tu dices 12. La otra persona no sabrá de que estas hablando y dejará de molestarte. Y a su vez tu estarás diciendo la verdad, así que tu alma puede estar tranquila. Escribe un programa que dadas las ciudades que visitarás en tus vacaciones, imprima un número indicando el itinerario codificado.",
        "entrada": "Un número n (0<=n<=30), indicando la cantidad de ciudades que visitarás. Le siguen n líneas indicando cada una de las ciudades que visitarás.",
        "salida": "Un sólo número indicando el itinerario codificado.",
        "nivel": "Intermedio (fácil) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Manipulación de bits"
        ],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int n, itinerario = 0;\n    cin >> n;\n    for(auto i = 0; i < n; ++i){\n        int ciudad;\n        cin >> ciudad;\n        itinerario |= (1 << ciudad); \n    }\n    cout << itinerario << \"\\n\";\n\n    return 0;\n}\n"
    },
    {
        "titulo": "6355. La Risa en Vacaciones 3",
        "url": "https://omegaup.com/arena/problem/La-Risa-en-Vacaciones-3/",
        "descripcion": "Existen 30 ciudades, numeradas del 0 al 29. Estás a punto de salir de vacaciones, en las cuales visitarás una o más de éstas ciudades. En el trabajo te estan preguntando constantemente que ciudades visitarás, pero tu no quieres decirles, para que no te vayan a encontrar y a molestar con asuntos de trabajo durante tus vacaciones. Para lidiar con este problema has ideado una forma de codificar tu itinerario para tus vacaciones que consiste en representar las ciudades como bits en un número binario. Si visitas la ciudad k, entonces el bit k tendrá un 1, sino tendrá un 0. Por ejemplo, si visitas las ciudades 2 y 3, esto equivale al número 1100, que representa el número 12. Entonces si alguién te pregunta que ciudades visitaras, tu dices 12. Otra cosa importante es que dado que eres muy original y siempre quieres ser diferente a los demás, sólo visitarás ciudades que NO hayan sido visitadas por ninguno de tus amigos anteriormente. Dados los itinierarios codificados de tus amigos, escribe un programa que indique las ciudades que visitarás en las vacaciones.",
        "entrada": "Un número n (0<=n<=10), indicando la cantidad de amigos que te dijeron sus itinerarios de viajes previos. Le siguen n líneas con los itinerarios codificados de tus amigos.",
        "salida": "Las ciudades que visitarás en las vacaciones, en orden ascendente y en líneas separadas. Si NO hay ciudades que visitar, imprimir el mensaje ''Sin vacaciones''.",
        "nivel": "Intermedio (fácil) - Estructuras de datos y Algoritmos: 2",
        "categorias": [
            "Manipulación de bits"
        ],
        "estructuras": [
            "bool",
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int n;\n    cin >> n;\n    // Se utiliza un entero para almacenar los itinerarios de todos los amigos, \n    // ya que 2^30 es menor al l?ite de un entero (int).\n    int itinerarios_amigos = 0;\n    for (int i = 0; i < n; ++i) {\n        int itinerario_amigo;\n        cin >> itinerario_amigo;\n        itinerarios_amigos |= itinerario_amigo; // Combinar los itinerarios\n    }\n    // Iterar sobre cada ciudad (bit)\n    bool sin_vacaciones = true;\n    for (int ciudad = 0; ciudad < 30; ++ciudad) {\n        // Verificar si la ciudad (bit) NO est? en los itinerarios de los amigos\n        if (!(itinerarios_amigos & (1 << ciudad))) {\n            cout << ciudad << \"\\n\";\n            sin_vacaciones = false;\n        }\n    }\n    if (sin_vacaciones) {\n        cout << \"Sin vacaciones\\n\";\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "6353. La Risa en Vacaciones",
        "url": "https://omegaup.com/arena/problem/La-Risa-en-Vacaciones/",
        "descripcion": "Existen n ciudades, numeradas del 0 al n-1. Estás a punto de salir de vacaciones, en las cuales visitarás una o más de éstas ciudades. En el trabajo te estan preguntando constantemente que ciudades visitarás, pero tu no quieres decirles, para que no te vayan a encontrar y a molestar con asuntos de trabajo durante tus vacaciones. Pero tampoco eres buena para decir mentiras. Para lidiar con este problema has ideado una forma de codificar tu itinerario para tus vacaciones que consiste en representar las ciudades como bits en un número binario. Si visitas la ciudad k, entonces el bit k tendrá un 1, sino tendrá un 0. Por ejemplo, si visitas las ciudades 2 y 3, esto equivale al número 1100, que representa el número 12. Entonces si alguién te pregunta que ciudades visitaras, tu dices 12. La otra persona no sabrá de que estas hablando y dejará de molestarte. Y a su vez tu estarás diciendo la verdad, así que tu alma puede estar tranquila. Escribe un programa que dado el itinerario codificado, imprima las ciudades que visitarás en tus vacaciones.",
        "entrada": "Un número k (0<=k<=2^30), indicando tu itinierario codificado.",
        "salida": "Las ciudades que visitarás durante tus vacaciones, cada una en una línea por separado y en orden ascendente. Si no visitarás ninguna ciudad, imprimir el mensaje ''No hay risas sin vacaciones >(''.",
        "nivel": "Intermedio (fácil) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Manipulación de bits"
        ],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int k;\n    cin >> k;\n    if (k==0){\n        cout << \"No hay risas sin vacaciones >('\\n\";\n        return 0;\n    }\n    for (int i=0; i<30; i++){\n        if ((1<<i) & k){\n            cout << i << \"\\n\";\n        }\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "1254. Tirando Tortillas",
        "url": "https://omegaup.com/arena/problem/Tirando-Tortillas/",
        "descripcion": "En cierta ciudad extraña, cierta tortillería extraña tiene muchas costumbres raras en su forma de funcionar. Una de estas costumbres es atender de una manera extraña, esto sucede así: Llega la primera persona que atenderá pidiendo x tortillas y sacan de la maquina de tortillas x tortillas, ahora pueden pasar 2 cosas: Llega otra persona y se pone delante de la que ya estaba y hace su pedido. Si el pedido es más grande que el anterior entonces solo sacan más tortillas pero si es menor entonces tiran las tortillas que sobran y vuelve a suscitarse alguno de estos 2 casos. Entregan las tortillas, la persona se va y vuelven a sacar x tortillas que es el pedido de la persona que estaba atrás de la que se acaba de ir (En caso de que todavía haya persona). El jefe de la tortillería esta muy ocupado atendiendo su carnicería, por eso te ha pedido que a partir de lo que sucedió en un día digas cuantas tortillas se tiraron.",
        "entrada": "En la primera línea N, que es el número de cosas que pasaron en un día (N siempre es par). De la línea N a la N+1 pueden haber uno de estos dos: Una letra ‘C’ seguido de un número x ,que significa que llegó una persona pidiendo x tortillas y que la tortillería saca x tortillas. Si ya había sacado anteriormente tortillas pasa lo que se explica en la descripción. Una letra ‘G’, que significa que se entregan las tortillas, la persona se va y ahora se atiende a la de atrás.",
        "salida": "El número de tortillas tiradas.",
        "nivel": "Intermedio (fácil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Caracteres y cadenas",
            "Pilas"
        ],
        "estructuras": [
            "char",
            "int",
            "stack<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  int a, b, c, d, e, f, g, h;\n   char z;\n   stack<int>num;\n    cin>>a>>z>>b;\n num.push(b);\n  a--;\n  while(a--){\n       cin>>z;\n       if(z=='C'){\n           cin>>b;\n           if(num.size()){\n               c+=max((int)0,num.top()-b);\n           }\n         num.push(b);\n      }\n     else{\n         num.pop();\n        }\n }\n cout<<c;\n  \n  return 0;\n}\n"
    },
    {
        "titulo": "10866. Programador desordenado",
        "url": "https://omegaup.com/arena/problem/Programador-desordenado/",
        "descripcion": "Josué es un programador desordenado ya que al programar declara sus variables con letras del abecedario y no le pone nombres congruentes de acuerdo con el problema que está resolviendo, después de estar un buen rato programando se le olvido cual era la variable que contiene el resultado de su código. Para su buena suerte recuerda que dicha variable es la que más se repite en su código, cada variable tiene asignado un numero diferente, pero Josué no tiene tiempo de buscar esta variable por tanto te pide tu ayuda para encontrar la variable que tiene la respuesta de su código en lo que resuelve más problemas.Dado N números encontrar el número asignado a la variable que más se repite en su código.",
        "entrada": "En la primera línea un entero N, en la segunda línea N (1<=N<=10^6) enteros n_i (1<=n_i<=10^6) que representan los números de las variables.",
        "salida": "Un único entero que representa la variable respuesta de Josué. Se te asegura que no existe otra variable con la misma frecuencia máxima.",
        "nivel": "Intermedio (fácil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Tablas de dispersión"
        ],
        "estructuras": [
            "int",
            "unordered_map<int,int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int N;\n    cin >> N;\n    unordered_map<int, int> frecuencia;\n    int max_frecuencia = 0;\n    int variable_respuesta = 0;\n    for (int i = 0; i < N; ++i) {\n        int variable;\n        cin >> variable;\n        frecuencia[variable]++;\n        if (frecuencia[variable] > max_frecuencia) {\n            max_frecuencia = frecuencia[variable];\n            variable_respuesta = variable;\n        }\n    }\n    cout << variable_respuesta << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "10727. Posicion Fibonacci",
        "url": "https://omegaup.com/arena/problem/Posicion-Fibonacci/",
        "descripcion": "Como ya sabemos la sucesión de fibonacci esta compuesta por los números: 1, 1, 2, 3, 5, 8, 13, 21, 34... Sabiendo esto tu tarea es dado un numero N debes encontrar la posición que ocupa en la sucesión de fibonacci.",
        "entrada": "Un numero N solamente (N<2^64).",
        "salida": "Un único entero que indique en que posición se encuentra el numero en la sucesión. Si el numero no se encuentra en la sucesión imprimir un -1.",
        "nivel": "Intermedio (fácil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Cálculo matemático"
        ],
        "estructuras": [
            "unsigned long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n// Funcion para encontrar la posicion de un numero en la secuencia de Fibonacci\nint encontrarPosicionFibonacci(unsigned long long n) {\n    if (n == 1) return 1; // Caso base: 1 esta en la posicion 1 y 2\n    if (n == 2) return 3; // Caso base: 2 esta en la posicion 3\n    unsigned long long a = 1, b = 1, c = a + b; \n    int posicion = 3; // Empezamos desde la posicion 3\n    // Calculamos la secuencia hasta que superemos o igualemos a 'n'\n    while (c <= n) {\n        if (c == n) {\n            return posicion; // Encontramos la posicion\n        }\n        a = b;\n        b = c;\n        c = a + b;\n        posicion++;\n    }\n    return -1; // 'n' no se encuentra en la secuencia\n}\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    unsigned long long n;\n    cin >> n;\n    cout << encontrarPosicionFibonacci(n) << endl; \n\n    return 0;\n}\n"
    },
    {
        "titulo": "7393. Serie Misteriosa",
        "url": "https://omegaup.com/arena/problem/Serie-Misteriosa/",
        "descripcion": "Pichu es un gato peludo, hermoso y naranjoso. La mayoría del tiempo hace cosas de gato (comer, dormir y eso). Sin embargo, a veces le da por hacer cosas menos interesantes. Un día se metió a ver la oficina de un tipo misterioso. Como el tipo era muy misterioso, tenía un pizarrón misterioso que tenía escrita una serie numérica (por supuesto, muy misteriosa)... La serie solo tenía 6 números escritos: 1, 11, 21, 1211, 111221, 312211, ...; Pichu quería saber cuál era el n-ésimo número de la serie, pero no logró adivinar el patrón de la serie misteriosa. Afortunadamente, hay un humano tratando de resolver problemas en OmegaUp que le va a ayudar... O al menos lo intentará. Escribe un programa que dado un número n determine el n-ésimo número de la serie misteriosa.",
        "entrada": "Un número entero n (n<=30).",
        "salida": "El n-ésimo número de la serie misteriosa.",
        "nivel": "Intermedio (fácil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "int",
            "char",
            "string",
            "to_string()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring serieMisteriosa(int n) {\n    if (n == 1) return \"1\";\n    if (n == 2) return \"11\";\n    string anterior = \"11\";\n    for (int i = 3; i <= n; ++i) {\n        string actual = \"\";\n        int contador = 1;\n        char digitoActual = anterior[0];\n        for (int j = 1; j < anterior.size(); ++j) {\n            if (anterior[j] == digitoActual) {\n                contador++;\n            } else {\n                actual += to_string(contador) + digitoActual;\n                digitoActual = anterior[j];\n                contador = 1;\n            }\n        }\n        actual += to_string(contador) + digitoActual;\n        anterior = actual;\n    }\n    return anterior;\n}\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int n;\n    cin >> n;\n    cout << serieMisteriosa(n) << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "1917. Dígitos volteados",
        "url": "https://omegaup.com/arena/problem/Digitos-Volteados/",
        "descripcion": "Acabas de encontrar una secuencia muy larga de N dígitos 0, 1 y 2, y decidiste comenzar a jugar un juego. En cada turno, comienzas desde la izquierda de la secuencia buscando un dígito 0 seguido de un 1. Si no los encuentras, el turno termina. De lo contrario, si el 0 estaba en una posición par, cambias el 0 y el 1 por dos 0s. En cambio, si estaba en una posición impar, cambias el 1 y el 0 por dos 1s. Con esto termina el turno. ¡Recuerda que comenzamos a contar las posiciones de los arreglos desde 0! Como es un juego muy divertido, decidiste continuar jugándolo durante K turnos. Al terminar de jugar no estabas seguro si seguiste los pasos correctamente, así que decidiste escribir un programa que corrobore la respuesta.",
        "entrada": "En la primera línea dos enteros: N y K. En la segunda línea, N dígitos 0, 1 o 2, separados por espacios. (1<=N<=50000) y (1<=k<=10^9).",
        "salida": "Una línea con los N dígitos después de los turnos.",
        "nivel": "Intermedio (fácil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Vectores",
            "Teoría de juegos"
        ],
        "estructuras": [
            "long long",
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b;\n    int num[50010];\n    cin>>a>>b;\n    for(auto i=0; i<a; i++){\n        cin>>num[i];\n    }\n    for(auto i=0; i<a; i++){\n        if(i%2==0 && num[i]==0 && num[i+1]==1 && num[i+2]==1){\n            if(b%2){\n                num[i+1]=0;\n            }\n            break;\n        }\n        else if(i%2==0 && num[i]==0 && num[i+1]==1){\n            b--;\n            num[i+1]=0;\n            if(b==0){\n                break;\n            }\n        }\n        else if(i%2 && num[i]==0 && num[i+1]==1){\n            if(b%2){\n                num[i]=1;\n            }\n            break;\n        }\n    }\n    for(auto i=0; i<a; i++){\n        cout<<num[i]<<\" \";\n    }\n        \n    return 0;\n}"
    },
    {
        "titulo": "12176. Cuantas veces aparece el numero",
        "url": "https://omegaup.com/arena/problem/Cuantas-veces-aparece-el-numero/",
        "descripcion": "Un gerente de una tienda ha tenido problemas de ventas últimamente por lo que ahora en adelante quiere vender los productos que mas se venden, y tu como buen programador le quieres ayudar a salvar su negocio. El te dará un numero N que representa la cantidad de ventas y un numero M que representa la cantidad mínima de ventas para seguir vendiendo un producto posteriormente N números que representa el ID de cada producto vendido.",
        "entrada": "Un numero N y un numero M seguido de los N números.",
        "salida": "Por cada producto que se haya vendido mas o igual de M veces imprimir el ID del producto seguido del numero de veces que se vendió ordenados por ID.",
        "nivel": "Básico (difícil) - Introducción a la programación",
        "categorias": [
            "Vectores",
            "Tablas de dispersión"
        ],
        "estructuras": [
            "int",
            "map<int,int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e, f, g, h;\n   vector<int>sub;\n  map<int,int>num;\n    cin>>a>>b;\n    while(a--){\n        cin>>c;\n        num[c]++;\n        if(num[c]==b){\n            sub.push_back(c);\n        }\n    }\n    sort(sub.begin(),sub.end());\n    for(auto i=0; i<sub.size(); ++i){\n        cout<<sub[i]<<\" \"<<num[sub[i]]<<\"\\n\";\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "12321. Primos Relativos",
        "url": "https://omegaup.com/arena/problem/Primos-Relativos/",
        "descripcion": "A Óscar se le ha asignado la tarea de revisar una lista de pares de números y determinar cuales de estos pares son primos relativos y cuales no. Como esta tarea es muy tediosa, Óscar te ha pedido ayuda sabiendo que eres un buen programador. Así que Óscar te ha pedido que escribas un programa que haga su tarea. Como él es un gran amigo tuyo, has decidido ayudarlo.",
        "entrada": "Tu programa recibirá como entrada un número, al que llamaremos N, que indica cuantos pares deberás revisar. Después de leer N, tu programa deberá leer cada uno de los N pares.",
        "salida": "Por cada par de números (todos son números enteros) tu programa deberá imprimir una línea de texto con la leyenda \"Primos Relativos\", cuando el par leído corresponda a un par de números coprimos. Si el par de números leídos no son primos, entonces tu programa imprimirá una línea de texto con la leyenda \"No primos\".",
        "nivel": "Básico (difícil) - Introducción a la programación",
        "categorias": [
            "Cálculo matemático"
        ],
        "estructuras": [
            "int",
            "__gcd()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e, f, g, h;\n    cin>>a;\n    while(a--){\n        cin>>b>>c;\n        cout<<((__gcd(b,c)==1)?\"Primos Relativos\\n\":\"No primos\\n\");\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "12276. Analizando y transformando una cadena",
        "url": "https://omegaup.com/arena/problem/Analizando-y-transformando-una-c/",
        "descripcion": "Escribe un programa que lea una línea de texto y que: Calcule la longitud de la línea y la cantidad de espacios que hay en ella. Cambie las letras mayúsculas por minúsculas, y viceversa. Incremente en uno cada dígito de la línea (excepto los dígitos 9, que se quedan como están).",
        "entrada": "Una línea de texto de a lo mucho 50 caracteres de longitud. Puedes suponer que la línea incluye letras, dígitos, espacios sencillos y símbolos de puntuación. El salto de línea no se considera parte de la entrada.",
        "salida": "En la primera línea, dos enteros que correspondan con el tamaño de la línea y la cantidad de espacios que hay en ella, respectivamente. En la segunda línea, la línea después de ser modificada.",
        "nivel": "Básico (difícil) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "int",
            "string",
            "getline()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  long long a=0, b, c, d, e, f, g, h;\n   string z;\n getline(cin,z);\n   cout<<z.size()<<\" \";\n    for(auto i=0; i<z.size(); ++i){\n        if(z[i]>='a' && z[i]<='z'){\n           z[i]-=32;\n     }\n     else if(z[i]>='A' && z[i]<='Z'){\n          z[i]+=32;\n     }\n     else if(z[i]>='0' && z[i]<'9'){\n           z[i]++;\n       }\n     else if(z[i]==' '){\n           a++;\n      }\n }\n cout<<a<<\"\\n\"<<z;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "9565. Cantidad de Divisores",
        "url": "https://omegaup.com/arena/problem/Cantidad-de-factores-primos/",
        "descripcion": "Dados n números enteros, encontrar la cantidad de divisores de cada uno.",
        "entrada": "La entrada empieza con un entero positivo n (1<=n<=10^4), la cantidad de casos. Luego le seguirán n enteros positivos x (1<=x<=10^6).",
        "salida": "Por cada número de la entrada se debe imprimir la cantidad de divisores del número.",
        "nivel": "Básico (difícil) - Introducción a la programación",
        "categorias": [
            "Cálculo matemático"
        ],
        "estructuras": [
            "int",
            "sqrt()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  int a, b, c, d, raiz;\n cin>>a;\n   while(a--){\n           cin>>b;\n           c=0;\n          d=1;\n          raiz=sqrt(b);\n     while(d<raiz){\n            if(b%d==0){\n                   c+=2;\n             }\n             d++;\n          }\n     if(raiz*raiz==b){\n             c++;\n          }\n         cout<<c<<\"\\n\";\n     }\n\n   return 0;\n}\n"
    },
    {
        "titulo": "19751. Contando perimetros",
        "url": "https://omegaup.com/arena/problem/Contando-perimetros/",
        "descripcion": "La universidad no cuenta con mucha iluminación, por eso Santy quiere poner una cinta LED (como la que usan los gamers) alrededor de toda la escuela. Sin embargo, para poder hacer esto, necesita saber cuánto mide el perímetro de la escuela. Por suerte, se tiene un mapa completo de la escuela. Además, la escuela es un área completamente conectada (no tiene huecos en medio). Tu tarea será determinar el perímetro de la escuela. El mapa de la escuela consiste en un rectángulo de N x M donde cada espacio puede o no pertenecer a la estructura de la universidad.",
        "entrada": "Se te darán los enteros 1<=N,M<=1000 que indican las dimensiones del mapa. Luego se te darán enteros a_(i,j)=0,1 que representan el mapa. Un 0 indica que ese espacio no le pertenece a la universidad y un 1 indica que sí. Cada espacio mide 1 unidad de alto y una de ancho.",
        "salida": "Deberás imprimir un entero indicando el perímetro de la universidad.",
        "nivel": "Básico (difícil) - Introducción a la programación",
        "categorias": [
            "Matrices"
        ],
        "estructuras": [
            "int",
            "vector<vector<int>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    ios_base::sync_with_stdio(false);\n cin.tie(0);\n   cout.tie(0);\n  int a, b, c, e, f, g, h, n,m;\n    cin>>n>>m;\n    vector<vector<int>> escuela(n+2,vector<int>(m+2,0));\n    for(auto i = 1; i<=n;i++){\n        for(auto j=1;j<=m;j++){\n            cin>>escuela[i][j];\n        }\n    }\n    int perimetro = 0;\n    for(auto i = 1; i<=n;i++){\n        for(auto j=1;j<=m;j++){\n            if(!escuela[i][j]) continue;\n            if(escuela[i-1][j] == 0){\n                perimetro++;\n            }\n            if(escuela[i+1][j] == 0){\n                perimetro++;\n            }\n            if(escuela[i][j-1] == 0){\n                perimetro++;\n            }\n            if(escuela[i][j+1] == 0){\n                perimetro++;\n            }\n        }\n    }\n    cout<<perimetro;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "19752. Diversión Bibliotecaria",
        "url": "https://omegaup.com/arena/problem/Diversion-Bibliotecaria/",
        "descripcion": "El Instituto Central del Pensamiento Creativo no es la universidad más seria de todas, por así decirlo. Un ejemplo de esto es su sistema bibliotecario; toda la universidad se rehúsa a ordenar los libros alfabéticamente, porque eso es muy aburrido. Sin embargo, a falta de creatividad, los libros no se encuentran ordenados de alguna forma especial. Santy ha decidido arreglar esto durante su mandato. Se le ha ocurrido una forma un tanto curiosa de ordenar algunos de los libros. Él quiere formar una línea de libros de tal forma que si tomamos la inicial de cada libro, esta línea forme un palíndromo*. Como quiere ordenar la mayor cantidad de libros posibles, quiere la línea más larga que se pueda. Además de esto, para hacerlo aún más interesante, dentro de todas las opciones iguales quiere la menor lexicográficamente*. *Palíndromo: Un palíndromo es una palabra que se lee de la misma forma de derecha a izquierda que de izquierda a derecha. Por ejemplo, aérea, ana, salas, rodador. *Lexicográficamente: Se dice que una palabra es menor a otra lexicográficamente si el primer caracter donde difieren es menor (va primero en el alfabeto) en la primera palabra. Por ejemplo, amancio es menor que amando porque el primer caracter donde difieren es donde uno es c y el otro d, donde la c viene primero en el alfabeto. Más aún, el prefijo de una palabra siempre será menor lexicográficamente. Por ejemplo, auto es menor que automático.",
        "entrada": "Se te dará una cadena de caracteres S de letras mayúsculas del alfabeto inglés que representan las iniciales de los libros que hay actualmente. La cadena tiene a lo más 5000 caracteres.",
        "salida": "Deberás imprimir la cadena que te pide el problema.",
        "nivel": "Básico (difícil) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas",
            "Tablas de dispersión"
        ],
        "estructuras": [
            "int",
            "char",
            "string",
            "map<char,int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    ios_base::sync_with_stdio(false);\n cin.tie(0);\n   cout.tie(0);\n  int a, b, c, e, f, g, h;\n    map<char,int>y;\n    int n;\n    string x;\n    cin>>x;\n    char z='@';\n    a=x.size();\n    for(auto i = 0; i<a; i++){\n        y[x[i]]++;\n    }\n    vector<char>zz;\n    for(const auto &d: y){\n        if(d.second%2 && z=='@'){\n            z=d.first;\n        }\n        b=d.second;\n        if(b%2){\n            b--;\n        }\n            b/=2;\n            while(b--){\n            cout<<d.first;\n            zz.push_back(d.first);\n            }\n    }\n    if(z!='@'){\n        cout<<z;\n    }\n    while(zz.size()){\n        cout<<zz.back();\n        zz.pop_back();\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "13001. Suma elementos consecutivos",
        "url": "https://omegaup.com/arena/problem/Suma-elementos-consecutivos/",
        "descripcion": "Dado un arreglo de tamaño n, determinar si existen k elementos consecutivos tales que sumen l.",
        "entrada": "En la primera línea los enteros n, k y l (1<=k<=n<=10^6) (1<=l<=10^14). En la segunda línea, n enteros a_i (0<=a_i<=10^8) separados por un espacio.",
        "salida": "Imprimir un \"Si\" si existen k elementos consecutivos que sumen l o un \"No\" en caso de que no exista.",
        "nivel": "Básico (difícil) - Introducción a la programación",
        "categorias": [
            "Vectores",
            "Ventana deslizante"
        ],
        "estructuras": [
            "long long",
            "vector<long long>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint main(){\n   ios::sync_with_stdio(0);\n  cin.tie(0);\n   cout.tie(0);\n  ll n, m, a, b=0, c=0, d, e, f, g, h;\n  vector<ll>ar(1000000,0);\n  cin>>n>>m>>a;\n for(auto i=0; i<m; i++){\n      cin>>ar[i];\n       b+=ar[i];\n }\n if(b==a){\n     c=1;\n  }\n for(auto i=m; i<n; i++){\n      cin>>ar[i];\n       b+=ar[i]-ar[i-m];\n     if(b==a){\n         c=1;\n      }\n }\n if(c){\n        cout<<\"Si\";\n }\n else{\n     cout<<\"No\";\n }\n\n   return 0;\n}\n"
    },
    {
        "titulo": "19749. Acechando Igualdades",
        "url": "https://omegaup.com/arena/problem/Acechando-Igualdades/",
        "descripcion": "El dictador Santy ha llegado al poder en el Instituto Central del Pensamiento Creativo. En esta universidad, los alumnos destacados reciben un apoyo económico para incentivarlos a seguir destacando. Sin embargo, durante el mandato anterior, se habían estado haciendo tratos oscuros y algunos alumnos recibían más que otros. Tú conoces la lista actual de los montos económicos que se le da a cada alumno. Tu tarea será determinar la cantidad minima de montos que debes cambiar para que todos sean iguales.",
        "entrada": "Se te dará un entero 1<=N<=100 indicando la cantidad de alumnos destacados. En la siguiente línea, habrá N enteros 1<=a_i<=100 que representan los apoyos económicos que se le da a los alumnos.",
        "salida": "Deberás imprimir la cantidad minima de montos que debes modificar para que a todos les toque lo mismo.",
        "nivel": "Básico (difícil) - Introducción a la programación",
        "categorias": [
            "Vectores",
            "Tablas de dispersión"
        ],
        "estructuras": [
            "int",
            "unordered_map<int,int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    ios_base::sync_with_stdio(false);\n cin.tie(0);\n   cout.tie(0);\n    int a, b, c, d, e, f, g, h;\n unordered_map<int,int> dinero;\n    int n;\n    cin>>n;\n    int aux;\n    for(auto i = 0; i<n; i++){\n        cin>>aux;\n        dinero[aux]++;\n    }\n    int mayor = 0;\n    for(const auto &d: dinero){\n        if(d.second > mayor) mayor = d.second;\n    }\n    cout<<n-mayor;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "19594. Cazador de Anomalías",
        "url": "https://omegaup.com/arena/problem/Cazador-de-Anomalias/",
        "descripcion": "Un elemento a_i de un arreglo se define como una anomalía si existe a_j tal que a_i<a_j. Tu tarea consiste en encontrar la cantidad de anomalías en el arreglo.",
        "entrada": "Se te dará un número 1<=N<=10^5 indicando la cantidad de elementos en el arreglo. Luego se te darán los elementos del arreglo 1<=a_i<=10^5.",
        "salida": "Deberás imprimir la cantidad de anomalías en el arreglo.",
        "nivel": "Básico (difícil) - Introducción a la programación",
        "categorias": [
            "Vectores"
        ],
        "estructuras": [
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    ios::sync_with_stdio(0);\n  cin.tie(0);\n   cout.tie(0);\n  int n, m, a, b, c, d, e, f, g, h;\n vector<int>ar(500000,0);\n  cin>>n>>b;\n    c=b;\n  d=1;\n  for(auto i=1; i<n; i++){\n      cin>>b;\n       if(b==c){\n         d++;\n      }\n     else if(b>c){\n         d=1;\n          c=b;\n      }\n }\n cout<<n-d;\n\n  return 0;\n}\n"
    },
    {
        "titulo": "10691. Spotifly",
        "url": "https://omegaup.com/arena/problem/Spotify/",
        "descripcion": "Como sabes, tu amigo es extremadamente metódico, asi que para poder crear la playlist tiene diferentes opciones: 1- Ingresa una canción a la playlist, pero recuerda estas playlist se basan en el tiempo de duración de las canciones y no tanto en el nombre de la canción. 2- Reproduce la canción que se encuentra al inicio de la playlist en ese momento. 3- Elimina la canción que se encuentra al inicio de la playlist sin que se reproduzca. 4- Muestra el tiempo que se lleva reproduciendo música en la fiesta. 5- Muestra cuantas canciones se encuentran en la playlist. 6- Se detiene la reproducción de la playlist.",
        "entrada": "Recibirás una serie de número que representan las instrucciones que te da tu amigo, síguelas al pie de la letra para que la fiesta sea todo un éxito.",
        "salida": "Existe la posibilidad de que le tengas que contestar preguntas a tu amigo, como por ejemplo cuanto tiempo se ha reproducido música en la fiesta o cuantas canciones hay en la playlist.",
        "nivel": "Básico (difícil) - Introducción a la programación",
        "categorias": [
            "Colas"
        ],
        "estructuras": [
            "float",
            "queue<float>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  float a, b, c, d, e, f, g, h;\n queue<float>num;\n  cin>>a;\n   while(a!=6){\n      switch((int)a){\n           case 1: cin>>a;num.push(a);break;\n         case 2: b+=num.front();num.pop();break;\n           case 3: num.pop();break;\n          case 4: cout<<b<<\"\\n\";break;\n           case 5: cout<<num.size()<<\"\\n\";break;\n      }\n     cin>>a;\n   }\n \n    return 0;\n}\n"
    },
    {
        "titulo": "6705. PSP y tamaños relativos",
        "url": "https://omegaup.com/arena/problem/PSP-y-tamanos-relativos/",
        "descripcion": "Personal Software Process (PSP), es un conjunto de prácticas desarrolladas para la administración del tiempo y las actividades personales de programadores o ingenieros de software. Está alineado y diseñado para emplearse en organizaciones con modelos de procesos CMMI o ISO 15504. Fue propuesto por Watts Humphrey en 1995. Uno de los muchos procesos que se incluyen en PSP implica el cálculo de una tabla de tamaños relativos usando desviación estándar. En esta tabla se deben calcular los siguientes tamaños: muy pequeño (VS), pequeño(S), medio (M), grande(L) y muy grande(VL) utilizando desviación estándar. Para calcular una tabla de tamaños relativos usando desviación estándar se usa el siguiente proceso: Leer n datos de entrada. Transformar cada uno de los datos a su logarirmo natural. Esto es necesario porque no se deben tener tamaños negativos y los valores pequeños tienden a amontonarse. Calcular el promedio de estos n valores logarítmicos mediante avg=[sum_{i=1}^{n}ln(x_i)]/n. Calcular la varianza: var=\\sigma^2=[sum_{i=1}^{n}(ln(x_i)-avg)^2]/(n-1). Calcular la desviación estándar: \\sigma=sqrt(var). Calcular los rangos: ln(VS)=avg-2*\\sigma, ln(S)=avg-\\sigma, ln(M)=avg, ln(L)=avg+\\sigma, ln(VL)=avg+2*\\sigma. Por último, convertir los valores logarítmicos a su tamaño natural usando el anti-logaritmo: VS=e^ln(VS), S=e^ln(S), M=e^ln(M), L=e^ln(L), VL=e^ln(VL).",
        "entrada": "Primero se leerá el valor de n (3<=n<=100) que representa el número de datos a recibir. A continuación se leerán n datos de tipo real.",
        "salida": "Imprimir los valores de los rangos VS, S, M, L y por último VL. Cada uno de ellos en un renglón y redondeados a dos decimales.",
        "nivel": "Básico (difícil) - Introducción a la programación",
        "categorias": [
            "Vectores",
            "Cálculo matemático"
        ],
        "estructuras": [
            "int",
            "double",
            "vector<double>",
            "log()",
            "pow()",
            "fixed",
            "setprecision()",
            "exp()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n   int n;\n    cin >> n;\n // Usamos vector para mayor flexibilidad\n  vector<double> datos(n);\n  // Leemos los datos\n   for (int i = 0; i < n; ++i) {\n     cin >> datos[i];\n  }\n // Calculamos la suma de los logaritmos naturales\n double sum_ln = 0;\n    for (int i = 0; i < n; ++i) {\n     sum_ln += log(datos[i]);\n  }\n // Calculamos el promedio de los logaritmos naturales\n double avg = sum_ln / n;\n  // Calculamos la suma de las diferencias cuadradas\n    double sum_sq_diff = 0;\n   for (int i = 0; i < n; ++i) {\n     sum_sq_diff += pow(log(datos[i]) - avg, 2);\n   }\n // Calculamos la varianza\n double var = sum_sq_diff / (n - 1);\n   // Calculamos la desviacion estandar\n    double std_dev = sqrt(var);\n   // Calculamos los limites de los rangos\n    double ln_VS = avg - 2 * std_dev;\n double ln_S = avg - std_dev;\n  double ln_M = avg;\n    double ln_L = avg + std_dev;\n  double ln_VL = avg + 2 * std_dev;\n // Imprimimos los rangos, redondeados a dos decimales\n cout << fixed << setprecision(2);\n cout << exp(ln_VS) << endl;\n   cout << exp(ln_S) << endl;\n    cout << exp(ln_M) << endl;\n    cout << exp(ln_L) << endl;\n    cout << exp(ln_VL) << endl;\n\n return 0;\n}\n"
    },
    {
        "titulo": "10220. Oro del sabio",
        "url": "https://omegaup.com/arena/problem/Oro-del-sabio/",
        "descripcion": "Cuenta la historia que existía un viejo sabio que regalaba oro a todo aquel que pudiera contestar su problema de forma eficiente, un día este sabio se le acercó al grupo organizador de la Olimpiada de Yucatán y les dijo el problema. Al ser personas muy hábiles pudieron con el problema con facilidad y le dieron el oro a uno de ellos... ya nunca volvimos a saber de aquella persona, ni el oro. Como personas creativas los organizadores decidieron poner este problema como parte del selectivo estatal y en vez de dar oro a quien lo responda, se darán puntos (mucho mejor) :D. El problema consiste en que tienes una línea de n montones de monedas, tu conoces la cantidad inicial de cada montón. Luego el sabio te hará preguntas, cada pregunta consiste en agregarle cierta cantidad de monedas a todos los montones de un rango y después de agregarles dicha cantidad decir cuánto es el total de monedas que hay en toda la fila. Por ejemplo, si tienes una línea de monedas 3, 6, 2, 4, entonces el total es de 3+6+2+4=15. Luego el sabio le agrega 5 a todos los montones desde el segundo hasta el cuarto y queda como 3, 11, 7, 9 y ahora hay 30. Se te dan los n montones iniciales de monedas, luego se te harán k preguntas en donde la pregunta i consiste en aumentar los montones desde x_i hasta y_i en r_i y decir cuanto suman todos los montones.",
        "entrada": "En la primera línea dos números enteros n y k (0<n,k<10^5) que representan el número de montes y el número de preguntas, respectivamente. En la segunda línea n enteros que representan los montones iniciales m_i (0<m_i<10^5). Las siguientes K líneas son tercias de números x_i, y_i (1<=x_i<=y_i<=n) y r_i (0<r_i<10^5), los primeros dos son el rango de aumento y el tercero en cuanto aumentan los montones.",
        "salida": "k números enteros que representan la respuesta a cada pregunta. Por cada una de esas preguntas debes decir la cantidad de monedas que hay en total (considerando todos los montones).",
        "nivel": "Básico (difícil) - Introducción a la programación",
        "categorias": [
            "Cálculo matemático"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d=0, e;\n    cin>>a>>b;\n    while(a--){\n        cin>>c;\n        d+=c;\n    }\n    //Optimizacion: En lugar de implementar un vector y sumar en todas las posiciones del rango,\n    //simplemente se realiza una suma en una sola variable (dado que se da la suma total, no de un rango).\n    while(b--){\n        cin>>a>>c>>e;\n        d+=((c-a)+1)*e;\n        cout<<d<<\"\\n\";\n    }\n    \n    return 0;\n}\n"
    },
    {
        "titulo": "9534. RooEnigma2",
        "url": "https://omegaup.com/arena/problem/RooEnigma2/",
        "descripcion": "Dada una configuración inicial, la máquina criptográfica alemana Enigma, de la segunda guerra mundial, sustituía cada letra digitada en el teclado por otra letra. La sustitución era bastante compleja, pero la máquina tenía una vulnerabilidad: ¡una letra nunca sería sustituida por ella misma! esa vulnerabilidad fue explorada por Alan Turing, quien trabajo en el criptoanálisis de Enigma durante la guerra. El objetivo era encontrar una configuración inicial de la máquina usando la suposición de que el mensaje contenía cierta expresión usual de comunicación, como por ejemplo la palabra ARMADA. Esas expresiones eran llamadas cribs. Si el mensaje cifrado era, por ejemplo, FDMLCRDMRALF, el trabajo de probar las posibles configuraciones de la máquina era simple porque la palabra ARMADA, si estuviese en ese mensaje cifrado, solo podría estar en dos posiciones, ilustradas en la tabla de abajo con una flecha. Las otras cinco posiciones no podrían corresponder al mismo crib ARMADA porque al menos una letra del crib, subrayada en la tabla de abajo, es emparejada con su correspondiente en el mensaje cifrado; como Enigma nunca sustituirá una letra por ella misma, esas cinco posiciones son descartadas por las pruebas. Escribe un programa para que, dado un mensaje cifrado en un crib, se calcule el número de posiciones posibles para el crib en el mensaje cifrado.",
        "entrada": "La primera línea de entrada contiene el mensaje cifrado, que es una secuencia de por lo menos una letra y máximo 10^4 letras. La segunda línea contiene el crib, que es una secuencia de por lo menos una letra y máximo el mismo número de letras que el mensaje. El crib y el mensaje únicamente incluyen las 26 letras del abecedario, mayúsculas y sin tildes.",
        "salida": "Imprima una línea con un entero, indicando el número de posiciones posibles para un crib en el mensaje cifrado.",
        "nivel": "Básico (difícil) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "bool",
            "int",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    string mensaje, crib;\n    cin >> mensaje >> crib;\n    int posiciones = 0;\n    int n = mensaje.size();\n    int m = crib.size();\n    for (int i = 0; i <= n - m; ++i) {\n        bool posible = true;\n        for (int j = 0; j < m; ++j) {\n            if (mensaje[i + j] == crib[j]) {\n                posible = false;\n                break;\n            }\n        }\n        if (posible) {\n            posiciones++;\n        }\n    }\n    cout << posiciones << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "8208. Buscando el mejor servicio",
        "url": "https://omegaup.com/arena/problem/Buscando-el-mejor-servicio/",
        "descripcion": "A una adolescente le gusta escuchar música todo el tiempo desde Spotify, Apple Music y YouTube Music. Sin embargo, con la cuarta transformación, nuestro presidente presentó una nueva ley que impide tener más de un servicio de streaming por ciudadano. Por esta razón, la adolescente debe elegir con cuál de todos se debe quedar en función del nombre de la canción más larga que tenga en sus diferentes playlists.",
        "entrada": "Tres líneas con las 3 canciones en el siguiente orden: primero la canción de Spotify, luego la de Apple Music y luego una de YouTube Music. Cada nombre de canción puede contener una cantidad indeterminada de espacion.",
        "salida": "El nombre del servicio de streaming donde va a seguir escuchando música la adolescente. Si todas las canciones son iguales en tamaño, entonces eligirá YouTube Music.",
        "nivel": "Básico (difícil) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "int",
            "string",
            "getline()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    string spotify, apple, youtube;\n    getline(cin, spotify);\n    getline(cin, apple);\n    getline(cin, youtube);\n    int max_len = spotify.length();\n    string servicio = \"Spotify\";\n    if (apple.length() > max_len) {\n        max_len = apple.length();\n        servicio = \"Apple Music\";\n    }\n    if (youtube.length() >= max_len) {\n        servicio = \"YouTube Music\";\n    }\n    cout << servicio << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "8644. Números Narcisistas",
        "url": "https://omegaup.com/arena/problem/Numeros-Narcisistas/",
        "descripcion": "Un número es narcisista si es igual a la suma de las potencias de sus cifras elevadas a la cantidad de cifras del número. Así, el número narcisista más pequeño es 153, que tiene 3 cifras y 1 elevado a 3 + 5 elevado a 3 + 3 elevado a 3 = 153. Leer un número entero X (mayor que 1 y menor que <500000) e informar si el mismo es narcisista.",
        "entrada": "La entrada consiste de una única línea conteniendo un valor entero x.",
        "salida": "La salida consiste de una línea con el mensaje \"Es Narcisista\" o \"No es Narcisista\" según corresponda a X.",
        "nivel": "Básico (difícil) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b=0, c=0, d;\n    string z;\n    cin>>z;\n    d=z.size();\n    for(auto i=0; i<d; i++){\n        a=z[i]-48;\n        c*=10;\n        c+=a;\n        b+=pow(a,z.size());\n    }\n    if(c==b){\n        cout<<\"Es Narcisista\";\n    }\n    else{\n        cout<<\"No es Narcisista\";\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "2208. Interview Question",
        "url": "https://omegaup.com/arena/problem/InterviewQuestion/",
        "descripcion": "Un amigo mío fue preguntado hoy en una entrevista para el puesto de desarrollador de software: Dadas dos cadenas s1 y s2, ¿cómo verificarías si s1 es una versión rotada de s2? Ejemplo: Si s1 = \"stackoverflow\", entonces las siguientes son algunas de sus versiones rotadas: “tackoverflows”, “ackoverflowst”, “overflowstack”, mientras que “stackoverflwo” no es una versión rotada. La respuesta que dio fue: Toma s2 y encuentra el prefijo más largo que es una subcadena de s1, eso te dará el punto de rotación. Una vez que encuentres ese punto, divide s2 en ese punto para obtener s2a y s2b, luego verifica si la concatenación de s2a y s2b es igual a s1. Parece una buena solución para mí y mi amigo, pero el entrevistador pensó lo contrario. Pidió una solución más simple. Por favor, ayúdame diciendo cómo lo harías. ¡Gracias anticipadas!",
        "entrada": "Una línea con un entero N, que es el número de casos de prueba siguientes. Luego siguen 2N líneas. Cada caso de prueba contiene un par de cadenas, s1 y s2, cada una en su propia línea. s1 y s2 pueden contener letras minúsculas, mayúsculas y números. Sin espacios. Las coincidencias deben ser sensibles a mayúsculas y minúsculas.",
        "salida": "Para cada caso de prueba, imprime una línea que contenga ‘Yes’ si s1 es una versión rotada de s2, o ‘No’ en caso contrario. Cuando hayas terminado con los casos de prueba, imprime la línea “Do I get the job?”",
        "nivel": "Básico (difícil) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "int",
            "string",
            "getline()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n// Funcion para verificar si s1 es una rotacion de s2\nstring isRotation(string s1, string s2) {\n    if (s1.length() != s2.length()) {\n        return \"No\";\n    }    \n    string temp = s1 + s1;\n    if (temp.find(s2) != string::npos) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int N;\n    cin >> N;\n    cin.ignore(); // Consumir el salto de linea despues de leer N\n    for (int i = 0; i < N; ++i) {\n        string s1, s2;\n        getline(cin, s1);\n        getline(cin, s2);\n        cout << isRotation(s1, s2) << endl;\n    }\n    cout << \"Do I get the job?\" << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "2981. Evaluar polinomios",
        "url": "https://omegaup.com/arena/problem/Evaluar-polinomios/",
        "descripcion": "Escribe un programa que, dados los valores de las incógnitas x_0, x_1, ..., x_n-1, evalúe una secuencia de polinomios. Cada polinomio es una suma de productos de variables.",
        "entrada": "El entero N seguido de N números en punto flotante, Posteriormente una secuencia de polinomios, uno por línea, los cuales deben procesarse hasta el fin de archivo. Puedes suponer que (1<=N<=10).",
        "salida": "Por cada polinomio, un real que corresponda con la evaluación del polinomio. El valor impreso se considerará correcto si está razonablemente cerca del valor exacto.",
        "nivel": "Básico (difícil) - Introducción a la programación",
        "categorias": [
            "Vectores",
            "Caracteres y cadenas",
            "Cálculo matemático"
        ],
        "estructuras": [
            "int",
            "string",
            "double",
            "vector<double>",
            "getline()",
            "fixed",
            "setprecision()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ndouble evaluar_polinomio(const string& polinomio, const vector<double>& variables) {\n    istringstream iss(polinomio);\n    string termino;\n    double resultado = 0.0;\n    while (getline(iss, termino, '+')) {\n        double valor_termino = 1.0;\n        for (int i = 0; i < termino.size(); ++i) {\n            if (termino[i] == 'x') {\n                valor_termino *= variables[termino[i + 1] - '0'];\n            }\n        }\n        resultado += valor_termino;\n    }\n    return resultado;\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int N;\n    cin >> N;\n    vector<double> variables(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> variables[i];\n    }\n    string polinomio;\n    getline(cin, polinomio); // Consumir el salto de l?ea despu? de leer N\n    while (getline(cin, polinomio)) {\n        double resultado = evaluar_polinomio(polinomio, variables);\n        cout << fixed << setprecision(2) << resultado << endl;\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "11455. Filtrando múltiplos",
        "url": "https://omegaup.com/arena/problem/Filtrando-multiplos/",
        "descripcion": "Escribe un programa que lea una secuencia de N enteros y un entero k y que reimprima la secuencia dada, reemplazando los enteros que no son múltiplos de K por una X mayúscula.",
        "entrada": "Un entero N seguido de una línea con los N enteros de la secuencia y de otra línea con un entero K. Los enteros de la secuencia aparecen separados por espacios. Puedes suponer que todos los enteros de la entrada están en el rango de 1 a 100.",
        "salida": "La secuencia leída con los elementos que no son múltiplos de K reemplazados por una X mayúscula.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores"
        ],
        "estructuras": [
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e;\n    vector<int>num(1000000,0);\n    cin>>a;\n    for(auto i=0; i<a; ++i){\n        cin>>num[i];\n    }\n    cin>>b;\n    for(auto i=0; i<a; ++i){\n        if(num[i]%b==0){\n            cout<<num[i]<<\" \";\n        }\n        else{\n            cout<<\"X \";\n        }\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "11414. Sumando elementos opuestos de un arreglo",
        "url": "https://omegaup.com/arena/problem/Sumando-elementos-opuestos-de-un/",
        "descripcion": "Dado un arreglo de N enteros donde N es par, escribe un programa que sume (en parejas) los elementos de lados opuestos del arreglo: el primer elemento con el último, el segundo elemento con el penúltimo, etc.",
        "entrada": "Un entero N seguido de una línea con los N enteros del arreglo separados por espacios. Puedes suponer que 2<=N<=200 y que N es par.",
        "salida": "Los N/2 enteros que se obtienen al sumar los elementos de lados opuestos del arreglo, comenzando por los elementos de los extremos.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores"
        ],
        "estructuras": [
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e;\n    vector<int>num(1000000,0);\n    cin>>a;\n    for(auto i=0; i<a; ++i){\n        cin>>num[i];\n    }\n    for(auto i=0, j=a-1; i<a/2; ++i, --j){\n        cout<<num[i]+num[j]<<\"\\n\";\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "8632. Días de Felicidad",
        "url": "https://omegaup.com/arena/problem/Dias-de-Felicidad/",
        "descripcion": "Domene tiene un método muy peculiar para calificar qué tan felices fueron sus días en el Tec. Entre más feliz es, lo califica con un número más alto, y entre menos feliz, con uno más bajo. Su preocupación últimamente ha sido por tener una racha de días donde la felicidad no baje. Esto es un problema porque si tiene un dia muy muy feliz, lo tendrá que calificar muy alto, y el siguiente día podría no ser tan feliz (aun y siendo feliz). Ayuda a Domene a calcular cual es la racha más larga de días consecutivos sin que la felicidad bajara.",
        "entrada": "N, El número de días en la lista, seguido por otra línea con N días con felicidad M.",
        "salida": "La racha más larga de días sin que la felicidad bajara.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores"
        ],
        "estructuras": [
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b=0, c=0, d, e=0;\n    cin>>a;\n    while(a--){\n        cin>>b;\n        if(b>=c){\n            d++;\n            c=b;\n        }\n        else{\n            e=max(e,d);\n            d=1;\n            c=b;\n        }\n    }\n    e=max(e,d);\n    cout<<e;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "7131. Modificando un arreglo",
        "url": "https://omegaup.com/arena/problem/Modificando-un-arreglo/",
        "descripcion": "Dado un arreglo de N enteros que comienzan valiendo 0, escribe un programa que lea M índices y para cada índice incremente la variable correspondiente del arreglo.",
        "entrada": "Dos enteros N (1<=N<=100) y M (0<=M<=100) seguidos de una secuencia de M enteros. Puedes suponer que todos los índices están en el rango de 0 a N-1.",
        "salida": "Los N enteros del arreglo después de haber aplicado todos los incrementos.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores"
        ],
        "estructuras": [
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e, f, g, h;\n   vector<int>num(10000,0);\n    cin>>a>>b;\n    while(b--){\n        cin>>c;\n        num[c]++;\n    }\n    for(auto i=0; i<a; ++i){\n        cout<<num[i]<<\" \";\n    }\n    \n    return 0;\n}\n"
    },
    {
        "titulo": "11884. Una fórmula con muchas divisiones",
        "url": "https://omegaup.com/arena/problem/Una-formula-con-muchas-divisione/",
        "descripcion": "Dados dos reales \"x\" y \"y\", escribe un programa que calcule el valor de \"z\" dado por: z=((x^3+x^2)/(y^2-y)-(x/y+5))/2x",
        "entrada": "Dos reales \"x\" y \"y\". Puedes suponer que -10<=x,y<=10 y que no se producirán divisiones entre cero.",
        "salida": "Un real que sea el valor de z. Tu programa se considerará correcto si el valor calculado es razonablemente cercano a la respuesta exacta.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Cálculo matemático"
        ],
        "estructuras": [
            "int",
            "pow(,)"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  long double a, b, c, d, e, f, g, h;\n   cin>>a>>b;\n    cout<<(((pow(a,3)+pow(a,2))/(pow(b,2)-b))-((a/b)+5))/(2*a);\n\n    return 0;\n}\n"
    },
    {
        "titulo": "9421. Cifrado Chido1",
        "url": "https://omegaup.com/arena/problem/Cifrado-Chido1/",
        "descripcion": "Trabajas en la CIA y se te dio el encargo de cifrar las palabras que te envian dependiendo de la primera letra del mensaje si es una vocal se muestran primero las vocales, luego las consonantes y si la primera letra es una consonante primero se muestran las consonantes, luego las vocales.",
        "entrada": "Un string palabra.",
        "salida": "Si es vocal la primera letra primero se muestran las vocales y despues las consonantes siguiendo el orden de la palabra original Si es consonante la primera letra primero se muestran las consonantes y despues las vocales siguiendo el orden de la palabra original.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "long long",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  long long a, b, c, d, e, f, g, h;\n string z;\n cin>>z;\n   if(z[0]=='a' || z[0]=='e' || z[0]=='i' || z[0]=='o' || z[0]=='u' || z[0]=='A' || z[0]=='E' || z[0]=='I' || z[0]=='O' || z[0]=='U'){\n       b=1;\n  }\n for(auto i=0; i<z.size(); ++i){\n        if(b && (z[i]=='a' || z[i]=='e' || z[i]=='i' || z[i]=='o' || z[i]=='u' || z[i]=='A' || z[i]=='E' || z[i]=='I' || z[i]=='O' || z[i]=='U')){\n            cout<<z[i];\n       }\n     else if(!b && (z[i]!='a' && z[i]!='e' && z[i]!='i' && z[i]!='o' && z[i]!='u' && z[i]!='A' && z[i]!='E' && z[i]!='I' && z[i]!='O' && z[i]!='U')){\n          cout<<z[i];\n       }\n }\n ++b%=2;\n   for(auto i=0; i<z.size(); ++i){\n        if(b && (z[i]=='a' || z[i]=='e' || z[i]=='i' || z[i]=='o' || z[i]=='u' || z[i]=='A' || z[i]=='E' || z[i]=='I' || z[i]=='O' || z[i]=='U')){\n            cout<<z[i];\n       }\n     else if(!b && (z[i]!='a' && z[i]!='e' && z[i]!='i' && z[i]!='o' && z[i]!='u' && z[i]!='A' && z[i]!='E' && z[i]!='I' && z[i]!='O' && z[i]!='U')){\n          cout<<z[i];\n       }\n }\n \n  return 0;\n}\n"
    },
    {
        "titulo": "6383. Matrices con Giro Completo",
        "url": "https://omegaup.com/arena/problem/Problema-Matrices-con-Giro-Compl/",
        "descripcion": "Dada una matriz cuadrada A de N X N, se puede definir la operación de giro a la derecha de A como sigue: el primer renglón de la matriz A se convierte en la última columna de la matriz girada, el segundo renglón de la matriz A se convierte en la penúltima columna de la matriz girada, y así sucesivamente hasta que el último renglón de la matriz A se convierte en la primera columna de la matriz girada. Por ejemplo, si N=3 y A es la matriz A={3 1 4,1 5 9,2 6 5}, entonces al girar A a la derecha obtenemos la matriz A={2 1 3,6 5 1,5 9 4}, Pero se realizarán de nuevo giros hasta volver a la matriz original, por lo que al siguiente giro obtenemos la matriz A={5 6 2,9 5 1,4 1 3}, Un siguiente giro dejará la matriz así: A={4 9 5,1 5 6,3 1 2} Y el último giro será la matriz original: A={3 1 4,1 5 9,2 6 5}",
        "entrada": "Consiste de un número entero N con 1<=N<=20, seguido de N renglones, cada uno de los cuales contiene N números enteros entre 0 y 9, separados por espacios, describiendo a la matriz A.",
        "salida": "Consiste de N*4 renglones, cada uno de los cuales contiene N números enteros separados por espacios describiendo a las matrices A'.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Matrices"
        ],
        "estructuras": [
            "int",
            "vector<vector<int>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  int a, b, c, d, e, f, g, h, l, m=1;\n   int num[1000][1000];\n  cin>>a;\n   for(auto i=0; i<a; i++){\n       for(auto j=0; j<a; j++){\n           cin>>num[i][j];\n       }\n }\n for(auto i=0; i<a; i++){\n       for(auto j=a-1; j>=0; j--){\n            cout<<num[j][i]<<\" \";\n       }\n     cout<<\"\\n\";\n    }\n cout<<\"\\n\";\n    for(auto i=a-1; i>=0; i--){\n        for(auto j=a-1; j>=0; j--){\n            cout<<num[i][j]<<\" \";\n       }\n     cout<<\"\\n\";\n    }\n cout<<\"\\n\";\n    for(auto i=a-1; i>=0; i--){\n        for(auto j=0; j<a; j++){\n           cout<<num[j][i]<<\" \";\n       }\n     cout<<\"\\n\";\n    }\n cout<<\"\\n\";\n    for(auto i=0; i<a; i++){\n       for(auto j=0; j<a; j++){\n           cout<<num[i][j]<<\" \";\n       }\n     cout<<\"\\n\";\n    }\n\n   return 0;\n}\n"
    },
    {
        "titulo": "6123. Matriz serpentina",
        "url": "https://omegaup.com/arena/problem/Matriz-serpentina/",
        "descripcion": "Escribe un programa que, dados dos números enteros M, N, construya una matriz con M renglones y N columnas cuyas entradas sean los números 1,2,...,M*N acomodados como una serpentina, comenzando con el 1 en la entrada (0,0), siguiendo hacia la derecha (hasta el final del renglón), luego una posición hacia abajo, siguiendo hacia la izquierda (hasta el principio del renglón), luego una posición hacia abajo y así sucesivamente (ver ejemplo).",
        "entrada": "Consiste de dos números enteros positivos, M, N (ambos menores que 20), separados por un espacio.",
        "salida": "La matriz requerida, debiendo haber M renglones, cada uno con N números enteros separados por espacios.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Matrices"
        ],
        "estructuras": [
            "int",
            "vector<vector<int>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  int a, b, c, d=0, e=0, f, g, h, l, m=1;\n   vector<vector<int> >num(1000,vector<int>(1000,0));\n    cin>>a>>b;\n    c=a*b;\n    while(c--){\n       num[d][e]=a*b-c;\n      if(m==1){\n         if(e==b-1){\n               d++;\n              m=2;\n          }\n         else{\n             e++;\n          }\n     }\n     else{\n         if(e==0){\n             d++;\n              m=1;\n          }\n         else{\n             e--;\n          }\n     }\n }\n for(auto i=0; i<a; i++){\n       for(auto j=0; j<b; j++){\n           cout<<num[i][j]<<\" \";\n       }\n     cout<<\"\\n\";\n    }\n\n   return 0;\n}\n"
    },
    {
        "titulo": "6892. Ordenamiento super basico",
        "url": "https://omegaup.com/arena/problem/boredx100/",
        "descripcion": "Como dejaron a Xela solo en su casa y tenia tiempo que no torturaba a los olímpicos de la OB pense en hacer un problema tan dificil que ni el mismo Legna pudiera resolver pero al ver a su gata dormiendo decidio mejor hacer un simple y aburrido problema de ordenacion.",
        "entrada": "La primer línea de entrada contendrá el número N. La segunda línea contendrá N elementos separados por un espacio.",
        "salida": "Solo debes de ordenarlos.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores",
            "Ordenamiento"
        ],
        "estructuras": [
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n     cout.tie(0);\n      int a, b, c, d, e, f, g, h;\n   vector<int>num;\n   cin>>a;\n   while(a--){\n       cin>>b;\n       num.push_back(b);\n }\n sort(num.begin(),num.end());\n  for(auto i=0; i<num.size(); i++){\n      cout<<num[i]<<\" \";\n  }\n     \n  return 0;\n}\n"
    },
    {
        "titulo": "6864. Direcciones al Tec",
        "url": "https://omegaup.com/arena/problem/itp18-direcciones/",
        "descripcion": "¡Hoy es el gran día! Hoy se lleva a cabo el 1er Concurso de Programación del Instituto Tecnológico de Pachuca; sin embargo de tan emocionadx que estás se te olvidó cómo llegar al Tec y vas a tener que pedir ayuda en la calle. El mapa de tu casa al Tec es un rectángulo de N casillas de alto por M casillas de ancho. Tu casa está en la esquina superior izquierda y el Tec está en la esquina inferior derecha. Empiezas tu recorrido en tu casa (esquina superior izquierda) viendo hacia el Este. Dado que no sabes cómo llegar en cada casilla (incluída la casilla inicial) pides ayuda a la persona en esa casilla. Esa persona te puede aconsejar: Sigue derecho, Gira a la derecha, Gira a la izquierda, ó, Date la vuelta. Después de recibir el consejo, lo sigues y avanzas una casilla. Al llegar a una nueva casilla vuelves a hacer el mismo proceso: preguntar, seguir consejo, avanzar una casilla. Así hasta que llegues al Tec (esquina inferior derecha) o te salgas del mapa (si te sales del mapa ya te perdiste y es un hecho que no llegarás al concurso). Escribe un programa que dadas las respuestas de las personas en cada casilla del mapa determine si vas a llegar al Tec o te vas a perder.",
        "entrada": "Dos enteros indicando las dimensiones del mapa. El formato es N M donde: N = alto del mapa, y M = ancho del mapa. N renglones conteniendo M valores separados por espacios. Estos valores representan los consejos que vas a recibir en cada casilla. Los posibles valores son: 0 = sigue derecho, 1 = gira a la derecha, 2 = gira a la izquierda, ó, 3 = date la vuelta.",
        "salida": "Imprime \"llegaste\" si siguiendo las instrucciones llegas al Tec, ó, imprime \"te perdiste\" si te sales del mapa.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Matrices"
        ],
        "estructuras": [
            "bool",
            "int",
            "vector<vector<int>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, m;\nvector<vector<int>> mapa;\n\n// Funcion para simular el movimiento en el mapa\nbool mover(int &i, int &j, int &dir) {\n    if (mapa[i][j] == 0) { // Sigue derecho\n       if (dir == 0) j++; // Este\n        else if (dir == 1) i++; // Sur\n        else if (dir == 2) j--; // Oeste\n      else i--; // Norte\n    } else if (mapa[i][j] == 1) { // Gira a la derecha\n        dir = (dir + 1) % 4;\n      if (dir == 0) j++; // Este\n        else if (dir == 1) i++; // Sur\n        else if (dir == 2) j--; // Oeste\n      else i--; // Norte\n    } else if (mapa[i][j] == 2) { // Gira a la izquierda\n      dir = (dir + 3) % 4;\n      if (dir == 0) j++; // Este\n        else if (dir == 1) i++; // Sur\n        else if (dir == 2) j--; // Oeste\n      else i--; // Norte\n    } else { // Date la vuelta\n        dir = (dir + 2) % 4;\n      if (dir == 0) j++; // Este\n        else if (dir == 1) i++; // Sur\n        else if (dir == 2) j--; // Oeste\n      else i--; // Norte\n    }\n // Verificar si se sale del mapa\n  if (i < 0 || i >= n || j < 0 || j >= m) return false;\n return true;\n}\n\nint main() {\n   cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  cin >> n >> m;\n    mapa.resize(n, vector<int>(m));\n   for (int i = 0; i < n; i++) {\n     for (int j = 0; j < m; j++) {\n         cin >> mapa[i][j];\n        }\n }\n int i = 0, j = 0, dir = 0; // Posicion inicial (0,0) viendo al Este\n    while (i != n - 1 || j != m - 1) { // Mientras no llegue al Tec\n       if (!mover(i, j, dir)) { // Simular movimiento\n            cout << \"te perdiste\\n\";\n           return 0;\n     }\n }\n cout << \"llegaste\\n\";\n\n    return 0;\n}\n"
    },
    {
        "titulo": "4103. Analizar palabra",
        "url": "https://omegaup.com/arena/problem/Analizar-palabra/",
        "descripcion": "Crear un programa para analizar palabras. Este programa recibirá una palabra solamente y a continuación revisará cuantas letras tiene, cuantas vocales y además imprimirá la cadena invertida.",
        "entrada": "Leer una cadena. Esta cadena será siempre una sola palabra, sin espacios.",
        "salida": "Debe imprimimir tres líneas: En la primera, la cantidad de letras que tiene la palabra. En la segunda, la cantidad de vocales que tiene la palabra (si se repiten también debe contarlas). Y en la tercera, la palabra invertida.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "int",
            "string",
            "tolower()",
            "reverse()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout.tie(0);\n  string palabra;\n  cin >> palabra;\n  int letras = palabra.length();\n  int vocales = 0;\n  for (char c : palabra) {\n   // Optimizacion: Convertir a minuscula para contar vocales sin importar mayusculas/minusculas\n    c = tolower(c);\n    if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n      vocales++;\n    }\n  }\n  reverse(palabra.begin(), palabra.end()); // Invertir la palabra\n  cout << letras << \"\\n\" << vocales << \"\\n\" << palabra << \"\\n\";\n\n  return 0;\n}\n"
    },
    {
        "titulo": "4028. Rango simple",
        "url": "https://omegaup.com/arena/problem/Rango-simple/",
        "descripcion": "Encontrar la cantidad de números que hay en un rango. Como entrada se tendrán N números y un rango. Lo único que debe hacer el programa es calcular la cantidad de números que hay dicho rango.",
        "entrada": "Leer primero N (1<=N<=100) que indica la cantidad de números que se leerán desde el teclado. En las siguientes N lineas se encuentran los datos de entrada. Al finalizar se tienen dos números enteros A y B (0<=A<=B<=1000) que indican el rango.",
        "salida": "Imprima la cantidad de números que existen en el rango desde A hasta B.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores"
        ],
        "estructuras": [
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n   cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  int N, A, B;\n  cin >> N;\n vector<int> nums(N);\n  for (int i = 0; i < N; ++i) {\n     cin >> nums[i];\n   }\n cin >> A >> B;\n    int count = 0;\n    for (int i = 0; i < N; ++i) {\n     if (nums[i] >= A && nums[i] <= B) {\n           count++;\n      }\n }\n cout << count << endl;\n\n  return 0;\n}\n"
    },
    {
        "titulo": "10694. Formula general",
        "url": "https://omegaup.com/arena/problem/Formula-general-/",
        "descripcion": "Escriba un programa que calcule las soluciones de una ecuación de segundo grado de la forma a*x^2+b*x+c=0, teniendo en cuenta que: x=(-b+-sqrt(b^2-4*a*c))/(2*a).",
        "entrada": "En las primeras tres lineas recibirás el valor de a, b y c.",
        "salida": "Mostrar el resultado de X_i y X_2.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Cálculo matemático"
        ],
        "estructuras": [
            "long long",
            "double",
            "sqrt()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  long long a, b, c;\n    cin >> a >> b >> c;\n   long long discriminante = b*b - 4*a*c;\n    if (discriminante < 0){\n       cout << \"La ecuacion no tiene soluciones reales\\n\"; \n   } else {\n      double x1 = (-b + sqrt(discriminante)) / (2*a);\n       double x2 = (-b - sqrt(discriminante)) / (2*a);\n       cout << \"X1 = \" << x1 << endl;\n      cout << \"X2 = \" << x2 << endl;\n  }\n\n   return 0;\n}\n"
    },
    {
        "titulo": "10471. Contando los segundos",
        "url": "https://omegaup.com/arena/problem/Contando-los-segundos/",
        "descripcion": "Ya es febrero y Luis está tan emocionado por ver a su novia Lucía en San Valentín que cuenta hasta los segundos que faltan para poder verla, o algo así. A Luis no es muy bueno con las cuentas, por eso pide tu ayuda para saber cuántos días, horas, minutos y segundos faltan para poder reunirse con su amada en este día especial. Tu tarea será ayudar al enamorado. Luis te dirá qué día es hoy y qué hora, minuto y segundo marca en su reloj, y en base a eso, le tendrás que decir cuántos días, horas, minutos y segundos faltan para las 00:00:00 del 14 de febrero, como Luis es muy distraído es posible que ya sea 14 de febrero, en cuyo caso solo te queda desearle un \"Feliz San Valentin\", o incluso que se le haya pasado la fecha, en cuyo caso tendrás que decir \"Mas suerte a la siguiente\".",
        "entrada": "Recibirás cuatro enteros d (29>=d>=0), h (12>=h>=0), m (59>=m>=0) y s (59>=s>=0); que indican el día, la hora, minuto y segundo en el reloj de Luis cuando empieza a contar.",
        "salida": "Cuatro enteros expresando los días, horas, minutos y segundos que faltan para el 14 de febrero. En caso de que ya sea 14 de febrero únicamente el mensaje \"Feliz San Valentin\" o bien el mensaje \"Mas suerte a la siguiente\" en caso de que la fecha se haya pasado.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Cálculo matemático"
        ],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int d, h, m, s;\n    cin >> d >> h >> m >> s;\n    if (d > 14) {\n        cout << \"Mas suerte a la siguiente\\n\";\n    } else if (d == 14) {\n        cout << \"Feliz San Valentin\\n\";\n    } else {\n        int totalSegundos = (14 - d - 1) * 86400 + (24 - h - 1) * 3600 + (60 - m - 1) * 60 + (60 - s); \n        int dias = totalSegundos / 86400;\n        totalSegundos %= 86400;\n        int horas = totalSegundos / 3600;\n        totalSegundos %= 3600;\n        int minutos = totalSegundos / 60;\n        totalSegundos %= 60;\n        cout << dias << \" \" << horas << \" \" << minutos << \" \" << totalSegundos << \"\\n\";\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "3172. occ15nsf21",
        "url": "https://omegaup.com/arena/problem/funcion_convergente/",
        "descripcion": "Considere una función f(n) definida así: f(n)=n/2 si n es par. f(n)=3n+1 si n es impar. Cuando se aplica repetidamente esta funcion a un número siempre se llega a 1. Por ejemplo si se comienza con 5, se tiene: f(5)=16 -> f(16)=8 -> f(8)=4 ->f(4)=2 -> f(2)=1. En este caso se aplica la función 5 veces para llegar a 1. Haga un programa que dado un numero n diga cuántas veces hay que aplicar f para llegar a 1.",
        "entrada": "Un entero n positivo.",
        "salida": "El número de veces que hay que aplicar f para llegar a 1.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Cálculo matemático"
        ],
        "estructuras": [
            "int",
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long n;\n    cin >> n;\n    int pasos = 0;\n    while (n != 1) {\n        if (n % 2 == 0) {\n            n /= 2;\n        } else {\n            n = 3 * n + 1;\n        }\n        pasos++;\n    }\n    cout << pasos << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "9533. RooClub",
        "url": "https://omegaup.com/arena/problem/RooClub/",
        "descripcion": "El club deportivo Cancún Caribe, está compuesto por N cantidad de socios. Debido a su impecable servicio y amplias instalaciones, se implementaron dos disciplinas deportivas más (futbol y atletismo); en las cuales una cantidad A, se inscribió en atletismo y una cantidad F, lo hizo en futbol, el resto R decidió no inscribirse a ninguna de las dos. Sin embargo hubo quienes aprovecharon y se inscribieron en ambas disciplinas. Con el objetivo de ofrecer un servicio plus que consiste en obsequiarles bebidas isotónicas para mitigar el desgaste y mantener una buena hidratación, solo a aquellos socios que se inscribieron a las dos disciplinas, se requiere saber la cantidad total de estos. Elabora un programa que permita conocer la cantidad total de socios que se inscribieron a las dos disciplinas, así como la cantidad total de socios que solo se inscribieron en atletismo y de los que solo lo hicieron a futbol.",
        "entrada": "Deberás leer un valor N (10<=N<=1000), que representa la cantidad total de socios que integran el club deportivo, así como una variable A que representa los socios inscritos en atletismo, una variable F que representa los socios inscritos en futbol y una variable R que representa a los socios que decidieron NO inscribirse a ninguna de las dos disciplinas (2<=A,F,R<=N/2).",
        "salida": "Deberás imprimir en una sola línea tres valores separados por un espacio, el primero que representa la cantidad de socios que se inscribieron a las dos disciplinas y quienes recibirán bebidas isotónicas; el segundo que representa la cantidad de socios que solo se inscribió en atletismo y el tercer valor que representa a los socios que hicieron lo propio solo a futbol.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Cálculo matemático"
        ],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int a, b, c, d;\n    cin>>a>>b>>c>>d;\n    if(a-b-c-d<=0){\n        cout<<abs(a-b-c-d)<<\" \"<<abs(a-c-d)<<\" \"<<abs(a-b-d);\n    }\n    else{\n        cout<<\"0 \"<<b<<\" \"<<c;\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "6818. Los Ultimos Seran Los Primeros",
        "url": "https://omegaup.com/arena/problem/Los-Ultimos-Seran-Los-Primeros/",
        "descripcion": "En una carrera en el pueblo de Yahualica todos los participantes creen que el que llegue primero será el ganador, pero no, las reglas son diferentes en Yahualica, el ganador es el que llega al último. Escribe un programa que dados los nombres de los concursantes como van cruzando la meta, imprima dichos nombres en orden de acuerdo al lugar que consiguieron en la competencia (El que llego al último obtiene el primer lugar, el penúltimo el segundo lugar, y así sucesivamente).",
        "entrada": "Varios nombres de concursantes como van cruzando la meta. La entrada termina con el string \"#\".",
        "salida": "Los nombres en orden al lugar que ocuparon en la competencia.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas",
            "Pilas"
        ],
        "estructuras": [
            "string",
            "stack<string>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    string nombre;\n    stack<string> pilaDeNombres;\n    // Leer nombres hasta encontrar \"#\"\n    while (cin >> nombre, nombre != \"#\") {\n        pilaDeNombres.push(nombre);\n    }\n    // Imprimir nombres en orden inverso\n    while (!pilaDeNombres.empty()) {\n        cout << pilaDeNombres.top() << \"\\n\";\n        pilaDeNombres.pop();\n    }\n\n     return 0;\n}\n"
    },
    {
        "titulo": "1900. Números pitagóricos",
        "url": "https://omegaup.com/arena/problem/Numeros-pitagoricos/",
        "descripcion": "Es bien conocido que las ternas pitagóricas son aquellas donde la suma de los cuadrados de dos de los numeros, te da el tercero al cuadrado. ¿Podrías identificar una terna pitagórica?",
        "entrada": "Una sola linea. Tres números enteros: a, b y c, tales que 0<=a,b,c<=1000.",
        "salida": "Una sola palabra, en una linea, \"Si\" o \"No\" si la terna es pitagórica o no.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Cálculo matemático"
        ],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int a, b, c;\n    cin >> a >> b >> c;\n    // Verificar todas las posibles combinaciones para la terna pitagorica\n    if (a*a + b*b == c*c || a*a + c*c == b*b || b*b + c*c == a*a) {\n        cout << \"Si\\n\";\n    } else {\n        cout << \"No\\n\";\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "4220. Contando Dinero",
        "url": "https://omegaup.com/arena/problem/ENIGMA/",
        "descripcion": "Un luchador de la EAW (Extreme Wrestling Action) que se hace llamar Enigma, ha estado ganando mucho dinero los ultimos meses; y aunque es muy bueno para las matematicas, aveces se le hace dificil hacer algunas sumas, ya sea que se equivoca o lo hace muy lento. El te dara una recompensa si lo haces bien y en menos tiempo de que el lo haria. El te dara un numero N de meses y luego N_i que es el dinero que gano en el i-esimo mes, luego te dara un numero M de consultas a realizar, por cada consulta te da 2 numeros l y r, y tu tendras que responderle rapidamente la suma total del dinero que gano entre el mes l y el mes r. Por ejemplo, si N = 5, y el dinero que gano en cada mes es 100 200 300 400 500 respectivamente; para la consulta l = 1 y r = 5, el resultado seria 1500, y si l = 2 y r = 4 entonces la suma seria 900.",
        "entrada": "En la primera linea un numero N (1<=N<=10^5), en la 2da linea N numeros que es la cantidad de dinero que Enigma gana en el i-esimo mes (-10^9<=N_i<=10^9). En la tercer linea un numero M (1<=M<=10^5) que es el numero de consultas a realizar, luego M lineas, en cada consulta dos enteros L y R (1<=L,R<=10^5).",
        "salida": "Por cada consulta, imprimir un entero indicando la suma total de dinero que Enigma gana entre los meses L y R.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores",
            "Suma de prefijos"
        ],
        "estructuras": [
            "int",
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long ganancias[100005]; // Arreglo para almacenar las ganancias de Enigma\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int N, M;\n    cin >> N;\n    // Lectura de las ganancias de cada mes\n    for (int i = 1; i <= N; ++i) {\n        cin >> ganancias[i];\n        ganancias[i] += ganancias[i - 1]; // Calcular la suma acumulada\n    }\n    cin >> M;\n    // Procesamiento de las consultas\n    for (int i = 0; i < M; ++i) {\n        int L, R;\n        cin >> L >> R;\n        cout << ganancias[R] - ganancias[L - 1] << \"\\n\"; // Imprimir la suma entre L y R\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "65. Patos",
        "url": "https://omegaup.com/arena/problem/patos/",
        "descripcion": "El señor Dengklek vive en el Reino de los Patos, donde humanos y patos viven juntos en paz y harmonía. Los patos estan numerados por números enteros positivos distintos de A a B, inclusive, donde A<=B. La última noche, el señor Dengklek no podía dormir, así que salió de su casa a intentar contar todos los patos en el reino. Cada vez que veía a un nuevo pato, decía su número en voz alta. El señor Dengklek sólo decía sus números (números que van de A a B). Nunca dijo el mismo número dos veces ni tampoco se tomó la molestia de decirlos en orden. Es posible que el señor Dengklek no haya visto a algunos patos. Obviamente, el número de patos que no vió depende de los valores de A y B. Los valores A y B son desconocidos para tí. Calcula el menor número de patos que el señor Dengklek se pudo haber perdido.",
        "entrada": "Un entero positivo N (1<=N<=50) con la cantidad de patos que el señor Dengklek vio. En la siguiente línea, habrá N números, representando los números de los patos que fueron vistos. Cada número de pato es un entero entre el 1 y el 100, inclusive. Todos los N_i números en la entrada son distintos.",
        "salida": "Un entero representando el menor número de patos que el señor Denglklek se pudo haber perdido.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores",
            "Cálculo matemático"
        ],
        "estructuras": [
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    //Code here\n    int N;\n    cin >> N;\n    vector<int> patosVistos(101, 0); \n    for (int i = 0; i < N; ++i) {\n        int pato;\n        cin >> pato;\n        patosVistos[pato] = 1; \n    }\n    int A = 1;\n    while (!patosVistos[A]) {\n        A++;\n    }\n    int B = 100;\n    while (!patosVistos[B]) {\n        B--;\n    }\n    int patosPerdidos = B - A + 1 - N;\n    cout << patosPerdidos << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "3581. La llave dorada",
        "url": "https://omegaup.com/arena/problem/Alicia-y-la-llave-dorada/",
        "descripcion": "Después de que la gran caída por el agujero terminó, Alicia se encontraba ilesa y frente a un largo pasillo con muchas puertas de cerraduras diversas. Un poco más adelante se encontraba una mesa de cristal con una llave dorada. Alicia quería salir de ahí tan pronto como fuera posible y pensó que seguramente alguna puerta correspondía con la llave, así tuviera que girar la llave para poder insertarla en la cerradura. Ayuda a Alicia a encontrar la puerta correcta.",
        "entrada": "Un entero N seguido de una matriz de N*N caracteres . y # que representa la forma de la llave. Posteriormente un entero M seguido de M matrices de N*N caracteres que representan las cerraduras de las M puertas, numeradas de 1 a M. Puedes suponer que 1<=N,M<=100. La entrada puede contener saltos de línea adicionales para separar los datos de la misma y deben ser ignorados.",
        "salida": "Un entero que es el número de la puerta que abre con la llave dada o -1 si ninguna puerta abre. La llave puede girarse 90, 180 o 270 grados.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Matrices",
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "bool",
            "int",
            "vector<vector<char>>",
            "vector<vector<vector<char>>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<vector<char>> rotarMatriz(const vector<vector<char>> &matriz) {\n    int n = matriz.size();\n    vector<vector<char>> rotada(n, vector<char>(n));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            rotada[j][n - 1 - i] = matriz[i][j];\n        }\n    }\n    return rotada;\n}\n\nbool compararMatrices(const vector<vector<char>> &llave, const vector<vector<char>> &cerradura) {\n    int n = llave.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (llave[i][j] != cerradura[i][j]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int n, m;\n    cin >> n;\n    vector<vector<char>> llave(n, vector<char>(n));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cin >> llave[i][j];\n        }\n    }\n    cin >> m;\n    vector<vector<vector<char>>> cerraduras(m, vector<vector<char>>(n, vector<char>(n)));\n    for (int k = 0; k < m; ++k) {\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                cin >> cerraduras[k][i][j];\n            }\n        }\n    }\n    int puerta = -1;\n    for (int k = 0; k < m; ++k) {\n        for (int r = 0; r < 4; ++r) { \n            if (compararMatrices(llave, cerraduras[k])) {\n                puerta = k + 1;\n                break;\n            }\n            llave = rotarMatriz(llave); \n        }\n        if (puerta != -1) {\n            break; \n        }\n    }\n    cout << puerta << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "6844. La Aventura de Kirby",
        "url": "https://omegaup.com/arena/problem/La-Aventura-de-Kirby/",
        "descripcion": "Oh no! Kirby se ha perdido en DreamLand! El malvado Meta Knight lo ha lanzado desde el Halberd y ahora el pobre no sabe donde esta... Afortunadamente, Kirby no esta solo... Cuenta con tu ayuda!. Con tus increíbles habilidades de programación puedes ayudarlo a hacer un mapa y encontrar la salida. El lugar donde kirby ha caído cuenta con N puertas, cada una con un numero. La salida tiene el numero K en ella. Ayuda a kirby a encontrar la posición en la que esta la salida.",
        "entrada": "En la primera linea un numero N (1<=N<=1000) que denota la cantidad de puertas en el area seguido de un numero K (0<=K<=1000) que corresponde al numero que tendra la salida. En la segunda linea N numeros, que seran el valor de cada puerta N_i.",
        "salida": "La posición en la que esta la puerta que lleva a la salida (las posiciones se cuentan desde 0). Si ninguna puerta cumple la condición imprime \"Poyo :(\" (Sin las comillas).",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores"
        ],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int N, K;\n    cin >> N >> K;\n    int puerta;\n    for (int i = 1; i <= N; ++i) {\n        cin >> puerta;\n        if (puerta == K) {\n            cout << i << endl;\n            return 0;\n        }\n    }\n    cout << \"Poyo :(\" << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "8658. Intervalo maximo consecutivo",
        "url": "https://omegaup.com/arena/problem/Intervalo-maximo-consecutivo/",
        "descripcion": "Dado un arreglo de tamaño N determine la longitud del intervalo más grande entre dos elementos consecutivos cuando el arreglo está ordenado de mayor a menor.",
        "entrada": "Un entero N seguido de N enteros. Puedes suponer que 1<=N<=1000.",
        "salida": "Un entero que representa la longitud del intervalo más grande.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores",
            "Ordenamiento"
        ],
        "estructuras": [
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int N;\n    cin >> N;\n    vector<int> arr(N);\n    for(auto i = 0; i < N; i++){\n        cin >> arr[i];\n    }\n    sort(arr.rbegin(), arr.rend()); // Ordenar de mayor a menor\n    int maxDiff = 0;\n    for(auto i = 1; i < N; i++){\n        maxDiff = max(maxDiff, arr[i - 1] - arr[i]);\n    }\n    cout << maxDiff << \"\\n\";\n\n    return 0;\n}\n"
    },
    {
        "titulo": "7186. Girando un vector",
        "url": "https://omegaup.com/arena/problem/Girando-vector/",
        "descripcion": "Escriba un programa que lea dos números enteros positivos N,G y un vector X de N componentes enteras y que escriba el vector Y de N componentes formado al girar G veces el vector X hacia la derecha. Al hacer esto, la componente más a la derecha de X se debe colocar en la componente más a la izquierda de Y. Por ejemplo, si N=5, X=(3,1,4,1,5), al girarlo una vez (G=1), se obtiene el vector Y=(5,3,1,4,1); y si se girara una vez más (G=2), se obtendría el vector Y=(1,5,3,1,4), etcétera.",
        "entrada": "Consiste de dos números enteros, N y G, separados por un espacio, con valores entre 1 y 100, y en la siguiente línea, N números enteros, separados por espacios, cada uno con valor entre 0 y 9 (las componentes de X).",
        "salida": "Consiste de N números enteros separados por espacios (las componentes de Y).",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores"
        ],
        "estructuras": [
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int N, G;\n    cin >> N >> G;\n    vector<int> X(N), Y(N);\n    for (int i = 0; i < N; ++i) {\n      cin >> X[i];\n    }\n    // Optimizar las rotaciones utilizando el m?ulo\n    G %= N; \n    for (int i = 0; i < N; ++i) {\n      Y[i] = X[(i - G + N) % N]; \n    }\n    for (int i = 0; i < N; ++i) {\n      cout << Y[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "6542. Frase Volteada",
        "url": "https://omegaup.com/arena/problem/Frase-Volteada/",
        "descripcion": "Dada una frase compuesta de letras y espacios, cambia el orden de las palabras para que queden exactamente al revés de como estaban inicialmente, pero haciendo que cada palabra: #1. Si inicia con mayúscula, dejarla igual, #2. Si no, voltear el orden de las letras y hacer que inicie en mayúscula.",
        "entrada": "Una sola entrada, como está descrita en el problema.",
        "salida": "Una sola salida, como está descrita en el problema.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "char",
            "string",
            "reverse()",
            "getline()",
            "vector<string>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n// Funci? para invertir una palabra\nstring invertirPalabra(string palabra) {\n    reverse(palabra.begin(), palabra.end());\n    return palabra;\n}\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    string frase;\n    getline(cin, frase);\n    string palabraActual = \"\";\n    vector<string> palabras;\n    // Separar la frase en palabras\n    for (char c : frase) {\n        if (c == ' ') {\n            palabras.push_back(palabraActual);\n            palabraActual = \"\";\n        } else {\n            palabraActual += c;\n        }\n    }\n    palabras.push_back(palabraActual);\n    // Invertir el orden de las palabras\n    reverse(palabras.begin(), palabras.end());\n    // Imprimir las palabras procesadas\n    for (int i = 0; i < palabras.size(); i++) {\n        if (isupper(palabras[i][0])) {\n            cout << palabras[i] << \" \";\n        } else {\n            palabras[i] = invertirPalabra(palabras[i]);\n            palabras[i][0] = toupper(palabras[i][0]);\n            cout << palabras[i] << \" \";\n        }\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "7465. Esta difícil joven, hoy no circula",
        "url": "https://omegaup.com/arena/problem/Esta-dificil-joven-hoy-no-circul/",
        "descripcion": "Con la entrada del nuevo gobierno, se planea un cambio a la reglamentación del famoso \"Hoy no circula\", en la que en vez de ver que día de la semana es, se verifica qué día del mes es y se siguen las siguientes reglas: • Los automóviles cuya placa contenga un número par solamente podrán circular los días pares del mes. • Los automóviles cuya placa contenga un número impar solamente podrán circular los días impares del mes. • El monto de la multa cambia diariamente. Ricardo es un oficial de policía muy flojo, por lo que en vez de aplicar las multas correspondientes inmediatamente, él va anotando las placas de todos los coches que pasan por enfrente de su tienda de donas favorita y aplica las multas al final del día. Ricardo te preguntó si tu \"le sabes\" a eso de las computadoras y te pidió que le hicieras una herramienta para ver el total de dinero que se va a recaudar debido a las multas que aplicará.",
        "entrada": "Un número N que representa cuántas placas Ricardo anotó mientras comía donas. N líneas que contienen los números de las N placas que Ricardo anotó. D, el número de día del mes, y, M, el monto de cuánto se cobrará de multa ese día.",
        "salida": "El monto total de las multas que se aplicarán ese día.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Cálculo matemático"
        ],
        "estructuras": [
            "int",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int N;\n    cin >> N; \n    // Dado que solo nos interesa la paridad de la placa, \n    // no es necesario almacenar el n?mero completo.\n    int placas_pares = 0; \n    for (int i = 0; i < N; ++i) {\n        string placa; \n        cin >> placa;\n        // Verificamos el ?ltimo d?ito de la placa\n        if ((placa.back() - '0') % 2 == 0) {\n            placas_pares++; \n        }\n    }\n    int D, M;\n    cin >> D >> M;\n    int total_multas = 0;\n    if (D % 2) { \n        total_multas = placas_pares * M;\n    } else {\n        total_multas = (N - placas_pares) * M;\n    }\n    cout << total_multas << \"\\n\";\n\n    return 0;\n}\n"
    },
    {
        "titulo": "6169. Encontrar valor",
        "url": "https://omegaup.com/arena/problem/Encontrar-valor/",
        "descripcion": "Hacer un programa que diga si un valor introducido desde teclado se encuentra o no en un arreglo. Si está en él, ha de mostrar la posición que ocupa.",
        "entrada": "Un entero N que indica la cantidad de elementos del arreglo (Un arreglo en orden ascendente). Las siguientes N lineas un entero que indica un elemento del arreglo. Un entero K que indica el valor que se quiere encontrar.",
        "salida": "Si el valor esta en el arreglo, mostrar la posición (en caso de que aparezca en dos posiciones, mostrar la menor). Si el valor no esta en el arreglo, mostrar \"NO\".",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores",
            "Búsqueda binaria"
        ],
        "estructuras": [
            "long long",
            "vector<long long>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d;\n    vector<long long>falta;\n    cin>>a;\n    while(a--){\n        cin>>b;\n        falta.push_back(b);\n    }\n    cin>>a;\n    b=0;\n    c=falta.size()-1;\n    while(b<=c){\n        d=(b+c)/2;\n        if(falta[d]==a){\n            while(d>-1 && falta[d]==a){\n                d--;\n            }\n            cout<<d+1;return 0;\n        }\n        else if(falta[d]<a){\n            b=d+1;\n        }\n        else{\n            c=d-1;\n        }\n    }\n    cout<<\"NO\";\n    \n    return 0;\n}\n"
    },
    {
        "titulo": "4984. EncuentraDivisibles",
        "url": "https://omegaup.com/arena/problem/EncuentraDivisibles/",
        "descripcion": "Dada una lista de 5 números naturales, identifica si algún número de la lista divide a algún otro.",
        "entrada": "5 números naturales, uno en cada renglón.",
        "salida": "La frase: \"Existen\" si existe dentro de la lista un número que divida exactamente a otro. La frase: \"No existen\" si ningún elemento de la lista divide exactamente a otro.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores"
        ],
        "estructuras": [
            "bool",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    vector<int> numeros(5);\n    for (int i = 0; i < 5; ++i) {\n        cin >> numeros[i];\n    }\n    bool existen = false;\n    for (int i = 0; i < 5; ++i) {\n        for (int j = 0; j < 5; ++j) {\n            if (i != j && numeros[i] != 0 && numeros[j] % numeros[i] == 0) {\n                existen = true;\n                break;\n            }\n        }\n    }   \n    if (existen) {\n        cout << \"Existen\\n\";\n    } else {\n        cout << \"No existen\\n\";\n    }\n    \n    return 0;\n}\n"
    },
    {
        "titulo": "1781. Elevador",
        "url": "https://omegaup.com/arena/problem/elevador/",
        "descripcion": "En el edificio más grande de nuestra ciudad, hay un sólo elevador. Una lista de peticiones se hace con N números positivos. El número indica a cuales pisos se detendrá el elevador, en un orden específico. 6 segundos se tarda el elevador en subir un piso, y 4 segundos en bajar un piso. El elevador se quedará por 5 segundos en cada parada. Dada una lista de peticiones, deberás calcular el total de tiempo que se necesitará para atender todas las peticiones de la lista. Todos los números en la entrada son menos a 100. El elevador inicia en el piso 0 al comienzo y no tiene que regresar cuando la lista se haya terminado.",
        "entrada": "Una línea con un entero positivo  N que indica el número de peticiones, seguido de N números positivos. Todos los números son menores que 100.",
        "salida": "Despliega el total de tiempo en una sóla línea, que el elevador tardará en procesar la lista de peticiones.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Cálculo matemático"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b=0, c=0, d;\n    cin>>a;\n    b+=(a*5);\n    while(a--){\n        cin>>d;\n        if(d>c){\n            b+=((d-c)*6);\n        }\n        else if(d<c){\n            b+=((c-d)*4);\n        }\n        c=d;\n    }\n    cout<<b;\n\n    return 0;\n}"
    },
    {
        "titulo": "5410. El elevador",
        "url": "https://omegaup.com/arena/problem/El-elevador-ASINUS/",
        "descripcion": "La torre Latinoamericana es uno de los edificios más emblemáticos de la Ciudad de México, ahí trabaja Chema, quien es el encargado del control del elevador. Sin embargo últimamente ha tenido algunos problemas ya que su supervisor ha recibido quejas de que el elevador no responde cuando lo mandas llamar, por lo cual el supervisor de Chema, supone que como ha comenzado un noviazgo con una señorita en el piso 21 se detiene en este piso, provocando que se ponga lento el servicio al hacer esperar a la gente que desea subir al mirador. Para solucionar el problema el supervisor desea instalar un programa en el elevador que le reporte cuáles pisos fueron visitados por Chema durante los recorridos, ya que el supervisor se encuentra en la recepción le será fácil general el reporte una vez que Chema regrese al Lobby y así saber si se detuvo en algún momento en el piso 21. Ayuda al supervisor con el programa para el elevador, en el cual se registren todos los pisos que visitó durante el recorrido, para al llegar al Lobby nuevamente se pueda imprimir un reporte con los pisos, en caso de que entre los pisos no aparezca el piso 21, sólo se generará el reporte, pero en caso de que sí aparezca, al final de la lista deberá de indicarse ALERTA.",
        "entrada": "N como el número pisos que visitó durante el recorrido >0 y <=45. Seguido del número de cada piso que se visitó.",
        "salida": "El registro de los pisos visitados. En caso de que no visitara el piso 21, sólo el registro, pero en caso de que visitara el piso 21, al final del registro se imprimirá: ALERTA. El número de pisos visitados debe ser >0 y <=45, de lo contrario se marcará \"ERROR\". El número de piso capturado debe ser >0 y <=45, de lo contrario se marcará \"ERROR\". El Lobby no se contará en los registros.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores"
        ],
        "estructuras": [
            "long long",
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c=0;\n    vector<long long>falta;\n    cin>>a;\n    if(a<=0 || a>45){\n        cout<<\"ERROR\";return 0;\n    }\n    while(a--){\n        cin>>b;\n        if(b==21){\n            c++;\n        }\n        else if(b==0){\n            cout<<\"ERROR\";return 0;\n        }\n        falta.push_back(b);\n    }\n    for(auto i=0; i<falta.size(); i++){\n        cout<<falta[i]<<\"\\n\";\n    }\n    if(c){\n        cout<<\"ALERTA\";\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "4085. El Intervalo y el divisor",
        "url": "https://omegaup.com/arena/problem/Multiplos-en-el-intervalo/",
        "descripcion": "Teniendo un intervalo de A y B, calcule cuantos números son divisibles por el número N.",
        "entrada": "Un número entero N, que representa el valor del divisor y dos números, A y B que representan el valor inicial y el final del intervalo respectivamente. Límites no establecidos",
        "salida": "Un solo número que representa la cantidad de números cuyo divisor es N",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Cálculo matemático"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c;\n    cin>>a>>b>>c;\n    cout<<(c/a)-((b-1)/a);\n    \n    return 0;\n}"
    },
    {
        "titulo": "814. Ej2.- Orden inverso",
        "url": "https://omegaup.com/arena/problem/Ej2--Orden-inverso/",
        "descripcion": "Elabora un programa que lea una secuencia de N palabras y las imprima en orden inverso.",
        "entrada": "N .- Numero de palabras, N palabras en N lineas diferentes (2<N<100).",
        "salida": "N lineas con las palabras en el orden inverso al que se leyeron.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Ciclos",
            "Caracteres y cadenas",
            "Pilas"
        ],
        "estructuras": [
            "string",
            "long long",
            "stack<string>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a;\n    stack<string>falta;\n    string z;\n    cin>>a;\n    while(a--){\n        cin>>z;\n        falta.push(z);\n    }\n    while(falta.size()){\n        cout<<falta.top()<<\"\\n\";\n        falta.pop();\n    }\n        \n    return 0;\n}\n"
    },
    {
        "titulo": "12322. Infección de negativos",
        "url": "https://omegaup.com/arena/problem/Infeccion-de-negativos-ANH/",
        "descripcion": "Los científicos del lugar (los de notación científica), han encontrado una vacuna en poco tiempo, pero ahora deben ubicar a todos los contagiados para poderlos vacunar primero y detener el contagio. Pero son muchos y sólo pueden probar a grupos de 30. Te contrataron para detectar a los infectados.",
        "entrada": "30 números enteros entre -10 y 50",
        "salida": "Los índices en los que se encuentran los números negativos separados por un espacio y la cantidad total de números negativos que hay en el grupo",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Vectores"
        ],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b=0, c, d, e, f, g, h;\n    for(auto i=0; i<30; ++i){\n        cin>>a;\n        if(a<0){\n            cout<<i<<\" \";\n            b++;\n        }\n    }\n    cout<<b;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "12323. Leer al reves",
        "url": "https://omegaup.com/arena/problem/Leer-al-reves-ANH/",
        "descripcion": "Ellos deben ingresar una palabra y el programa debe imprimirla al revés, de esta manera será más fácil leerla para ellos.",
        "entrada": "Una palabra con N caracteres",
        "salida": "La palabra escrita al revés.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e, f, g, h;\n   string s;\n    getline(cin,s);\n    reverse(s.begin(),s.end());\n    cout<<s;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "11614. Imprimir un arreglo al revez",
        "url": "https://omegaup.com/arena/problem/Imprimir-un-arreglo-al-revez/",
        "descripcion": "Leer un arreglo de N numeros e imprimirlo al revez.",
        "entrada": "En la primera linea de entrada un numero entero N (1<=N<=100). En la segunda linea de entrada, habra N numeros enteros que representan los elementos del arreglo",
        "salida": "El arreglo de N enteros, impreso al revez.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Vectores"
        ],
        "estructuras": [
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e, f, g, h;\n   vector<int>num(1000000,0);\n    cin>>a;\n    for(auto i=0; i<a; ++i){\n        cin>>num[i];\n    }\n    for(auto i=a-1; i>=0; --i){\n        cout<<num[i]<<\" \";\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "11773. Sumando Arreglos",
        "url": "https://omegaup.com/arena/problem/Sumando-Arreglos/",
        "descripcion": "En este problema realizaras la suma de dos arreglos con el mismo tamaño y varios números ya sean iguales o diferentes;",
        "entrada": "Un numero entero N que indicara el tamaño de los arreglos; Los siguientes N números serán los números de los arreglos;",
        "salida": "Una fila de la suma de los arreglos separados por un espacio;",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Vectores"
        ],
        "estructuras": [
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e, f, g, h;\n   vector<int>num(1000000,0);\n    cin>>a;\n    for(auto i=0; i<a; ++i){\n        cin>>num[i];\n    }\n    for(auto i=0; i<a; ++i){\n        cin>>b;\n        cout<<num[i]+b<<\" \";\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "10173. Parasoul",
        "url": "https://omegaup.com/arena/problem/Parasoul/",
        "descripcion": "Los amigos del mago siguen sin ser pros en programación, por lo que necesitan tu ayuda para resolver este problema y así entender mejor para no reprobar el siguiente semestre.",
        "entrada": "Tres números de tipo entero, N_1, N_2 y N_3, en donde se debe evaluar cual es el numero mayor. Si al menos uno de los números introducidos es diferente al resto, entonces solicitara un numero N el cual sera las veces que se mostrara el numero mayor en un aumento de 2. En caso de que los 3 numeros sean iguales, solo habra 3 datos como entrada.",
        "salida": "Mostrar X (el numero mayor de los 3 números) seguido del mismo valor pero aumentando +2 hasta N veces. En caso de que los 3 números sean iguales, mostrar X seguido del mismo valor aumentando +2 hasta 7 veces.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  long long a, b, c, d, e, f, g, h;\n cin>>a>>b>>c;\n if(a==b && a==c){\n     cout<<a<<\"\\n\"<<a+2<<\"\\n\"<<a+4<<\"\\n\"<<a+6<<\"\\n\"<<a+8<<\"\\n\"<<a+10<<\"\\n\"<<a+12<<\"\\n\"<<a+14;return 0;\n    }\n cin>>d;\n   a=max(max(a,b),c);\n    cout<<a<<\"\\n\";\n for(auto i=1; i<=d; ++i){\n      cout<<a+2*i<<\"\\n\";\n }\n\n   return 0;\n}\n"
    },
    {
        "titulo": "9464. B07 Mientras tanto",
        "url": "https://omegaup.com/arena/problem/B07-Mientras-tanto/",
        "descripcion": "Komugi es la mejor jugadora de Gungi del mundo. Pero con el avance de un nuevo contrincante Meruem parece ser que no podra tener el titulo de campeona para siempre. Pero como campeona de gungi que es, ella sabe que cosas como derrota no es una opcion, todo el tiempo es victoria o nada. Sin embargo, la derrota nos llega a todos, de una forma u otra, pero no hay que ponerse tristes por la derrota, siempre podemos ver para atras y ver cuantos puntos ganamos hasta este momento. Ayuda a Komugi a saber cuantos puntos obtuvo hasta su momento de la derrota, aunque no sabes en cuantos juegos participo sabes cuanto puntos obtuvo, que siempre representan una cantidad positiva excepto en el que pierde que se representa con un 0, despues del juego que perdio con 0 puntos no hay mas juegos.",
        "entrada": "Varios numeros positivos N menores a 100000 y un numero 0 que representa el final",
        "salida": "La suma total de los puntos conseguidos por Komugi.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  long long a=1, b=0, c, d, e, f, g, h;\n while(a){\n     cin>>a;\n       b+=a;\n }\n cout<<b;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "12110. Clasificando mascotas",
        "url": "https://omegaup.com/arena/problem/CR-2020-Clasificando-mascotas/",
        "descripcion": "Andrea tiene muchas mascotas y le encanta complicarle la vida a sus amigos. Decidió que cuando le pregunten algo sobre sus mascotas les dirá lo siguiente: Si el nombre de la mascota tiene 5 letras o menos, entonces es un perro. Si tiene 6 o más letras, es un gato. Si el nombre de la mascota tiene alguna 'a' o alguna 'y', entonces su mascota es hembra. En caso contrario, es macho. Ayuda a los amigos de Andrea a que descubran que tipo de animal es cada una de sus mascotas.",
        "entrada": "En la primera línea un entero N indicando el número de mascotas que tiene Andrea. Después vendrán N líneas. Cada línea representa cada uno de los nombres de las mascotas de Andrea. NOTA: Se te asegura que todos los nombres contendrán únicamente letras minúsculas.",
        "salida": "Deberás imprimir 4 líneas en el siguiente orden y con el siguiente formato (sin comillas): \"Tiene W perros macho\", \"Tiene X perros hembra\", \"Tiene Y gatos macho\", \"Tiene Z gatos hembra\". Donde W es el número de perros macho que tiene Andrea, X el número de perros hembra, Y el número de gatos macho y Z el número de gatos hembra.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Vectores",
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "int",
            "vector<string>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  long long a, b, c=0, d=0, e=0, f=0, g, h;\n string z;\n cin>>a;\n   while(a--){\n       cin>>z;\n       b=0;\n      for(auto i=0; i<z.size(); ++i){\n            if(z[i]=='a' || z[i]=='y'){\n               b=1;break;\n            }\n     }\n     if(b && z.size()<6){\n          c++;\n      }\n     else if(!b && z.size()<6){\n            d++;\n      }\n     else if(b && z.size()>5){\n         e++;\n      }\n     else{\n         f++;\n      }\n }\n cout<<\"Tiene \"<<d<<\" perros macho\\nTiene \"<<c<<\" perros hembra\\nTiene \"<<f<<\" gatos macho\\nTiene \"<<e<<\" gatos hembra\";\n\n    return 0;\n}\n"
    },
    {
        "titulo": "8457. Dados apilados",
        "url": "https://omegaup.com/arena/problem/Dados-apilados/",
        "descripcion": "Un día mientras Juan jugaba con sus amigos, notó que al apilar un número n de dados sobre una mesa, la suma que resulta de todos los valores en las caras visibles se encuentra acotada entre un valor inferior y uno superior.",
        "entrada": "Un entero n que representa el número de dados apilados. Puedes suponer que 1<=n<=1000000.",
        "salida": "Dos enteros separados por un espacio que representan el valor inferior y superior de la suma de todas las caras visibles de los dados.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  int a;\n    cin>>a;\n   cout<<a*14+1<<\" \"<<a*14+6;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "11750. Comprobación de triángulos",
        "url": "https://omegaup.com/arena/problem/Comprobacion-de-triangulos/",
        "descripcion": "Desarrolle un programa en lenguaje C/C++ que dadas las longitudes de 3 lados a, b y c, determine si pueden formar un triángulo o no. Sugerencia: Puede utilizar la desigualdad del triángulo para verificar si dados 3 lados es posible formar un triángulo.",
        "entrada": "El programa deberá recibir por la entrada estándar los valores positivos de longitudes de 3 segmentos a, B y C.",
        "salida": "El programa deberá imprimir SI, cuando sea posible formar un triángulo con los valores introducidos. Deberá imprimir NO en otro caso.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  long long a, b, c, d, e, f, g, h;\n cin>>a>>b>>c;\n if(c>b){\n      swap(b,c);\n    }\n if(b>a){\n      swap(a,b);\n    }\n cout<<((a-b-c<0)?\"SI\":\"NO\");\n\n    return 0;\n}\n"
    },
    {
        "titulo": "11733. Mayores de Edad",
        "url": "https://omegaup.com/arena/problem/MayEdadANH/",
        "descripcion": "Resulta que mi tío invirtió en un antro, ahí por la calle Primera, pero al que contrato de cadenero no es muy bueno para sacar edades. Entonces cuando pide el ID a los clientes, ve el año de edad y el tipo no sabe si son o no mayores de edad. Así que mi tío pidió si podíamos crear un programa para ayudar al cadenero a saber si los que entran son mayores o menores de edad introduciendo su año de nacimiento y el año actual. Con que este año cumpla 18 con eso lo dejarán entrar.",
        "entrada": "Dos números enteros separados por un espacio, el primero representa el año de nacimiento y el segundo el año actual.",
        "salida": "La frase \"Mayor de edad\" si tendrá 18 o más al finalizar el presente año o la frase \"Menor de edad\" si no tendrá 18.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  long long a, b, c, d, e, f, g, h;\n cin>>a>>b;\n    cout<<((b-a>17)?\"Mayor de edad\":\"Menor de edad\");\n\n   return 0;\n}\n"
    },
    {
        "titulo": "10704. Hipotenusa",
        "url": "https://omegaup.com/arena/problem/Hipotenusa/",
        "descripcion": "Escriba un programa que lea de la entrada estándar los dos catetos de un triángulo rectángulo y escriba en la salida estándar su hipotenusa.",
        "entrada": "Dos números reales los cuales serán el cateto 1 y el cateto 2.",
        "salida": "El resultado de la hipotenusa mostrando dos decimales.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Cálculo matemático"
        ],
        "estructuras": [
            "double",
            "sqrt()",
            "fixed",
            "setprecision()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    double cateto1, cateto2, hipotenusa;\n    cin >> cateto1 >> cateto2;\n    hipotenusa = sqrt(cateto1 * cateto1 + cateto2 * cateto2);\n    cout << fixed << setprecision(2) << hipotenusa << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "10462. El Mandado",
        "url": "https://omegaup.com/arena/problem/El-Mandado-/",
        "descripcion": "Bajas de tu cuarto para comer, y justo cuando te sientas, te manda tu mamá a la tienda por refresco, papas amarillas, servilletas y leche. Llegas a la tienda y saludas a Don Stevan, la persona que atiende la tienda y te dice que por la noche lo abducieron los aliens y ha olvidado como hacer operaciones básicas, así que tendrás que hacerlas por ti mismo. ¡Recuerda que robar es malo! así que asegúrate de hacer las cuentas correctamente.",
        "entrada": "Dos enteros correspondientes a la cantidad y el precio (Tanto el precio y la cantidad son números enteros, y son menores a 100.) para cada uno de los productos. Estos siempre serán refresco, papas amarillas, servilletas y leche.",
        "salida": "El total que gastaste en la tienda.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int total = 0;\n    for (int i = 0; i < 4; ++i) {\n        int cantidad, precio;\n        cin >> cantidad >> precio;\n        total += cantidad * precio; \n    }\n    cout << total << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "10463. Suma de cuadrados :D",
        "url": "https://omegaup.com/arena/problem/Suma-de-cuadrados-D/",
        "descripcion": "Calcula la suma de los cuadrados de cada número hasta X.",
        "entrada": "Un único entero X (X<=10).",
        "salida": "La suma total de todos los cuadrados hasta X.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int X;\n    cin >> X;\n    int suma = 0;\n    for(auto i = 1; i <= X; ++i){\n        suma += i*i;\n    }\n    cout << suma << \"\\n\";\n\n    return 0;\n}\n"
    },
    {
        "titulo": "10458. PromedioAlumno",
        "url": "https://omegaup.com/arena/problem/PromedioAlumno/",
        "descripcion": "Ayuda al maestro Willy a calcular el promedio de uno de sus alumnos.",
        "entrada": "Un entero n (0<=n<=100), la cantidad de calificaciones del alumno seguido de n numeros enteros Y (0<=Y<=100).",
        "salida": "El promedio de las calificaciones del alumno. El resultado no es necesariamente un entero. Si el resultado es entero imprime solamente el valor entero como se muestra en el ejemplo, si es decimal, redondea a una cifra.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "int",
            "double",
            "floor()",
            "fixed",
            "setprecision()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int n, calificacion;\n    double suma = 0; \n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        cin >> calificacion;\n        suma += calificacion;\n    }\n    double promedio = suma / n;\n    if (promedio == floor(promedio)) {\n        cout << (int)promedio << endl;\n    } else {\n        cout << fixed << setprecision(1) << promedio << endl;\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "10329. Palomitas grandes",
        "url": "https://omegaup.com/arena/problem/Palomitas-grandes/",
        "descripcion": "Un par de amigos van al cine cada 2 meses, y cada 4 meses piden palomitas grandes. Tu trabajo es determinar que van a pedir este par de amigos en determinado mes.",
        "entrada": "Un entero X (1<=X<=12) indicando el primer mes del año en el cual compraron palomitas grandes seguido de un entero Y (1<=Y<=12) el cual es el mes a determinar la compra.",
        "salida": "\"Palomitas grandes\" si los amigos compran palomitas grandes. \"Palomitas medianas\" Si no compran grandes y van al cine y \"Nada\" si los amigos no van al cine.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int X, Y;\n    cin >> X >> Y;\n    // Ajustamos los meses para que sean congruentes modulo 12\n    if (Y < X) {\n        Y += 12; \n    }\n    if ((Y - X) % 4 == 0) {\n        // Verificamos si compran palomitas grandes\n        cout << \"Palomitas grandes\\n\";\n    }\n    else if ((Y - X) % 2 == 0) {\n        // Verificamos si van al cine\n        cout << \"Palomitas medianas\\n\";\n    }\n    else {\n        // No van al cine\n        cout << \"Nada\\n\";\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "5835. Fahrenheit a Centigrados (agua fría y caliente)",
        "url": "https://omegaup.com/arena/problem/Fahrenheit-a-Centigrados/",
        "descripcion": "Escriba un programa que lea una temperatura F en grados Fahrenheit y que escriba la temperatura equivalente C en grados centígrados. Recuerde que 9C=5(F-32). Además, su programa debe decir si a esa temperatura el agua estaría fría (C<=36) o caliente (C>36). Use únicamente enteros para realizar los cálculos.",
        "entrada": "Consiste de un número entero F que tendrá un valor entre -450 y 1000.",
        "salida": "Consiste de dos números enteros C y E en ese orden y separados por un espacio, donde E=0 si el agua está fría y E=1 si está caliente.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int F, C, E;\n    cin >> F;\n    C = 5 * (F - 32) / 9; // Calculamos C directamente\n    E = (C > 36); // Usamos una comparacion booleana para determinar E\n    cout << C << \" \" << E << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "9417. Es hoy",
        "url": "https://omegaup.com/arena/problem/Es-hoy/",
        "descripcion": "¡Ha llegado el día! Por fin, ahora puedes HACKEAR LA NASA. Pero antes de ello tienes que solucionar este problema. MUAHAHAHA. Un profesor, ha comprado muchas cajas llenas de pelotas. A la hora de recibirlas, se dió cuenta que le enviaron dos tipos de cajas A y B, de las cuales hay N cajas de tipo A y M de tipo B. En cada caja hay una cantidad diferente de pelotas, así que te pide a ti (Supremo Dios de la Programación Tebana) a que le ayudes a saber cuantas pelotas hay en total de cada tipo de caja A y B. Toma en cuenta que si fallas, te va a reprobar y tampoco tendras permiso de hacker la nasa.",
        "entrada": "La primera y segunda líneas de entrada contendrán los numeros N y M (1<=N,M<=100) respectivamente. La siguientes N líneas contendrán la cantidad de pelotas en las cajas de tipo A y las proximas M lineas las de B.",
        "salida": "La cantidad de pelotas que hay de tipo A y las de tipo B.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout.tie(0);\n  int N, M;\n  cin >> N >> M;\n  int totalA = 0, totalB = 0;\n  for (int i = 0; i < N; ++i) {\n    int pelotas;\n    cin >> pelotas;\n    totalA += pelotas;\n  }\n  for (int i = 0; i < M; ++i) {\n    int pelotas;\n    cin >> pelotas;\n    totalB += pelotas;\n  }\n  cout << totalA << \" \" << totalB << \"\\n\";\n\n  return 0;\n}\n"
    },
    {
        "titulo": "9386. Samuel y sus lapiceras",
        "url": "https://omegaup.com/arena/problem/Samuel-y-sus-lapiceras/",
        "descripcion": "Un estudiante especifico esta aburrido en clases, y cuando el se aburre decide realizar algún calculo de cosas que parecen ser absurdas, en esta ocasión el ha decidido calcular el promedio de lapiceras negras que hay por alumno en su salón, por lo que, aprovechando que el profesor no se encontraba, empezó a preguntarle a cada uno de sus compañeros por la cantidad de lapiceras negras que tenia, y posteriormente calculo el promedio; una vez que lo hizo, decidió hacer lo mismo en toda la escuela, por lo que le pidió a sus amigos en cada salón que le mandaran la información de las lapiceras negras; ahora que tiene mucha información, necesita un programa que lo ayude a calcular el promedio con la información recibida, ayudalo a calcular el promedio de lapiceras.",
        "entrada": "Recibirás un numero n, que indica el numero de alumnos en el salón, después recibirás n números, que sera la cantidad de lapiceras por cada alumno en el salón.",
        "salida": "Deberás mostrar el promedio de lapiceras que hay en el salón analizado.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "int",
            "double"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int n, lapiceras, totalLapiceras = 0;\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        cin >> lapiceras;\n        totalLapiceras += lapiceras;\n    }\n    double promedio = (double)totalLapiceras / n;\n    cout << promedio << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "10233. Hora de entrega",
        "url": "https://omegaup.com/arena/problem/Hora-de-entrega/",
        "descripcion": "Un estudiante andaba en su clase de informática muy aburrido como siempre, ya que era un gran programador. Un día el maestro decide dejar la tarea en la página de colegio. Dentro de la página los alumnos suben su tarea desde una computadora a la hora que puedan; sin embargo, existe una hora límite. El estudiante al entrar a la página para ver las tareas se percata de un fallo. Al momento de mostrar las horas de entrega, hay ciertos números que no se logran distinguir. Como buen alumno, el estudiante reporto el fallo a control escolar y le respondieron \"puedes decirnos la hora que quieras y esa pondremos como el límite. Siempre y cuando se conserven los dígitos que si son visibles\". Como alumno flojo, el estudiante decide decir la hora más tarde posible. La hora está marcada desde 00:00 hasta las 23:59. Por ejemplo, si en la plataforma aparece ?1:2?, quiere decir que el primer digito de la hora y el ultimo digito de los minutos no son visibles. Por tanto, el estudiante dirá la hora 21:29, ya que es la más tarde que puede poner, de manera que ninguno de los dígitos que sí se veían cambien. Dada una hora dada en el formato hh:mm (horas:minutos). En donde algunos dígitos no son visibles (vamos a representarlos como -1), decir cuál es la hora más tarde que se puede formar, reemplazando esos dígitos que no son visibles (representados con -1).",
        "entrada": "4 números enteros que representan la hora, los primeros dos corresponden a la hora y los segundos corresponden a los minutos. Se pondrá un -1 en caso de que el digito no sea visible. Los 4 números son solo un digito y siempre se puede formar una hora valida, es decir, no se darán entradas como 5 -1 9 -1.",
        "salida": "4 números que representan la mayor hora válida que se puede formar.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int a, b, c, d, e, f, g;\n    cin>>a>>b>>c>>d;\n    if(a==-1 && b==-1){\n        a=2;\n        b=3;\n    }\n    if(a==-1){\n        if(b<4){\n            a=2;\n        }\n        else{\n            a=1;\n        }\n    }\n    if(b==-1){\n        if(a==2){\n            b=3;\n        }\n        else{\n            b=9;\n        }\n    }\n    if(c==-1){\n        c=5;\n    }\n    if(d==-1){\n        d=9;\n    }\n    cout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<d;\n    \n    return 0;\n}\n"
    },
    {
        "titulo": "6273. Un algoritmo de Gauss poco conocido",
        "url": "https://omegaup.com/arena/problem/Algoritmo-de-Gauss/",
        "descripcion": "La Pascua cae en el primer domingo que sigue a la primera luna llena que ocurra el 21 de marzo o después. El siguiente algoritmo, propuesto por Gauss, calculará, dado un año A>=1583, un número que representa la fecha de la Pascua de la siguiente forma: si J<=31, entonces la Pascua será el J de marzo; en otro caso la Pascua será el J-31 de abril. Pasos: #1 Haz B=A/100+1. #2 Haz C=3*B/4-12. #3 Haz E=(A mod 19)+1. #4 Haz F=(8*B+5)/25-(5+C). #5 Haz G=5*A/4-(C+10). #6 Haz H=(11*E+20+F) mod 30. #7 Si H no vale 25 entonces ir al paso 9. #8 Si E es mayor que 11 entonces suma 1 a H. #9 Si H vale 24 entonces suma 1 a H. #10 Haz I=44-H. #11 Si I es menor que 21 entonces suma 30 a I. #12 Haz J=I+7-[(G+I) mod 7]. En este algoritmo todas las divisiones son enteras y mod es el residuo de la división. Dado un año A, deberás calcular el día D y el mes M en el que cae la Pascua en el año A.",
        "entrada": "Consiste de un número entero A que tendrá un valor entre 1583 y 9999.",
        "salida": "Consiste de dos números enteros D y M, separados por un espacio (M=3 significa marzo y M=4 significa abril).",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int A, B, C, E, F, G, H, I, J, D, M;\n    cin >> A;\n    B = A / 100 + 1;\n    C = 3 * B / 4 - 12;\n    E = (A % 19) + 1;\n    F = (8 * B + 5) / 25 - (5 + C);\n    G = 5 * A / 4 - (C + 10);\n    H = (11 * E + 20 + F) % 30;\n    if (H != 25){\n        goto paso9;\n    }\n    if (E > 11){\n        H++;\n    }\n    paso9:\n    if (H == 24){\n        H++;\n    }\n    I = 44 - H;\n    if (I < 21){\n        I += 30;\n    }\n    J = I + 7 - ((G + I) % 7);\n    if (J <= 31){\n        D = J;\n        M = 3;\n    }\n    else{\n        D = J - 31;\n        M = 4;\n    }\n    cout << D << \" \" << M << \"\\n\";\n\n    return 0;\n}\n"
    },
    {
        "titulo": "8501. FuncionX",
        "url": "https://omegaup.com/arena/problem/FuncionX/",
        "descripcion": "Para un entero positivo n definamos una función f: f(n)=-1+2-3+4-5+..+((-1)^n)*n. Su tarea es calcular f(n) para un entero n dado.",
        "entrada": "La línea única contiene el entero positivo n (1<=n<=10^15).",
        "salida": "Imprimir f(n) en una sola línea.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n// Funcion para calcular f(n)\nlong long calcularFn(long long n) {\n    if (n % 2 == 0) {\n        return n / 2;\n    } else {\n        return -((n + 1) / 2);\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long n;\n    cin >> n;\n    cout << calcularFn(n) << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "5162. Respuesta al Universo",
        "url": "https://omegaup.com/arena/problem/Respuesta-al-Universo/",
        "descripcion": "Uno de tus amigos, antes de dormir tomó una lata de una bebida energetizante y como podrás imaginar no puede dormirse otra vez. Como tu tienes una salida importante con tus amigos mañana, decidiste decirle a tu perro que buscara la respuesta al universo. Tu amigo se puso a pensar y dedujo que para encontrar la respuesta tienes que tener N números, los multiplicas entre sí, luego los divides entre la multiplicación del tercer número por dos y por el último número de la lista, para finalmente sumarle el promedio de todos los números en posiciones impares. Y el resultado de todo esto sería alguna respuesta del universo. Pero tu al haber leído mucho, ya sabes la respuesta al universo... Aunque quizás no sepas la verdadera pregunta. Tu amigo no es programador por lo que el cuenta iniciando en 1 y no en 0. Y la respuesta al universo es única.",
        "entrada": "La primer línea de entrada contendrá el número N (3<=N<=1000) de elementos. Las siguientes N líneas contendrán las diferentes M (1<=M<=1000) cantidades a procesar.",
        "salida": "Únicamente tienes que regresar un entero con la respuesta.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores"
        ],
        "estructuras": [
            "long long",
            "int",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int N;\n    cin >> N;\n    vector<int> numeros(N);\n    long long multiplicacion = 1; // Usamos long long para evitar overflow\n    int sumaImpares = 0;\n    for (int i = 0; i < N; ++i) {\n        cin >> numeros[i];\n        multiplicacion *= numeros[i];\n        if (i % 2 == 0) {\n            sumaImpares += numeros[i];\n        }\n    }\n    // Aplicamos la formula, notando que el indice del ultimo elemento es N-1\n    long long resultado = multiplicacion / (numeros[2] * 2 * numeros[N - 1]);\n    resultado += (sumaImpares * 1.0) / ((N + 1) / 2); // Calculo del promedio\n    cout << resultado << endl; \n\n    return 0;\n}\n"
    },
    {
        "titulo": "9347. Equipo de Basquetbol",
        "url": "https://omegaup.com/arena/problem/Equipo-de-Basquetbol/",
        "descripcion": "El profesor de deportes esta reclutando a los y las integrantes de de la selección de basquetbol de la escuela, pero ha puesto una restricción para poder formar parte del equipo, el cual es que el participante debe de medir al menos 1.60 m. (160 cm.). Toda persona que quiera formar parte del equipo debe de ir a la enfermería para tomar su altura, donde se le notificara si es apto o no para el equipo. Tu tarea sera ayudar a enfermería para indicar si la persona es apta o no para estar en el equipo.",
        "entrada": "Como entrada recibirás una altura h, que representa la altura en centímetros del estudiante que quiere ingresar al equipo.",
        "salida": "Como salida deberas mostrar el mensaje de \"Bienvenido al equipo\" (sin las comillas), si la h es mayor o igual a 160 cm; de lo contrario usted debera mostrar el mensaje \"Lo siento, te faltan x cm para poder entrar al equipo\", donde x es la diferencia entre la altura del estudiante y la requerida para entrar al equipo.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int h;\n    cin >> h;\n    if (h >= 160){\n        cout << \"Bienvenido al equipo\\n\";\n    } else {\n        cout << \"Lo siento, te faltan \" << 160 - h << \" cm para poder entrar al equipo\\n\";\n    }\n\n   return 0;\n}\n"
    },
    {
        "titulo": "7538. Números pares entre dos números",
        "url": "https://omegaup.com/arena/problem/Numeros-pares-entre-dos-numeros/",
        "descripcion": "Realiza un programa que solicite al usuario dos números a y b; y que imprima los números pares que existen entre dichos números.",
        "entrada": "Dos números enteros a y b.",
        "salida": "Números pares enteros entre dichos números.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n// Funci? para imprimir los n?meros pares entre a y b (excluyendo a y b)\nvoid imprimirPares(int a, int b) {\n    // Ajustar el valor inicial si 'a' es par\n    if (a % 2 == 0) {\n        a += 2;\n    } else {\n        a += 1; \n    }\n    // Imprimir los n?meros pares en el rango\n    for (int i = a; i < b; i += 2) {\n        cout << i << endl;\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int a, b;\n    cin >> a >> b;\n    imprimirPares(a, b);\n\n    return 0;\n}\n"
    },
    {
        "titulo": "2990. Imprime Pares",
        "url": "https://omegaup.com/arena/problem/Imprime-Pares/",
        "descripcion": "Dado un número n, escribe un programa que imprima todos los números pares en el intervalo [1,n].",
        "entrada": "Un número n (1<=n<=100).",
        "salida": "Imprime los números pares en el intervalo [1,n]. Si no hay ningún número par en el intervalo [1,n] imprime el mensaje \"Nada que imprimir\".",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "bool",
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int n;\n    cin >> n;\n    bool encontrado = false;\n    for (int i = 2; i <= n; i += 2) {\n        cout << i << \" \";\n        encontrado = true;\n    }\n    if (!encontrado) {\n        cout << \"Nada que imprimir\";\n    }\n    cout << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "7404. ¡Amamos los dulces!",
        "url": "https://omegaup.com/arena/problem/Dulces-2/",
        "descripcion": "Andrés, Abel y Alan AMAN los dulces, por eso decidieron salir a pedir calaverita. Los tres se dejaron llevar por la euforia del momento y quedaron en juntar todo lo obtenido para, posteriormente, dividir las ganancias en partes iguales. Después de meditar un rato, vieron que no había sido un buen trato, pero no se podían ya echar para atrás. Lo único que les quedó fue, al menos, decir que no estaban dispuestos a recibir un \"cachito\" de dulce, lo que deberían obtener eran dulces enteros, y todos la misma cantidad. Después de una caminata kilométrica llena de risas, sustos y MUCHOS dulces ha llegado el punto de la repartición de los preciados bienes. Tu papel en esta historia es leer el número total de dulces recolectados y decir si existe un reparto igualitario de dulces enteros.",
        "entrada": "Un número entero N que denota el total de dulces recolectados por los tres amigos.",
        "salida": "La frase \"Felicidad pura\" si se pueden repartir los dulces entre los tres amigos en partes iguales y que a cada uno solo le toquen dulces enteros, la frase \"Pelea segura\" de lo contrario.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int N;\n    cin >> N;\n    if (N % 3 == 0) {\n        cout << \"Felicidad pura\" << endl;\n    } else {\n        cout << \"Pelea segura\" << endl;\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "8622. Diferencia en Minutos",
        "url": "https://omegaup.com/arena/problem/Diferencia-en-Minutos/",
        "descripcion": "Se leen cuatro valores enteros H1, M1, H2 y M2, que indican: H1:M1 la hora de comienzo y H2:M2 la hora de final de un intervalo de tiempo del mismo día (la hora:minuto de comienzo es menor o igual que la hora:minuto de final). Hay que informar la cantidad de minutos de diferencia entre ambas.",
        "entrada": "La entrada viene en dos líneas: en la primera vienen H1 y M1, en la segunda vienen H2 y M2.",
        "salida": "La salida consiste en sólo una línea, conteniendo un valor entero que es diferencia en minutos entre las dos horas ingresadas.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    // Leer las horas de inicio y fin\n    int H1, M1, H2, M2;\n    cin >> H1 >> M1 >> H2 >> M2;\n    // Convertir las horas a minutos\n    int minutosInicio = H1 * 60 + M1;\n    int minutosFin = H2 * 60 + M2;\n    // Calcular la diferencia en minutos\n    int diferencia = minutosFin - minutosInicio;\n    // Imprimir la diferencia\n    cout << diferencia << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "4071. CANICAS BÁSICO",
        "url": "https://omegaup.com/arena/problem/CANICAS-BASICO-ASINUS/",
        "descripcion": "Pepechuy y Junior son dos niños que todos los días juegan a las canicas ya que están obsesionados con ser el mejor de los dos. Sin embargo, siempre que jugan tienen el mismo problema, ya que están cursando a penas el primer año de primaria, por lo cual, saben perfectamente cuantos puntos obtiene cada uno al tirar, pero al terminar de jugar siempre olvidan la cantidad de puntos y no los pueden sumar para saber quien es el mejor, así que lo deciden lo mejor que su memoria les permite. Ayuda a Pepechuy y a Junior a llevar el control de la puntuación que obtienen en cada turno, considerando que el juego está conformado por 5 turnos, y cada uno de ellos tira después del turno del otro. Muéstrales al final del juego; quién obtuvo la mayor puntuación, para así llamarse el rey de las canicas de la calle San Toribio. Los puntos a obtener en cada turno, pueden ir desde 0, si no golpearon o metieron ninguna canica, a 1, 2 ó 3, dependiendo de qué movieron o metieron a la choya.",
        "entrada": "El puntaje que obtuvo Pepechuy en el primer turno, seguido del puntaje que obtuvo Junior también en el primer turno, posteriormente los siguientes puntajes en el mismo orden hasta completar los 5 turnos de cada uno.",
        "salida": "\"1\" si ganó Pepechuy, o bien \"2\" si ganó Junior, en caso de empate deberá indicar \"EMPATE\".",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int puntajePepechuy = 0;\n    int puntajeJunior = 0;\n    for (int turno = 1; turno <= 5; turno++) {\n        int puntosPepechuy, puntosJunior;\n        cin >> puntosPepechuy >> puntosJunior;\n        puntajePepechuy += puntosPepechuy;\n        puntajeJunior += puntosJunior;\n    }\n    if (puntajePepechuy > puntajeJunior) {\n        cout << \"1\\n\";\n    } else if (puntajeJunior > puntajePepechuy) {\n        cout << \"2\\n\";\n    } else {\n        cout << \"EMPATE\\n\";\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "2504. El problema de los Múltiplos",
        "url": "https://omegaup.com/arena/problem/El-problema-de-los-Multiplos/",
        "descripcion": "Si hacemos una lista de todos los números naturales antes del número 10 que son múltiplos de 3 ó 5, obtenemos el 3, 5, 6 y 9. La suma de esos múltiplos es 23. Encuentre la suma de todos los múltiplos de 3 o 5 que se localizan antes de cierto numero natural dado.",
        "entrada": "En una línea un único número natural N (1<=N<=90000).",
        "salida": "Una solo línea en la cual se deberá mostrar el resultado obtenido.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int N;\n    cin >> N;\n    long long suma = 0;\n    for (int i = 1; i < N; ++i){\n        if(i % 3 == 0 || i % 5 == 0){\n            suma += i;\n        }\n    }\n    cout << suma << \"\\n\";\n\n    return 0;\n}\n"
    },
    {
        "titulo": "3770. Serie-Navideña",
        "url": "https://omegaup.com/arena/problem/Serie-Navidena/",
        "descripcion": "¡YA VIENE LA NAVIDAD! Y Karel como todo buen amante de la navidad, ha decidido poner de una vez por todas su árbol navideño. Karel estaba muy emocionado poniendo todos los adornos en su árbol, cuando se dió cuenta que la serie de luces que había comprado el año pasado tenía focos fundidos (típico). Como Karel gastó mucho dinero en el Buen Fin comprando una computadora nueva, ha decidido que solamente comprará los foquitos necesarios para cambioar los que se han fundido. Ayuda a Karel a ver cuántos focos de la serie se han fundido y calcular cuánto dinero tendrá que gastar para comprarlos.",
        "entrada": "En la primera línea, dos números N (1<=N<=1000000) y M separados por un espacio, donde N representa el número de foquitos que tiene la serie y M el precio que tiene cada foquito. En la segunda línea N números serparados por un espacio. Si el número es 1, significa que es un foquito que funciona perfectamente, si es un 0, entonces ese foquito está fundido y debe ser reemplazado.",
        "salida": "Dos números, uno en cada línea. El primero indica el total de foquitos fundidos en la serie, y el segundo el total de dinero que Karel tendrá que gastar.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "int",
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int N, M, focosFundidos = 0;\n    long long costoTotal = 0; \n    cin >> N >> M;\n    for (int i = 0; i < N; ++i) {\n        int estadoFoco;\n        cin >> estadoFoco;\n        if (estadoFoco == 0) {\n            focosFundidos++;\n            costoTotal += M; \n        }\n    }\n    cout << focosFundidos << \"\\n\" << costoTotal << \"\\n\";\n\n    return 0;\n}\n"
    },
    {
        "titulo": "8167. Contando los medicamentos",
        "url": "https://omegaup.com/arena/problem/Contando-los-medicamentos/",
        "descripcion": "Una agencia de seguros tiene el mayor número de polizas en México. Actualmente, quiere expandir su mercado hacia la compra y venta de medicamentos y para iniciar su prueba piloto, usará a sus clientes para ver si es viable o no. La agencia distribuirá los medicamentos entre 4 grupos: los niños (0-10 años), jóvenes (11-17), adultos (18-60), ancianos (61 en adelante). Al primer grupo (niños) le darán 2 medicamentos, al segundo (jóvenes) 5, al tercero (adultos) 8 y al cuarto (ancianos) 10. Ayuda a la agencia a obtener el número de medicamentos necesarios para entregárselos a la persona que llegue.",
        "entrada": "Un número entero, E, que representa la edad de la persona que llegó por sus medicamentos.",
        "salida": "Un número entero M que representa el número de medicamentos que le tocan a la persona que llegó.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int E, M;\n    cin >> E;\n    if (E <= 10){\n        M = 2;\n    } else if (E <= 17){\n        M = 5;\n    } else if (E <= 60){\n        M = 8;\n    } else {\n        M = 10;\n    }\n    cout << M << \"\\n\";\n\n    return 0;\n}\n"
    },
    {
        "titulo": "836. Sumas y Restas",
        "url": "https://omegaup.com/arena/problem/Sumas-y-Restas/",
        "descripcion": "Se tienen 2 números diferentes A y B. Se desea saber la cantidad de números que existe entre A y B en una determinada secuencia. La secuencia comienza con el valor A, posteriormente se le suma 1, al valor resultante se le resta 2, al resultante se le suman 3, y así sucesivamente hasta llegar al número B. Se asegura que partiendo desde A y siguiendo el procedimiento correcto, la secuencia siempre te llevara al número B.",
        "entrada": "2 números enteros separados por un salto de línea, la primera línea contendrá el valor de A y la segunda línea contendrá el valor de B.",
        "salida": "Un solo número, representando la cantidad de números entre los valores de A y B que hay en la secuencia (teniendo en cuenta que A<=B o A>=B).",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c=0;\n    cin>>a>>b;\n    //Optimizacion: En lugar de generar la secuencia completa, se aplica una formula matematica\n    if(a<b){\n        c=((b-a)-1)*2;\n    }\n    else if(a>b){\n        c=((a-b)*2)-1;\n    }\n    cout<<c;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "5124. Doña Atanila",
        "url": "https://omegaup.com/arena/problem/Dona-Atanila-ASINUS/",
        "descripcion": "La señora Atanila se ha dedicado a vender tortas fuera del hospital de su comunidad desde hace algún tiempo, cerca de diez años, y al estar vendiendo en este lugar se ha vuelto una persona muy sensible ya que llega gente que usualmente tiene a familiares internados, por ello tiene un método para cobrar bastante especial. Para ello, la señora cuando le piden una torta hace una serie de preguntas que le permiten determinar el costo de ésta. El cobro de sus tortas debido a su éxito ha llegado a ser un poco agobiante por tal motivo ya no puede hacerlo mentalmente, para ello requiere tu ayuda para que calcule el costo con base en lo siguiente. Tipo de torta (si se introduce un número diferente de 1, 2, 3 ó 4, en el tipo de torta de imprime: ERROR.): (1)Adobada $15.00, (2)Cubana $25.00, (3)Jamón $12.00, (4)Lomo $15.00; Sin embargo los costos varían según los siguientes argumentos. Con base en los días internado: (a)Si tienen un familiar internado de 1 a 5 días -$3.00. (b)Si tienen un familiar internado de 6 a 30 días -$5.00. (c)Si tienen un paciente internado de 30 días o más -$8.00; Con base en la enfermedad: (1)Si el paciente tiene cáncer o diabetes -$2.00. (2)Si el paciente tiene alguna otra enfermedad Sin descuento; Con base en los ingredientes. Para ello, el cliente debe especificar si quiere una porción de algún ingrediente de más: (a)Si quiere aguacate +$2.00. (q)Si quiere queso +$2.50. (s)Sin ingredientes extra.",
        "entrada": "Se deberá introducir el tipo de torta que el cliente desea >=1, <=4, seguido del tipo de días que tiene su familiar internado (a, b, o c), después el tipo de enfermedad (1 ó 2) y finalmente si el cliente quiere algún ingrediente extra o no (a, q o s).",
        "salida": "El costo total a pagar por la torta.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "char",
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int tipoTorta;\n    char diasInternado, enfermedad, ingredienteExtra;\n    int costo = 0;\n    cin >> tipoTorta >> diasInternado >> enfermedad >> ingredienteExtra;\n    if (tipoTorta == 1) {\n        costo = 15.00;\n    } else if (tipoTorta == 2) {\n        costo = 25.00;\n    } else if (tipoTorta == 3) {\n        costo = 12.00;\n    } else if (tipoTorta == 4) {\n        costo = 15.00;\n    } else {\n        cout << \"ERROR.\" << endl;\n        return 0;\n    }\n    if (diasInternado == 'a') {\n        costo -= 3.00;\n    } else if (diasInternado == 'b') {\n        costo -= 5.00;\n    } else if (diasInternado == 'c') {\n        costo -= 8.00;\n    }\n    if (enfermedad == '1') {\n        costo -= 2.00;\n    }\n    if (ingredienteExtra == 'a') {\n        costo += 2.00;\n    } else if (ingredienteExtra == 'q') {\n        costo += 2.50;\n    }\n    cout << << costo << endl;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "6010. Kaijus",
        "url": "https://omegaup.com/arena/problem/Kaijus/",
        "descripcion": "Los kaijus son mounstros que por alguna razón misteriosa salen de una abertura en el océano. La cantidad de Kaijus que aparecen cada año se duplica. El 2018 se espera que salga un Kaiju, en el 2019, saldrán 2 Kaijus, en el 2020, 4 Kaijus, en el 2021, 8 Kaijus, y así sucesivamente. Para defenderse de los Kaijus los humanos han creado sus propios mounstros llamados \"Jaegers\", que son robots piloteados por dos humanos, y que tienen bastantes monerías, como espadas, cohetes, etc. Hay un total de n Jaegers, y las peleas con los Kaijus son uno a uno. Escribe un programa que determine el año en el que los Kaijus superarán a los Jaegers en número. Ese año es de gran importancia, pues puede ser el año en que el ser humano deje de existir :(. Nota: El material con que se hacen los Jaegers se termino después de hacer el n-ésimo Jaeger, así que ya no se pueden hacer más :'(.",
        "entrada": "Un número n (1<=n<=10^9), indicando la cantidad de Jaegers que existen.",
        "salida": "El año en que los Kaijus superarán a los Jaegers en número.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b=1, c=1;\n    cin>>a;\n    while(b<=a){\n        c++;\n        b*=2;\n    }\n    cout<<2017+c;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "2390. Intervalos",
        "url": "https://omegaup.com/arena/problem/Intervalos/",
        "descripcion": "Escribe un programa que lea tres enteros a, b, c y determine si c se encuentra en el intervalo [a,b] a la izquierda o a la derecha del intervalo [a,b].",
        "entrada": "Una línea con los enteros a,b,c separados por un espacio.",
        "salida": "Imprime INTERVALO, IZQUIERDA o DERECHA según sea el caso.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int a, b, c;\n    cin >> a >> b >> c;\n    if (c >= a && c <= b){\n        cout << \"INTERVALO\\n\";\n    } else if (c < a){\n        cout << \"IZQUIERDA\\n\";\n    } else {\n        cout << \"DERECHA\\n\";\n    }\n\n   return 0;\n}\n"
    },
    {
        "titulo": "6202. Finales alternativos",
        "url": "https://omegaup.com/arena/problem/Finales-alternativos/",
        "descripcion": "Recientemente conociste un juego llamado Reversi, el cual consiste en que dos jugadores, cada uno con un color de ficha distinto, deberá ocupar la máxima cantidad de casillas de un tablero de 8*8. Estás decidido a mejorar en este juego, por lo que te has puesto a practicar jugando con tu hermano, sin embargo, después de un par de rondas, tu hermano se ha cansado de contar las fichas para ver quién ha ganado y te ha pedido a ti que las cuentes ahora.",
        "entrada": "64 enteros que representan las 64 casillas del tablero. Cada entero puede ser 0 que indica que la casilla está libre, 1 que indica que la casilla está ocupada por una ficha tuya o 2 que indica que la casilla está ocupada por tu hermano.",
        "salida": "Deberás indicar quién es el ganador del juego. Si tu hermano ganó deberás imprimir PERDI, si tú ganaste deberás imprimir GANE. Si ninguno ha ganado entonces mostrarás EMPATE.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int tablero[64];\n    int miFicha = 0, hermanoFicha = 0;\n    for (int i = 0; i < 64; ++i) {\n        cin >> tablero[i];\n        if (tablero[i] == 1) {\n            miFicha++;\n        } else if (tablero[i] == 2) {\n            hermanoFicha++;\n        }\n    }\n    if (miFicha > hermanoFicha) {\n        cout << \"GANE\\n\";\n    } else if (hermanoFicha > miFicha) {\n        cout << \"PERDI\\n\";\n    } else {\n        cout << \"EMPATE\\n\";\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "5258. Empleados Universitarios",
        "url": "https://omegaup.com/arena/problem/Empleados-Universitarios/",
        "descripcion": "En cierta isla habitada, existen 2 tipos de personas. 1.- Las personas honestas que siempre te dicen la verdad. 2.- Las personas deshonestas que siempre dicen mentiras. En ésta isla existe una universidad, con R empleados. Si uno se aproxima a uno de los empleados ellos siempre te dirán dos cosas. a.- \"Hay menos de N empleados que trabajan más que yo\". b.- \"Al menos M empleados tienen un salario mayor al mio\". Tambien se sabe que ningun empleado trabaja lo mismo que otro y que ninguno gana lo mismo que otro.",
        "entrada": "La entrada consiste en exactamente 1000 casos, cada uno en una linea. Cada linea contiene dos números N y M. (0<=N , M<=10^9) (0<=N+M=E) ",
        "salida": "Para cada linea de entrada, una linea que contenga E. la cantidad de empleados de la universidad",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b;\n    while(cin>>a){\n        cin>>b;\n        cout<<a+b<<\"\\n\";\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "4924. Elevando números al cuadrado",
        "url": "https://omegaup.com/arena/problem/Elevando-al-cuadrado/",
        "descripcion": "Juanito acaba de aprender en su clase acerca de como elevar números al cuadrado y se obsesiono tanto con estos que uso sus habilidades de informática para crear un programa capaz de elevar cualquier numero al cuadrado.El problema es que sus conocimientos de informatica no alcanzan para crear este programa, así que te pidió ayuda para hacer el programa.",
        "entrada": "En la primera linea recibirás n que es la cantidad de números que se elevaran al cuadrado. En la segunda linea recibirás los n números que elevaras al cuadrado separados por un espacio. (0<n<20, 0<=k_1,k_2...,k_n<1000)",
        "salida": "Deberás sacar los n números introducidos, elevados al cuadrado y separados por un espacio",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b;\n    cin>>a;\n    while(a--){\n        cin>>b;\n        cout<<b*b<<\" \";\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "5601. Mi Cumpleaños",
        "url": "https://omegaup.com/arena/problem/Mi-Cumpleanos/",
        "descripcion": "Hoy es tu fiesta de cumpleaños, y quieres atender bien a los invitados, por lo que decides ayudar a el mesero, al revisar que en cada lugar de la mesa este un vaso para las bebidas, te das cuenta que en algunos lugares el mesero dejo correctamente un vaso, que en otros lugares falta el vaso y en algunos lugares de la mesa dejo mas de un vaso.",
        "entrada": "La mesa con N lugares para sentarse, un 0 indica que falta el vaso en ese lugar, un numero entero mayor que cero indica cuantos vasos dejo el mesero en ese lugar. La mesa mas grande es de 100 lugares La mesa mas chica es de 5 lugares El numero maximo de vasos que dejo en un lugar el mesero es de 4",
        "salida": "Un numero negativo indica cuantos vasos faltan en la mesa. El numero cero indica que todos los lugares de la mesa tienen 1 vaso. Un numero positivo que indica si sobran vasos en dicha mesa.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b=0, c=0;\n    while(cin>>a){\n        b++;\n        c+=a;\n    }\n    cout<<c-b;\n\n    return 0;\n}"
    },
    {
        "titulo": "7078. El mini juego de la vida",
        "url": "https://omegaup.com/arena/problem/El-mini-juego-de-la-vida/",
        "descripcion": "En el año de 1970 el matemático John Conway desarrolló el llamado juego de la vida. Este juego consiste en seleccionar cada una de las casillas de un tablero inmenso e inspeccionar el valor contenido en dicha casilla. Una vez obtenido el valor almacenado en una casilla c se inspeccionan los valores almacenados en las ocho casillas más cercanas a esta (ver Figura). Sea N el número total de casillas vecinas con valor uno (en la figura (N=5)) .Las reglas del juego son las siguientes: Si (c=0) y (N!=3) entonces el nuevo valor de c es 0. Si (c=0) y (N=3) entonces el nuevo valor de c es 1. Si (c=1) y (N<2) o (N>3) entonces el nuevo valor de c es 0 . Si (c=1) y (N=2) o (N=3) entonces el nuevo valor de c es 1. Use estas reglas para determinar el nuevo valor de una casilla c.",
        "entrada": "Dos enteros c y N que representan el valor almacenado en una casilla c y el número de casillas vecinas de c con valor 1 respectivamente. Puede asumir que c solo puede tomar el valor 0 o el valor 1, y que (-10<=N<=10).",
        "salida": "Un entero que representa el nuevo valor de c de acuerdo a las reglas del juego de la vida o el mensaje \"ERROR\" si (N>8 o N<0).",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b;\n    cin>>a>>b;\n    if(b>8 || b<0 || a<0 || a>1){\n        cout<<\"ERROR\";return 0;\n    }\n    if(a==0){\n        if(b==3){\n            cout<<1;return 0;\n        }\n        cout<<0;return 0;\n    }\n    if(b<2 || b>3){\n        cout<<0;return 0;\n    }\n    cout<<1;\n    \n    return 0;\n}"
    },
    {
        "titulo": "1789. El Sentido de la Vida, el Universo y Todo lo Demás",
        "url": "https://omegaup.com/arena/problem/El-Sentido-de-la-Vida/",
        "descripcion": "Quieres encontrar el sentido de la vida, el universo y todo lo demás. Para ello, recibirás una lista muy larga de enteros y debes contestar cuántos tuviste que leer antes de encontrar 42.",
        "entrada": "Una lista de enteros, uno por línea.",
        "salida": "Un entero: cuántos enteros tuviste que leer antes de encontrar 42.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c=0;\n    cin>>a;\n    while(a!=42){\n        c++;\n        cin>>a;\n    }\n    cout<<c;\n    \n    return 0;\n}"
    },
    {
        "titulo": "3059. Edificación Virtual",
        "url": "https://omegaup.com/arena/problem/Edificacion-Virtual/",
        "descripcion": "Uno de los juegos más divertidos de la existencia es Minecraft. Mientras estabas en una de tus divertidas partidas online, uno de los jugadores extraños de internet te ha comentado algo súper importante: quiere construir una pirámide en dos dimensiones en Minecraft. Sin embargo, no es muy bueno con las matemáticas y ha pedido tu ayuda. Él necesita saber cuántos pisos tendrá su pirámide si solo tiene N bloques de tierra. Los pisos se cuentan de abajo hacia arriba. El último piso siempre tendrá 1 solo bloque, el penúltimo piso tendrá 2 bloques, el siguiente piso tendrá 3 bloques y así sucesivamente. Como eres una buena persona que ayuda a los extraños en internet, tu tarea es encontrar el número de pisos de esta pirámide. Se te asegura que dado N siempre es posible construir una pirámide de la forma ya descrita.",
        "entrada": "N, cuántos bloques de tierra tiene el extraño del internet.",
        "salida": "Cuántos pisos tendría su pirámide de tierra.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "long long",
            "sqrt()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a;\n    cin>>a;\n    a*=2;\n    a=sqrt(a);\n    cout<<a;\n        \n    return 0;\n}"
    },
    {
        "titulo": "8239. El espía David",
        "url": "https://omegaup.com/arena/problem/El-Espia-David-/",
        "descripcion": "El espía David tiene una misión para infiltrarse en la base secreta de la malvada Pandora y por ende necesita la clave para pasar por la puerta con un mecanismo el cual le da 5 letras del alfabeto y David tiene que darle a la máquina el valor de ese carácter en su código Ascii. Ayuda a David a poder pasar por la puerta.",
        "entrada": "5 letras del alfabeto separadas por espacio.",
        "salida": "Escribir el valor Ascii de esas letras separadas por espacio.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "long long",
            "char"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a;\n    char z;\n    for(auto i=0; i<5; i++){\n        cin>>z;\n        a=z;\n        cout<<a<<\" \";\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "5018. Divisible 7",
        "url": "https://omegaup.com/arena/problem/Divisible-7/",
        "descripcion": "El comité Quinatanarroense se siente bondadoso este año, y en tu primer problema de lenguaje te pedirá que hagas algo muy fácil. Tu tarea consiste en identificar si un numero es divisible entre 7, es decir, si un numero al dividirlo entre 7 nos da algún otro numero entero. Sin embargo eso no es todo, tienes que identificar cuantos números son divisibles entre 7 de entre toda una lista de N números. Dada una lista de N números identificar cuántos de ellos son divisibles entre 7 y arrojarlo como resultado.",
        "entrada": "En la primera línea un numero N que representa la cantidad de números a analizar. En la segunda línea tendrás N números aleatorios sin ningún orden. (0<=N<=100,000) Los N números estarán entre 0 y 65,000. Tu programa deberá ejecutarse en menos de 0.5 segundos.",
        "salida": "Una única línea con un numero que representa la cantidad de números divisibles entre 7.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Ciclos",
            "Teoría de números"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c=0;\n    cin>>a;\n    while(a--){\n        cin>>b;\n        if(b%7==0){\n            c++;\n        }\n    }\n    cout<<c;\n        \n    return 0;\n}"
    },
    {
        "titulo": "5831. Divisibles",
        "url": "https://omegaup.com/arena/problem/Divisibles/",
        "descripcion": "Hacer un programa que reciba dos número por el teclado, a y b. Si a es divisible entre b, el programa ha de mostrar el mensaje \"DIVISIBLES\".",
        "entrada": "Dos enteros a y b.",
        "salida": "Si a es divisible entre b imprimir DIVISIBLES, si no imprimir NO DIVISIBLES.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Condicionales"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b;\n    cin>>a>>b;\n    a%=b;\n    if(a){\n        cout<<\"NO DIVISIBLES\";\n    }\n    else{\n        cout<<\"DIVISIBLES\";\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "4991. Dungeon Lvl.1",
        "url": "https://omegaup.com/arena/problem/Dungeon-Lvl1/",
        "descripcion": "Acabas de adquirir un nuevo videojuego, se llama Dungeon. En la trama un hechicero te encerró en un calabozo por coquetear con su hija en la fiesta de la aldea. Ahora debes escapar para volver con tu amada (aunque sólo la hayas conocido por 10 minutos). Emocionado por comenzar tu nueva aventura, insertas el disquete en la computadora y te dispones a jugar. Como en todo juego, comienzas en el nivel uno (pues en los juegos para machos no hay tutoriales). Tu personaje aparece en el primer nivel de calabozo,una cuadrícula de N x M sobre la que puedes moverte solo hacia las casillas adyacentes (arriba,abajo,derecha,izquierda), para pasar al siguiente nivel debes encontrar la puerta que te llevará a la siguiente sala. Después de unos minutos de juego consigues encontrar la puerta, sólo para enterarte que necesitas una llave para abrirla. Dada la configuración del calabozo, la localización de la llave y la localización de la puerta. Debes imprimir el menor número de pasos que debes moverte para superar el nivel.",
        "entrada": "La primera linea consiste en dos números N y M. Las siguientes N lineas contendrán M caracteres, cada uno correspondiente a una casilla del calabozo (3<=N,M<=100). Los caracteres pueden ser: Un punto ‘.’: Representa que la casilla está libre y puedes pasar. Un asterisco ‘*’: Representa que hay una pared bloqueando el camino. Una P minúscula ‘p’: Representa la puerta. Una L minúscula ‘l’: Representa la llave. Una C minúscula ‘c’: Representa la posición inicial de tu personaje.",
        "salida": "Un número con la cantidad de movimientos mínimos necesarios para superar el nivel. En caso de no ser posible, imprimir -1.",
        "nivel": "Intermedio (medio) - Análisis y diseño de algoritmos",
        "categorias": [
            "Búsqueda en amplitud",
            "Colas",
            "Matrices"
        ],
        "estructuras": [
            "long long",
            "vector<vector<char>>",
            "queue<struct>",
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long a, b;\nstruct sobra{\n    int aa, bb, cc;\n};\nqueue<sobra>falta;\nchar num[102][102];\nsobra z;\n\nvoid sub(){\n    while(falta.size()){\n        falta.pop();\n    }\n    falta.push(z);\n    num[z.aa][z.bb]='*';\n    while(falta.size()){\n        z=falta.front();\n        falta.pop();\n        z.cc++;\n        z.aa++;\n        if(num[z.aa][z.bb]=='p'){\n            cout<<z.cc;return;\n        }\n        else if(num[z.aa][z.bb]=='.' || num[z.aa][z.bb]=='0'){\n            num[z.aa][z.bb]='*';\n            falta.push(z);\n        }\n        z.aa-=2;\n        if(num[z.aa][z.bb]=='p'){\n            cout<<z.cc;return;\n        }\n        else if(num[z.aa][z.bb]=='.' || num[z.aa][z.bb]=='0'){\n            num[z.aa][z.bb]='*';\n            falta.push(z);\n        }\n        z.aa++;\n        z.bb++;\n        if(num[z.aa][z.bb]=='p'){\n            cout<<z.cc;return;\n        }\n        else if(num[z.aa][z.bb]=='.' || num[z.aa][z.bb]=='0'){\n            num[z.aa][z.bb]='*';\n            falta.push(z);\n        }\n        z.bb-=2;\n        if(num[z.aa][z.bb]=='p'){\n            cout<<z.cc;return;\n        }\n        else if(num[z.aa][z.bb]=='.' || num[z.aa][z.bb]=='0'){\n            num[z.aa][z.bb]='*';\n            falta.push(z);\n        }\n    }\n    cout<<\"-1\";\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    cin>>a>>b;\n    for(auto i=1; i<=a; i++){\n        for(auto j=1; j<=b; j++){\n            cin>>num[i][j];\n            if(num[i][j]=='c'){\n                z.aa=i;\n                z.bb=j;\n                falta.push(z);\n                num[z.aa][z.bb]='0';\n            }\n        }\n    }\n    while(falta.size()){\n        z=falta.front();\n        falta.pop();\n        z.cc++;\n        z.aa++;\n        if(num[z.aa][z.bb]=='l'){\n            sub();return 0;\n        }\n        else if(num[z.aa][z.bb]=='.'){\n            num[z.aa][z.bb]='0';\n            falta.push(z);\n        }\n        z.aa-=2;\n        if(num[z.aa][z.bb]=='l'){\n            sub();return 0;\n        }\n        else if(num[z.aa][z.bb]=='.'){\n            num[z.aa][z.bb]='0';\n            falta.push(z);\n        }\n        z.aa++;\n        z.bb++;\n        if(num[z.aa][z.bb]=='l'){\n            sub();return 0;\n        }\n        else if(num[z.aa][z.bb]=='.'){\n            num[z.aa][z.bb]='0';\n            falta.push(z);\n        }\n        z.bb-=2;\n        if(num[z.aa][z.bb]=='l'){\n            sub();return 0;\n        }\n        else if(num[z.aa][z.bb]=='.'){\n            num[z.aa][z.bb]='0';\n            falta.push(z);\n        }\n    }\n    cout<<\"-1\";return 0;\n    \n    return 0;\n}"
    },
    {
        "titulo": "7042. Déjà Vu en ESCOM",
        "url": "https://omegaup.com/arena/problem/Deja-Vu-en-ESCOM/",
        "descripcion": "Últimamente en el Club de Algoritmia ESCOM se han desarrollado nuevas técnicas que no tienen nada que ver con la programación competitiva. En este caso hablaremos de las habilidades que han desarrollado nuestros integrantes para poder controlar los sueños de las personas. Aún después de tanta preparación los estudiantes siguen siendo un poco novicios en estas técnicas obscuras y tenebrosas. Por lo que el especialista en esta técnica, el profesor Norman nos ha pedido ayuda para resolver el siguiente problema. El profesor Norman puede meterse en los sueños de las personas cuando están dormidos, para que dentro del mismo sueño haga dormir al individuo y pueda volver a meterse de nuevo en su sueño. Es decir, el profesor puede estar en un sueño dentro de otro sueño. Como sus habilidades son bastante sorprendentes, el puede repetir este proceso infinito número de veces. Al momento de meterse en un sueño, este es identificado con un número que representa el tipo de sueño en el que se encuentra actualmente (Solo existen tipos de sueños desde 1 a 10^9). Cuando el profesor Norman se mete en una serie de sueños, esto es representado con un arreglo A de números enteros. Por ejemplo: A = [1,2,3,4,5,6]. Esto nos dice que el profesor se fue metiendo en un sueño de tipo 1, después en uno de tipo 2, 3 y así consecutivamente. Si Norman comienza metiéndose a un sueño de tipo x y en alguno de los sueños posteriores vuelve a estar en otro sueño de tipo x, el siente que ya lo vivió antes, es decir, un Déjà Vu! De igual manera, si él se mete por primera vez a un sueño de tipo x y inmediatamente a uno de tipo y y se repite la secuencia x, y posteriormente, es un Déjà Vu doble. Como quiere estar preparado para lo peor que pueda suceder, Norman quiere saber cuál es la máxima secuencia de sueños para la que va a sentir un Déjà Vu. Cabe aclarar que el profesor sentirá un Déjà Vu solo con secuencias de sueños similares a las que inician en el primero en el que se adentró.",
        "entrada": "La primera línea de entrada contendrá un numero N(1<=N<=10^6), indicando la cantidad de sueños a los que el profesor se adentró. En la siguiente línea habrán N números A_i(1<=A_i<=10^9) indicando cada tipo de sueño.",
        "salida": "Un numero representando la máxima secuencia de sueños para los cuales el profesor sentirá un Déjà Vu.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores"
        ],
        "estructuras": [
            "vector<int>",
            "long long",
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c=0;\n    int num[1000002];\n    cin>>a;\n    for(auto i=0; i<a; i++){\n        cin>>num[i];\n    }\n    for(auto i=1; i<a; i++){\n        if(num[i]==num[0]){\n            b=0;\n            while((i+b)<a && num[i+b]==num[b]){\n                b++;\n            }\n            c=max(c,b);\n            if((i+b)==a){\n                cout<<c;return 0;\n            }\n        }\n    }\n    cout<<c;\n    \n    return 0;\n}"
    },
    {
        "titulo": "1099. Cifrado de Vigenère",
        "url": "https://omegaup.com/arena/problem/vigenere/",
        "descripcion": "Para cifrar una palabra con el método Cifrado de Vigenère, se hace una tabla como la que se muestra y se escoge una palabra clave. Con un ejemplo explicaremos la forma de cifrar. Supongamos que el mensaje que queremos cifrar es la palabra AGUASCALIENTES y la palabra clave es OMIAGS. Paso 1: Se hacen corresponder las letras de la palabra que se tiene que cifrar con la letras de la palabra clave, (en caso de que la palabra clave sea más corta que el mensaje, se repite tantas veces como sea necesario): AGUASCALIENTES OMIAGSOMIAGSOM Paso 2: Sustituimos cada letra del mensaje con la letra de la tabla que se encuentra en el renglón de la letra de la palabra y la columna de la letra del mensaje. Por ejemplo, para sustituir la primera A, buscamos en el renglón de la O y la columna de la A, encontrando la O. La G se sustituirá por la letra que se encuentra en el renglón de la M y la columna de G, es decir, la S. La U se sustituirá por la letra que se encuentra en el renglón de la I y la columna de U, la C. Y así sucesivamente, la palabra AGUASCALIENTES se convertiría en OSCAYUOXQETLSE. Cifrar o descifrar un mensaje dado usando el Cifrado Vigenère.",
        "entrada": "La primera línea tendrá un 1 o un 2. La segunda línea tendrá la palabra que tendrás que cifrar o descifrar. La tercera línea tendrá la palabra clave. La palabras serán de longitud a lo más 100 y estarán formadas solamente por mayúsculas.",
        "salida": "Si en la entrada la primera línea era un 1, debes imprimir la palabra cifrada. Si en la entrada la primera línea era un 2, debes imprimir la descifrada.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Aritmética",
            "Ciclos",
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "long long",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c;\n    string z, zz;\n    cin>>a>>z>>zz;\n    if(a==1){\n        for(auto i=0; i<z.size(); i++){\n            b=z[i]-64;\n            c=zz[i%zz.size()]-65;\n            b+=c;\n            b%=26;\n            if(b==0){\n                b=26;\n            }\n            z[i]=64+b;\n            cout<<z[i];\n        }\n    }\n    else{\n        for(auto i=0; i<z.size(); i++){\n            b=z[i]-64;\n            c=zz[i%zz.size()]-65;\n            b-=c;\n            if(b<=0){\n                b+=26;\n            }\n            z[i]=64+b;\n            cout<<z[i];\n        }\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "8442. Perfectamente Balanceado",
        "url": "https://omegaup.com/arena/problem/OMI-2019-Progresion/",
        "descripcion": "Tras pelear con los Avengers para conseguir las gemas del infinito, Thanos está agotado. Sin embargo, tiene una última tarea pendiente. Thanos tiene un arreglo de N enteros que debe dejar perfectamente balanceado. Un arreglo de números está perfectamente balanceado si la diferencia entre un elemento y el siguiente siempre es la misma para todos los elementos del arreglo. la diferencia entre cualquier elemento y el siguiente siempre debe ser constante. Para balancear el arreglo, Thanos sólo puede sumar o restar 1 a cada elemento. Cada vez que Thanos sume o reste un 1 a algún elemento se considera que hizo una operación. Solo se puede hacer una operacion por elemento. Thanos ofreció salvarte cuando elimine a la mitad de la población a cambio de tu ayuda. Imprime el menor número de operaciones que se necesitan para que el arreglo quede perfectamente balanceado, o -1 si no es posible balancearlo. Subtarea 1 (17 puntos): Se asegura que siempre se puede balancear usando sólo la operación de suma. Subtarea 2 (21 puntos): El primer elemento no necesita que le apliques ninguna operación. Subtarea 3 (62 puntos): No hay consideraciones adicionales.",
        "entrada": "En la primer línea el entero N. En la segunda línea N enteros separados por un espacio que representan los números del arreglo. (1<= N<=100000), (1<=n_i<=10^9).",
        "salida": "Un entero que indica el menor número de operaciones necesarias para que el arreglo quede perfectamente balanceado, o -1 si no es posible balancearlo.",
        "nivel": "Avanzado (medio) - Programación competitiva",
        "categorias": [
            "Ciclos",
            "Vectores",
            "Recursión",
            "Condicionales",
            "Programación dinámica"
        ],
        "estructuras": [
            "long long",
            "pair<int,int>",
            "vector<int>",
            "int",
            "bool"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    typedef pair < int, int > pii;\n    typedef long long int lld;\n    int n;\n    cin >> n;\n    int arr[n];\n    for (int i = 0; i < n; ++i)\n        cin >> arr[i];\n    if (n == 1) {\n        cout << \"0\\n\";\n        return 0;\n    }\n    int ans = -1;\n    for(auto f = -1; f <= 1; ++f) for (int s = -1; s <= 1; ++s) {\n        arr[0] += f; arr[1] += s;\n        bool progresion = true;\n        int cnt = abs(f) + abs(s);\n        int k = arr[1] - arr[0];\n        int act = arr[0];\n        for (int i = 1; i < n; ++i) {\n            act += k;\n            if (abs(act - arr[i]) > 1) {\n                progresion = false;\n                break;\n            }\n            cnt += abs(act - arr[i]);\n        }\n        if (progresion) ans = ans == -1 ? cnt : min(ans, cnt);\n        arr[0] -= f; arr[1] -= s;\n    }\n    cout << ans << \"\\n\";\n\n    return 0;\n}"
    },
    {
        "titulo": "6129. Mesa Redonda",
        "url": "https://omegaup.com/arena/problem/COMI-Mesa-redonda/",
        "descripcion": "Hay una mesa (redonda) con N niños numerados de 1 a N, la maestra ha decidido hacer un nuevo juego para determinar quien sale primero a jugar en el recreo, en el cual, iniciando desde el primer niño, la maestra avanza K niños en el sentido de las manecillas del reloj. Donde termine la maestra, ese niño sale al recreo, luego la maestra se para en el siguiente niño y vuelve a repetir este proceso hasta que todos los niños salgan al recreo. Randy está impaciente por salir a comer y le interesa saber después de cuantos niños saldrá él al recreo. Randy siempre es el niño número 1.",
        "entrada": "Dos enteros, N y K, el número de niños y el salto de avance que se hace. (1<=N,K<=1000).",
        "salida": "Un entero que represente el número de niños que salieron antes de Randy.",
        "nivel": "Intermedio (difícil) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Punteros"
        ],
        "estructuras": [
            "int",
            "struct"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint localiza(int x);\nvoid alta(int x);\nvoid baja();\n\ntypedef struct reg{\n    reg *sig;\n    int  dat;       //número de alumno\n}reg;\n\nreg *p, *a, *aux;\nint  n, k, c;\n\nint main(){\n    p =(reg*)malloc(sizeof(reg));  //inicio d ela lista\n    p->sig=NULL;\n    a =(reg*)malloc(sizeof(reg));  //nodo actual\n    a->sig=NULL;\n    aux=(reg*)malloc(sizeof(reg));\n    aux->sig=NULL;\n    cin>>n>>k;\n    for(auto i=1;i<=n;i++) alta(i);\n    a=p;\n    while(1){\n        a=a->sig;\n        for(auto i=1;i<=k;i++) localiza(i);\n        if(a->dat==1) break;       //regresa con Randy\n        baja();\n    }\n    cout<<c;\n\n    return 0;\n}\n\nvoid alta(int x){\n    if (p->sig == NULL){       // Si Lista Vacia\n        p->sig = a;\n        a->dat = x;\n    }\n    else{\n        reg *n;\n        n=(reg*) malloc(sizeof(reg));\n        n->sig=p->sig;\n        n->dat=x;\n        a->sig=n;\n        a=n;\n    }\n}\n\nint localiza(int x){\n    if(a->sig!=NULL){       //Solo queda Randy\n        aux=a;\n        a=a->sig;\n    }\n}\n\nvoid baja(){\n    aux->sig=a->sig;\n    if (p==aux) p->sig=aux->sig;\n    c++;\n\n}"
    },
    {
        "titulo": "6201. Rectangulo",
        "url": "https://omegaup.com/arena/problem/COMI-Rectangulo/",
        "descripcion": "Karel el constructor ha decidido hacer una nueva casa en la metropolí de karelotitlan. Como sabras Karel no es muy bueno con las figuras geometricas irregulares, asi que ha decidido construir su casa en la primer calle y que su casa sera el espacio rectangular más grande que hay en la metropoli.",
        "entrada": "Se te dara n, el número de avenidas que hay en la metropoli, en la siguiente linea habra n enteros indicando cuanto espacio libre hay en esa avenida (partiendo de la primera calle). (1<=n<=10^6), (1<=n_i<=10^6).",
        "salida": "El área del rectángulo más grande.",
        "nivel": "Intermedio (fácil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Vectores",
            "Pilas"
        ],
        "estructuras": [
            "long long",
            "stack<long long>",
            "vector<long long>"
        ],
        "codigo": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    long long int hist[1000100];\n    long long int n;\n    stack<long long int> s;\n    cin>>n;\n    for(auto i=0;i<n;i++){\n        cin>>hist[i];\n    }\n    long long int area = 0;\n    long long int tp;\n    long long int areasuperior;\n    long long int i = 0;\n    while (i < n){\n        if (s.empty() || hist[s.top()] <= hist[i]){\n            s.push(i++);\n        }\n        else{\n            tp = s.top();\n            s.pop();\n            areasuperior = hist[tp] * (s.empty() ? i : i - s.top() - 1);\n            if (area < areasuperior)\n                area = areasuperior;\n        }\n    }\n    while (s.empty() == false){\n        tp = s.top();\n        s.pop();\n        areasuperior = hist[tp] * (s.empty() ? i : i - s.top() - 1);\n        if (area < areasuperior)\n            area = areasuperior;\n    }\n    cout<<area;\n}"
    },
    {
        "titulo": "3471. Carguero",
        "url": "https://omegaup.com/arena/problem/carguero/",
        "descripcion": "La Organización Mundial Inter-oceánica (OMI) ha iniciado operaciones en el país y actualmente dispone de 4 cargueros para transportar mercancía de un puerto marítimo a otro. A pocos días de realizar su primer envío de 12 contenedores, el jefe de operaciones ha decidido que cada carguero lleve 3 contenedores, y que éstos, de acuerdo con su peso, estén distribuidos de manera uniforme. Ayuda al jefe de operaciones para minimizar T-t, donde T es el peso del carguero con mayor carga y, t el peso del carguero con la carga menor.",
        "entrada": "12 líneas que contienen la carga c_i, donde (1<=c<=1000000).",
        "salida": "Una sola línea indicando el valor mínimo de T-t.",
        "nivel": "Intermedio (difícil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Vectores",
            "Recursión"
        ],
        "estructuras": [
            "vector<int>",
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint carga_peso[12];\nint carga_carguero[12];\nint carguero_count[4];\nint answer = -1;\n\nvoid recurse(int carga) {\n    if (carga == 12) {\n        int carguero_carga[4] = {0,0,0,0};\n        for (int i = 0; i < 12; i++) {\n            carguero_carga[carga_carguero[i]] += carga_peso[i];\n        }\n        int T = max(max(carguero_carga[0], carguero_carga[1]),\n                    max(carguero_carga[2], carguero_carga[3]));\n        int t = min(min(carguero_carga[0], carguero_carga[1]),\n                    min(carguero_carga[2], carguero_carga[3]));\n        if (answer == -1 || T - t < answer) {\n            answer = T - t;\n        }\n        return;\n    }\n    for (int carguero = 0; carguero < 4; carguero++) {\n        if (carguero_count[carguero] < 3) {\n            carga_carguero[carga] = carguero;\n            carguero_count[carguero]++;\n            recurse(carga+1);\n            carguero_count[carguero]--;\n        }\n    }\n}\n\nint main() {\n    for (int i = 0; i < 12; i++) {\n        cin >> carga_peso[i];\n    }\n    recurse(0);\n    cout << answer << '\\n';\n\n    return 0;\n}"
    },
    {
        "titulo": "6120. Canchas",
        "url": "https://omegaup.com/arena/problem/COMI-Canchas/",
        "descripcion": "El director de la escuela necesita tu ayuda para redistribuir la cancha de basket y de volley en el patio de la escuela. Ambas canchas ahora serán rectángulos cuyas esquinas estarán en coordenadas enteras dentro del nuevo patio. El director te dará las coordenadas de las esquinas opuestas de cada cancha nueva y quiere que calcules cuál será el área total del patio que quedará cubierta por ambas canchas. A pesar del tamaño del patio de la escuela, puede ser que ambas canchas puedan encimarse, por lo que deberás tomar eso en cuenta para no contar dos veces el área. Escribe un programa que dadas las coordenadas de un par de esquinas opuestas de cada cancha calcule el área total cubierta por ambas canchas.",
        "entrada": "Tu programa deberá leer del teclado dos líneas, cada una con 4 números enteros separados por un espacio que representan las coordendas x_1, y_1, x_2, y_2 de cada una de las canchas (0<=x_1,y_1,x_2,y_2<=10000).",
        "salida": "Tu programa deberá escribir en la pantalla un único número entero que represente el área total cubierta por ambas canchas.",
        "nivel": "Intermedio (medio) - Matemáticas en la programación",
        "categorias": [
            "Aritmética",
            "Condicionales",
            "Geometría Analítica"
        ],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main (){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    int x_1,y_1,x_2,y_2;\n    int a_1,b_1,a_2,b_2;\n    cin>>x_1>>y_1>>x_2>>y_2;\n    cin>>a_1>>b_1>>a_2>>b_2;\n    int s1=(abs(x_1-x_2)*abs(y_1-y_2));\n    int s2=(abs(a_1-a_2)*abs(b_1-b_2));\n    int res=s1+s2;\n    int a=max(x_1,a_1);\n    int b=min(x_2,a_2);\n    int c=max(y_1,b_1);\n    int d=min(y_2,b_2);\n    if(a<b&&c<d)res-=((b-a)*(d-c));\n    cout << res<<\"\\n\";\n\n    return 0;\n}"
    },
    {
        "titulo": "6110. Traductor",
        "url": "https://omegaup.com/arena/problem/COMI_Traductor/",
        "descripcion": "En un lejano planeta coexisten dos culturas ancestrales, la Numírica y la Enteral y pese a sus similitudes culturales, se comunican en lenguajes totalmente diferentes. Por ejemplo, en numírico podrías decir \"hola\" con \"53134\" mientras que en enteral sería \"46952\". Tu tarea será realizar traducciones entre ambos idiomas. Escribe un programa que dada una lista de palabras que representa un diccionario, pueda traducir palabras entre lenguajes.",
        "entrada": "La primer linea tendrá dos enteros d y w. Las siguientes d lineas representan las traducciones del diccionario. Cada una con un par de enteros; n_i y e_i separados por un espacio. n_i representa una palabra en numírico y e_i su representación a enteral. Puedes estar seguro de que las palabras no se repetirán en el diccionario. Las siguientes w líneas contienen un entero, representando la palabra en numírico que tendrás que traducir. (0<=d, w<=1000), (-2,000,000,000<=n_i,e_i<=2,000,000,000).",
        "salida": "Por cada palabra a traducir, deberás imprimir una línea que contenga su respectiva traduccion en enteral. Si una palabra no tiene traducción debes imprimir \"C?\" en esa línea.",
        "nivel": "Intermedio (medio) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Búsqueda binaria",
            "Tablas de dispersión",
            "Vectores",
            "Colas"
        ],
        "estructuras": [
            "queue<long long>",
            "long long",
            "vector<pair<long long,long long>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    queue<long long>falta;\n    queue<long long>sobra;\n    long long a, b, c, d, e, f;\n    cin>>a>>b;\n    long long num[2][a];\n    for(auto i=0; i<a; i++){\n        cin>>num[0][i]>>num[1][i];\n    }\n    for(auto i=0; i<a; i++){\n        c=0;\n        for(auto j=0; j<(a-i)-1; j++){\n            if(num[0][j+1]<num[0][j]){\n                swap(num[0][j],num[0][j+1]);\n                swap(num[1][j],num[1][j+1]);\n                c=1;\n            }\n        }\n        if(c==0){\n            break;\n        }\n        c=0;\n    }\n    while(b!=0){\n        b--;\n        cin>>c;\n        d=0; e=a-1;\n        while(d<=e){\n            f=(d+e)/2;\n            if(num[0][f]==c){\n                cout<<num[1][f]<<\"\\n\";break;\n            }\n            else if(num[0][f]>c){\n                e=f-1;\n            }\n            else{\n                d=f+1;\n            }\n        }\n        if(d>e){\n            cout<<\"C?\\n\";\n        }\n    }\n        \n    return 0;\n}"
    },
    {
        "titulo": "6955. Guacamole",
        "url": "https://omegaup.com/arena/problem/OMI2018-Guacamole/",
        "descripcion": "En la Feria de Chapultepec se encuentra el juego Guacamole, la versión mexicana de Whac-a-mole y obviamente quieres obtener la mayor cantidad de puntos posible. El juego es una cuadrícula de tamaño NxM en la que hay un topo en cada casilla. Los topos están escondidos inicialmente y en cada segundo salen topos de algunas casillas y se esconden topos de otras casillas. Obtienes puntos por cada topo que logras golpear. Para jugar tienes que seguir las siguientes reglas: El topo en la posición (i,j)aparecerá por primera vez en el segundo I_{i,j} y volverá a aparecer cada S_{i,j} segundos. Por ejemplo si I_{i,j}=2 y S_{i,j}=3, aparecerá un topo en la posición (i,j) en los segundos (2,5,8,11...) y durará un segundo afuera antes de volver a esconderse. El segundo que está afuera el topo es el único momento en que puedes ganar puntos por golpearlo, es decir, si el topo sale en el segundo 2, puedes golpearlo en ese segundo, para el segundo 3, se habrá escondido de nuevo. Debes elegir en qué casilla pegar en el segundo 1, no importa si hay o no topo afuera. No puedes no golpear. Es decir, en cada segundo debes golpear alguna casilla, sin importar si hay o no un topo afuera. Como no eres tan rápido para moverte por las casillas, si golpeas en la casilla (i,j), tu siguiente golpe (en el siguiente segundo) debe ser en esa misma casilla o en alguna de sus 8 adyacentes. Es decir, si (i,j) es la última casilla que golpeaste, en el siguiente turno puedes golpear las casillas (i,j),(i-1,j),(i-1,j-1),(i,j-1),(i+1,j),(i+1,j+1),(i,j+1),(i-1,j+1) y (i+1, j-1) y siempre y cuando estén dentro de la cuadrícula. Si golpeas en la posición (i,j) y hay un topo afuera, se suman P_{i,j} puntos a tu total. Si no hay un topo afuera, no se suma nada a tu total. Encuentra la mayor puntuación posible que se puede lograr con las reglas anteriores. Subtareas: En el 30% de los casos, para todo i,j. I_{i,j} = i+j-1(con (1<=i<=N,1<=j<=M), S_{i,j}=T, (0<=P_{i,j}), para el 70% restante no hay consideraciones adicionales.",
        "entrada": "En la primera línea 3 enteros: N, M y T que representan el número de filas, el número de columnas del tablero y los segundos que dura el juego, respectivamente. Sigue la matriz I de tamaño NxM que indica en qué segundo sale cada topo por primera vez. Después una matriz S de tamaño NxM que indica cuántos segundos tarda cada topo en volver a salir. Por último una matriz P de tamaño NxM  que indica cuántos puntos obtienes si logras golpear al topo en cada casilla. (1<=N,M<=100), (1<=T<=500), (1<=S_{i,j},I_{i,j}<=T), (-10^9<=P_{i,j}<=10^9).",
        "salida": "Un entero que indica el puntaje más alto que se puede obtener en el juego.",
        "nivel": "Avanzado (medio) - Programación competitiva",
        "categorias": [
            "Programación dinámica",
            "Vectores",
            "Recursión"
        ],
        "estructuras": [
            "bool",
            "long long",
            "vector<vector<vector<long long>>>",
            "vector<vector<vector<bool>>>",
            "vector<long long>"
        ],
        "codigo": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nll n,m,t,mdo[4][101][101],DP[101][101][501],ans;\nll dx[]= {0,1,1,0,-1,-1,-1,0,1};\nll dy[]= {0,0,-1,-1,-1,0,1,1,1};\nbool use[101][101][501];\n\nll fn(ll fila,ll columna, ll tiempo)\n{\n    if(tiempo>t) return 0LL;\n\n    if(use[fila][columna][tiempo]) return DP[fila][columna][tiempo];\n\n    use[fila][columna][tiempo] = true;\n\n    ll x=0,y;\n    bool useY=false;\n    if(tiempo>=mdo[1][fila][columna] && (tiempo-mdo[1][fila][columna])%mdo[2][fila][columna]==0) x=mdo[0][fila][columna];\n\n    for(ll k=0; k<9; k++)\n    {\n        ll f=fila+dy[k];\n        ll c=columna+dx[k];\n        if(f>=0 && f<n && c>=0 && c<m)\n        {\n            if(!useY)\n            {\n                useY=true;\n                y=fn(f,c,tiempo+1);\n            }\n            y=max(y,fn(f,c,tiempo+1));\n        }\n    }\n\n    return DP[fila][columna][tiempo]=x+y;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    cin >> n >> m >> t;\n    for(ll i=0; i<n; i++) for(ll j=0; j<m; j++) cin >> mdo[1][i][j];\n    for(ll i=0; i<n; i++) for(ll j=0; j<m; j++) cin >> mdo[2][i][j];\n    for(ll i=0; i<n; i++) for(ll j=0; j<m; j++) cin >> mdo[0][i][j];\n\n    ans=fn(0,0,1);\n    for(ll i=0; i<n; i++) for(ll j=0; j<m; j++) ans=max(ans,fn(i,j,1));\n\n    cout << ans;\n\n    return 0;\n"
    },
    {
        "titulo": "6378. COCI 20/01/2018 Olivander",
        "url": "https://omegaup.com/arena/problem/Olivander/",
        "descripcion": "Harry Potter ha dañado su vara mágica en una pelea con Lord Voldemort. El ha decidido conseguir una nueva vara en la tienda de varas de Olivander. En el piso de la tienda, él vió N varas y N cajas de varas. Las longitudes de las varas son respectivamente X_1, X_2,...X_n y las longitudes de las cajas son Y_1, Y_2,...Y_n. Una vara de longitud X puede ser puesta en una caja de tamaño Y si X<=Y. Harry quiere saber si puede poner todas las varas en cajas de tal manera que cada caja contenga exactamente una vara. Ayúdelo a resolver este difícil problema.",
        "entrada": "La primera línea de la entrada contiene el entero positivo N(2<=N,<=100), el número de la tarea. La segunda línea de la entrada contiene N números positivos X_i(1<=X_i<=10^9), los números de la tarea. La tercera línea de la entrada contiene N números positivos Y_i(1<=Y_i<=10^9), los números de la tarea.",
        "salida": "Si Harry puede poner todas las varas en cajas dé como salid 'DA' (si en croata), en otro caso dé como salida 'NE' (no en croata).",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores",
            "Ordenamiento"
        ],
        "estructuras": [
            "long long",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b;\n    vector<int>falta;\n    vector<int>faltas;\n    cin>>a;\n    for(auto i=0; i<a; i++){\n        cin>>b;\n        falta.push_back(b);\n    }\n    for(auto i=0; i<a; i++){\n        cin>>b;\n        faltas.push_back(b);\n    }\n    sort(falta.begin(),falta.end());\n    sort(faltas.begin(),faltas.end());\n    for(auto i=0; i<a; i++){\n        if(falta[i]>faltas[i]){\n            cout<<\"NE\";return 0;\n        }\n    }\n    cout<<\"DA\";\n    \n    return 0;\n}\n"
    },
    {
        "titulo": "3442. COCI TABOVI",
        "url": "https://omegaup.com/arena/problem/COCI-TABOVI/",
        "descripcion": "Zvonkec es aún otro programador empleado de una empresa pequeña. Cada día tiene que refactorizar un archivo de código fuente. Muy a su pesar, la fuente está generalmente lejos de ser clara y ordenada. Él está especialmente molesto con la indentación irregular, es decir, el número de tabuladores (tabs) indentados en cada línea. Afortunadamente, su editor tiene un comando para seleccionar un grupo de líneas consecutivas y añadir o eliminar un carácter del inicio de cada una. Ayuda a Zvonkec a organizar el código tan rápido como sea posible. Se te da el número de líneas N, una secuencia especificando el número de tabulaciones al inicio de cada línea, y una secuencia que especifica el número requerido de tabulaciones al inicio de cada línea. Zvonkec puede ejecutar cualquier número de comandos que consisten en: Seleccionar cualquier número de líneas consecutivas. Agregar o eliminar una sola tabulación de cada una de las líneas seleccionadas. Las dos acciones anteriores comprenden un solo comando, sin importar el número de líneas seleccionadas. Debe tenerse en cuenta que está prohibido eliminar más tabulaciones de una línea que en realidad no tiene ya tabulaciones al inicio, ya que el editor comenzaría a eliminar caracteres en vez de tabulaciones. Se te pide calcular el mínimo número de comandos requeridos para ordenar el código.",
        "entrada": "La primera línea contiene un entero positivo N. La segunda línea contiene una secuencia de N enteros P_i, especificando el número de tabulaciones al inicio de la i-ésima línea antes de cualquier edición. La tercera línea contiene una secuencia de N enteros K_i, especificando el número de tabulaciones que Zvonkec quiere al inicio de la i-ésima línea.",
        "salida": "La primera y la única línea debe contener el número requerido, como se especifica en la descripción del problema.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores"
        ],
        "estructuras": [
            "long long",
            "vector<pair<int,int>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d=0;\n    pair<int,int>num[1002];\n    cin>>a;\n    for(auto i=0; i<a; i++){\n        cin>>num[i].first;\n    }\n    for(auto i=0; i<a; i++){\n        cin>>num[i].second;\n    }\n    for(auto i=0; i<a; i++){\n        if(num[i].first==num[i].second){\n            continue;\n        }\n        if(num[i].first>num[i].second){\n            b=i;\n            c=num[i].first-num[i].second;\n            while(num[b].first>num[b].second){\n                if((num[b].first-num[b].second)<c){\n                    c=num[b].first-num[b].second;\n                }\n                b++;\n            }\n            for(auto j=i; j<b; j++){\n                num[j].first-=c;\n            }\n            d+=c;\n            i--;continue;\n        }\n        b=i;\n        c=num[i].first-num[i].second;\n        while(num[b].first<num[b].second){\n            if((num[b].first-num[b].second)>c){\n                c=num[b].first-num[b].second;\n            }\n            b++;\n        }\n        for(auto j=i; j<b; j++){\n            num[j].first-=c;\n        }\n        d-=c;\n        i--;continue;\n    }\n    cout<<d;\n    \n    return 0;\n}\n\n"
    },
    {
        "titulo": "4246. COCI-NIZOVI",
        "url": "https://omegaup.com/arena/problem/COCI-NIZOVI/",
        "descripcion": "Un arreglo en cierto lenguaje de programación está definido de la siguiente manera: El inicio y el final de un arreglo está denotado por una llave abierta y cerrada, respectivamente. Dentro de las llaves, hay (posiblemente 0) valores separados por comas (no hay una coma después del último elemento del arreglo). Cada valor puede ser una palabra (un arreglo de letras minúsculas del alfabeto inglés) u otro arreglo. Ejemplos de arreglos correctamente definidos son: {}, {a,b,c}, {abc,znj,{novi,niz},pozz}. Recientemente, has notado que el lenguaje de programación no arroja un error si no colocas la cantidad apropiada de espacios y líneas nuevas antes o después de las llaves o las comas. Dado el hecho de que te molesta que los valores estén muy apretados, has decidido ponerte a trabajar y modificar la forma de los arreglos de la siguiente manera: Cada valor que no es un arreglo o denota el inicio o el final de un arreglo (llaves) estará en su propia línea. Las comas están 'conectadas' con el valor ubicado directamente antes de ellas y hay una línea nueva después de cada coma. Después de la llave que denota el inicio de un arreglo, la indentación aumenta (moviendo el contenido a la derecha) dos espacios. Antes de la llave que denota el final de un arreglo '}', la indentación del contenido disminuye (moviendo el contenido a la izquierda) dos espacios.",
        "entrada": "La primera línea de entrada contiene un arreglo de caracteres S (1<=|S|<=1500) representando el arreglo de la tarea.",
        "salida": "La salida debe consistir de la versión modificada del arreglo de la tarea.",
        "nivel": "Básico (difícil) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "long long",
            "string",
            "getline()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a=0, b, c;\n    string z, zz=\"\";\n    getline(cin,z);\n    for(auto i=0; i<z.size()-1; i++){\n        if(z[i]==' ' || z[i]==','){\n            continue;\n        }\n        if(z[i]=='{'){\n            b=a;\n            while(b--){\n                cout<<\" \";\n            }\n            cout<<z[i]<<\"\\n\";\n            a+=2;continue;\n        }\n        if(z[i]=='}'){\n            b=1;\n            for(auto j=i+1; j<z.size(); j++){\n                if(z[j]=='}'){\n                    b--;break;\n                }\n                if(z[j]!=' ' && z[j]!=','){\n                    break;\n                }\n            }\n            a-=2;\n            c=a;\n            while(c--){\n                cout<<\" \";\n            }\n            cout<<\"}\";\n            if(b){\n                cout<<\",\";\n            }\n            cout<<\"\\n\";continue;\n        }\n        zz=zz+z[i];\n        i++;\n        while(z[i]!=' ' && z[i]!=',' && z[i]!='{' && z[i]!='}'){\n            zz=zz+z[i];\n            i++;\n        }\n        i--;\n        b=a;\n        while(b--){\n            cout<<\" \";\n        }\n        cout<<zz;\n        zz=\"\";\n        b=1;\n        for(auto j=i+1; j<z.size(); j++){\n            if(z[j]=='}'){\n                b--;break;\n            }\n            if(z[j]!=' ' && z[j]!=','){\n                break;\n            }\n        }\n        if(b){\n            cout<<\",\";\n        }\n        cout<<\"\\n\";\n    }\n    cout<<\"}\";\n    \n    return 0;\n}"
    },
    {
        "titulo": "4151. Carlos El Oso y la víbora",
        "url": "https://omegaup.com/arena/problem/carlos_el_oso_y_la_vibora/",
        "descripcion": "Carlos el Oso está aprendiendo a programar. La primer tarea es dibujar un oso! Sin embargo Carlos cree que eso es muy difícil para un principiante, así que mejor decide dibujar una víbora. Una víbora es un patrón en una tabla de n por m. Donde la celda de la c-ésima columna del r-iésimo renglón, se define como (r,c). La cola de la víbora está en (1,1) y su cuerpo se extiende por (1,m), luego va para abajo 2 renglones hasta (3,m) y luego a la izquierda hasta (3,1), etc. Tu tarea es díbujar la víbora de Carlos el oso; una celda vacía se representará por el caracter del punto \".\" y las celdas de la víbora se rellenarán con el signo de número \"#\". Ve los ejemplos para que entiendas mejor el patrón de la víbora.",
        "entrada": "La única línea contiene dos enteros: n y m (3<=n,m<=59). n es un número impar.",
        "salida": "La salida serán n líneas. Cada línea contendrá una cadena que constará de m caracteres. No muestre espacios.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Matrices",
            "Ciclos",
            "Geometría"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c=1;\n    cin>>a>>b;\n    for(auto i=1; i<=a; i++){\n        if(i%2){\n            for(auto j=1; j<=b; j++){\n                cout<<\"#\";\n            }\n        }\n        else{\n            if(c%2){\n                for(auto j=1; j<b; j++){\n                    cout<<\".\";\n                }\n                cout<<\"#\";\n            }\n            else{\n                cout<<\"#\";\n                for(auto j=1; j<b; j++){\n                    cout<<\".\";\n                }\n            }\n            c++;\n        }\n        cout<<\"\\n\";\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "3050. Casilla para votar",
        "url": "https://omegaup.com/arena/problem/Casilla-para-votar/",
        "descripcion": "Las votaciones en Nlognoria están a punto de llevarse a cabo, sin embargo, los ciudadanos no saben con certeza en dónde se encuentra su casilla para votar. Debido a este problema, el CEN (Consejo Nacional Electoral) de Nlognoria, ha decidido intervenir y te ha contratado para que les ayudes en esta importante labor. Lo interesante en esto, es que desde su fundación, Nlognoria siempre ha sido un país bastante regular, en primer lugar, se conforma de un territorio rectangular de anchura N y altura M, el cual se encuentra dividido en N x M regiones cuadradas, en donde en cada una puede haber una montaña, un pastizal, un tramo de agua o una casa. A su vez, los habitantes se organizaron en pueblos, construyendo nuevas casas en forma ortogonal a las ya existentes, o aislándose para crear un nuevo pueblo. Debido a esto, dos casas se encuentran en el mismo pueblo solo si existe un camino de movimientos ortogonales compuesto únicamente por casas que las interconecta. Cada habitante conoce las coordenadas donde se encuentra su casa. Para este año el CEN ha decidido poner una casilla en cada pueblo y lo hará primero buscando la casa que se encuentra más abajo y después la más a la derecha de cada uno. Así que el programa que te han encomendado tiene como objetivo que los ciudadanos puedan ingresar las coordenadas de su casa y éste imprima las coordenadas de la casilla en donde le toca votar.",
        "entrada": "La entrada comienza con dos números enteros N y M separados por un espacio con 1<=N,M<=10^2, que indica la anchura y longitud que tiene Nlognoria, posteriormente le siguen N líneas, cada una con M enteros 0<=m_i<=3 separados entre si por un espacio, en donde el valor 0 indica una porción de agua, el 1 una montaña, el 2 un pastizal y el 3 una casa. Seguido a esto se tiene un entero Q con 1<=Q<=10^4 que indica el número de peticiones que se harán al programa, seguido de Q coordenadas enteras en formato x y con 1<=x<=N y 1<=y<=M separadas por un espacio.",
        "salida": "Para cada petición, se deberá imprimir una línea en formato (x,y) la cual representa las coordenadas de la casilla en la que le toca votar al ciudadano, o la palabra montana, pastizal o agua indicando del tipo de terreno si es que no existe una casa en ese lugar.",
        "nivel": "Avanzado (difícil) - Programación competitiva",
        "categorias": [
            "Matrices",
            "Colas",
            "Búsqueda en amplitud"
        ],
        "estructuras": [
            "long long",
            "pair<int,pair<int,int>>[][]",
            "queue<pair<int,int>>",
            "pair<int,int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d;\n    pair<int,pair<int,int>>num[102][102];\n    queue<pair<int,int>>falta;\n    pair<int,int>z;\n    cin>>a>>b;\n    for(auto i=1; i<=a; i++){\n        for(auto j=1; j<=b; j++){\n            cin>>num[i][j].first;\n        }\n    }\n    for(auto i=1; i<=a; i++){\n        for(auto j=1; j<=b; j++){\n            if(num[i][j].first==3 && num[i][j].second.first==0){\n                z.first=i;\n                z.second=j;\n                c=i;\n                d=j;\n                falta.push(z);\n                num[i][j].second.first=-1;\n                while(falta.size()){\n                    z=falta.front();\n                    falta.pop();\n                    if(z.first>c){\n                        c=z.first;\n                        d=z.second;\n                    }\n                    else if(z.first==c && z.second>d){\n                        d=z.second;\n                    }\n                    z.first++;\n                    if(num[z.first][z.second].first==3 && num[z.first][z.second].second.first==0){\n                        num[z.first][z.second].second.first=-1;\n                        falta.push(z);\n                    }\n                    z.first-=2;\n                    if(num[z.first][z.second].first==3 && num[z.first][z.second].second.first==0){\n                        num[z.first][z.second].second.first=-1;\n                        falta.push(z);\n                    }\n                    z.first++;\n                    z.second++;\n                    if(num[z.first][z.second].first==3 && num[z.first][z.second].second.first==0){\n                        num[z.first][z.second].second.first=-1;\n                        falta.push(z);\n                    }\n                    z.second-=2;\n                    if(num[z.first][z.second].first==3 && num[z.first][z.second].second.first==0){\n                        num[z.first][z.second].second.first=-1;\n                        falta.push(z);\n                    }\n                }\n                z.first=i;\n                z.second=j;\n                falta.push(z);\n                num[i][j].second.first=c;\n                num[i][j].second.second=d;\n                while(falta.size()){\n                    z=falta.front();\n                    falta.pop();\n                    z.first++;\n                    if(num[z.first][z.second].first==3 && num[z.first][z.second].second.first==-1){\n                        num[z.first][z.second].second.first=c;\n                        num[z.first][z.second].second.second=d;\n                        falta.push(z);\n                    }\n                    z.first-=2;\n                    if(num[z.first][z.second].first==3 && num[z.first][z.second].second.first==-1){\n                        num[z.first][z.second].second.first=c;\n                        num[z.first][z.second].second.second=d;\n                        falta.push(z);\n                    }\n                    z.first++;\n                    z.second++;\n                    if(num[z.first][z.second].first==3 && num[z.first][z.second].second.first==-1){\n                        num[z.first][z.second].second.first=c;\n                        num[z.first][z.second].second.second=d;\n                        falta.push(z);\n                    }\n                    z.second-=2;\n                    if(num[z.first][z.second].first==3 && num[z.first][z.second].second.first==-1){\n                        num[z.first][z.second].second.first=c;\n                        num[z.first][z.second].second.second=d;\n                        falta.push(z);\n                    }\n                }\n            }\n        }\n    }\n    cin>>a;\n    while(a--){\n        cin>>b>>c;\n        if(num[b][c].first==3){\n            cout<<\"(\"<<num[b][c].second.first<<\",\"<<num[b][c].second.second<<\")\";\n        }\n        else{\n            switch(num[b][c].first){\n                case 0: cout<<\"agua\";break;\n                case 1: cout<<\"montana\";break;\n                case 2: cout<<\"pastizal\";break;\n            }\n        }\n        cout<<\"\\n\";\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "6275. Centro de un vector",
        "url": "https://omegaup.com/arena/problem/Centro-vector/",
        "descripcion": "Considera un vector x cuyas coordenadas van de la 0 a la n y contienen valores enteros. A una coordenada c (entre 0 y n) se le dice el centro de x si cumple que la suma desde i=0 hasta i=c-1 de (c-i)x_i es igual a la suma desde i=c+1 hasta n de (i-c)x_i. Observa que la entrada en la coordenada c no participa en ninguna de las dos sumas. Por ejemplo, si x es el vector (6,2,3,0,1), entonces c=1 es un centro de x, pues la primera suma (1-0)6 es igual a la segunda suma (2-1)3+(3-1)0+(4-1)1 (ambas valen 6). No todos los vectores tienen centro. Por ejemplo, el vector (1,2,1,1) no tiene centro porque ninguna de sus coordenadas cumple que las dos sumas son iguales. Advierte que el centro de un vector tiene interpretación física: si se considera a los valores contenidos en el vector como pesos, entonces un centro del vector (si acaso existe) corresponde con el centro de gravedad.",
        "entrada": "Consiste de un número entero n que tendrá un valor entre 1 y 1000 seguido de un renglón con n+1 números enteros, x_0, x_1, ..., x_n, separados por espacios, cada uno con valor entre 1 y 1000",
        "salida": "Consiste de dos números enteros c, s, separados por un espacio. El primero es el centro de x y el segundo es el valor de la suma. Si x no tiene centro, entonces c=-1, s=0.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Cálculos aritméticos",
            "Ciclos",
            "Vectores"
        ],
        "estructuras": [
            "long long",
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b=0, c=0, d=0;\n    int num[1001];\n    cin>>a;\n    for(auto i=0; i<=a; i++){\n        cin>>num[i];\n        c+=(num[i]*i);\n    }\n    if(c==0){\n        cout<<\"0 0\";return 0;\n    }\n    while(d<a){\n        d++;\n        for(auto i=d; i<=a; i++){\n            c-=num[i];\n        }\n        for(auto i=d-1; i>=0; i--){\n            b+=num[i];\n        }\n        if(b==c){\n            cout<<d<<\" \"<<b;return 0;\n        }\n        if(b>c){\n            cout<<\"-1 0\";return 0;\n        }\n    }\n    cout<<\"-1 0\";\n    \n    return 0;\n}"
    },
    {
        "titulo": "102. Cadenas de Potencias de 2",
        "url": "https://omegaup.com/arena/problem/cadenasp2/",
        "descripcion": "Si hicieras listas del 1 a una potencia de 2, las primeras cinco listas serían:1 12 1234 12345678 12345678910111213141516. Si solamente te quedaras con la cifra de las unidades y juntas todas esas cifras quedaría una cadena de este tipo: 1121234123456781234567890123456. Ahora imagina que se hace lo anterior para una infinidad de listas, ¿podrías decir qué cifra está en el lugar y a qué número corresponde dicha cifra?",
        "entrada": "La primera línea tendrá un entero , la cantidad de números en la lista, 0<n<=2^62",
        "salida": "Una línea con dos números separados por un espacio, la cifra y el número al que corresponde.",
        "nivel": "Intermedio (medio) - Matemáticas en la programación",
        "categorias": [
            "Cálculos aritméticos"
        ],
        "estructuras": [
            "unsigned long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    unsigned long long a, b = 1, c = 0;\n    cin >> a;\n    while (c < a)\n    {\n        c += b;\n        b *= 2;\n    }\n    if (c == a)\n    {\n        cout << (b / 2) % 10 << \" \" << b / 2;\n        return 0;\n    }\n    c -= (b / 2);\n    cout << (a - c) % 10 << \" \" << a - c;\n\n    return 0;\n}"
    },
    {
        "titulo": "2274. Arte Vacuno",
        "url": "https://omegaup.com/arena/problem/Arte-Vacuno/",
        "descripcion": "Un hecho poco conocido acerca de las vacas es que ellas son ciegas para el color verde, para ellas los colores rojo y verde se ven iguales. Esto hace especialmente difícil diseñar arte que sea atractivo tanto para vacas como para humanos. Considere una pintura en un cuadrado que está descrito como una cuadrícula NxN de caracteres (1 <= N <= 100), cada uno o R (rojo), G (verde) o B (azul). Una pintura es interesante si tiene muchas regiones coloreadas que puedan distinguirse unas de otras. Dos caracteres pertenecen a la misma región si están adyacentes directamente (este, oeste, norte o sur) y si ellas son indistinguibles por color. Por ejemplo, la pintura RRRBB GGBBB BBBRR BBRRR RRRRR tiene 4 regiones (2 rojas,1 azul y 2 verdes) si es vista por un humano y únicamente 3 regiones (2 rojo-verde, 1 azul) si es vista por una vaca. Dada una pintura como entrada, por favor, ayude a calcular el número de regiones en la pintura cuando es vista por un humano y cuando es vista por una vaca.",
        "entrada": "Línea 1: El entero N. Líneas 2..1+N: Cada línea contiene una cadena con N caracteres, describiendo una fila de pintura.",
        "salida": "Línea 1: Dos enteros separados por espacio, diciendo el número de regiones en la pintura cuando es vista por un humano y por una vaca.",
        "nivel": "Intermedio (difícil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Matrices",
            "Colas",
            "Búsqueda en amplitud"
        ],
        "estructuras": [
            "struct",
            "long long",
            "char",
            "vector<vector<char>>",
            "queue<struct>",
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long a, c = 0;\nstruct sobra\n{\n    int aa, bb;\n    char cc;\n};\nchar num[102][102];\nqueue<sobra> falta;\nsobra z;\n\nvoid sub(sobra x, char y)\n{\n    c++;\n    if (y == 'B')\n    {\n        num[x.aa][x.bb] = '2';\n        x.cc = '2';\n    }\n    else\n    {\n        num[x.aa][x.bb] = '1';\n        x.cc = '1';\n    }\n    falta.push(x);\n    while (falta.size())\n    {\n        x = falta.front();\n        falta.pop();\n        x.aa++;\n        if (num[x.aa][x.bb] == y)\n        {\n            num[x.aa][x.bb] = x.cc;\n            falta.push(x);\n        }\n        x.aa -= 2;\n        if (num[x.aa][x.bb] == y)\n        {\n            num[x.aa][x.bb] = x.cc;\n            falta.push(x);\n        }\n        x.aa++;\n        x.bb++;\n        if (num[x.aa][x.bb] == y)\n        {\n            num[x.aa][x.bb] = x.cc;\n            falta.push(x);\n        }\n        x.bb -= 2;\n        if (num[x.aa][x.bb] == y)\n        {\n            num[x.aa][x.bb] = x.cc;\n            falta.push(x);\n        }\n    }\n}\n\nvoid sum(sobra x, char y)\n{\n    c++;\n    falta.push(x);\n    while (falta.size())\n    {\n        x = falta.front();\n        falta.pop();\n        x.aa++;\n        if (num[x.aa][x.bb] == y)\n        {\n            num[x.aa][x.bb] = '.';\n            falta.push(x);\n        }\n        x.aa -= 2;\n        if (num[x.aa][x.bb] == y)\n        {\n            num[x.aa][x.bb] = '.';\n            falta.push(x);\n        }\n        x.aa++;\n        x.bb++;\n        if (num[x.aa][x.bb] == y)\n        {\n            num[x.aa][x.bb] = '.';\n            falta.push(x);\n        }\n        x.bb -= 2;\n        if (num[x.aa][x.bb] == y)\n        {\n            num[x.aa][x.bb] = '.';\n            falta.push(x);\n        }\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    cin >> a;\n    for (int i = 1; i <= a; i++)\n    {\n        for (int j = 1; j <= a; j++)\n        {\n            cin >> num[i][j];\n        }\n    }\n    for (int i = 1; i <= a; i++)\n    {\n        for (int j = 1; j <= a; j++)\n        {\n            if (num[i][j] == 'R')\n            {\n                z.aa = i;\n                z.bb = j;\n                sub(z, 'R');\n            }\n            else if (num[i][j] == 'G')\n            {\n                z.aa = i;\n                z.bb = j;\n                sub(z, 'G');\n            }\n            else if (num[i][j] == 'B')\n            {\n                z.aa = i;\n                z.bb = j;\n                sub(z, 'B');\n            }\n        }\n    }\n    cout << c << \" \";\n    c = 0;\n    for (int i = 1; i <= a; i++)\n    {\n        for (int j = 1; j <= a; j++)\n        {\n            if (num[i][j] == '1')\n            {\n                z.aa = i;\n                z.bb = j;\n                sum(z, '1');\n            }\n            else if (num[i][j] == '2')\n            {\n                z.aa = i;\n                z.bb = j;\n                sum(z, '2');\n            }\n        }\n    }\n    cout << c;\n\n    return 0;\n}"
    },
    {
        "titulo": "3696. Bienevales",
        "url": "https://omegaup.com/arena/problem/Bienevales/",
        "descripcion": "Como todo inicio de semestre y como todo buen \"estudihambre\". Karel debe ir a recoger sus bienevales a la temible fila. Como todos los años, la fila es enorme, le da 2 vueltas a toda la escuela y hace un calor tremendo. Por si fuera poco, el que está entregando los bienevales tiene una familia enorme y a todos sus primos los esta dejando formarse en el décimo lugar de la fila, sin importar que hayan mas primos detrás de el. Karel está muy molesto y para no perder la costumbre, ha decidido escribir un programa que simule lo que le pasa para perder el tiempo. Ayúdalo creando un programa que soporte 2 tipos de operaciones: La operación uno consiste en que llega una persona identificada con el número X. La operación 2 indica que han sido atendidas X personas de la fila.",
        "entrada": "En la primer linea, un número 1<=n<=500000 con la cantidad de consultas. En las siguientes n lineas 2 números separados por un espacio, O y X, donde O representa el tipo de operación y X el argumento de la operación.",
        "salida": "Una única línea con todos los números que fueron procesados y el orden en que estos fueron atendidos separados por un espacio.",
        "nivel": "Intermedio (difícil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Colas"
        ],
        "estructuras": [
            "long long",
            "queue<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d;\n    queue<int> falta;\n    cin >> a;\n    while (a--)\n    {\n        cin >> b >> c;\n        if (b == 2)\n        {\n            while (c-- && falta.size())\n            {\n                cout << falta.front() << \" \";\n                falta.pop();\n            }\n            continue;\n        }\n        if (c == 1 || (c % 2 == 0 && c != 2) || falta.size() < 10)\n        {\n            falta.push(c);\n            continue;\n        }\n        b = sqrt(c);\n        if ((b * b) == c)\n        {\n            falta.push(c);\n            continue;\n        }\n        b = 3;\n        while (b < sqrt(c))\n        {\n            if (c % b == 0)\n            {\n                falta.push(c);\n                b = 0;\n                break;\n            }\n            b += 2;\n        }\n        if (b == 0)\n        {\n            continue;\n        }\n        d = falta.size() - 9;\n        b = 9;\n        while (b--)\n        {\n            falta.push(falta.front());\n            falta.pop();\n        }\n        falta.push(c);\n        while (d--)\n        {\n            falta.push(falta.front());\n            falta.pop();\n        }\n    }\n    while (falta.size())\n    {\n        cout << falta.front() << \" \";\n        falta.pop();\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "6483. Bolsa de valores",
        "url": "https://omegaup.com/arena/problem/Bolsa-de-valores/",
        "descripcion": "Se compra una acción del mercado de valores de cierta compañía y se analiza su comportamiento a lo largo de una hora. Al inicio, la acción se mantiene estable, pero en determinado momento, el comportamiento de la acción comienza a variar. Compara el precio de la acción al principio y al final del tiempo para decidir si hubo ganancia o pérdida de valor y de cuánto fué ese cambio.",
        "entrada": "La primer línea contiene el valor inicial de la acción. La segunda línea recibe un número que decidirá cuántas veces cambió el comportamiento de la acción. Después, por cada vez que cambie el comportamiento, se reciben dos líneas, cada una conteniendo un número, la primera que indica en qué minuto cambió de comportamiento y la segunda, que indica el porcentaje de cambio de valor por minuto de la acción. Cada minuto a partir del tiempo asignado, hasta el siguiente cambio, la acción cambiará el porcentaje referido. Los cambios pueden iniciar en cualquier momento entre el minuto 0 y el 59. El cambio en el minuto 60, ya no se considera como parte de la hora indicada.",
        "salida": "Si la acción ganó valor, la frase \"LA ACCION GANA n%\", donde n, es el porcentaje de cambio con respecto al valor inicial, redondeado a dos decimales. Si la acción perdió valor, la frase \"LA ACCION PIERDE n%\", donde n, es el porcentaje de cambio en positivo con respecto al valor inicial, redondeado a dos decimales.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Vectores"
        ],
        "estructuras": [
            "long double",
            "vector<pair<int,int>>",
            "long long",
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long double a, b, c;\n    pair<int, int> num[100];\n    long long z, zz;\n    cin >> a >> zz;\n    c = a;\n    while (zz--)\n    {\n        cin >> z >> b;\n        if (z >= 0 && z <= 59)\n        {\n            num[z].first = b;\n            num[z].second = 1;\n        }\n    }\n    b = 0;\n    for (int i = 0; i <= 59; i++)\n    {\n        if (num[i].second)\n        {\n            b = num[i].first;\n        }\n        if (b == 0)\n        {\n            continue;\n        }\n        if (b > 0)\n        {\n            a += ((a / 100) * b);\n        }\n        else\n        {\n            a -= ((a / 100) * fabs(b));\n        }\n    }\n    if (a >= c)\n    {\n        b = c / 10000;\n        a /= b;\n        a -= 10000;\n        a /= 100;\n        cout << fixed << setprecision(2) << \"LA ACCION GANA \" << a << \"%\";\n    }\n    else\n    {\n        b = c / 10000;\n        a /= b;\n        a /= 100;\n        a = 100 - a;\n        cout << fixed << setprecision(2) << \"LA ACCION PIERDE \" << a << \"%\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "7955. Busca la Clave",
        "url": "https://omegaup.com/arena/problem/Busca-la-Clave-/",
        "descripcion": "María y Cristina necesitan comunicarse una clave numérica (un PIN), desde luego no desean que nadie se entere de la clave que se comunican. Desafortunadamente para ellas, es muy posible que alguien esté interceptando sus mensajes. Como ellas saben que esto es posible, idean un esquema de oclusión. Es decir, el que él número que desean comunicarse se esconde en una secuencia grande de números. Ellas codifican la información necesaria para encontrar el número en la misma secuencia de números. Esto es lo que hacen; primero se envían M números enteros, en desorden, después envían un número mas (N). La clave se esconde en la secuencia y es uno de los M números. Se trata del número que es el inmediato mayor a N. Su tarea consiste en escribir un programa para encontrar la clave oculta en el mensaje. Su programa recibe primero un número (M), después recibe M números enteros. Al final recibe otro número (N). Su programa debe imprimir la clave oculta. Por ejemplo suponga que María y Cristina se envían el siguiente mensaje 5 3 8 4 10 9 7. En este caso, la clave es 8 pues es el número (en la serie de cinco números) que es el inmediato mayor a 7.",
        "entrada": "Primera Entrada: Un numero 0<M que indique el numero de enteros a recibir. Segunda Entrada: El mensaje indicado por M numeros separados por espacios. Tercer Entrada: Numero 0<N que indique la condicion de la clave oculta.",
        "salida": "Aquellos numeros del mensaje que cumplan con la condicion",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores",
            "Ordenamiento"
        ],
        "estructuras": [
            "long long",
            "vector<int>",
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b;\n    vector<int> falta;\n    cin >> a;\n    while (a--)\n    {\n        cin >> b;\n        falta.push_back(b);\n    }\n    cin >> a;\n    sort(falta.begin(), falta.end());\n    for (int i = 0; i < falta.size(); i++)\n    {\n        if (falta[i] > a)\n        {\n            cout << falta[i];\n            return 0;\n        }\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "969. Intersecciones",
        "url": "https://omegaup.com/arena/problem/Intersecciones/",
        "descripcion": "Existe cierta ciudad donde el flujo del tránsito es muy controlado, sobre todo en las intersecciones de calles y avenidas. Algunas intersecciones están prohibidas, otras solo te permiten moverte de norte o sur, otras al este u oeste y algunas te permiten ir en cualquier dirección (N,S,E,O). Afortunadamente, cuentas con un mapa que indica a través de símbolos, como puedes moverte. Específicamente existen 4 símbolos: + indica que te puedes mover en cualquier dirección, - indica que te puedes mover únicamente al este u oeste a partir de tu ubicación, | indica que solo puedes moverte al norte o sur. '*' indica que está prohibido pasar por esa intersección.",
        "entrada": "En las primeras dos líneas los números R, C que denotan el numero de filas y columnas del mapa, respectivamente.En las siguientes R líneas, C caracteres que describen las intersecciones de la ciudad.",
        "salida": "Una línea con un número que denota el mínimo número de intersecciones por las que tienes que pasar para llegar a la esquina inferior derecha de la ciudad desde la esquina superior izquierda. Imprime -1 en caso de que no sea posible.",
        "nivel": "Intermedio (difícil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Búsqueda en amplitud",
            "Colas",
            "Matrices"
        ],
        "estructuras": [
            "long long",
            "struct",
            "int",
            "queue<int>",
            "vector<vector<char>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b;\n    struct sobra\n    {\n        int aa, bb, cc;\n    };\n    queue<sobra> falta;\n    char num[102][102];\n    sobra z;\n    cin >> a >> b;\n    for (int i = 1; i <= a; i++)\n    {\n        for (int j = 1; j <= b; j++)\n        {\n            cin >> num[i][j];\n        }\n    }\n    if (num[1][1] == '*')\n    {\n        cout << \"-1\";\n        return 0;\n    }\n    z.aa = 1;\n    z.bb = 1;\n    z.cc = 1;\n    falta.push(z);\n    while (falta.size())\n    {\n        z = falta.front();\n        falta.pop();\n        z.cc++;\n        if (num[z.aa][z.bb] == '+')\n        {\n            z.aa++;\n            if (z.aa == a && z.bb == b)\n            {\n                cout << z.cc;\n                return 0;\n            }\n            if (num[z.aa][z.bb] != '*')\n            {\n                falta.push(z);\n            }\n            z.aa -= 2;\n            if (z.aa == a && z.bb == b)\n            {\n                cout << z.cc;\n                return 0;\n            }\n            if (num[z.aa][z.bb] != '*')\n            {\n                falta.push(z);\n            }\n            z.aa++;\n            z.bb++;\n            if (z.aa == a && z.bb == b)\n            {\n                cout << z.cc;\n                return 0;\n            }\n            if (num[z.aa][z.bb] != '*')\n            {\n                falta.push(z);\n            }\n            z.bb -= 2;\n            if (z.aa == a && z.bb == b)\n            {\n                cout << z.cc;\n                return 0;\n            }\n            if (num[z.aa][z.bb] != '*')\n            {\n                falta.push(z);\n            }\n            z.bb++;\n        }\n        else if (num[z.aa][z.bb] == '-')\n        {\n            z.bb++;\n            if (z.aa == a && z.bb == b)\n            {\n                cout << z.cc;\n                return 0;\n            }\n            if (num[z.aa][z.bb] != '*')\n            {\n                falta.push(z);\n            }\n            z.bb -= 2;\n            if (z.aa == a && z.bb == b)\n            {\n                cout << z.cc;\n                return 0;\n            }\n            if (num[z.aa][z.bb] != '*')\n            {\n                falta.push(z);\n            }\n            z.bb++;\n        }\n        else if (num[z.aa][z.bb] == '|')\n        {\n            z.aa++;\n            if (z.aa == a && z.bb == b)\n            {\n                cout << z.cc;\n                return 0;\n            }\n            if (num[z.aa][z.bb] != '*')\n            {\n                falta.push(z);\n            }\n            z.aa -= 2;\n            if (z.aa == a && z.bb == b)\n            {\n                cout << z.cc;\n                return 0;\n            }\n            if (num[z.aa][z.bb] != '*')\n            {\n                falta.push(z);\n            }\n            z.aa++;\n        }\n        num[z.aa][z.bb] = '*';\n    }\n    cout << \"-1\";\n\n    return 0;\n}"
    },
    {
        "titulo": "8546. Coeficiente binomial recursivo",
        "url": "https://omegaup.com/arena/problem/Coeficiente-binomial-recursivo/",
        "descripcion": "El coeficiente binomial binom{N}{K} puede definirse de forma recursiva como binom{N}{K} = binom{N - 1}{K} + binom{N - 1}{K - 1} y binom{N}{0} = binom{N}{N} = 1. Escribe un programa que calcule el valor de y cuántas llamadas a función hace la implementación recursiva (incluyendo la llamada original).",
        "entrada": "Dos enteros N y K. Puedes suponer que 0<=K<=N<=30.",
        "salida": "Dos enteros que sean el valor de binom{N}{K} y el número de llamadas a función que realiza la implementación recursiva, respectivamente.",
        "nivel": "Intermedio (difícil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Recursión",
            "Análisis de recurrencias"
        ],
        "estructuras": [
            "unsigned long long",
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nunsigned long long a, b, c = 0, d;\n\nint num(int x, int y)\n{\n    c++;\n    if (x == y || y == 0)\n    {\n        return 1;\n    }\n    return num(x - 1, y) + num(x - 1, y - 1);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    cin >> a >> b;\n    d = num(a, b);\n    cout << d << \" \" << c;\n\n    return 0;\n}"
    },
    {
        "titulo": "4183. Contando Ovejas",
        "url": "https://omegaup.com/arena/problem/Contando-Ovejas/",
        "descripcion": "Bleatrix Trotter la oveja ha ideado una estrategia que le ayude a conciliar el sueño más rápido. En primer lugar, elige un número N. Entonces empieza nombrando N, 2N, 3N, , y así sucesivamente. Cada vez que nombra un número, piensa en todos sus dígitos y guarda un registro de los dígitos (0, 1, 2, 3, 4, 5, 6, 7, 8, y 9) que ha visto al menos una vez desde que inicio a nombrar. Una vez que ha visto cada uno de los diez dígitos al menos una vez, se quedará dormida. Bleatrix debe comenzar con N  y continuara siempre con (i+1)*N directamente después de i*N Por ejemplo, supongamos que Bleatrix elige N = 1692. ella contaría como sigue: N = 1692. Ahora ha visto a los dígitos 1, 2, 6, y 9; 2N =  3384. Ahora ya ha visto los dígitos 1, 2, 3, 4, 6, 8, y 9; 3N = = 5076. Ahora que ha visto los diez dígitos, se queda dormida. ¿Cuál es el último número que va a nombrar antes de dormirse? Si contará para siempre, mostrar INSOMNIA en su lugar.",
        "entrada": "La primera línea de la entrada da el número de casos de prueba T.T (1<=T<=100) lineas siguen cada una consta de un único entero N (0<=N<=106), el número que Bleatrix ha elegido.",
        "salida": "Para cada caso de prueba, la salida en una línea que contiene Case #x:y, donde x es el número del caso de prueba (comenzando en 1) y y  es el último número que Bleatrix nombrará antes de dormirse, de acuerdo con las reglas descritas en la descripción.",
        "nivel": "Intermedio (difícil) - Matemáticas en la programación",
        "categorias": [
            "Cálculo matemático",
            "Vectores"
        ],
        "estructuras": [
            "long long",
            "vector<int>",
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e;\n    int num[10];\n    cin >> a;\n    for (int i = 1; i <= a; i++)\n    {\n        cin >> b;\n        if (b == 0)\n        {\n            cout << \"Case #\" << i << \": INSOMNIA\\n\";\n            continue;\n        }\n        cout << \"Case #\" << i << \": \";\n        c = 0;\n        d = 10;\n        while (d)\n        {\n            c += b;\n            e = c;\n            while (e)\n            {\n                if (num[e % 10] == 0)\n                {\n                    num[e % 10]++;\n                    d--;\n                }\n                e /= 10;\n            }\n        }\n        cout << c << \"\\n\";\n        for (int i = 0; i < 10; i++)\n        {\n            num[i] = 0;\n        }\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "7785. Contenedores Nueva Jersey",
        "url": "https://omegaup.com/arena/problem/Contenedores-Nueva-Jersey/",
        "descripcion": "Luis trabaja en la terminal de carga de contenedores en Nueva Jersey (Estados Unidos) y se encarga de almacenar diferente objetos voluminosos pesados para su transporte por vía marítima. Luis tiene objetos que tiene que almacenar en  m contenedores, cada contenedor tiene un tamaño exactamente de k. Luis enumera los objetos del 1 al n en orden de izquierda a derecha, el tamaño del i-ésimo objeto es a_i Para almacenar los objetos Luis tiene una forma particular para acomodarlos dentro de los contenedores la cual se explica a continuación: Luis empieza con un contenedor vacío y para acomodar cada objeto los recorre de izquierda a derecha y si el i-ésimo objeto encaja en el contenedor actual (el tamaño restante del contenedor es mayor o igual que a_i) lo acomoda dentro del contenedor y el espacio restante disminuye en a_i De lo contrario, abre un nuevo contenedor vacío y continúa el proceso anterior. Si llega el momento en que Luis ya no tiene contenedores vacíos y hay al menos un objeto que no fue almacenado en ningún contenedor, entonces Luis no puede almacenar el conjunto de objetos elegido. Luis quiere saber el número máximo de objetos que puede almacenar en los contenedores con el proceso anterior. Para alcanzar esta meta, Luis descarta el objeto situado más a la izquierda del conjunto hasta que el conjunto restante de objetos pueda ser almacenado en los contenedores disponibles. La meta es decir el número máximo de objetos que Luis puede almacenar en los contenedores vacíos que tiene a su disposición. Cada vez que Luis intenta almacenar objetos en los contenedores, vaciará todos los contenedores que tiene antes de hacerlo (y el orden relativo del conjunto restante de objetos no cambiará).",
        "entrada": "La primera línea de entrada contiene 3 enteros n, m, k (1<=n, m<=2x10^5, 1<=k<=10^9) - el número de objetos, el número de contenedores y el tamaño de cada contenedor.  La segunda línea de la entrada contiene n enteros a_1,a_2,…,a_n (1<=a_i<=k), donde a_i es el tamaño del i-ésimo objeto.",
        "salida": "Imprimir el número máximo de los objetos que Luis puede almacenar usando el proceso descrito anteriormente.",
        "nivel": "Avanzado (fácil) - Programación competitiva",
        "categorias": [
            "Teoría de numeros",
            "Vectores"
        ],
        "estructuras": [
            "long long",
            "vector<int>",
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e, f = 0;\n    int num[200001];\n    cin >> a >> b >> c;\n    for (int i = 0; i < a; i++)\n    {\n        cin >> num[i];\n    }\n    d = b - 1;\n    e = c;\n    for (int i = a - 1; i >= 0; i--)\n    {\n        e -= num[i];\n        if (e < 0)\n        {\n            if (num[i] > c)\n            {\n                cout << (a - i) - 1;\n                return 0;\n            }\n            d--;\n            if (d < 0)\n            {\n                f = i;\n                break;\n            }\n            e = c;\n            e -= num[i];\n        }\n    }\n    e = c;\n    b--;\n    for (int i = f; i < a; i++)\n    {\n        e -= num[i];\n        if (e < 0)\n        {\n            b--;\n            if (b < 0)\n            {\n                cout << a - (f + 1);\n                return 0;\n            }\n            e = c;\n            e -= num[i];\n        }\n    }\n    cout << a - f;\n\n    return 0;\n}"
    },
    {
        "titulo": "2257. Conversión de Números Romanos",
        "url": "https://omegaup.com/arena/problem/Conversion-de-Nemeros-Romanos/",
        "descripcion": "Se te da un numero 1<=N<=3999, y deberás realiza la converción equivalente en números romanos. Aunque existen los limites, es necesarios que realices la validación correspondiente y en caso de no cumplir la validación deberás imprimir un mensaje idéntico al siguiente: LIMITE EXCEDIDO",
        "entrada": "Para este ejercicio, como entrada recibe únicamente un número entero.",
        "salida": "La salida deberá imprimir a consola el equivalente en romano de número proporcionado.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Cálculos aritméticos",
            "Ciclos"
        ],
        "estructuras": [
            "unsigned long long",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    unsigned long long a;\n    string z = \"\", zz;\n    cin >> a;\n    if (a < 1 || a > 3999)\n    {\n        cout << \"LIMITE EXCEDIDO\";\n        return 0;\n    }\n    if (a % 10)\n    {\n        switch (a % 10)\n        {\n        case 1:\n            zz = \"I\";\n            break;\n        case 2:\n            zz = \"II\";\n            break;\n        case 3:\n            zz = \"III\";\n            break;\n        case 4:\n            zz = \"IV\";\n            break;\n        case 5:\n            zz = \"V\";\n            break;\n        case 6:\n            zz = \"VI\";\n            break;\n        case 7:\n            zz = \"VII\";\n            break;\n        case 8:\n            zz = \"VIII\";\n            break;\n        case 9:\n            zz = \"IX\";\n            break;\n        }\n        z = zz + z;\n    }\n    a /= 10;\n    if (a % 10)\n    {\n        switch (a % 10)\n        {\n        case 1:\n            zz = \"X\";\n            break;\n        case 2:\n            zz = \"XX\";\n            break;\n        case 3:\n            zz = \"XXX\";\n            break;\n        case 4:\n            zz = \"XL\";\n            break;\n        case 5:\n            zz = \"L\";\n            break;\n        case 6:\n            zz = \"LX\";\n            break;\n        case 7:\n            zz = \"LXX\";\n            break;\n        case 8:\n            zz = \"LXXX\";\n            break;\n        case 9:\n            zz = \"XC\";\n            break;\n        }\n        z = zz + z;\n    }\n    a /= 10;\n    if (a % 10)\n    {\n        switch (a % 10)\n        {\n        case 1:\n            zz = \"C\";\n            break;\n        case 2:\n            zz = \"CC\";\n            break;\n        case 3:\n            zz = \"CCC\";\n            break;\n        case 4:\n            zz = \"CD\";\n            break;\n        case 5:\n            zz = \"D\";\n            break;\n        case 6:\n            zz = \"DC\";\n            break;\n        case 7:\n            zz = \"DCC\";\n            break;\n        case 8:\n            zz = \"DCCC\";\n            break;\n        case 9:\n            zz = \"CM\";\n            break;\n        }\n        z = zz + z;\n    }\n    a /= 10;\n    if (a % 10)\n    {\n        switch (a % 10)\n        {\n        case 1:\n            zz = \"M\";\n            break;\n        case 2:\n            zz = \"MM\";\n            break;\n        case 3:\n            zz = \"MMM\";\n            break;\n        }\n        z = zz + z;\n    }\n    cout << z;\n\n    return 0;\n}"
    },
    {
        "titulo": "4532. Cuadrados Pintados al reves",
        "url": "https://omegaup.com/arena/problem/Cuadrados-Pintados-al-reves/",
        "descripcion": "Escriba un programa que pida n números y los guarde en un arreglo. Luego debe escribir el cuadrado de cada número en orden inverso al que fueron introducidos.",
        "entrada": "La primera linea contiene un entero n que esta entre 1 y 100, le siguen n líneas con lo números del arreglo. solo se aceptan 100 elementos, *--",
        "salida": "El cuadrado de cada elemento del arreglo, desplegado en orden inverso al que fueron introducidos.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores",
            "Cálculos aritméticos",
            "Ciclos",
            "Pilas"
        ],
        "estructuras": [
            "long long",
            "stack<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b;\n    stack<int> falta;\n    cin >> a;\n    while (a--)\n    {\n        cin >> b;\n        b *= b;\n        falta.push(b);\n    }\n    while (falta.size())\n    {\n        cout << falta.top() << \"\\n\";\n        falta.pop();\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "4662. Cómo enviar Problemas",
        "url": "https://omegaup.com/arena/problem/Como-enviar-Problemas/",
        "descripcion": "Natalia es una estudiante entusiasta que le encanta asumir retos nuevos. Por ello ha decidido participar del Concurso Escolar de Programación. Pero nunca antes ha participado en nada similar, así que no sabe cómo sus respuestas son calificadas. Ella cree que habrá una persona que reciba su código, lo compile y lo ejecute manualmente para decidir si es correcto o no. Pero lo cierto es que todo eso lo realiza un sistema automático. Para ello, Natalia debe hacer que su programa lee datos de la entrada estándar y escriba datos en la salida estándar. Clarifiquemos con un ejemplo. Sea el siguiente problema: Dados 2 enteros a y b (1<=a,b<=1000000). Los enteros son presentados en una única línea, separados por un espacio. Imprime un único entero, la suma de a y b. Tu primera tarea es similar: calcula la suma de todos los números desde a hasta b.",
        "entrada": "La entrada consiste de una única línea que contiene 2 enteros a y b (a<=b), separados por un espacio. Para el grupo 1 (30 pts): 1<=a, b<=1000000, b=a+1. Para el grupo 2 (30 pts): 1<=a, b<=1000000. Para el grupo 3 (40 pts): 1<=a, b<=1000000000.",
        "salida": "Un único entero, la suma de todos los números desde a hasta b.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c;\n    cin >> a >> b;\n    a--;\n    c = (((b + 1) * b) / 2) - (((a + 1) * a) / 2);\n    cout << c;\n\n    return 0;\n}"
    },
    {
        "titulo": "2320. Desfile vacuno facil",
        "url": "https://omegaup.com/arena/problem/Desfile-vacuno/",
        "descripcion": "Habiendo oído que la última tendencia de moda vacuna era vacas con dos manchas en sus pieles, el Granjero Juan ha comprado un rebaño enero de vacas con dos manchas. Desafortunadamente, las tendencias de moda cambian muy rápidamente, y la moda más popular en estos días son las vacas con una sola mancha. GJ quiere hacer que sus vacas estén más a la moda pintando cada una de sus vacas de tal manera que sus dos manchas se junten en una sola. La piel de una vaca se representa por una cuadrícula N por M (1 <= N,M <= 50) de caracteres. Aquí, cada 'X' denota parte de una mancha. Dos 'X's pertenecen a la misma mancha si se puede ir de una a la otra a través de Xs adyacentes vertical u horizontalmente (la adyacencia en diagonal no se tiene en cuenta). De tal manera que la figura anterior tiene exactamente dos manchas. Todas las vacas en el rebaño de GJ tienen exactamente dos manchas. GJ quiere usar tan poca pintura como sea posible para juntar las dos manchas en una. En el ejemplo anterior, él puede hacer esto pintando únicamente tres caracteres adicionales con 'X's. Ayude a GJ a determinar el mínimo número de nuevas 'X's que él debe pintar con el propósito de juntar las dos manchas en una sola mancha grande.",
        "entrada": "Línea 1: Dos enteros separados por espacio, N y M. Líneas 2..1+N: Cada línea contiene una cadena de longitud M de 'X's y '.'s especificando una fila en el diseño de la piel de la vaca.",
        "salida": "Línea 1: El mínimo número de nuevas 'X's que deben ser añadidas al diseño de la entrada con el propósito de obtener una sola mancha.",
        "nivel": "Avanzado (difícil) - Programación competitiva",
        "categorias": [
            "Colas",
            "Matrices"
        ],
        "estructuras": [
            "long long",
            "vector<vector<char>>",
            "queue<pair<int,int>>",
            "vector<pair<int,int>>",
            "pair<int,int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n   cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  long long a, b, c=0, d=1000000;\n   char num[52][52];\n queue<pair<int,int>>falta;\n    vector<pair<int,int>>sub;\n pair<int,int> z;\n  cin>>a>>b;\n    for(auto i=1; i<=a; i++){\n      for(auto j=1; j<=b; j++){\n          cin>>num[i][j];\n       }\n }\n for(auto i=1; i<=a; i++){\n      for(auto j=1; j<=b; j++){\n          if(num[i][j]=='X' && c==0){\n               z.first=i;\n                z.second=j;\n               sub.push_back(z);\n             num[i][j]='.';\n                falta.push(z);\n                while(falta.size()){\n                  z=falta.front();\n                  falta.pop();\n                  z.first++;\n                    if(num[z.first][z.second]=='X'){\n                      sub.push_back(z);\n                     num[z.first][z.second]='.';\n                       falta.push(z);\n                    }\n                 z.first-=2;\n                   if(num[z.first][z.second]=='X'){\n                      sub.push_back(z);\n                     num[z.first][z.second]='.';\n                       falta.push(z);\n                    }\n                 z.first++;\n                    z.second++;\n                   if(num[z.first][z.second]=='X'){\n                      sub.push_back(z);\n                     num[z.first][z.second]='.';\n                       falta.push(z);\n                    }\n                 z.second-=2;\n                  if(num[z.first][z.second]=='X'){\n                      sub.push_back(z);\n                     num[z.first][z.second]='.';\n                       falta.push(z);\n                    }\n             }\n             c=1;\n          }\n         else if(num[i][j]=='X'){\n              z.first=i;\n                z.second=j;\n               for(auto k=0; k<sub.size(); k++){\n                 d=min(d,(long long)(fabs(i-sub[k].aa)+fabs(j-sub[k].second))-1);\n              }\n             num[i][j]='.';\n                falta.push(z);\n                while(falta.size()){\n                  z=falta.front();\n                  falta.pop();\n                  z.first++;\n                    if(num[z.first][z.second]=='X'){\n                      for(auto k=0; k<sub.size(); k++){\n                        d=min(d,(long long)(fabs(z.first-sub[k].aa)+fabs(z.second-sub[k].second))-1);\n                      }\n                     num[z.first][z.second]='.';\n                       falta.push(z);\n                    }\n                 z.first-=2;\n                   if(num[z.first][z.second]=='X'){\n                      for(auto k=0; k<sub.size(); k++){\n                        d=min(d,(long long)(fabs(z.first-sub[k].aa)+fabs(z.second-sub[k].second))-1);\n                      }\n                     num[z.first][z.second]='.';\n                       falta.push(z);\n                    }\n                 z.first++;\n                    z.second++;\n                   if(num[z.first][z.second]=='X'){\n                      for(auto k=0; k<sub.size(); k++){\n                        d=min(d,(long long)(fabs(z.first-sub[k].aa)+fabs(z.second-sub[k].second))-1);\n                      }\n                     num[z.first][z.second]='.';\n                       falta.push(z);\n                    }\n                 z.second-=2;\n                  if(num[z.first][z.second]=='X'){\n                      for(auto k=0; k<sub.size(); k++){\n                        d=min(d,(long long)(fabs(z.first-sub[k].aa)+fabs(z.second-sub[k].second))-1);\n                      }\n                     num[z.first][z.second]='.';\n                       falta.push(z);\n                    }\n             }\n             c=1;\n          }\n     }\n }\n cout<<d;\n  \n  return 0;\n}"
    },
    {
        "titulo": "8315. Desv.Est",
        "url": "https://omegaup.com/arena/problem/DesvEst/",
        "descripcion": "Calcular la desviación estandar de un conjunto de datos.",
        "entrada": "La entrada tendrá el número de elementos de la lista de datos y posteriormente dicha lista de datos de enteros positivos.",
        "salida": "La salida será el valor de la desviación estandar del conjunto de datos de entrada, redondeado a dos decimales.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Probabilidad",
            "Ciclos",
            "Cálculo matemático",
            "Vectores"
        ],
        "estructuras": [
            "long double",
            "vector<long double>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n   cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  long double a, b, c;\n  long double num[101];\n cin>>a;\n   for(auto i=0; i<a; i++){\n      cin>>num[i];\n      b+=num[i];\n    }\n b/=a;\n for(auto i=0; i<a; i++){\n      c+=pow((num[i]-b),2);\n }\n c/=a;\n c=sqrt(c);\n    cout<<fixed<<setprecision(2)<<c;\n  \n  return 0;\n}"
    },
    {
        "titulo": "4720. Divertidas Cadenas",
        "url": "https://omegaup.com/arena/problem/Divertidas-Cadenas/#problems",
        "descripcion": "A Ricardo no le gusta mucho leer, pero cuando lo hace disfruta leer cadenas donde no hay caracteres consecutivos iguales. Como no quiere aburrirse durante los sábados donde no hay Coding Rush ha decidido revisar cadenas de texto que se conforman únicamente de las letras A y B. Para Ricardo una cadena es aburrida cuando tiene caracteres consecutivos iguales y divertida en caso contrario. Para convertir todas las cadenas aburridas en divertidas sólo puede borrar letras. Tu tarea es determinar el número mínimo de letras a borrar para convertir una cadena en divertida.",
        "entrada": "Un número N indicando el número de cadenas que Ricardo va a leer. Después leerás N líneas.",
        "salida": "Para cada línea debes determinar el número mínimo de letras que Ricardo debe borrar para convertirla en una cadena divertida.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "long long",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n   cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  long long a, b;\n   string z;\n cin>>a;\n   while(a--){\n       cin>>z;\n       b=0;\n      for(auto i=1; i<z.size(); i++){\n            if(z[i]==z[i-1]){\n             b++;\n          }\n     }\n     cout<<b<<\"\\n\";\n }\n \n  return 0;\n}"
    },
    {
        "titulo": "3007. Divide Tres",
        "url": "https://omegaup.com/arena/problem/Divide-Tres/",
        "descripcion": "Un dato curioso sobre los números es que un número que es divisible entre tres, por ejemplo, 13707. Tiene la propiedad de que la suma de sus dígitos también es divisible entre tres, para éste caso en particular la suma es: 1+3+7+0+7=18, la cual es divisible entre tres. La UP (Unidad de Programadores) te pide que escribas un programa que indentifique si un número es divisible entre tres.",
        "entrada": "Un número n (1<=n<=10^1000)",
        "salida": "Imprimir \"SI es divisible\" en caso de que n sea divisible entre tres, en caso contrario imprimir \"NO es divisible\".",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "long long",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n   cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  long long b;\n  string z;\n cin>>z;\n   b=0;\n  for(auto i=0; i<z.size(); i++){\n       b+=(z[i]-48);\n }\n b%=3;\n if(b){\n        cout<<\"NO es divisible\";\n    }\n else{\n     cout<<\"SI es divisible\";\n    }\n \n  return 0;\n}"
    },
    {
        "titulo": "5525. Divide y sumarás",
        "url": "https://omegaup.com/arena/problem/Divide-y-sumaras/",
        "descripcion": "Dado un entero N, evalúa el valor de la suma [sum_{i=0}^{inf}floor(N/(2^i))]=floor(N/1)+floor(N/2)+floor(N/3)+floor(N/4)+... donde floor(N/(2^i)) es la parte entera de la división.",
        "entrada": "El entero N. Puedes suponer que 1<=N<=1000000",
        "salida": "Un entero que sea el valor de la suma.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Cálculos aritméticos",
            "Ciclos"
        ],
        "estructuras": [
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    int a, b=1, c=0;\n  cin>>a;\n   while(b<=a){\n      c=c+(a/b);\n        b=b*2;\n    }\n cout<<c;\n  \n  return 0;\n}"
    },
    {
        "titulo": "174. Divisibilidad",
        "url": "https://omegaup.com/arena/problem/divisibilidad/",
        "descripcion": "Es bien sabido que un número es divisible por 2 si y sólo si su último dígito (el menos significativo) es par. Un número es divisible por 3 si y sólo si la suma de sus dígitos es un múltiplo de 3. El criterio de divisibilidad por 7 es un poco más complicado: empezando por el último dígito, multiplicamos cada dígito de derecha a izquierda por 1,3,2,6,4,5,1,3,2,6,4,5,1,3,... y así sucesivamente hasta llegar al primer dígito, luego sumamos todos los productos y el número original es divisible por 7 si y sólo si la suma que obtuvimos es divisible por 7. En este problema, te daremos un entero positivo N que representa el número de dígitos que tiene el número, y te daremos también un número primo P. Tu trabajo es encontrar un criterio de divisibilidad por P para un número de N dígitos. Mas específicamente, debes asignar un factor a cada dígito tal que la suma de los productos de los dígitos por sus respectivos factores sea divisible por P si y sólo si el número de N dígitos es divisible por P. Para asegurarnos de que la solución sea única, vamos a agregar las siguientes condiciones: Todos los factores deben estar entre 0 Y P-1, inclusive. El factor para el último dígito debe ser siempre 1. El criterio de divisibilidad debe funcionar incluso si el número de N dígitos empieza con ceros. Escribe un programa que dados N y P, imprima los N factores asignados a los N dígitos, comenzando por el primer dígito (el de más a la izquierda).",
        "entrada": "En la primera linea los números N y P separados por un espacio.",
        "salida": "En la primera linea imprime los N factores asignados a los dígitos, de izquierda a derecha, separados por espacios.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Cálculo matemático"
        ],
        "estructuras": [
            "long long",
            "pow()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n   cin.tie(0);\n   ios_base::sync_with_stdio(0);\n cout.tie(0);\n  long long a, b, c;\n    cin>>a>>b;\n    a--;\n  while(a){\n     c=pow(10,a);\n      c%=b;\n     cout<<c<<\" \";\n       a--;\n  }\n cout<<1;\n      \n  return 0;\n}"
    },
    {
        "titulo": "5221. La baraja de Andy",
        "url": "https://omegaup.com/arena/problem/La-baraja-de-Andy-c/",
        "descripcion": "Hace unos días, Andy estaba jugando cartas, al finalizar el juego le tocaba recogerlas, sin embargo se dio cuenta de que tiene N cartas en su baraja. Entonces ella se puso a pensar en cuántas formas distintas de ordenar la baraja había.",
        "entrada": "La primera linea con un número N indicando la cantidad de cartas que tiene su baraja.",
        "salida": "Un único número que exprese cuántas formas distintas de ordenar la baraja tiene.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Ciclos"
        ],
        "estructuras": [
            "unsigned long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    unsigned long long a, b=1;\n    cin>>a;\n    for(auto i=1; i<=a; i++){\n        b*=i;\n    }\n    cout<<b;\n\n    return 0;\n}"
    },
    {
        "titulo": "5584. Ahorrando Agua",
        "url": "https://omegaup.com/arena/problem/Ahorrando-Agua-ASINUS/",
        "descripcion": "Don Sabiniano se encuentra muy contento gracias a toda el agua que ha logrado ahorrar con su nuevo dispositivo que han creado los estudiantes del IPN. Ahora tiene que pensar en donde almacenará tanta agua que ha logrado ahorrar; por lo que decidió excavar unos ojos de agua. Don Sabiniano estuvo presente en la creación de cada ojo de agua y por lo tanto conoce como quedó cada uno, el terreno que los conforman y las irregularidades que tienen. Sin embargo, se le presenta una nueva problemática; el proceso de excavación ha sido muy rudimentario y la cantidad de agua que almacena cada ojo de agua es aparentemente incierta. Ayuda a Don Teodomiro a calcular la cantidad de agua que puede almacenar uno de estos ojos de agua. El agua ocupará aquel espacio disponible dentro del ojo de agua sin contar las secciones donde se encuentre alguna irregularidad.",
        "entrada": "El primer valor N que representa las secciones del ojo de agua, donde 3<=N<=10000. Los valores enteros subsecuentes k_1, k_2, ..., k_n representan las irregularidades de estas secciones, donde k>0 y (k_1=k_n)>0. Considera que un valor igual a 0 significa que en esa sección no existen irregularidades.",
        "salida": "La cantidad total de agua representada por cada unidad o espacio en la imagen con fondo azul.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Ciclos"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c=0, d;\n    cin>>a>>b;\n    for(auto i=1; i<a; i++){\n        cin>>d;\n        c+=b-d;\n    }\n    cout<<c;\n\n    return 0;\n}"
    },
    {
        "titulo": "5611. Lenguaje de la efe",
        "url": "https://omegaup.com/arena/problem/Lenguaje-de-la-efe-ASINUS/",
        "descripcion": "En uno de los episodios de los Simpsons, Bart y Lisa se encuentran peleado por el control de la televisión, al caer al piso la televisión sintoniza un programa para niños el cual parece agradar a la pequeña Maggie. Bart y Lisa intentan evitar que Marge deje a Maggie ver el show. Para conspirar entre ellos utilizan un lenguaje especial con el cual pretenden dejar a Marge fuera de la conversación. A pesar de sus esfuerzos Marge es muy lista y ya conoce cómo utilizar ese lenguaje. Sin embargo, no todos saben o conocen cómo hablar en ese misterioso lenguaje, por lo que te toca a ti; programador experto, ayudar al mundo a hablar como los hermanos Simpsons. En realidad, es bastantes sencillo, a cada palabra se le agrega una sílaba adicional dependiendo de las vocales que tenga: Si tiene 'a' se reemplaza por 'afa'. Si tiene 'e' se reemplaza por 'efe'. Si tiene 'i' se reemplaza por 'ifi'. Si tiene 'o' se reemplaza por 'ofo'. Si tiene 'u' se reemplaza por 'ufu'. Por ejemplo: La palabra Hola tiene dos vocales 'o' y 'a', se remplazará 'o' por 'ofo' y 'a' por 'afa', y el resultado es 'Hofolafa'.",
        "entrada": "Una línea de texto que será transformada al lenguaje misterioso de los hermanos Simpsons.",
        "salida": "La misma línea de texto de la entrada transformada.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas",
            "Ciclos"
        ],
        "estructuras": [
            "string",
            "getline()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    string z;\n    getline(cin,z);\n    for(auto i=0; i<z.size(); i++){\n        if(z[i]=='a'){\n            cout<<\"afa\";\n        }\n        else if(z[i]=='e'){\n            cout<<\"efe\";\n        }\n        else if(z[i]=='i'){\n            cout<<\"ifi\";\n        }\n        else if(z[i]=='o'){\n            cout<<\"ofo\";\n        }\n        else if(z[i]=='u'){\n            cout<<\"ufu\";\n        }\n        else{\n            cout<<z[i];\n        }\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "5515. Valles",
        "url": "https://omegaup.com/arena/problem/Valles/",
        "descripcion": "Los valles son pedazos de terreno rodeados por montañas. Dado el mapa de una isla escribe un programa que determine la cantidad de valles que existen en la isla. La isla se puede ver como una matriz de números enteros, donde las montañas son representadas con \"1\" y los terrenos planos con \"0\". Por lo que un valle es un 0 rodeado por 1's.",
        "entrada": "La primera línea contiene dos números n y m (1<=n,m<=20) indicando las dimensiones de la isla. Le siguen n líneas, cada una con m números separados por un espacio, indicando el mapa de la isla.",
        "salida": "La cantidad de valles en la isla.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Matrices",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "vector<vector<int>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c=0;\n    int num[22][22];\n    cin>>a>>b;\n    for(auto i=0; i<a; i++){\n        for(auto j=0; j<b; j++){\n            cin>>num[i][j];\n        }\n    }\n    a--;\n    b--;\n    for(auto i=1; i<a; i++){\n        for(auto j=1; j<b; j++){\n            if(num[i][j]==0 && num[i+1][j]==1 && num[i-1][j]==1 && num[i][j+1]==1 && num[i][j-1]==1){\n                c++;\n            }\n        }\n    }\n    cout<<c;\n    \n    return 0;\n}"
    },
    {
        "titulo": "7663. Picos y Valles",
        "url": "https://omegaup.com/arena/problem/Picos-y-Valles/",
        "descripcion": "El profesor MC se dió cuenta que en el paisaje de NLogonia hay un pico cada cien metros, y que siempre hay un valle en la mitad de la distancia entre dos picos. Esto significa que cada 50 metros hay un valle o un pico, a lo largo del paisaje, no puede haber un pico seguido de otro pico o dos valles consecutivos.",
        "entrada": "La entrada viene en dos líneas. La primera tiene el número N de mediciones del paisaje (1 < N <= 100). La segunda línea tiene N enteros: la altura Hi de cada medición (-10000 <= Hi <= 10000, para todo Hi, tal que 1 <= i <= N). Una medida se considera un pico si es más alto que la medida previa, y una medida se considera un valle si es más bajo que la medida previa.",
        "salida": "La salida consiste de una única línea. Si el paisaje tiene el mismo patrón que el paisaje de NLogonia se debe mostrar el número 1, en otro caso se debe mostrar el número 0.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores",
            "Ciclos"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e;\n    cin>>a;\n    if(a==1){\n        cin>>a;\n        cout<<1;return 0;\n    }\n    if(a==2){\n        cin>>a>>a;\n        cout<<1;return 0;\n    }\n    cin>>b>>c;\n    if(c==b){\n        d=0;\n    }\n    if(c>b){\n        e=1;\n    }\n    else{\n        e=0;\n    }\n    for(auto i=3; i<=a; i++){\n        b=c;\n        cin>>c;\n        e++;\n        e%=2;\n        if(c>b && e==0){\n            d=0;\n        }\n        if(b>c && e){\n            d=0;\n        }\n    }\n    cout<<d;\n    \n    return 0;\n}"
    },
    {
        "titulo": "4674. Reverse String",
        "url": "https://omegaup.com/arena/problem/Reverse-String/",
        "descripcion": "Uno de los voluntarios del CodingRush, Gildardo, le gusta ir a fiestas locas, sin embargo sus papás lo han regañado ya que constantemente termina muy mal. A pesar de lo que dijeron sus padres, Gildardo ha ido a una fiesta el último fin de semana y sus amigos, para ver que tan mal estaba le han dicho que dijera una palabra al revés. Ayuda a Gildardo a voltear la palabra que le digan sus amigos.",
        "entrada": "Primera y Única Linea: S, La cadena de texto que Gildardo tiene que invertir",
        "salida": "El String invertido",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Ciclos",
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);;\n    string z;\n    cin>>z;\n    for(auto i=z.size()-1; i>=0; i--){\n        cout<<z[i];\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "8422. COME GALLETAS",
        "url": "https://omegaup.com/arena/problem/COME-GALLETAS/",
        "descripcion": "A Pedro le gustan mucho las galletas y siempre va a comprar a la tienda de la esquina, cada paquete contiene 10 galletas, pero como el es un comprador frecuente, el vendedor le regala galletas cada numero par como lo muestra la siguiente secuencia: 10,11,10,12,10,13. son el ejemplo de galletas que contendría cada paquete si Pedro comprase 6. Ayuda a pedro a encontrar las galletas totales que compraría.",
        "entrada": "En una linea escribe el numero de paquetes de galletas que Pedro comprara.",
        "salida": "La salida contendrá la cantidad de galletas que pedro compro incluyendo las que le fueron regaladas.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "long double"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long double a, b=0;\n    cin>>a;\n    b+=(a*10);\n    a/=2;\n    b+=(((a+1)*a)/2);\n    cout<<b;\n\n    return 0;\n}"
    },
    {
        "titulo": "8429. TROCAS",
        "url": "https://omegaup.com/arena/problem/TROCAS/",
        "descripcion": "En la preparatoria CBTIS 217, se organizo una excursión. pero para ello, los maestras decidieron contratar trocas en lugar de un autobús y formar grupos de alumnos de cantidades indefinidas. tu misión sera repartir a todos los alumnos a un autobús, la única condición es que no se puedan separar grupos.",
        "entrada": "En una sola linea coloca el numero de integrantes de cada grupo, separados por un espacio.",
        "salida": "El numero de trocas necesario para transportar a todos los alumnos. A cada troca le caben máximo 6 alumnos.",
        "nivel": "Intermedio (medio) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Vectores",
            "Ordenamiento",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c = 0, d = 0, e = 0, f = 0;\n    vector<int> falta;\n    while (cin >> a)\n    {\n        falta.push_back(a);\n    }\n    sort(falta.begin(), falta.end());\n    if (falta[0] == 6)\n    {\n        cout << falta.size();\n        return 0;\n    }\n    a = 0;\n    b = falta.size() - 1;\n    while (b != a && falta[b] == 6)\n    {\n        c++;\n        b--;\n    }\n    while (falta[a] == 1 && falta[b] == 5)\n    {\n        c++;\n        a++;\n        b--;\n    }\n    if (a > b)\n    {\n        cout << c;\n        return 0;\n    }\n    while (falta[a] == 1)\n    {\n        d++;\n        a++;\n    }\n    if (a > b)\n    {\n        c += (d / 6);\n        d %= 6;\n        if (d)\n        {\n            c++;\n        }\n        cout << c;\n        return 0;\n    }\n    while (falta[b] == 5)\n    {\n        c++;\n        b--;\n    }\n    if (a > b)\n    {\n        cout << c;\n        return 0;\n    }\n    while (falta[a] == 2 && falta[b] == 4)\n    {\n        c++;\n        a++;\n        b--;\n    }\n    if (a > b)\n    {\n        c += (d / 6);\n        d %= 6;\n        if (d)\n        {\n            c++;\n        }\n        cout << c;\n        return 0;\n    }\n    while (falta[b] == 4 && d >= 2)\n    {\n        d -= 2;\n        b--;\n        c++;\n    }\n    if (a > b)\n    {\n        c += (d / 6);\n        d %= 6;\n        if (d)\n        {\n            c++;\n        }\n        cout << c;\n        return 0;\n    }\n    while (falta[b] == 4)\n    {\n        b--;\n        c++;\n    }\n    if (a > b)\n    {\n        c += (d / 6);\n        d %= 6;\n        if (d)\n        {\n            c++;\n        }\n        cout << c;\n        return 0;\n    }\n    while (falta[a] == 2)\n    {\n        f++;\n        a++;\n    }\n    if (a > b)\n    {\n        c += (f / 3);\n        f %= 3;\n        if (f)\n        {\n            d += (f * 2);\n        }\n        c += (d / 6);\n        d %= 6;\n        if (d)\n        {\n            c++;\n        }\n        cout << c;\n        return 0;\n    }\n    while (falta[b] == 3)\n    {\n        b--;\n        e++;\n    }\n    c += (e / 2);\n    e %= 2;\n    if (e && f && d)\n    {\n        f--;\n        d--;\n        c++;\n        e--;\n    }\n    if (e && f)\n    {\n        f--;\n        e--;\n        c++;\n    }\n    if (e && d)\n    {\n        if (d <= 3)\n        {\n            d = 0;\n        }\n        else\n        {\n            d -= 3;\n        }\n        e--;\n        c++;\n    }\n    if (e)\n    {\n        c++;\n        e--;\n    }\n    c += (d / 6);\n    d %= 6;\n    if (d)\n    {\n        c++;\n    }\n    cout << c;\n\n    return 0;\n}"
    },
    {
        "titulo": "7412. Promedios en intervalos",
        "url": "https://omegaup.com/arena/problem/Promedios-en-intervalos/",
        "descripcion": "Dado un registro de alumnos donde cada uno tiene un número de lista y una calificación, escribe un programa que pueda resolver la siguiente pregunta: ¿cuál es el promedio entero de las calificaciones de los alumnos cuyos números de lista están entre I y U inclusivos?",
        "entrada": "Un entero N seguido de N parejas de enteros L, C donde L es el número de lista de un alumno y C es su calificación. Posteriormente un entero M seguido de M parejas de enteros I y U. Puedes suponer que 0<=N<=10^5, que 0<=M, que, 0<=L<=10^9, que 0<=I<=U<N y que no hay números de lista repetidos, aunque puede haber números de lista faltantes.",
        "salida": "Para cada intervalo, un entero que sea el promedio entero de las calificaciones de los alumnos con números de lista en ese intervalo o bien, el entero -1 si no hay alumnos en ese intervalo.",
        "nivel": "Intermedio (difícil) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Búsqueda binaria",
            "Ordenamiento",
            "Ciclos",
            "Suma de prefijos"
        ],
        "estructuras": [
            "long long",
            "vector<pair<int, int>>",
            "auto"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e, f, g, h, l;\n    vector<pair<int, int>> num(100001);\n    cin >> a;\n    for (auto i = 0; i < a; i++)\n    {\n        cin >> num[i].first >> num[i].second;\n    }\n    sort(num.begin(), num.end());\n    for (auto i = 1; i < a; i++)\n    {\n        num[i].second += num[i - 1].second;\n    }\n    cin >> b;\n    while (b--)\n    {\n        cin >> c >> d;\n        c--;\n        if (d < num[0].first || c >= num[a - 1].first)\n        {\n            cout << \"-1\\n\";\n            continue;\n        }\n        e = 0;\n        f = a - 1;\n        l = -1;\n        while (e <= f)\n        {\n            g = (e + f) / 2;\n            if (num[g].first == d)\n            {\n                l = g;\n                break;\n            }\n            else if (num[g].first < d)\n            {\n                e = g + 1;\n                l = max(l, g);\n            }\n            else\n            {\n                f = g - 1;\n            }\n        }\n        if (c < num[0].first)\n        {\n            cout << num[l].second / (l + 1) << \"\\n\";\n            continue;\n        }\n        e = 0;\n        f = a - 1;\n        h = -1;\n        while (e <= f)\n        {\n            g = (e + f) / 2;\n            if (num[g].first == c)\n            {\n                h = g;\n                break;\n            }\n            else if (num[g].first < c)\n            {\n                e = g + 1;\n                h = max(h, g);\n            }\n            else\n            {\n                f = g - 1;\n            }\n        }\n        if (h == l)\n        {\n            cout << \"-1\\n\";\n            continue;\n        }\n        cout << (num[l].second - num[h].second) / (l - h) << \"\\n\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "8464. SUMAR HORAS (ETITC)",
        "url": "https://omegaup.com/arena/problem/SUMAR-HORAS-ETITC/",
        "descripcion": "Haga un programa que reciba dos horas en formato hh mm y que dé como respuesta la hora resultante de sumar las dos horas en ese formato. Las horas estarán entre 0 y 23 y los minutos entre 0 y 59.",
        "entrada": "Se ingresa el primer formato de hora minuto y posteriormente el segundo formato hora minuto.",
        "salida": "Como salida debe mostrar la suma de las dos horas.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d;\n    cin >> a >> b >> c >> d;\n    b += d;\n    if (b >= 60)\n    {\n        b -= 60;\n        a++;\n    }\n    a += c;\n    if (a >= 24)\n    {\n        a -= 24;\n    }\n    cout << a << \" \" << b;\n\n    return 0;\n}"
    },
    {
        "titulo": "847. Suma de 3 números",
        "url": "https://omegaup.com/arena/problem/Suma-de-3-numeros/",
        "descripcion": "",
        "entrada": "Recibe tres números enteros.",
        "salida": "Retorna el total de la suma de los 3 números",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Cálculos aritméticos"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c;\n    cin >> a >> b >> c;\n    cout << a + b + c;\n\n    return 0;\n}"
    },
    {
        "titulo": "6593. Los focos",
        "url": "https://omegaup.com/arena/problem/Los-focos/",
        "descripcion": "Se tienen n focos apagados, cada uno tiene su interruptor, una persona pasa y cambia el interruptor de todos los focos, una segunda persona pasa y cambia los interruptores de los focos 2, 4, 6, 8, etc. Hasta n, una tercera persona pasa y cambia los interruptores de 3, 6, 9, 12, etc... hasta n, una cuarta persona pasa y cambia los interruptores 4, 8, 12...etc y así sucesivamente hasta la persona n. Dado n, determina que interruptores quedan prendidos. Para 50 puntos 1<=n<=1000. Para 50 puntos 1<=n<=1000000000",
        "entrada": "Un entero n.",
        "salida": "El número de cada uno de los focos que quedan prendidos, separados por un salto de linea.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Ciclos"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b = 1;\n    cin >> a;\n    while (true)\n    {\n        if ((b * b) <= a)\n        {\n            cout << b * b << \"\\n\";\n        }\n        else\n        {\n            break;\n        }\n        b++;\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "4745. Glorietas Campechanas",
        "url": "https://omegaup.com/arena/problem/OMICAMP-Glorietas-Campechanas/",
        "descripcion": "El gobierno del estado de Campeche, manda cada cierto tiempo a podar las áreas verdes de las glorietas que están en toda la ciudad, para ello cuenta con muchos trabajadores, cada uno de ellos tiene su monto a cobrar por metro cuadrado de las áreas verdes, el problema que tiene el gobierno del estado es que no conoce el área circular de las glorietas, pero si conoce los radios. El radio N que abarcan desde el punto central de la glorieta hasta la orilla de la misma y el radio M que abarca desde el punto central hasta la orilla donde comienza las zonas verdes de la glorieta. Considerando que el radio N siempre va a hacer mayor que el radio M  El gobierno del estado de Campeche te contrata para calcular el monto a pagar por una glorieta contemplando que S es el precio por metro cuadrado que cobra un trabajador y los radios N y M que conoce el gobierno de las glorietas. Tu deber es crear un programa que calcule el monto a pagar por cada glorieta. Considerar que 1<=S<=1000000 y 0<=M<N<=1000000.",
        "entrada": "De entrada recibirás el costo S por metro cuadro, seguido de los radios N y M.",
        "salida": "Tu programa debe imprimir el monto que hay que pagar con dos decimales después del punto, por la glorieta a podar",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "unsigned long long",
            "long double",
            "pow()",
            "fixed",
            "setprecision()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    unsigned long long a, b, c, d;\n    long double z;\n    cin >> a >> b >> c;\n    d = ((pow(b, 2) * 31416) - (pow(c, 2) * 31416)) * a;\n    cout << fixed << setprecision(2) << \"$\";\n    if (d / 100000)\n        cout << d / 100000;\n    d %= 100000;\n    z = (long double)d / 10000;\n    cout << fixed << setprecision(2) << z;\n\n    return 0;\n}"
    },
    {
        "titulo": "5409. Barajeo de Cartas",
        "url": "https://omegaup.com/arena/problem/Shuffling-Cards-ASINUS/",
        "descripcion": "Charles y William han sido amigos desde ya hace un tiempo, ellos son conocidos por su espíritu competitivo. Cada fin de semana se reúnen para jugar cartas, y a pesar de ser buenos amigos, durante los juegos ninguno quiere perder. Usualmente discuten sobre la manera en la que las cartas son barajeadas, Charles diciendo que William siempre hace trampa porque el obtiene las mejores cartas al final de cada juego, mientras que William dice que Charles simplemente no es tan bueno. Ahora, es tu turno de ayudarlos con este pequeño problema, te toca a ti barajear las cartas. Cada una de las cartas serán representadas por un número entero (k), estas deberán ser barajeadas teniendo dos grupos o sets (s1, s2), y cada uno debe contener el mismo número de cartas (n). Para obtener la pila barajeada final, una carta de cada set o grupo deberá ser tomada, comenzando con una carta del primer conjunto y luego una del segundo conjunto, y continuando hasta que no haya alguna carta sobrante de los sets originales.",
        "entrada": "El número de cartas de cada set o mano dado por n. Cada una de las cartas k representadas por enteros.",
        "salida": "La pila final barajeada a partir de las cartas de las dos manos originales.",
        "nivel": "Intermedio (medio) - Análisis y diseño de algoritmos",
        "categorias": [
            "Ciclos",
            "Vectores"
        ],
        "estructuras": [
            "long long",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b;\n    vector<int> falta;\n    vector<int> faltas;\n    cin >> a;\n    for (auto i = 0; i < a; i++)\n    {\n        cin >> b;\n        falta.push_back(b);\n    }\n    for (auto i = 0; i < a; i++)\n    {\n        cin >> b;\n        faltas.push_back(b);\n    }\n    for (auto i = 0; i < a; i++)\n    {\n        cout << falta[i] << \" \" << faltas[i] << \" \";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "8375. Las cemitas programadoras",
        "url": "https://omegaup.com/arena/problem/Las-cemitas-programadoras/",
        "descripcion": "La crisis en el país esta fea y nuestro amigo Eduardo tiene que poner un negocio para poder vivir mas o menos bien. Como el vive en Puebla, puso un negocio de ricas cemitas caseras el cual empezó a recibir gente rápidamente. Lamentablemente se dio cuenta que los gastos eran bastantes entre las cemitas, las milanesas, el quesillo, el aguacate y el odioso papalo que nadie quiere y se cuestiono si el negocio iba a funcionar. Eduardo tiene anotado las ganancias y las perdidas pero no tiene tiempo para hacer las cuentas porque tiene que atender el changarro, asi que te pide tu ayuda para saber si el negocio es viable o no. Se te va a otorgar A y B donde A es el valor de las ganancias y B el valor de las perdidas y tu tendrás que determinar si el negocio va bien o mal.",
        "entrada": "A seguida de B.",
        "salida": "Si las ganancias superan las perdidas tendrás que imprimir sin comillas \"El negocio si va a jalar\" y después el valor de las ganancias. De lo contrario si las perdidas son mas grandes que las ganancias deberás imprimir sin comillas \"Dejalo ya esta muerto\" y después el valor de las perdidas.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Cálculos aritméticos"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b;\n    cin>>a>>b;\n    if(a>b){\n        cout<<\"El negocio si va a jalar \"<<a-b;\n    }\n    else{\n        cout<<\"Dejalo ya esta muerto \"<<b-a;\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "2648. Gastos",
        "url": "https://omegaup.com/arena/problem/Gastos/",
        "descripcion": "Dada una lista de gastos, calcula e imprime el total gastado y cuantos gastos se totalizaron.",
        "entrada": "Una línea con la lista de gastos, todos los enteros correspondientes a los gastos se separan con un espacio. Asume que la lista de gastos termina cunado se lee un cero.",
        "salida": "Dos enteros M, N separados por un espacio que denotan el total gastado y el número de gastos totalizados, respectivamente.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Ciclos",
            "Cálculos aritméticos",
            "Matrices"
        ],
        "estructuras": [
            "long long",
            "vector<vector<int>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b=0, c=0;\n    int num[1001][1001];\n    cin>>a;\n    while(a){\n        c+=a;\n        b++;\n        cin>>a;\n    }\n    cout<<c<<\" \"<<b;\n    \n    return 0;\n}"
    },
    {
        "titulo": "5074. Que fácil es dar cambio",
        "url": "https://omegaup.com/arena/problem/Que-facil-es-dar-cambio-emh/",
        "descripcion": "Atsa acaba de abrir una tienda de abarrotes en medio de la ciudad; después de unos días se dio cuenta que la cantidad de clientes que tenía era demasiada. Cierto día se dispuso a analizar cual podría ser la razón por la cual siempre tenía mucha clientela y se di cuenta que el problema no era que hubiera mucha gente sino que él tardaba mucho en dar el cambio, es decir, que cuando un cliente le pagaba el tardaba mucho en regresarle su cambio. Como Atsa quiere mejorar esta labor, decidió cambiar su forma de hacerlo. En la ciudad solo hay monedas de $10, $5, $2 y de $1 pesos; la nueva forma de dar el cambio será dar tantas monedas de $10 como sea posible, si hace falta dar más cambio dará la mayor cantidad de monedas de $5 que sea posible, si nuevamente es necesario dar cambio dará la mayor cantidad de monedas de $2 pesos y finalmente hará lo mismo con la moneda de $1.",
        "entrada": "Una única linea que contiene un número entero C que representa la cantidad en pesos que debe dar de cambio. (0<=N<=x^10)",
        "salida": "Una única línea con cuatro números separados por espacio que representen la cantidad de monedas de $10, $5, $2 y $1 respectivamente que debe dar para la cantidad de C.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Aritmética",
            "Condicionales"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a;\n    cin>>a;\n    cout<<a/10<<\" \"<<(a%10)/5<<\" \"<<((a%10)%5)/2<<\" \"<<(((a%10)%5)%2);\n    \n    return 0;\n}"
    },
    {
        "titulo": "8418. Probabilidad",
        "url": "https://omegaup.com/arena/problem/Probabilidad/",
        "descripcion": "En un pueblo llamado Moroleón. se organizo una rifa, en la cual Pedro y Jorge compraron una cantidad determinada de boletos. Si se sabe cual es la cantidad que se vendieron en total de boletos. ¿Puedes ayudarlos a sacar su probabilidad de ganar la rifa?.",
        "entrada": "La primera linea contendrá la cantidad de boletos comprados por jorge y pedro. y la segunda los boletos totales.",
        "salida": "La salida contendrá la probabilidad de ganar con solamente 2 números después del punto decimal.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "long double",
            "fixed",
            "setprecision()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long double a, b, c;\n    cin>>a>>b;\n    c=(100/b)*a;\n    cout<<fixed<<setprecision(2)<<\"La probabilidad es de %\"<<c;\n\n    return 0;\n}"
    },
    {
        "titulo": "5822. Raíces de un polinomio de segundo grado",
        "url": "https://omegaup.com/arena/problem/raices-p2/",
        "descripcion": "Anita está en su primer curso de programación, quiere combinar sus habilidades de programación y matemáticas. En esta ocasión le han pedido que calcule las raíces de polinomios de segundo grado usando la fórmula cuadrática. r+ = (-b + sqrt(b^2 - 4ac)) / (2a) y r- = (-b + sqrt(b^2 - 4ac)) / (2a). Anita únicamente está practicando con problemas en que existen las raíces son valores reales.",
        "entrada": "Recibirás tres valores reales, que corresponden a los coeficientes de un polinomio de segundo grado: a, b y c. Todas las soluciones estarán en el dominio de los reales.",
        "salida": "Mostrar los valores de las raíces para cada polinomio de entrada recibido en la entrada.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "long double",
            "sqrt()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long double a, b, c, d, e;\n    cin>>a>>b>>c;\n    d=(((-1)*b)+sqrt(pow(b,2)-(4*a*c)))/(2*a);\n    e=(((-1)*b)-sqrt(pow(b,2)-(4*a*c)))/(2*a);\n    cout<<fixed<<setprecision(4)<<\"Root +: \"<<d<<\"\\nRoot -: \"<<e;\n    \n    return 0;\n}"
    },
    {
        "titulo": "5821. Área de un triángulo",
        "url": "https://omegaup.com/arena/problem/area-triangulo-inout/",
        "descripcion": "En la escuela a Carlitos le han enseñado a calcular el área de un triángulo usando los valores de los lados. La maestra le ha indicado que lo primero que debe calcular es el valor: (S = (L1 + L2 + L3) / 2). El siguiente paso es aplicar la fórmula para calcular el área. area = (sqrt(s * (s - L1) * (s - L2) * (s - L3))). Carlitos está empezando sus cursos, por ello te pide que le apoyes escribiendo un programa que permita verificar si está haciendo bien sus cálculos.",
        "entrada": "Recibirás 3 valores de tipo real. Estos lados corresponden siempre a un triángulo válido. Los valores de entrada para cada lado son reales positivos mayores a 0 y menores a 20,000. Todas las entradas forman triángulos válidos.",
        "salida": "Mostrar cada uno de los lados leídos en la entrada y el área del triángulo. Considera 15 caracteres para imprimir cada número y cuatro decimales. Los detalles puedes consultarlos en los ejemplos.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "long double",
            "fixed",
            "setprecision()",
            "sqrt()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long double a, b, c, d, e;\n    cin>>a>>b>>c;\n    d=(a+b+c)/2;\n    e=sqrt(d*(d-a)*(d-b)*(d-c));\n    cout<<fixed<<setprecision(4)<<\"Side 1: \"<<a<<\"\\nSide 2: \"<<b<<\"\\nSide 3: \"<<c<<\"\\nArea : \"<<e;\n    \n    return 0;\n}"
    },
    {
        "titulo": "8347. 0 fortnite vs minecraft",
        "url": "https://omegaup.com/arena/problem/fvm/",
        "descripcion": "Habia una ves un niño que se llamaba Jesus, el jugaba mucho al minecraft, pero luego salio el fortnite, ese niño no tenia amigos, por que estaba todo el dia jugando o fortnite o minecraft, pero ese niño quiere saber en cuantos años va a tener su primera novia, ya que cada dia que juegue uno de estos juegos, aumentan los años en los que no tendra novia de esta manera: 1 dia de minecraft=4.27 años sin novia, 1 dia de fortnite=2.91 años sin novia.",
        "entrada": "linea 1: un entero que dice cuantos dias Jesus a jugado al mincecraft, linea 2: un entero que dice cuantos dias jugo al fortnite. jesus no es tan rata y no puede jugar mas de 1 000 000 dias en total.",
        "salida": "el numero exacto de cuantos años jesus no va a tener novia en el siguiente formato [jesus no va a tener novia por X anos] o en el caso de que no haya jugado a ninguno imprime [jesus va a ser feliz].",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "long double"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long double a, b, c;\n    cin>>a>>b;\n    c=(a*4.27)+(b*2.91);\n    if(c){\n        cout<<\"jesus no va a tener novia por \"<<c<<\" anos\";\n    }\n    else{\n        cout<<\"jesus va a ser feliz\";\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "5421. AnagramValidator",
        "url": "https://omegaup.com/arena/problem/AnagramValidator/",
        "descripcion": "Un anagrama de una frase es otra frase que contiene las mismas letras que la original, pero con las letras en diferente orden. Dadas dos frases, decidir si son anagramas una de la otra.",
        "entrada": "Dos líneas, cada una conteniendo una frase compuesta por letras y símbolos de puntuación.",
        "salida": "La frase \"Son anagramas\" si las dos frases son anagramas. La frase \"No son anagramas\" si las dos frases no son anagramas",
        "nivel": "Básico (difícil) - Introducción a la programación",
        "categorias": [
            "Vectores",
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "int",
            "string",
            "getline()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int num[30];\n    string z;\n    getline(cin,z);\n    for(auto i=0; i<z.size(); i++){\n        if(z[i]>='a' && z[i]<='z'){\n            num[z[i]-97]++;\n        }\n        else if(z[i]>='A' && z[i]<='Z'){\n            num[z[i]-65]++;\n        }\n    }\n    getline(cin,z);\n    for(auto i=0; i<z.size(); i++){\n        if(z[i]>='a' && z[i]<='z'){\n            num[z[i]-97]--;\n        }\n        else if(z[i]>='A' && z[i]<='Z'){\n            num[z[i]-65]--;\n        }\n    }\n    for(auto i=0; i<30; i++){\n        if(num[i]!=0){\n            cout<<\"No son anagramas\";return 0;\n        }\n    }\n    cout<<\"Son anagramas\";\n    \n    return 0;\n}\n"
    },
    {
        "titulo": "1301. Números Libres",
        "url": "https://omegaup.com/arena/problem/Numeros-Libres/",
        "descripcion": "Dados dos números square-free a y b, determina si su producto también es square-free. Decimos que un número x es square-free si para todo primo p, p^2 no divide a x. Por ejemplo, 6 es square free porque el cuadrado de ningún primo lo divide. En cambio, 12 sí, porque 2^2 = 4 sí lo divide.",
        "entrada": "En la primera linea contiene un entero N el numero de casos a resolver. En las siguientes N lineas, dos numeros enteros a y b. (1<=N<=15 y 1<=a,b<=1000) 30 puntos, (1<=N<=500 y 1<=a,b<= 2^31) 30 puntos y (1<=N<=500 y 1<= a,b<=2^63) 40 puntos.",
        "salida": "Para cada caso de prueba, decir \"SI\" (sin comillas) si el producto de a y b es square-free, de caso contrario \"NO\" (sin comillas).",
        "nivel": "Intermedio (medio) - Matemáticas en la programación",
        "categorias": [
            "Aritmética",
            "Ciclos",
            "Prueba de primalidad",
            "Generación primaria"
        ],
        "estructuras": [
            "long long",
            "__gcd()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d;\n    cin>>a;\n    while(a--){\n        cin>>b>>c;\n        d=__gcd(b,c);\n        if(d<=1){\n            cout<<\"SI\\n\";\n        }\n        else{\n            cout<<\"NO\\n\";\n        }\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "909. Capturando al gato",
        "url": "https://omegaup.com/arena/problem/L-OMI2011-Capturando-al-gato/",
        "descripcion": "Homero Simpson y su equipo de zorros (agentes secretos) se han dado a la tarea de capturar al criminal internacional conocido como el gato. El plan de Homero es crear un cerco de vigilancia alrededor del Museo de Springfield, próximo objetivo del criminal. Si se traza un círculo alrededor del museo existen N lugares adecuados para que un zorro ponga su puesto de vigilancia. Homero quiere poner el máximo número de zorros posibles alrededor del Museo, sin embargo hay una limitante. El método de comunicación entre los zorros (inventado por el mismo Homero) es el teléfono de hilo. Este teléfono consta de dos vasos unidos por un hilo el cual debe estar tenso para que funcione. El círculo de zorros estará comunicado por teléfonos de la siguiente forma: cada zorro tendrá dos teléfonos, uno para comunicarse con el zorro a su derecha y otro para comunicarse con el zorro a su izquierda. Para que la comunicación sea funcional, el círculo deberá estar cerrado. Homero no es un buen ingeniero y aunque puede hacer muchos teléfonos, requiere que el hilo de todos tenga la misma longitud. Ayuda a Homero a determinar cuál es el máximo número de zorros que puede colocar alrededor del Museo de modo que todos estén comunicados por teléfonos cuyo hilo sea de la misma longitud.",
        "entrada": "En la primera línea el número N, la cantidad de posiciones posibles para zorros En las siguientes N líneas un entero d_i que representa la distancia que hay entre el puesto i y el puesto i+1. El entero en la última de estas líneas representa la distancia del último puesto hacia el primero para cerrar el círculo. (1 <= N <= 5000) y (1<= sum(di, i=1 to N) <= 2 * 10^9). Subtask 1 (75%): (0<N<=10^3) y los casos no están agrupados. Subtask 2 (25%): No hay restricciones adicionales.",
        "salida": "Tu programa debe escribir a la pantalla un único número entero que representa la cantidad máxima de zorros que se pueden colocar.",
        "nivel": "Intermedio (fácil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Vectores",
            "Pilas",
            "Implementación"
        ],
        "estructuras": [
            "long long",
            "stack<int>",
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long a, b=0, c=0, d, e=1, f;\nint num[5001];\nstack<int>falta;\n\nint sub(int x){\n    int y=0, z=0;\n    for(auto i=x; i<a; i++){\n        y+=num[i];\n        if(y==e){\n            z++;\n            y=0;\n        }\n        else if(y>e){\n            return 0;\n        }\n    }\n    for(auto i=0; i<x; i++){\n        y+=num[i];\n        if(y==e){\n            z++;\n            y=0;\n        }\n        else if(y>e){\n            return 0;\n        }\n    }\n    \n    return z;\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    cin>>a;\n    for(auto i=0; i<a; i++){\n        cin>>num[i];\n        b=max(b,(long long)num[i]);\n        c+=num[i];\n    }\n    while(e<sqrt(c)){\n        if(c%e==0){\n            falta.push(c/e);\n            if(e>=b){\n                d=0;\n                f=0;\n                for(auto i=0; i<a; i++){\n                    d+=num[i];\n                    if(d==e){\n                        f++;\n                        d=0;\n                    }\n                    else if(d>e){\n                        f=-1;break;\n                    }\n                }\n                if(f!=-1){\n                    cout<<f;return 0;\n                }\n                d=0;\n                f=0;\n                for(auto i=1; i<a; i++){\n                    d+=num[i];\n                    if(d==e){\n                        f++;\n                        d=0;\n                    }\n                    else if(d>e){\n                        f=-1;break;\n                    }\n                }\n                if(f!=-1){\n                    d+=num[0];\n                    if(d==e){\n                        f++;\n                        cout<<f;return 0;\n                    }\n                }\n                for(auto j=2; j<=7; j++){\n                    f=sub(j);\n                    if(f){\n                        cout<<f;return 0;\n                    }\n                }\n            }\n        }\n        e++;\n    }\n    e=sqrt(c);\n    if((e*e)==c && e>=b){\n        d=0;\n        f=0;\n        for(auto i=0; i<a; i++){\n            d+=num[i];\n            if(d==e){\n                f++;\n                d=0;\n            }\n            else if(d>e){\n                f=-1;break;\n            }\n        }\n        if(f!=-1){\n            cout<<f;return 0;\n        }\n        d=0;\n        f=0;\n        for(auto i=1; i<a; i++){\n            d+=num[i];\n            if(d==e){\n                f++;\n                d=0;\n            }\n            else if(d>e){\n                f=-1;break;\n            }\n        }\n        if(f!=-1){\n            d+=num[0];\n            if(d==e){\n                f++;\n                cout<<f;return 0;\n            }\n        }\n        for(auto j=2; j<=7; j++){\n            f=sub(j);\n            if(f){\n                cout<<f;return 0;\n            }\n        }\n    }\n    while(falta.size()!=1){\n        e=falta.top();\n        falta.pop();\n        if(e>=b){\n            d=0;\n            f=0;\n            for(auto i=0; i<a; i++){\n                d+=num[i];\n                if(d==e){\n                    f++;\n                    d=0;\n                }\n                else if(d>e){\n                    f=-1;break;\n                }\n            }\n            if(f!=-1){\n                cout<<f;return 0;\n            }\n            d=0;\n            f=0;\n            for(auto i=1; i<a; i++){\n                d+=num[i];\n                if(d==e){\n                    f++;\n                    d=0;\n                }\n                else if(d>e){\n                    f=-1;break;\n                }\n            }\n            if(f!=-1){\n                d+=num[0];\n                if(d==e){\n                    f++;\n                    cout<<f;return 0;\n                }\n            }\n            for(auto j=2; j<=7; j++){\n                f=sub(j);\n                if(f){\n                    cout<<f;return 0;\n                }\n            }\n        }\n    }\n    cout<<1;\n\n    return 0;\n}"
    },
    {
        "titulo": "5287. El ratón que salta chueco",
        "url": "https://omegaup.com/arena/problem/El-raton-que-salta-chueco/",
        "descripcion": "Un ratón tiene lastimada su patita izquierda pero debe llegar a su madriguera lo más rápido posible antes de que el gato aparezca. La casa en la que viven los ratones y el gato es de dimensiones M x N, el ratón se encuentra actualmente en la posición (R_i,R_j) y la madriguera está en la posición (H_i,H_j). Como al ratón le cuesta trabajo caminar, sólo puede ejecutar cierto tipo de salto que lo desplaza simultáneamente F unidades al frente y D unidades a la derecha.  El ratón debe evitar chocar contra las paredes de la casa pero puede orientarse en cualquiera de las cuatro direcciones cardinales antes de dar cada salto. Escribe un programa que calcule cuál es la cantidad mínima de saltos que el ratón necesita para llegar a la madriguera.",
        "entrada": "Los ocho enteros M, N, F, D, R_i, R_j, H_i, H_j. Puedes suponer que 1<=M,N,F,D<=1000, 0<=R_i,H_i<M y 0<=R_j,H_j<N",
        "salida": "Un entero que sea la mínimo número de saltos que necesita dar el ratón para llegar a la madriguera o el entero -1 si no existe solución.",
        "nivel": "Intermedio (fácil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Búsqueda en amplitud",
            "Colas",
            "Matrices",
            "Ciclos"
        ],
        "estructuras": [
            "int",
            "struct",
            "long long",
            "vector<vector<int>>",
            "queue<struct>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct sobra{\n    int aa, bb, cc;\n};\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d;\n    vector<vector<int>>num(1001,vector<int>(1001,0));\n    queue<sobra>falta;\n    sobra z;\n    cin>>a>>b>>c>>d>>z.aa>>z.bb>>g>>h;\n    num[z.aa][z.bb]=1;\n    falta.push(z);\n    if(z.aa==g && z.bb==h){\n        cout<<\"0\";return 0;\n    }\n    while(falta.size()){\n        z=falta.front();\n        falta.pop();\n        z.cc++;\n        z.aa-=c;\n        z.bb+=d;\n        if(z.aa>=0 && z.aa<a && z.bb>=0 && z.bb<b && num[z.aa][z.bb]==0){\n            if(z.aa==g && z.bb==h){\n                cout<<z.cc;return 0;\n            }\n            num[z.aa][z.bb]=1;\n            falta.push(z);\n        }\n        z.aa+=c;\n        z.bb-=d;\n        z.bb+=c;\n        z.aa+=d;\n        if(z.aa>=0 && z.aa<a && z.bb>=0 && z.bb<b && num[z.aa][z.bb]==0){\n            if(z.aa==g && z.bb==h){\n                cout<<z.cc;return 0;\n            }\n            num[z.aa][z.bb]=1;\n            falta.push(z);\n        }\n        z.bb-=c;\n        z.aa-=d;\n        z.aa+=c;\n        z.bb-=d;\n        if(z.aa>=0 && z.aa<a && z.bb>=0 && z.bb<b && num[z.aa][z.bb]==0){\n            if(z.aa==g && z.bb==h){\n                cout<<z.cc;return 0;\n            }\n            num[z.aa][z.bb]=1;\n            falta.push(z);\n        }\n        z.aa-=c;\n        z.bb+=d;\n        z.bb-=c;\n        z.aa-=d;\n        if(z.aa>=0 && z.aa<a && z.bb>=0 && z.bb<b && num[z.aa][z.bb]==0){\n            if(z.aa==g && z.bb==h){\n                cout<<z.cc;return 0;\n            }\n            num[z.aa][z.bb]=1;\n            falta.push(z);\n        }\n    }\n    cout<<\"-1\";\n    \n    return 0;\n}"
    },
    {
        "titulo": "6913. Directorio Chihuahuense",
        "url": "https://omegaup.com/arena/problem/Directorio-Chihuahuense/",
        "descripcion": "Un amigo tuyo va a ir de vacaciones a Chihuahua y quiere saber cuáles son los lugares a los que pertenece cierta clave lada L.",
        "entrada": "Un número entero L que representa la clave lada.",
        "salida": "El lugar de donde es la clave lada.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a;\n    cin>>a;\n    switch(a){\n        case 614: cout<<\"Chihuahua\";break;\n        case 621: cout<<\"Saucillo\";break;\n        case 625: cout<<\"Cuauhtemoc\";break;\n        case 626: cout<<\"Coyame\";break;\n        case 627: cout<<\"Parral\";break;\n        case 628: cout<<\"Santa Barbara\";break;\n        case 629: cout<<\"Jimenez\";break;\n        case 635: cout<<\"Creel\";break;\n        case 636: cout<<\"Casas Grandes\";break;\n        case 639: cout<<\"Delicias\";break;\n        case 648: cout<<\"Camargo\";break;\n        case 649: cout<<\"Guachochi\";break;\n        case 652: cout<<\"Madera\";break;\n        case 656: cout<<\"Juarez\";break;\n        case 659: cout<<\"Bachiniva\";break;\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "5265. Términos pares de Fibonacci ",
        "url": "https://omegaup.com/arena/problem/Terminos-pares-de-Fibonacci-emh/",
        "descripcion": "Cada nuevo término en la sucesión de Fibonacci es generado por la adición de los dos términos anteriores. Comenzando con 1 y 2, los 10 primeros términos serían: 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, etc. Considerando los términos de la sucesión de Fibonacci cuyos valores no superan un cierto número dado, halla la suma de los términos cuyo valor es par.",
        "entrada": "Un único número entero positivo N, donde 1<=N<=4*(10^6).",
        "salida": "Imprime un único número que representa la suma de todos terminos pares cuyo valor es menor o igual a N",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Ciclos"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b=1, c=0, d=1, e=0;\n    cin>>a;\n    while(b<=a){\n        b=c+d;\n        if(b>a){\n            break;\n        }\n        if(b%2==0){\n            e+=b;\n        }\n        d=c;\n        c=b;\n    }\n    cout<<e;\n    \n    return 0;\n}"
    },
    {
        "titulo": "6425. Triangulos rectángulos",
        "url": "https://omegaup.com/arena/problem/DRMIGTriangulosRectangulos/",
        "descripcion": "Según el teorema de pitágoras, para cualquier triángulo rectángulo con catetos a y b e hipotenusa c, se cumple la condición = a^2+b^2=c^2. En este problema se dan tres números. Debes decir si con ellos se forma un triángulo rectángulo o no. Habrá casos que con las tres medidas proporcionadas ni siquiera se pueda formar un triángulo. Si este es el caso, también se debe identificar.",
        "entrada": "Tres entradas, cada una de ellas representando un número decimal.",
        "salida": "Una sola línea con la frase SI ES RECTANGULO si se puede formar un triángulo rectángulo con ellos. Si no se puede formar un triángulo rectángulo, escribir la frase NO ES RECTANGULO, y si no se puede formar un triángulo con las tres medidas, escribir la frase NI SIQUIERA ES TRIANGULO. La precisión con la que se deben comparar los decimales es 0.001",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "long double",
            "pow()",
            "swap()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long double a, b, c, d;\n    cin>>a>>b>>c;\n    if(b>a){\n        swap(b,a);\n    }\n    if(c>a){\n        swap(c,a);\n    }\n    if(c>b){\n        swap(c,b);\n    }\n    if(a>=(b+c)){\n        cout<<\"NI SIQUIERA ES TRIANGULO\";return 0;\n    }\n    d=pow(a,2)-(pow(b,2)+pow(c,2));\n    if(d>=0 && d<=0.1){\n        cout<<\"SI ES RECTANGULO\";return 0;\n    }\n    cout<<\"NO ES RECTANGULO\";\n    \n    return 0;\n}"
    },
    {
        "titulo": "4537. Tres hermanos agricultores",
        "url": "https://omegaup.com/arena/problem/Tres-hermanos-agricultores/",
        "descripcion": "En una aldea lejana viven tres hermanos agricultores, cada uno posee un 4 hectareas de tierra y cada año cada uno siembra zanahorias, calabazas, frijol y lechuga en cada una de sus hectareas. Al final de año se reunen entre los tres para saber quien cosecho más de cada una de las verduras y cuantas verduras cosecharon cada uno.",
        "entrada": "La primera línea contiene 4 números separados por espacios con la cosecha de zanahorias, calabazas, frijol y lechuga del primer hermano. La segunda línea contiene 4 números separados por espacios con la cosecha de zanahorias, calabazas, frijol y lechuga del segundo hermano La tercera línea contiene 4 números separados por espacios con la cosecha de zanahorias, calabazas, frijol y lechuga del tercer hermano.",
        "salida": "La primera línea muestra el número de hermano que cosecho más zanahorias y la cantidad cosechada. La segunda muestra el número de hermano que cosecho más calabazas y la cantidad cosechada. La tercera línea muestra el número de hermano que cosecho más frijol y la cantidad cosechada. La cuarta línea muestra el número de hermano que cosecho más lechuga y la cantidad cosechada.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Ciclos",
            "Matrices"
        ],
        "estructuras": [
            "long long",
            "vector<vector<int>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a=1, b=1, c=1, d=0, e=0, f=0, g=0, h=0, l=0, m=0, n, o, p=2, q;\n    vector<vector<int>>num;\n    cin>>num[0][0]>>num[1][0]>>num[2][0]>>num[3][0]>>num[0][1]>>num[1][1]>>num[2][1]>>num[3][1]>>num[0][2]>>num[1][2]>>num[2][2]>>num[3][2];\n    for(auto i=0; i<4; i++){\n        a=0;\n        b=0;\n        for(auto j=0; j<3; j++){\n            if(num[i][j]>a){\n                a=num[i][j];\n                b=j+1;\n            }\n        }\n        cout<<b<<\" \"<<a<<\"\\n\";\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "4064. Tomando Café",
        "url": "https://omegaup.com/arena/problem/DOCENTES-SIN-DORMIR-ASINUS/",
        "descripcion": "Los docentes del ASINUS INSTITUTE tienen problemas de desempeño, ya que no están durmiendo lo suficiente para enseñar de una forma óptima. Han descubierto que el café les brinda aquella energía que no están obteniendo al dormir, sin embargo no siempre consumen la misma cantidad, por ello, a pesar de que el café les ayuda, su nivel de desempeño varia mucho debido a la diferencia de éste que consumen. Las horas que deben dormir para estar con el 100% de energía son 8hrs. y con la experiencia se han dado cuenta que por cada hora que no duermen deben beber 1.5 tazas de café de Veracruz. Ayuda a los docentes a encontrar la cantidad exacta de tazas de café que necesitarán para tener el 100% de energía y dar lo mejor de sí en todas sus clases, tomando en cuenta las horas que durmieron.",
        "entrada": "El número de horas que durmió el docente.",
        "salida": "El número de tazas que requiere para tener el 100% de energía. Si el docente durmió 8 horas o más, no necesitará beber café a lo que se indicará: \"NO CAFE\".",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Cálculos aritméticos"
        ],
        "estructuras": [
            "long double"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long double a=1;\n    cin>>a;\n    if(a>=8){\n        cout<<\"NO CAFE\";\n    }\n    else{\n        cout<<(8-a)*1.5;\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "1795. Supermercado Difícil",
        "url": "https://omegaup.com/arena/problem/SupermercadoDificil/",
        "descripcion": "Juan Pérez ha ido al supermercado varias veces en el año y ha anotado en una lista los precios de los productos que ha comprado durante cada día. Sin embargo, mientras anotaba los precios de los productos también hacía anotaciones arbitrarias en su lista, como nombres de personas, canciones, o bien ponía cualquier cosa que se le ocurriera. Ayude a Juan Pérez a determinar el gasto que tuvo durante cada visita al supermercado ignorando las cosas que no son precios.",
        "entrada": "La entrada consiste de un número arbitrario de líneas de entrada. Cada línea contiene los precios de los productos que Juan Perez compró durante una visita al supermercado, separados por letras, espacios, tabulaciones y los signos de puntuación ',', '.', ';', ':', '-', '@', ')', '('.",
        "salida": "La suma de los precios de cada línea de la entrada. Puede suponer que la suma de la lista de los precios cabe en un entero de 32 bits con signo.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "string",
            "getline()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    long long a, b;\n    string z;\n    while(getline(cin,z)){\n        a=0;\n        b=0;\n        for(auto i=0; i<z.size(); i++){\n            if(z[i]>='0' && z[i]<='9'){\n                b*=10;\n                b+=(z[i]-48);\n            }\n            else{\n                a+=b;\n                b=0;\n            }\n        }\n        a+=b;\n        cout<<a<<\"\\n\";\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "2940. Robot Arm",
        "url": "https://omegaup.com/arena/problem/Robot-Arm/",
        "descripcion": "Estamos entusiasmados en la empresa, un brazo de robot nuevo ha sido ensamblado y esta conectado a nuestra plataforma listo para recibir las ordenes necesarias. Donde lo instalamos? Está dentro de nuestra maquina de sodas, cada soda en el sistema esta representada por un código numérico diferente. Esta maquina tiene 3 operaciones principales que necesitamos configurar lo antes posible. 1.- x insertar x: hace que la soda x sea insertada al final de toda la pila de sodas. 2.- sacar: saca la soda al final de toda la pila e imprime su código. 3.- invertir: este comando invierte una cantidad \"M\" de sodas al final de la pila. Por ejemplo si M es 3 y en la pila tenemos los enteros [8, 2, 1, 5, 4, 7, 3] al usar la operación la pila invierte el sub-array [4, 7, 3] y quedara [8, 2, 1, 5, 3, 7, 4] dejando al numero 4 al final de la pila. Si la pila contiene menos de M sodas invierte toda la pila. Este brazo nos ayudara proveer las sodas de manera que todos los empleados reciban la soda que deseen.",
        "entrada": "La entrada comienza con un numero entero T la cantidad de casos de prueba. Cada caso de prueba comienza con dos números enteros N y M la cantidad de operaciones que se realizaran y el numero de sodas que se invertirán al final de la cola con la operación “invertir” respectivamente. A continuación están T lineas con una operación cada una. Por cada operación se puede recibir una de las siguientes cadenas \"1 x\", \"2\" y \"3\", el comando \"1 x\" es para insertar donde x es el numero de la soda, el comando 2 es para sacar y el comando 3 es para invertir. Se garantiza que no se realizara una operación \"2 sacar\" si es que no hay valores en la pila.",
        "salida": "Imprimir por cada operación \"2\" el código numérico de la soda que salio de la pila.",
        "nivel": "Intermedio (fácil) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Pilas",
            "Colas",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "stack<int>",
            "queue<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d;\n    stack<int>falta;\n    queue<int>faltas;\n    cin>>a;\n    while(a--){\n        cin>>b>>c;\n        while(falta.size()){\n            falta.pop();\n        }\n        while(b--){\n            cin>>d;\n            if(d==1){\n                cin>>d;\n                falta.push(d);\n            }\n            else if(d==2){\n                cout<<falta.top()<<\"\\n\";\n                falta.pop();\n            }\n            else{\n                d=c;\n                while(falta.size() && d){\n                    d--;\n                    faltas.push(falta.top());\n                    falta.pop();\n                }\n                while(faltas.size()){\n                    falta.push(faltas.front());\n                    faltas.pop();\n                }\n            }\n        }\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "3318. QirMontaña",
        "url": "https://omegaup.com/arena/problem/QirMontana/",
        "descripcion": "Nicte-Ha una niña de Felipe Carrillo Puerto, de fue de vacaciones al Estado de México, lo primero que observó fueron las bellas montañas de la sierra - ya que nunca las había visto - cuando comenzó a preguntarse: ¿Cuál montaña es la más ancha? Ella decidió tomar N medidas igualmente espaciadas de altura H_i secuencialmente a través del horizonte usando su nuevo Geoaltímetro de Larga Distancia. Una montaña se define como una secuencia consecutiva de valores H_i que aumentan (o permanecen igual) y luego disminuye (o permanece igual), por ejemplo: 2,3,3,5,4,4,1. Es posible que una montaña en el borde de su campo de visión únicamente aumente o disminuya en su altura, también. El ancho de una montaña es el número de medidas que abarque. Escribe un programa, que ayude a la niña Nicte-Ha a encontrar la montaña mas alta.",
        "entrada": "Línea 1: Un solo entero: N. Líneas 2..N+1: La línea i+1 contiene un solo entero: H_i",
        "salida": "Línea 1: Una sola línea con un solo entero que es el ancho de la montaña más ANCHA.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b=1, c, d;\n    vector<int>num(100001);\n    cin>>a;\n    for(auto i=0; i<a; i++){\n        cin>>num[i];\n    }\n    for(auto i=0; i<a; i++){\n        c=i-1;\n        d=1;\n        while(c>=0 && num[c]<=num[c+1]){\n            d++;\n            c--;\n        }\n        c=i+1;\n        while(c<a && num[c]<=num[c-1]){\n            d++;\n            c++;\n        }\n        if(d>b){\n            b=d;\n        }\n        i=c-1;\n    }\n    cout<<b;\n    \n    return 0;\n}"
    },
    {
        "titulo": "6995. Programando fórmulas raras",
        "url": "https://omegaup.com/arena/problem/Programando-formulas/",
        "descripcion": "Te gustan mucho las matemáticas pero no eres muy rápido haciendo los cálculos manualmente. Como estás aprendiendo a programar, crees que podrías solucionar este problema haciendo un programa que sea capaz de evaluar rápidamente ciertas expresiones aritméticas. Para probar tus habilidades, has dedicido escribir un programa que evalúe una fórmula que tú inventaste, la cual es: (x+x(y+z^2))/((x + PI)(y + PI)). Escribe un programa que calcule el resultado de evaluar la fórmula anterior.",
        "entrada": "Tres reales x,y,z. Puedes suponer que 0<=x,y,z<=1000.",
        "salida": "Un real que sea el valor de la fórmula evaluada. Tu programa se considerará correcto si el valor calculado es razonablemente cercano a la respuesta exacta.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Cálculos aritméticos"
        ],
        "estructuras": [
            "long double",
            "setprecision()",
            "pow()",
            "fixed"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long double a, b, c;\n    cin>>a>>b>>c;\n    cout<<fixed<<setprecision(6)<<(a+(a*(b+pow(c,2))))/((a+3.14159)*(b+3.14159));\n    \n    return 0;\n}"
    },
    {
        "titulo": "3695. Permutaciones-OMIJAL",
        "url": "https://omegaup.com/arena/problem/Permutaciones-OMIJAL/",
        "descripcion": "En matemáticas, una permutación es la variación del orden o de la disposición de los elementos de un conjunto. Por ejemplo, en el conjunto [1,2,3], cada ordenación posible de sus elementos, sin repetirlos, es una permutación. Existe un total de 6 permutaciones para estos elementos: \"1,2,3\", \"1,3,2\", \"2,1,3\", \"2,3,1\", \"3,1,2\" y \"3,2,1\". En este ejemplo las permutaciones están de manera ordenada, si les diéramos un valor a cada una según la posición que les corresponde en este orden serían de la siguiente forma: 1.- 1,2,3. 2.- 1,3,2. 3.- 2,1,3. 4.- 2,3,1. 5.- 3,1,2. 6.-3,2,1. Tu tarea, a pesar de esta mala redacción es escribir un programa que dada una permutación de los primeros N números enteros positivos encuentre cual es el número que le correspondería en la tabla de permutaciones ordenadas, al generar las permutaciones de estos N números de la manera demostrada.",
        "entrada": "La entrada consiste de dos líneas. La primera contiene el número N. La segunda línea contiene los N números separados por espacio. Para el 50% de los casos, 1<=N<=10. Para el 100% de los casos, 1<=N<=1000.",
        "salida": "Un solo número entero, el número de la permutación dada en la entrada. Como este número puede ser muy grande deberás imprimirlo módulo 1000000007.",
        "nivel": "",
        "categorias": [
            "Ciclos",
            "Ordenamiento",
            "Arboles",
            "Vectores",
            "Aritmética modular"
        ],
        "estructuras": [
            "long long",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b=1, c=1;\n    vector<int>falta;\n    vector<int>faltas;\n    vector<int>num(1001);\n    cin>>a;\n    for(auto i=1; i<a; i++){\n        cin>>num[i-1];\n        b*=i;\n        b%=1000000007;\n        faltas.push_back(b);\n        falta.push_back(num[i-1]);\n    }\n    cin>>num[a-1];\n    falta.push_back(num[a-1]);\n    sort(falta.begin(),falta.end());\n    for(auto i=0; i<a-1; i++){\n        for(auto j=0; true; j++){\n            if(num[i]==falta[j]){\n                c+=(j*faltas[faltas.size()-1]);\n                c%=1000000007;\n                falta[j]=1000000007;break;\n            }\n        }\n        faltas.pop_back();\n        sort(falta.begin(),falta.end());\n        falta.pop_back();\n    }\n    cout<<c;\n    \n    return 0;\n}"
    },
    {
        "titulo": "6147. Permutaciones de la OPI",
        "url": "https://omegaup.com/arena/problem/Permutaciones-de-la-OPI/",
        "descripcion": "Para poder realizar el examen estatal de la OPI, los competidores fueron acomodados en diferentes aulas por grupos. En un determinado grupo, se le asignó a cada competidor una letra del alfabeto inglés, que no se repetiría con la de ningún otro competidor en el aula. Para poder ingresar al salón, los competidores deberían estar ordenados alfabéticamente según la letra asignada, sin embargo, el examen comenzó tan temprano y los competidores tenían tanto sueño que no lograron ordenarse adecuadamente. Al estar desordenados los participantes, notaron que formaban una cadena de caracteres que era una permutación de la cadena original (en la que estaban ordenados alfabéticamente) por lo que para poder despertar y prepararse para el examen, se pusieron a calcular qué número de permutación de la cadena original habían formado. Decimos que una permutación 'y' de una cadena sucede a una permutación cuando 'x' al ser ordenadas alfabéticamente no existe una permutación que pueda estar entre las dos. Dado un entero N que indica la cantidad de permutaciones a revisar, la cadena S de longitud M con las letras en desorden que se asignaron a los competidores y N permutaciones de la cadena original, indicar para cada permutación el orden en que se generaría a partir de la original.",
        "entrada": "El entero N seguido de la cadena S. Las siguientes N líneas indican las permutaciones a identificar. Las cadenas solo tendrán letras mayúsculas del alfabeto inglés y no habrá letras repetidas. 1<=M<=20, 1<=N<=20.",
        "salida": "Para cada permutación de la cadena S indicar el número de permutación que sería a partir de la cadena original.",
        "nivel": "Intermedio (fácil) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Ciclos",
            "Ordenamiento",
            "Vectores",
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "long long",
            "vector<char>",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b=1, c, d;\n    vector<char>falta;\n    vector<char>faltas;\n    string z, zz;\n    cin>>a>>z;\n    for(auto i=1; i<=z.size(); i++){\n        falta.push_back(z[i-1]);\n        b*=i;\n    }\n    b/=z.size();\n    sort(falta.begin(),falta.end());\n    while(a--){\n        faltas=falta;\n        c=b;\n        d=1;\n        cin>>zz;\n        for(auto i=0; i<zz.size(); i++){\n            for(auto j=0; j<faltas.size(); j++){\n                if(faltas[j]==zz[i]){\n                    d+=(j*c);\n                    faltas[j]='a';break;\n                }\n            }\n            sort(faltas.begin(),faltas.end());\n            faltas.pop_back();\n            if(faltas.size()){\n                c/=faltas.size();\n            }\n        }\n        cout<<d<<\"\\n\";\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "3913. Pares Intermedios",
        "url": "https://omegaup.com/arena/problem/Pares-Intermedios/",
        "descripcion": "El vendedor de Bonice DanielBun no sabe matemáticas y quiere aprender. Quiere saber cuantos números pares hay en un intervalo de dos números enteros. Recordó que si a los números pares se sumas dos unidades más, este se convierte en un número par, y que si a un número non le sumas dos unidades, este se convierte en un número non. Escribe un Programa que lea 2 números y escriba la cantidad de números pares que hay entre ambos. Si el intervalo inferior o el superior es par, también se cuenta.",
        "entrada": "Un entero n, representando el límite inferior, y un entero m, representando el límite superior.",
        "salida": "La cantidad de números pares que hay entre los dos límites.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b;\n    cin>>a>>b;\n    if(b%2){\n        b--;\n    }\n    if(a%2){\n        a--;\n    }\n    else{\n        a-=2;\n    }\n    cout<<(b-a)/2;\n    \n    return 0;\n}"
    },
    {
        "titulo": "6963. Mensajes DRM",
        "url": "https://omegaup.com/arena/problem/Mensajes-DRM/",
        "descripcion": "La encriptación DRM es relativamente nueva . Dada una cadena encriptada (la cual llamaremos mensaje DRM) , la desencriptación consiste en tres simples pasos : Dividir , Rotar y Unir. Estos pasos se describirán usando el siguiente mensaje DRM como ejemplo , \"EWPGAJRB\": Divide - Primero , divide el mensaje a la mitad , obteniendo \"EWPG\" y \"AJRB\". Rota - Para cada mitad, calcula su valor de rotación, el cual se obtiene sumando el valor de cada carácter (A = 0 , B = 1 , ... , Z = 25). El valor de rotación de \"EWPG\" es 4 + 22 + 15 + 6 = 47. Rota cada elemento de \"EWPG\" 47 veces hacia adelante (pasando de A a Z en caso de ser necesario) para obtener una nueva cadena, \"ZRKB\". Haciendo lo mismo con la segunda mitad \"AJRB\", se obtiene \"BKSC\". Une - El último paso es unir la dos mitades obtenidas en el paso anterior, esto se lograra rotando cada carácter de la primera mitad el valor correspondiente del carácter en la segunda mitad. Para la primera posición, rotar 'Z' un total de 'B' veces, significa avanzar una sola vez, es decir, se obtiene 'A'. Continuando con este proceso para cada posición, se obtiene \"ABCD\", siendo este el mensaje ya descifrado.",
        "entrada": "La entrada consiste en una sola línea, una cadena de longitud L, que es el mensaje DRM que se va a descifrar. Todos los caracteres de la cadena son letras mayúsculas. L <=15000.",
        "salida": "Muestra el mensaje DRM ya descifrado.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a=0, b=0;\n    string z, zz=\"\", zzz=\"\";\n    cin>>z;\n    for(auto i=0; i<z.size()/2; i++){\n        zz=zz+z[i];\n        a+=(z[i]-65);\n    }\n    for(auto i=z.size()/2; i<z.size(); i++){\n        zzz=zzz+z[i];\n        b+=(z[i]-65);\n    }\n    a%=26;\n    b%=26;\n    for(auto i=0; i<zz.size(); i++){\n        zz[i]+=a;\n        if(zz[i]>'Z'){\n            zz[i]=64+(zz[i]-90);\n        }\n    }\n    for(auto i=0; i<zzz.size(); i++){\n        zzz[i]+=b;\n        if(zzz[i]>'Z'){\n            zzz[i]=64+(zzz[i]-90);\n        }\n    }\n    for(auto i=0; i<zz.size(); i++){\n        a=zzz[i]-65;\n        zz[i]+=a;\n        if(zz[i]>'Z'){\n            zz[i]=64+(zz[i]-90);\n        }\n        cout<<zz[i];\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "5407. Las hormigas",
        "url": "https://omegaup.com/arena/problem/Las-hormigas-ASINUS/",
        "descripcion": "Las hormigas son una especie muy bien organizada por tal motivo a pesar de ser tan pequeñas son capaces de sobrevivir a contextos algo extremos, sin embargo por su tamaño es un esfuerzo constante, en donde cada una de ellas hace lo que le corresponde, generando un sistema continuo y perfecto. Para poder sobrevivir, ellas salen todos los días, si así el clima lo permite, a conseguir comida o materiales para su vivienda, para ello, todos sabemos que suelen hacer largos caminos en donde una tras otra carga lo que le corresponde hasta llegar nuevamente al hormiguero, si el camino se interrumpe, hay encargadas de volver a encauzar el camino de todas las que vienen detrás. Una vez que llegan al hormiguero, son distribuidas según lo que cargaron durante su viaje, ya que para ellas cada cosa tiene una función especial, para ello, pueden cargar tres tipos de cosas: Piedras, Hojas, Restos de comida (alimento humano, semillas, insectos, etc). Cuando una hormiga trae piedras pequeñas se va al sótano del hormiguero, para construir nuevos cominos, cuando trae hojas va al piso 1, en el cual crecen los hongos que cultivan para comer y cuando trae alimento va al piso 2, el hormiguero tiene 2 pisos más que sirven para socializar y comer. En cada recorrido puede haber N hormigas, las cuales en su regreso serán clasificadas según el tipo de carga que trajeron consigo, 3 para las que van al sótano, 1 para las que van al primer piso y 2 para las que van al segundo piso. Así mismo en la entrada de cada piso hay una hormiga encargada del inventario, la cual contabiliza la cantidad de cargas que entraron. Sin embargo, es mucho trabajo tomando en cuenta el recorrido y el esfuerzo diario al cargar 8 veces su peso, para ello, ayuda diseñando un programa que le permita a las hormigas clasificar rápidamente las cargas y llevar un inventario exacto de lo que entró en cada viaje.",
        "entrada": "N como el número de hormigas que salieron al recorrido. La clasificación de cada hormiga (3, 1, 2) que se les da al regresar a cada una de ellas. El número de hormigas que salen al recorrido debe ser >0, de lo contrario se indicará ERROR. La clasificación sólo puede ser 3, 1 ó 2, por tal motivo si es diferente se indicará ERROR.",
        "salida": "El inventario de cada piso en orden de pisos, primero el sótano, después el piso 1 y después el piso 2.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Ciclos",
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "long double",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long double a, b=0, c=0, d=0;\n    string z;\n    cin>>a;\n    if(!a){\n        cout<<\"ERROR\";return 0;\n    }\n    while(a--){\n        cin>>z;\n        if(z==\"3\"){\n            b++;\n        }\n        else if(z==\"1\"){\n            c++;\n        }\n        else if(z==\"2\"){\n            d++;\n        }\n        else{\n            cout<<\"ERROR\";return 0;\n        }\n    }\n    cout<<b<<\"\\n\"<<c<<\"\\n\"<<d;\n    \n    return 0;\n}"
    },
    {
        "titulo": "4571. Formación para honores",
        "url": "https://omegaup.com/arena/problem/Formacion-para-honores/",
        "descripcion": "Como siempre después de un gran fin de semana regresamos a un nuevo lunes de actividades, y como siempre en todo lunes en las escuelas de educación básica se llevan a cabo honores a la bandera. En este caso te toca ser el prefecto y tienes acomodar al grupo de nuevo ingreso, como no sabes donde los van a ubicar el director te indicara la manera de formarlos. El director te dirá cuantos N alumnos hay en el grupo y las K filas de alumnos en que se deben formar, seguido N números que representan la estatura de los alumnos, como el director es muy estricto todos los alumnos deben de estar formados por estatura de izquierda a derecha y de adelante hacia atrás.",
        "entrada": "Un numero 1 <= N <= 1,000,000 que representa el numero de alumnos, en esta escuela los salones son muy grandes; seguido de k alumnos en fondo que deben de ser formados y finalmente 1 <= N números <= 1000000000 que representan la altura de los alumnos.",
        "salida": "Los N alumnos formados de K en fondo.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Ordenamiento",
            "Ciclos",
            "Vectores"
        ],
        "estructuras": [
            "long long",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d;\n    vector<int>falta;\n    cin>>a>>b;\n    d=a;\n    while(d--){\n        cin>>c;\n        falta.push_back(c);\n    }\n    sort(falta.begin(),falta.end());\n    cout<<falta[0]<<\" \";\n    for(auto i=1; i<a; i++){\n        if(i%b==0){\n            cout<<\"\\n\";\n        }\n        cout<<falta[i]<<\" \";\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "2155. El cuarto oscurito",
        "url": "https://omegaup.com/arena/problem/El-cuarto-oscurito/",
        "descripcion": "Nuestro ya conocido héroe Tlakarelel ha sido capturado por el enemigo y encerrado en un enorme cuarto oscuro. Después de recobrar el conocimiento, descubrió (a tientas) que en la pared existían una gran cantidad de interruptores. Pensando que activaban la luz, comenzó a accionarlos uno tras otro desesperadamente, pero ninguna luz se encendió, al contrario, algunos ruidos se oyeron en el piso, como si algo se estuviera moviendo. Al accionar de nuevo los interruptores, se dio cuenta de que cada uno quitaba y ponía baldosas del piso alternadamente, es decir, si la baldosa no estaba la ponía y si estaba la quitaba. Cada interruptor activaba varias baldosas. Tlakarelel siguió buscando en la pared, y encontró que debajo de cada interruptor estaba escrito (en braile) cuáles baldosas activaba cada interruptor. Con esto Tlakarelel se regocijó, puesto que recordaba cuáles eran los interruptores que había presionado y ahora sabría cuales baldosas había quitado en su afán por prender la luz. Por el momento, no hay que salvar a Tlakarelel, sólo tienes que ayudarle a saber cuáles baldosas no se encuentran en el piso después de que presionó los interruptores.",
        "entrada": "En la primera línea los números b (8<=b<=3000), n (2<=n<=16) y m (2<=m<=b) donde b indica el número de baldosas que hay en el cuarto, n el número de interruptores que hay y m el número de baldosas que se activan al presionar un interruptor (todos los interruptores cambian el estado de la misma cantidad de baldosas). En cada una de las siguientes n líneas, habrá m números separados por un espacio, que indican las baldosas que se alternan al presionar el interruptor correspondiente. En la siguiente línea el número a (5<=a<=30000) de veces que Tlakarelel activó los interruptores. En la última línea, a úmeros separados por un espacio que corresponden al número de los interruptores que presionó nuestro héroe, enlistados en el orden en el que fueron efectuados. Considera que No hacía falta ninguna baldosa antes de que Tlakarelel empezara a accionar botones",
        "salida": "En la primera línea, el número de baldosas que faltaban a final (las que fueron quitadas). En la segunda línea, separados por espacios y ordenadas ascendentemente, las baldosas que hacen falta.",
        "nivel": "Intermedio (medio) - Análisis y diseño de algoritmos",
        "categorias": [
            "Matrices",
            "Colas"
        ],
        "estructuras": [
            "long long",
            "vector<vector<int>>",
            "vector<int>",
            "queue<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\n using namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e;\n    vector<vector<int>>num(17,vector<int>(3001));\n    vector<int>sub(3001);\n    vector<int>sum(17);\n    queue<int>falta;\n    cin>>a>>b>>c;\n    for(auto i=1; i<=b; i++){\n        for(auto j=0; j<c; j++){\n            cin>>num[i][j];\n        }\n    }\n    cin>>d;\n    while(d--){\n        cin>>e;\n        sum[e]++;\n    }\n    for(auto i=1; i<=b; i++){\n        if(sum[i]){\n            for(auto j=0; j<c; j++){\n                sub[num[i][j]]+=sum[i];\n            }\n        }\n    }\n    for(auto i=1; i<=a; i++){\n        if(sub[i]%2){\n            falta.push(i);\n        }\n    }\n    cout<<falta.size()<<\"\\n\";\n    while(falta.size()){\n        cout<<falta.front()<<\" \";\n        falta.pop();\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "8177. Aguas termales",
        "url": "https://omegaup.com/arena/problem/Aguas-termales/",
        "descripcion": "Después del último terremoto en la lejana región de Volcantepec, se descubrieron nuevas fuentes de aguas termales formando pequeñas lagunas en una región en que se pensaba construir un hotel ecológico. La noticia emocionó a los constructores, que decidieron utilizar las nuevas lagunas como parte de la arquitectura. Los ingenieros dividieron el sitio de construcción en una cuadrícula uniforme de manera que cada celda de la cuadrícula estuviera cubierta de agua o de tierra. La pregunta que debes contestar es la siguiente: Dada una fila y una columna de la celda, de qué tamaño es la laguna que la contiene. (El tamaño se mide por el número de celdas de agua contiguas. Las celdas diagonales se consideran contiguas.)",
        "entrada": "El primer renglón consiste en dós números enteros. El primer número entero representa la cantidad N e líneas que forman la cuadrícula. El segundo número representa la cantidad M celdas tiene cada línea. Las siguientes N líneas contienen una secuencia de M caracteres \"T\" y \"A\" donde la \"T\" representa que la celda está cubierta por tierra y la \"A\" representa que la celda está cubierta por agua. La última línea contiene dos números n m que representa la posición en fila y columna desde donde se medirá el lago.",
        "salida": "La frase \"El lago mide C celdas\" donde C es el área del lago.",
        "nivel": "Intermedio (difícil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Representación de grafos",
            "Conectividad en grafos",
            "Búsqueda en amplitud",
            "Colas",
            "Matrices",
            "Vectores"
        ],
        "estructuras": [
            "vector<vector<char>>",
            "vector<char>",
            "queue<pair<int, int>>",
            "pair<int, int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e = 0;\n    vector<vector<char>> num(1001, vector<char>(1001));\n    queue<pair<int, int>> falta;\n    pair<int, int> z;\n    cin >> a >> b;\n    for (auto i = 1; i <= a; i++)\n    {\n        for (auto j = 1; j <= b; j++)\n        {\n            cin >> num[i][j];\n        }\n    }\n    cin >> c >> d;\n    if (num[c][d] == 'A')\n    {\n        z.first = c;\n        z.second = d;\n        falta.push(z);\n        num[c][d] = 'T';\n        e++;\n    }\n    while (falta.size())\n    {\n        z = falta.front();\n        falta.pop();\n        z.first++;\n        if (num[z.first][z.second] == 'A')\n        {\n            e++;\n            falta.push(z);\n            num[z.first][z.second] = 'T';\n        }\n        z.first -= 2;\n        if (num[z.first][z.second] == 'A')\n        {\n            e++;\n            falta.push(z);\n            num[z.first][z.second] = 'T';\n        }\n        z.first++;\n        z.second++;\n        if (num[z.first][z.second] == 'A')\n        {\n            e++;\n            falta.push(z);\n            num[z.first][z.second] = 'T';\n        }\n        z.second -= 2;\n        if (num[z.first][z.second] == 'A')\n        {\n            e++;\n            falta.push(z);\n            num[z.first][z.second] = 'T';\n        }\n        z.second += 2;\n        z.first++;\n        if (num[z.first][z.second] == 'A')\n        {\n            e++;\n            falta.push(z);\n            num[z.first][z.second] = 'T';\n        }\n        z.first -= 2;\n        z.second -= 2;\n        if (num[z.first][z.second] == 'A')\n        {\n            e++;\n            falta.push(z);\n            num[z.first][z.second] = 'T';\n        }\n        z.first += 2;\n        if (num[z.first][z.second] == 'A')\n        {\n            e++;\n            falta.push(z);\n            num[z.first][z.second] = 'T';\n        }\n        z.first -= 2;\n        z.second += 2;\n        if (num[z.first][z.second] == 'A')\n        {\n            e++;\n            falta.push(z);\n            num[z.first][z.second] = 'T';\n        }\n    }\n    cout << \"El lago mide \" << e << \" celdas\";\n\n    return 0;\n}"
    },
    {
        "titulo": "7896. Comprando agua",
        "url": "https://omegaup.com/arena/problem/Comprando-agua/",
        "descripcion": "Después de un divertido taller de la OMIAGS te das cuenta que llevas 5 horas sin tomar agua. Como sabes lo importante que es mantenerse hidratado, decides llegar a la tienda más cercana para comprar una botella de agua. Al llegar, observas que existen N marcas de agua, todas de diferente precio. Puesto que tienes que pagar tu camión de regreso a casa, quieres aquirir el producto de menor precio.",
        "entrada": "Un entero N (0<N<=10000), indicando la cantidad de marcas disponibles, seguido de N enteros, todos distintos, indicando los precios. Considera que los precios de cada marca son positivos y menores que 100000",
        "salida": "Imprimir el precio de la botella que vas a adquirir, que tiene que ser la de menor costo.",
        "nivel": "Intermedio (fácil) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Ciclos",
            "Ordenamiento"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c;\n    cin >> a >> b;\n    a--;\n    while (a--)\n    {\n        cin >> c;\n        b = min(b, c);\n    }\n    cout << b;\n\n    return 0;\n}"
    },
    {
        "titulo": "4976. El agua y el aceite",
        "url": "https://omegaup.com/arena/problem/El-agua-y-el-aceite/",
        "descripcion": "El maestro Santiago odia ver los números pares e impares juntos así que le pidió a sus alumnos de informática que hicieran un programa que los separara.",
        "entrada": "Un número N (0<=N<=20) y abajo N números",
        "salida": "Los números N pares seguido de los números N impares",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Ciclos",
            "Colas"
        ],
        "estructuras": [
            "long long",
            "queue<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b;\n    queue<int> falta;\n    cin >> a;\n    while (a--)\n    {\n        cin >> b;\n        if (b % 2)\n        {\n            falta.push(b);\n        }\n        else\n        {\n            cout << b << \" \";\n        }\n    }\n    while (falta.size())\n    {\n        cout << falta.front() << \" \";\n        falta.pop();\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "1807. Las aguas de la muerte",
        "url": "https://omegaup.com/arena/problem/aguas/",
        "descripcion": "Una vez que Gilgamesh tuvo listos los remos que Urshanabí le solicitó, ellos emprendieron su viaje a través de las aguas de la muerte para visitar a Utanapíshtim y obtener el secreto de la vida eterna. Para atravesar las aguas de la muerte ellos deben recorrer una distancia de K kilómetros. La travesía es larga y Gilgamesh sólo puede remar cierta distancia D para luego tomar un descanso. A lo largo del camino existen algunas islas donde nuestro héroe puede descansar. El recorrido comienza en la coordenada 0 y termina en la coordenada K .Calcule el mínimo número de descansos que Gilgamesh debe tomar para llegar a su destino.",
        "entrada": "Tres enteros N, K y D que denotan el número de islas, la longitud del recorrido y la distancia que Gilgamesh puede remar sin descanso, seguidos de una línea con N enteros p_ique denotan las coordenadas de las N islas. Puede suponer que 1<=N<=100000, que p_(i-1) < p_i y que ( p_i - p_(i-1) <= D ) para todo 1<=i<=N+1",
        "salida": "Un entero que sea la menor cantidad de descansos que Gilgamesh tuvo que tomar.",
        "nivel": "Intermedio (medio) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Ciclos",
            "Búsqueda binaria",
            "Vectores"
        ],
        "estructuras": [
            "long long",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d = 0, e = 0, f = 0;\n    vector<int> num(100001);\n    cin >> a >> b >> c;\n    for (auto i = 0; i < a; i++)\n    {\n        cin >> num[i];\n    }\n    num[a] = b;\n    while (true)\n    {\n        e += c;\n        if (e >= b)\n        {\n            cout << f;\n            return 0;\n        }\n        for (d; d <= a; d++)\n        {\n            if (num[d] == e)\n            {\n                break;\n            }\n            else if (num[d] > e)\n            {\n                e = num[d - 1];\n                d--;\n                break;\n            }\n        }\n        f++;\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "8070. Mis quincenas se van como el agua",
        "url": "https://omegaup.com/arena/problem/Mis-quincenas-se-van-como-el-agu/",
        "descripcion": "En estos últimos meses me he percatado de que mis gastos mensuales han incrementado, por lo que he estado llevando el registro de los gastos diarios durante más de medio año. Me han contado que eres un excelente programador y con tu ayuda puedo encontrar ciertos patrones para modificar mi comportamiento económico, por el momento lo que me interesa es saber los 3 días consecutivos de la semana en los que he gastado más dinero durante todo el mes.",
        "entrada": "La primera linea contiene un entero N que representa el número de casos. 1 <= N <= 10 La segunda contiene un número y un string M y D. M es el número de días del mes (29, 30 o 31). D es el día de la semana en que inicia el mes (sin acentos); LUNES, MARTES, MIERCOLES, JUEVES, VIERNES. La siguiente linea contiene M números que representan el gasto diario.",
        "salida": "Imprime en una sola linea por caso en el formato día-A gasto, día-B gasto, día-C gasto",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores",
            "Caracteres y cadenas",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "vector<int>",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e, f = 0, g;\n    vector<int> num(32);\n    string z;\n    cin >> a;\n    while (a--)\n    {\n        cin >> b >> z;\n        d = 0;\n        e = 0;\n        if (z == \"LUNES\")\n        {\n            c = 1;\n        }\n        else if (z == \"MARTES\")\n        {\n            c = 2;\n        }\n        else if (z == \"MIERCOLES\")\n        {\n            c = 3;\n        }\n        else if (z == \"JUEVES\")\n        {\n            c = 4;\n        }\n        else if (z == \"VIERNES\")\n        {\n            c = 5;\n        }\n        else if (z == \"SABADO\")\n        {\n            c = 6;\n        }\n        else\n        {\n            c = 7;\n        }\n        for (auto i = 0; i < b; i++)\n        {\n            cin >> num[i];\n            d += num[i];\n            if (i >= 3)\n            {\n                d -= num[i - 3];\n            }\n            if (d > e)\n            {\n                e = d;\n                f = i;\n            }\n        }\n        g = f - 2;\n        f += c;\n        f -= 2;\n        f %= 7;\n        switch (f)\n        {\n        case 0:\n            cout << \"DOMINGO \";\n            break;\n        case 1:\n            cout << \"LUNES \";\n            break;\n        case 2:\n            cout << \"MARTES \";\n            break;\n        case 3:\n            cout << \"MIERCOLES \";\n            break;\n        case 4:\n            cout << \"JUEVES \";\n            break;\n        case 5:\n            cout << \"VIERNES \";\n            break;\n        case 6:\n            cout << \"SABADO \";\n            break;\n        }\n        cout << num[g] << \", \";\n        f++;\n        f %= 7;\n        g++;\n        switch (f)\n        {\n        case 0:\n            cout << \"DOMINGO \";\n            break;\n        case 1:\n            cout << \"LUNES \";\n            break;\n        case 2:\n            cout << \"MARTES \";\n            break;\n        case 3:\n            cout << \"MIERCOLES \";\n            break;\n        case 4:\n            cout << \"JUEVES \";\n            break;\n        case 5:\n            cout << \"VIERNES \";\n            break;\n        case 6:\n            cout << \"SABADO \";\n            break;\n        }\n        cout << num[g] << \", \";\n        f++;\n        f %= 7;\n        g++;\n        switch (f)\n        {\n        case 0:\n            cout << \"DOMINGO \";\n            break;\n        case 1:\n            cout << \"LUNES \";\n            break;\n        case 2:\n            cout << \"MARTES \";\n            break;\n        case 3:\n            cout << \"MIERCOLES \";\n            break;\n        case 4:\n            cout << \"JUEVES \";\n            break;\n        case 5:\n            cout << \"VIERNES \";\n            break;\n        case 6:\n            cout << \"SABADO \";\n            break;\n        }\n        cout << num[g] << \"\\n\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "5633. iOI 2009 Garage",
        "url": "https://omegaup.com/arena/problem/iOI-2009-Garage/",
        "descripcion": "Un estacionamiento de autos tiene N espacios de estacionamiento, numerados de 1 a N.  El estacionamiento abre vacío y opera de la siguiente manera a través del día. Siempre que llega un auto, el asistente verifica si hay algún espacio libre. Si no hay ninguno, entonces el auto espera en la entrada hasta que un espacio esté libre. Si un espacio está libre, o en cuanto uno se libere, el auto se estacionará en el espacio libre. Si hay más de un espacio libre, el auto se estacionará en el espacio libre con el número menor. Si llegan más autos mientras algún auto está esperando, todos ellos se alinean en una cola en la entrada en el orden en que ellos llegaron. Entonces, cuando un espacio se libere, el primer auto en la cola (es decir, el que llegó más temprano) se estacionará allí. El costo de estacionar, en dólares, corresponde al peso del auto en kilogramos multiplicado por el precio específico del espacio donde se estacionó. El costo no depende de cuánto tiempo se quede un auto en el estacionamiento. El operador del estacionamiento sabe que hoy vienen M autos y él sabe el orden de sus llegadas y salidas. Ayúdele a calcular cuántos dólares ganará el estacionamiento el día de hoy. Escriba un programa que, dado los precios específicos de los espacios de estacionamiento, los pesos de los autos y el orden en el cual los autos llegan y se van, determine la ganancia total del estacionamiento en dólares. Para un número de casos de prueba, que suman 40 puntos, siempre habrá un espacio de estacionamiento libre para cada auto que llegue. En estos casos ningún auto tendrá que esperar por un espacio de estacionamiento.",
        "entrada": "Considera que N (1<=N<=100) es el número de espacios de estacionamiento. M (1<=M<=2000) es e número de autos. R_s (1<=R_s<=100) es el precio por usar el espacio de estacionamiento s en dólares por kilogramo. W_k (1<=W_k<=10000) es el peso del auto K en kilogramos. La primera línea contiene los enteros N y M, separados por un espacio. Las próximas N líneas describen los precios de los espacios de estacionamiento. La s-ésima de estas líneas contiene un entero simple R_s , el precio del espacio de estacionamiento número s en dólares por kilogramo. Las próximas M líneas describen el peso de los autos. Los autos son numerados desde 1 hasta M inclusive sin ningún orden particular. La k-ésima de estas M líneas contiene un solo entero W_i, el peso del auto K en kilogramos. Las próximas 2M líneas describen la entrada y salida de todos los autos en orden cronológico. Un entero positivo i indica que el auto número i llega al estacionamiento. Un entero negativo -i  indica que el auto número i sale del estacionamiento. Los autos no saldrán del estacionamiento antes de llegar, y todos los autos desde 1 hasta M inclusive aparecerán exactamente dos veces en la secuencia, una para la llegada y otra para la salida. Además, ningún auto saldrá del estacionamiento si no ha estacionado en él (es decir, ningún auto saldrá mientras esté esperando en la cola). ",
        "salida": "Su programa debe escribir a la salida estándar una sola línea conteniendo un solo entero: el número total de dólares que ganará el estacionamiento el día hoy.",
        "nivel": "Avanzado (fácil) - Programación competitiva",
        "categorias": [
            "Implementación",
            "Vectores",
            "Colas",
            "Ciclos",
            "Ordenamiento"
        ],
        "estructuras": [
            "int",
            "long long",
            "vector<pair<int, int>>",
            "vector<int>",
            "queue<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool sum(int x, int y)\n{\n    if (x >= y)\n        return true;\n    return false;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c = 0, d, e, f, g = 0;\n    vector<pair<int, int>> num(101);\n    vector<pair<int, int>> sub(2001);\n    vector<int> falta;\n    queue<int> faltas;\n    cin >> a >> b;\n    for (auto i = 1; i <= a; i++)\n    {\n        cin >> num[i].first;\n        falta.push_back(i);\n    }\n    for (auto i = 1; i <= b; i++)\n    {\n        cin >> sub[i].first;\n    }\n    sort(falta.begin(), falta.end(), sum);\n    d = b * 2;\n    while (d--)\n    {\n        cin >> e;\n        if (e > 0)\n        {\n            if (falta.size() == 0)\n            {\n                faltas.push(e);\n                continue;\n            }\n            if (c)\n            {\n                sort(falta.begin(), falta.end(), sum);\n                c = 0;\n            }\n            f = falta[falta.size() - 1];\n            falta.pop_back();\n            num[f].second = 1;\n            g += (num[f].first * sub[e].first);\n            sub[e].second = f;\n        }\n        else\n        {\n            e = fabs(e);\n            if (faltas.size())\n            {\n                f = faltas.front();\n                faltas.pop();\n                g += (sub[f].first * num[sub[e].second].first);\n                sub[f].second = sub[e].second;\n            }\n            else\n            {\n                num[sub[e].second].second = 0;\n                falta.push_back(sub[e].second);\n                c = 1;\n            }\n        }\n    }\n    cout << g;\n\n    return 0;\n}"
    },
    {
        "titulo": "7783. Crucigrama",
        "url": "https://omegaup.com/arena/problem/Cruci/",
        "descripcion": "or semanas has estado resolviendo crucigramas. Ahora quieres ganar un poco de dinero vendiéndole crucigramas a los periódicos diarios de la región. Como no quieres perder tiempo haciéndolos a mano, vas a escribir un programa que los genere. Al programa le das 2 palabras: palabra A y palabra B. La palabra A la debe escribir horizontalmente, y la palabra B la debe escribir verticalmente; de tal manera que las palabras se puedan cruzar; esto es deben compartir exactamente una letra. La letra compartida debe ser la primera letra en A que aparece en B, mas preciso: debe ser la primera ocurrencia de la letra, en ambas palabras. Por ejemplo: dadas las palabras A = \"ABBA\" y B = \"CCBBD\", el programa debe generar, en este caso, las 5 líneas que se muestran en el ejemplo mas abajo.",
        "entrada": "La primera y única línea de entrada contiene dos palabras: A (1 <= longitud de A <= 30) y B (1 <= longitud de B <= 30); de no mas de 30 letras cada una, separadas por un solo espacio. Ambas palabras están escritas con letras mayúsculas del alfabeto español. En todos los casos habrá, al menos, una letra común en ambas palabras.",
        "salida": "Si la longitud de la palabra A es N, y la longitud de la palabra B es M. La salida deben ser M líneas con N caracteres cada linea. La figura que se forme con la salida debe contener a las 2 palabras cruzadas, como se describe en la explicación del problema (por eso se llama crucigrama). El resto de los caracteres, en cada línea, deben ser puntos (el carácter punto).",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Matrices",
            "Vectores",
            "Ciclos",
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "vector<vector<char>>",
            "vector<char>",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    vector<vector<char>> num(31, vector<char>(31));\n    string z, zz;\n    cin >> z >> zz;\n    for (auto i = 0; i < z.size(); i++)\n    {\n        for (auto j = 0; j < zz.size(); j++)\n        {\n            if (z[i] == zz[j])\n            {\n                for (auto k = 0; k < z.size(); k++)\n                {\n                    num[j][k] = z[k];\n                }\n                for (auto k = 0; k < zz.size(); k++)\n                {\n                    num[k][i] = zz[k];\n                }\n                for (auto k = 0; k < zz.size(); k++)\n                {\n                    for (auto r = 0; r < z.size(); r++)\n                    {\n                        if (num[k][r] == NULL)\n                        {\n                            num[k][r] = '.';\n                        }\n                        cout << num[k][r];\n                    }\n                    cout << \"\\n\";\n                }\n                return 0;\n            }\n        }\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "6384. Búsqueda de Patrones en Cadenas",
        "url": "https://omegaup.com/arena/problem/Busqueda-de-Patrones-en-Cadenas/",
        "descripcion": "El problema de reconocimiento de cadenas es encontrar todas las ocurrencias de un patrón dado P = p_1p_2…p_m en un texto amplio T = t_1t_2…t_n donde ambos, T y P son secuencias de caracteres a partir de un conjunto finito de caracteres. Dado las cadenas x, y y z, se dice que x es un prefijo de xy, un sufijo de yx y un factor de xyz Hay tres enfoques de búsqueda de patrones, para este problema se describe únicamente el método de búsqueda llamado “Búsqueda de Sufijos”. La búsqueda de sufijos, la cuál tiene una ventana de búsqueda del tamaño del patrón, es hecha hacia atrás a lo largo de la ventana de búsqueda considerando el sufijo más largo de la ventana que es también el sufijo del patrón. El algoritmo más famoso usando este método es el algoritmo Horspool, el cual se describe a continuación: Para cada posición de la ventana de búsqueda, se tiene que comparar su último carácter (simboloBeta en la figura)  con el último carácter del patrón. Si ellos son iguales, se verifica la ventana de búsqueda hacia atrás contra el patrón hasta que se encuentre el patrón completo o falle la igualación en un carácter (simboloSigma en la figura). Entonces, si hubo una coincidencia o no, se corre la ventana de acuerdo a la siguiente ocurrencia de la letra simboloBeta en el patrón.",
        "entrada": "La primera línea contiene el texto T, donde 1<=T<=100 palabras. La segunda línea contiene el patrón P, donde 1<=P<=25 caracteres.",
        "salida": "Imprimir la(s) posición(es) donde inicia(n) el/los patrón(es) en el texto. Nota: Usar \" _ \" para separar palabras. El programa debe aceptar las letras del alfabeto americano (minúsculas y mayúsculas) (no usar ñ ni acentos) y los 10 dígitos.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas",
            "Ciclos"
        ],
        "estructuras": [
            "string",
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    string z, zz;\n    long long a;\n    cin >> z >> zz;\n    for (auto i = 0; i <= z.size() - zz.size(); i++)\n    {\n        if (z[i] == zz[0])\n        {\n            a = 0;\n            for (auto j = 0; j < zz.size(); j++)\n            {\n                if (z[i + j] != zz[j])\n                {\n                    a = 1;\n                    break;\n                }\n            }\n            if (a == 0)\n            {\n                cout << i + 1 << \"\\n\";\n            }\n        }\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "5112. Los Patrones de Ralf",
        "url": "https://omegaup.com/arena/problem/The-Crazy-Del-Elevador/",
        "descripcion": "Ralf a averiado el elevador de un hotel. Tardaran una cantidad N de tiempo en llegar repararlo. Ralf se ha quedado observando el elevador y observa como se marca los pisos a los que va, bien, pues Ralf esta tan aburrido que en lo que arreglan el ascensor ha decidido anotar que pisos visita el elevador en su libreta. Al poco tiempo Ralf descubre que el elevador sigue un patrón, Ralf es un poco torpe y quiero encontrar el patrón mas corto por lo que hay que ayudarlo a encontrar el patrón mas chico.",
        "entrada": "En la primera linea un numero N (1<=N<=10000) que es la cantidad de tiempo que tardaran en arreglar el elevador, sabiendo que cada minuto que pasa es un piso que visita el elevador, seguido una cantidad M que denota la cantidad de pisos que hay en el hotel. En la siguiente linea los N_i (1<=N_i<=500) números que Ralf Anota en su libreta.",
        "salida": "El patrón mas pequeño.",
        "nivel": "Avanzado (fácil) - Programación competitiva",
        "categorias": [
            "Vectores",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c;\n    vector<int> num(10001);\n    vector<int> falta;\n    cin >> a >> b;\n    for (auto i = 1; i <= a; i++)\n    {\n        cin >> num[i];\n    }\n    b = num[1];\n    falta.push_back(num[1]);\n    for (auto i = 2; i <= a; i++)\n    {\n        if (num[i] != b)\n        {\n            while (falta.size() != i)\n            {\n                falta.push_back(num[falta.size() + 1]);\n            }\n        }\n        else\n        {\n            c = 0;\n            for (auto j = 0; j < falta.size(); j++)\n            {\n                if (i + j > a)\n                {\n                    for (auto k = 1; k <= a; k++)\n                    {\n                        cout << num[k] << \" \";\n                    }\n                    return 0;\n                }\n                else if (num[i + j] != falta[j])\n                {\n                    c = 1;\n                    break;\n                }\n            }\n            if (c)\n            {\n                while (falta.size() != i)\n                {\n                    falta.push_back(num[falta.size() + 1]);\n                }\n            }\n            else\n            {\n                i += falta.size();\n                i--;\n            }\n        }\n    }\n    for (auto k = 0; k < falta.size(); k++)\n    {\n        cout << falta[k] << \" \";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "3971. Patron",
        "url": "https://omegaup.com/arena/problem/patron/",
        "descripcion": "El malvado Jose ha vuelto a el benevolo Octavio malvado y solo tu puedes revertirlo! El malvado Jose utilizo un sistema muy complejo para torturar a cualquiera que se atreva a revertir el efecto malvado de Octavio. El utilizo un sistema de patrones. Si puedes decir si cadena de numeros tiene un patron o no, el efecto se rompera, pero, si dices que no tiene un patron, pero si tiene un patron o viceversa, el efecto se quedara asi para siempre... Escribe un problema que, dados 5 numeros separados por espacio, imprime SI, si tiene un patron, o NO si no tiene. El patron solo puede tener un cambio, por ejemplo +1 y **2*. Nunca puede tener un patron de **2+1*, por mencionar un ejemplo. Todos los casos estaran agrupados, lo que significa que con un caso erroneo, no se otorgaran puntos. Para este programa, habra 5 casos de prueba.",
        "entrada": "5  numeros, separados por espacio. Considera que los numeros varian entre 1 y 100",
        "salida": "Imprime SI o NO dependiendo de si hay un patron o no.",
        "nivel": "Básico (difícil) - Introducción a la programación",
        "categorias": [
            "Ciclos"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e, f;\n    cin >> a >> b >> c >> d >> e;\n    if (b > a)\n    {\n        f = b - a;\n        while (true)\n        {\n            if (c - b != f)\n            {\n                break;\n            }\n            if (d - c != f)\n            {\n                break;\n            }\n            if (e - d != f)\n            {\n                break;\n            }\n            cout << \"SI\";\n            return 0;\n        }\n        f = b / a;\n        while (true)\n        {\n            if (c / b != f)\n            {\n                break;\n            }\n            if (d / c != f)\n            {\n                break;\n            }\n            if (e / d != f)\n            {\n                break;\n            }\n            cout << \"SI\";\n            return 0;\n        }\n        cout << \"NO\";\n        return 0;\n    }\n    else\n    {\n        f = a - b;\n        while (true)\n        {\n            if (b - c != f)\n            {\n                break;\n            }\n            if (c - d != f)\n            {\n                break;\n            }\n            if (d - e != f)\n            {\n                break;\n            }\n            cout << \"SI\";\n            return 0;\n        }\n        f = a / b;\n        while (true)\n        {\n            if (b / c != f)\n            {\n                break;\n            }\n            if (c / d != f)\n            {\n                break;\n            }\n            if (d / e != f)\n            {\n                break;\n            }\n            cout << \"SI\";\n            return 0;\n        }\n        cout << \"NO\";\n        return 0;\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "1749. La muralla interminable de Humbaba",
        "url": "https://omegaup.com/arena/problem/muralla_humbaba/",
        "descripcion": "Gilgamesh y Enkidu han decidido ir en busca de una nueva aventura por lo que se proponen enfrentar a Humbaba, cuidador del bosque de los cedros. Sin embargo, para poder llegar a donde se esconde Humbaba deben encontrar la entrada a la muralla que rodea dicho bosque. Antes de encontrar la entrada a la muralla, Gilgamesh y Enkidu deben determinar la cantidad de muros que la forman. Para ello, se han dado cuenta de que cada muro de la muralla se encuentra pintado de color blanco o negro. Con esta información, nuestros héroes rodearon la muralla. Después de un rato, saben que han dado al menos una vuelta completa y que tienen el registro de los colores de cada muro que se vieron en su recorrido, pero no saben si terminaron en el mismo lugar donde iniciaron. Escribe un programa que determine la cantidad mínima de muros que puede tener la muralla.",
        "entrada": "Una cadena M. El caracter M_i es N si el color del muro visto es negro o B si es blanco. Puedes suponer que M tiene entre 1 y 100000 caracteres.",
        "salida": "Un entero que es la cantidad mínima de muros que puede tener la muralla",
        "nivel": "Avanzado (fácil) - Programación competitiva",
        "categorias": [
            "Caracteres y cadenas",
            "Vectores",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "vector<int>",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c;\n    vector<int> num(100001);\n    vector<int> falta;\n    string z;\n    cin >> z;\n    a = z.size();\n    for (auto i = 1; i <= a; i++)\n    {\n        if (z[i - 1] == 'B')\n        {\n            num[i] = 2;\n        }\n        else\n        {\n            num[i] = 1;\n        }\n    }\n    b = num[1];\n    falta.push_back(num[1]);\n    for (auto i = 2; i <= a; i++)\n    {\n        if (num[i] != b)\n        {\n            while (falta.size() != i)\n            {\n                falta.push_back(num[falta.size() + 1]);\n            }\n        }\n        else\n        {\n            c = 0;\n            for (auto j = 0; j < falta.size(); j++)\n            {\n                if (i + j > a)\n                {\n                    cout << falta.size();\n                    return 0;\n                }\n                else if (num[i + j] != falta[j])\n                {\n                    c = 1;\n                    break;\n                }\n            }\n            if (c)\n            {\n                while (falta.size() != i)\n                {\n                    falta.push_back(num[falta.size() + 1]);\n                }\n            }\n            else\n            {\n                i += falta.size();\n                i--;\n            }\n        }\n    }\n    cout << falta.size();\n\n    return 0;\n}"
    },
    {
        "titulo": "7954. Banqueros Injustos",
        "url": "https://omegaup.com/arena/problem/Banqueros-Injustos-/",
        "descripcion": "A un banco llegan clientes a depositar (D) y retirar (R), el banquero avaro le ha dado instrucciones a todos sus empleados de tomar los depósitos de inmediato. Sin embargo, ningún empleado debe atender una operación de retiro si no hasta que el banquero de la orden de atender (A). Una vez dada la orden, los retiros se atienden mientras haya dinero suficiente para atenderlos. El dinero que el banco tiene disponible para atender los retiros viene todo de los depósitos. Los retiros se atienden en orden estricto de menor a mayor. El banco permanece en operaciones hasta que se encuentra la instrucción específica de fin de operaciones (F). Por ejemplo, suponga que al inicio de operaciones, llegan al banco una solicitud de depósito por $20, seguida de una solicitud de retiro por $30 y luego la instrucción de atender los retiros (D 20 R 30 A). En este caso, los empleados no podrán darle al cliente sus $30 porque el dinero disponible ($20) no es suficiente para atender la petición de retiro ($30). Veamos el siguiente otro caso, al inicio de operaciones, llegan al banco un depósito por $10, un retiro por $25, un depósito de $20, un retiro de $15 y luego la orden de atender los retiros (D 10 R 25 D 20 R 15 A). En este caso, se atenderá solamente el retiro de $15 pues los retiros pendientes se atienden de menor y mayor y solo mientras haya dinero suficiente. En este caso, después de atender el retiro por $15, el banco solo tiene disponibles $15, que es menor que el monto del retiro restante de $25. Se pide escribir un programa que lea todas estas solicitudes e imprima el orden en el que se atienden los retiros. Al final de operaciones del banco, se imprime el saldo disponible y la suma de los retiros que quedaron pendientes de atender. Notas La letra A indica que es tiempo de atender los retiros posibles La letra F indica el final de operaciones del banco. Considera que el número total de operaciones nunca será mayor a 1,000,000, los montos de depósito y retiro siempre se expresan como números enteros positivos y los montos de depósito y retiro serán siempre menores a 10,000",
        "entrada": "Todas las solicitudes mencionadas.",
        "salida": "Una impresión de el orden en el que se atienden los retiros. Al final de operaciones del banco, se imprime el saldo disponible y la suma de los retiros que quedaron pendientes de atender.",
        "nivel": "Intermedio (medio) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Ciclos",
            "Vectores",
            "Ordenamiento"
        ],
        "estructuras": [
            "int",
            "long long",
            "vector<int>",
            "char"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool num(int x, int y)\n{\n    if (x >= y)\n        return true;\n    return false;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a = 0, b;\n    vector<int> falta;\n    char z;\n    cin >> z;\n    while (z != 'F')\n    {\n        if (z == 'A')\n        {\n            sort(falta.begin(), falta.end(), num);\n            while (falta.size() && falta[falta.size() - 1] <= a)\n            {\n                cout << falta[falta.size() - 1] << \"\\n\";\n                a -= falta[falta.size() - 1];\n                falta.pop_back();\n            }\n        }\n        else if (z == 'D')\n        {\n            cin >> b;\n            a += b;\n        }\n        else\n        {\n            cin >> b;\n            falta.push_back(b);\n        }\n        cin >> z;\n    }\n    cout << a << \"\\n\";\n    a = 0;\n    while (falta.size())\n    {\n        a += falta[falta.size() - 1];\n        falta.pop_back();\n    }\n    cout << a;\n\n    return 0;\n}"
    },
    {
        "titulo": "4389. Construccion de un Triángulo",
        "url": "https://omegaup.com/arena/problem/DRMIGTriangulo/",
        "descripcion": "Un triángulo es construído con tres líneas rectas, que forman sus lados. Pero no cualquier conjunto de tres líneas puede formar un triángulo. Dadas las longitudes de tres líneas rectas, determinar si es posible formar un triángulo con ellas.",
        "entrada": "Tres entradas que representan cada una un número decimal. Cada número corresponde a la longitud de una línea recta.",
        "salida": "La palabra \"SI\" si se puede formar un triángulo con esos tres lados o la palabra \"NO\" si no es posible formarlo.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Cálculos aritméticos"
        ],
        "estructuras": [
            "long double"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long double a, b, c;\n    cin >> a >> b >> c;\n    if (b > a)\n    {\n        swap(a, b);\n    }\n    if (c > a)\n    {\n        swap(a, c);\n    }\n    if (c > b)\n    {\n        swap(c, b);\n    }\n    if (b + c <= a)\n    {\n        cout << \"NO\";\n        return 0;\n    }\n    cout << \"SI\";\n\n    return 0;\n}"
    },
    {
        "titulo": "4330. DRMIGCriba",
        "url": "https://omegaup.com/arena/problem/DRMIGCriba/",
        "descripcion": "Imprimir una tabla de unos y ceros correspondiente a la criba de Eratóstenes, donde cada línea tiene 10 dígitos correspondientes a la decena adecuada, separados por espacio. La primera línea contine la criba del 0 al 9. La segunda línea del 10 al 19, etcétera. El 1 corresponde a no ser primo, y el 0 corresponde a sí ser primo.",
        "entrada": "Un número entero positivo múltiplo de 10 mayor a 10 y menor a 1000",
        "salida": "La impresión de la tabla.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores",
            "Ciclos"
        ],
        "estructuras": [
            "vector<int>",
            "long double"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong double a;\nvector<int> num = {1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1};\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    cin >> a;\n    for (auto i = 0; i < a / 10; i++)\n    {\n        for (auto j = 0; j < 10; j++)\n        {\n            cout << num[(i * 10) + j] << \" \";\n        }\n        cout << \"\\n\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "5830. Determina carácter",
        "url": "https://omegaup.com/arena/problem/Determina-caracter/",
        "descripcion": "Hacer un programa que reciba un carácter, diga si es una letra mayúscula(ASCII del 65 al 90), una letra minúscula (ASCII del 97 al 122),o bien otro carácter.",
        "entrada": "Un carácter.",
        "salida": "Si es mayúscula imprimir MAYUSCULA, si es minúscula imprimir MINUSCULA, si no es una letra imprimir OTRO.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "char"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    ;\n    char z;\n    cin >> z;\n    if (z >= 'a' && z <= 'z')\n    {\n        cout << \"MINUSCULA\";\n    }\n    else if (z >= 'A' && z <= 'Z')\n    {\n        cout << \"MAYUSCULA\";\n    }\n    else\n    {\n        cout << \"OTRO\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "6982. Metros de Carretera",
        "url": "https://omegaup.com/arena/problem/Metros-de-Carretera/",
        "descripcion": "Tu buen amigo Rany ha conseguido un nuevo empleo, este consiste en pintar una carretera, pero Rany como ya es costumbre pinta de una manera muy rara. Su manera de pintar se consiste en pintar 1 metro de carretera el día 1, pintar 2 metros desde el punto anterior el día 2, pintar 3 metros el día 3, así hasta pintar k metros más en el día k. A Rany le pagarán por día pero el distraído de tu amigo olvidó cuantos días trabajo, lo único que recuerda son los N metros totales que pinto. Ayudalo a averiguar cuantos días trabajo con base a los N metros que pinto.",
        "entrada": "Un único entero N representando los metros totales que pinto. (1<=N<6*10^9)",
        "salida": "La cantidad de días que Rany trabajo.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "long long",
            "sqrt()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c;\n    cin>>a;\n    b=sqrt(a*2)-1;\n    while(true){\n        c=((b+1)*b)/2;\n        if(a==c){\n            cout<<b;return 0;\n        }\n        b++;\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "4348. Perímetro de asteriscos",
        "url": "https://omegaup.com/arena/problem/RECT_PERIM_ASTERISCOS/",
        "descripcion": "Escribe un programa que permita desplegar un rectángulo que consista de un perímetro formado por asteriscos. El rectángulo mide h asteriscos de alto y w asteriscos de ancho. Por ejemplo, el siguiente rectángulo tiene estas medidas: h=5 y w=10. Es importante notar lo siguiente: Los asteriscos de las dos líneas horizontales están separados entre sí por un espacio en blanco. El área central del rectángulo está compuesto únicamente de espacios en blanco. No debe haber espacios en blanco al final de cualquiera de los renglones. En otras palabras, el último carácter antes de cada salto de línea debe ser un asterisco. Tengan mucho cuidado con este punto pues es muy fácil pasarlo por alto ya que es algo que no es visible a simple vista.",
        "entrada": "La entrada consiste de dos líneas. La primera línea es el entero h, y la segunda línea es el entero w. (1<=h<=100), (1<=w<=100)",
        "salida": "La salida consiste del rectángulo correspondiente.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Ciclos"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b;\n    cin>>a>>b;\n    for(auto i=0; i<a; i++){\n        for(auto j=0; j<b; j++){\n            if(i==0 || j==0 || i==a-1 || j==b-1){\n                cout<<\"*\";\n            }\n            else{\n                cout<<\" \";\n            }\n            if(j!=b-1){\n                cout<<\" \";\n            }\n        }\n        cout<<\"\\n\";\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "8309. Perímetro de poligono",
        "url": "https://omegaup.com/arena/problem/Perimetro-de-poligono/",
        "descripcion": "Un ingeniero está tratando de calcular el perímetro de una figura de múltiples lados y desea que le ayudemos creando un programa para dicha tarea. El desea que el programa pueda leer múltiples números que representan la longitud de cada uno de los lados y terminar con un cero. Sin embargo, el teclado de su computadora está fallando y de vez en cuanto escribe - (signos negativos, convenientemente solo antes de escribir números). El ingeniero desea que el programa está preparado para estos errores y corrija dichos números negativos.",
        "entrada": "La entrada tendrá varios numeros enteros positivos y negativos, siendo el último un cero. La cantidad de números será menor a 100. Los números serán enteros positivos y negativos.",
        "salida": "La salida será el valor de la suma de los lados de la figura, cambiando los valores negativos a positivos.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Ciclos",
            "Aritmética"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b=0;\n    cin>>a;\n    while(a){\n        b+=fabs(a);\n        cin>>a;\n    }\n    cout<<b;\n    \n    return 0;\n}"
    },
    {
        "titulo": "6269. El calendario de la cuenta larga",
        "url": "https://omegaup.com/arena/problem/Calendario-cuenta-larga/",
        "descripcion": "Los mayas usaban tres calendarios, pero en este ejercicio nos concentraremos solamente en el calendario choltún, o calendario de la cuenta larga. En éste, un día se llama kin, 20 kines forman un uinal, 18 uinales forman un tun, 20 tunes forman un katún y 20 katunes forman un baktún (también existen periodos de tiempo más grandes, pero no nos ocuparemos de ellos). Una fecha se especifica como el número b de baktunes, seguido del número k de katunes, el número t de tunes, el número u de uinales y el número d de kines ocurridos a partir de una fecha inicial llamada 0.0.0.0.0 que corresponde al 11 de agosto del año 3113 antes de nuestra era, según el calendario gregoriano. Si sabemos el número n de días transcurridos a partir de esa fecha, se puede calcular fácilmente la fecha correspondiente del calendario choltún. Por ejemplo, si han transcurrido 314 159 265 días a partir de la fecha inicial, entonces la fecha correspondiente es 2181.13.4.11.5, es decir b=2181, k=13, t =4, u=11, d=5.",
        "entrada": "Consiste de un número entero n que tendrá un valor entre 0 y 2 000 000 000.",
        "salida": "Consiste de cinco números enteros, b, k, t, u, d, separados por espacios.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Aritmética"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e;\n    cin>>a;\n    b=a%20;\n    a/=20;\n    c=a%18;\n    a/=18;\n    d=a%20;\n    a/=20;\n    e=a%20;\n    a/=20;\n    cout<<a<<\" \"<<e<<\" \"<<d<<\" \"<<c<<\" \"<<b;\n    \n    return 0;\n}"
    },
    {
        "titulo": "1101. Nutrientes",
        "url": "https://omegaup.com/arena/problem/Nutrientes/",
        "descripcion": "Existe cierto árbol que a diferencia de los árboles comunes, que nutren sus hojas y tallos a través de su raiz, éste nutre su raíz con los nutrientes que sus hojas recogen del medio ambiente. Dicho árbol nace de una forma muy particular, exactamente igual que como se construye un árbol binario de búsqueda. inicialmente hay un brote que será la raiz del árbol, enseguida, suceden brotes secuencialmente de tamaño Ti y buscan su lugar en el árbol de acuerdo a su tamaño (tal como se inserta en un ABB). . Cada brote i, nace con Gi nutrientes. Una vez que el árbol termina de crecer, Empieza el proceso de nutrir desde las hojas hacia la raiz. Una raiz solo se nutre de aquella hoja o rama que tenga la mayor cantidad de nutrientes. Dada la descripción de crecimiento del árbol y los nutrientes de cada brote, escribe un programa que calcule el máximo de nutrientes que recibe la raiz.",
        "entrada": "En la primera línea un entero N que representa la cantidad brotes. En cada una de las siguientes N líneas, los enteros T y G que representan el tamaño del brote y la cantidad de nutrientes que tiene, respectivamente. Puedes estar seguro que nunca habrá dos brotes del mismo tamaño. (1 <= N <=1000 1 <= Ti<= 1000 1 <= Gi <= 100).",
        "salida": "Un entero seguido de un salto de línea que indique el máximo número de nutrientes que la raiz puede absorber. Explicación de la salida: Con la descripción de la entrada se construye el siguiente árbol. El máximo de nutrientes se logra a partir de la hoja de tamaño 6 que nutre a su raiz con 10 nutrientes, de tal manera que la raiz de tamaño 7 tendrá 18 nutrientes (los suyos mas los de su hoja con más nutrientes 10+8) . Este nodo a su vez, nutre a su raiz con 18 nutrientes de tal manera que la raiz del arbol tendrá finalmente 20 nutrientes. Existen otras maneras de nutrir a la raiz, sin embargo, la descrita proporciona la máxima cantidad de nutrientes.",
        "nivel": "Avanzado (medio) - Programación competitiva",
        "categorias": [
            "Recorrido de árboles",
            "Árbol de búsqueda binaria",
            "Recursión"
        ],
        "estructuras": [
            "int",
            "long long"
        ],
        "codigo": "\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct sobra{\n    int aa, bb, cc, dd;\n};\nsobra num[1001];\n\nint sub(int x){\n    int y=0;\n    if(num[x].bb!=-1){\n        y=sub(num[x].bb);\n    }\n    if(num[x].cc!=-1){\n        y=max(y,sub(num[x].cc));\n    }\n    return y+num[x].dd;\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b;\n    cin>>a>>num[0].aa>>num[0].dd;\n    num[0].bb=-1;\n    num[0].cc=-1;\n    for(auto i=1; i<a; i++){\n        cin>>num[i].aa>>num[i].dd;\n        b=0;\n        num[i].bb=-1;\n        num[i].cc=-1;\n        while(true){\n            if(num[i].aa>num[b].aa && num[b].cc==-1){\n                num[b].cc=i;break;\n            }\n            else if(num[i].aa>num[b].aa){\n                b=num[b].cc;\n            }\n            else if(num[i].aa<num[b].aa && num[b].bb==-1){\n                num[b].bb=i;break;\n            }\n            else{\n                b=num[b].bb;\n            }\n        }\n    }\n    cout<<sub(0);\n    \n    return 0;\n}"
    },
    {
        "titulo": "7050. Cálculos condicionales",
        "url": "https://omegaup.com/arena/problem/Calculos-condicionales/",
        "descripcion": "Eres muy bueno evaluando fórmulas y realizando cálculos directos, pero te cuesta trabajo decidir en qué situaciones se deben hacer qué operaciones. Un compañero te sugirió un ejercicio de cálculo mental que consiste en, dado un número inicial N, realizar las siguientes operaciones en el orden indicado y con aritmética entera: 1.Si el valor actual de N es par, divídelo entre 2. En caso contrario, súmale 1. 2.Si el valor actual de N tiene tres o más cifras, divídelo entre 100. Pero si tiene exactamente dos cifras, divídelo entre 10. 3.Si el valor actual de N es un múltiplo de tres, réstale uno. Escribe un programa que te ayude a calcular el valor final de N y el número de veces que N fue modificado.",
        "entrada": "Un entero N. Puedes suponer que 1<=N<=1000.",
        "salida": "Dos enteros que correspondan con el valor final de N y el número de veces que N fue modificado respectivamente.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Aritmética",
            "Condicionales"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a=1, b=1;\n    cin>>a;\n    if(a%2){\n        a++;\n    }\n    else{\n        a/=2;\n    }\n    if(a>=100){\n        a/=100;\n        b++;\n    }\n    else if(a>=10){\n        a/=10;\n        b++;\n    }\n    if(a%3==0){\n        a--;\n        b++;\n    }\n    cout<<a<<\" \"<<b;\n    \n    return 0;\n}"
    },
    {
        "titulo": "7107. Cálculos iterativos",
        "url": "https://omegaup.com/arena/problem/Calculos-iterativos/",
        "descripcion": "Dado un entero N con valor inicial 0, modifícalo realizando los siguientes pasos en el orden indicado: Súmale al valor actual de N todos los números impares que existen de 1 a A. Réstale al valor actual de N todas las potencias de 2 que existen de 1 a B. Si el valor actual de N es un múltiplo de C, divídelo entre C hasta que deje de serlo.",
        "entrada": "Tres enteros A, B, C. Puedes suponer que 2<=A,B,C<=1000.",
        "salida": "Un entero que sea el valor final de N.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Aritmética",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "pow()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d;\n    cin>>a>>b>>c;\n    if(a%2){\n        a++;\n    }\n    d=pow(a/2,2);\n    while(e<=b){\n        d-=e;\n        e*=2;\n    }\n    while(d%c==0){\n        d/=c;\n    }\n    cout<<d;\n    \n    return 0;\n}"
    },
    {
        "titulo": "7001. Cálculos mentales competitivos",
        "url": "https://omegaup.com/arena/problem/Calculos-mentales-competitivos/",
        "descripcion": "Tu mejor amigo y tú siempre sacan la mejor calificación en matemáticas (y además acaban los exámenes al mismo tiempo), por lo que siempre han tenido la duda de quién es el mejor haciendo cálculos. Un día, un compañero de ambos los retó a que jugaran un reto de cálculo mental; el que lo resolviera primero sería el mejor en matemáticas de la escuela. El reto consiste en, dado un número inicial R: Calcular el resultado de R+5. Al resultado anterior, elevarlo al cuadrado. Al resultado anterior, dividirlo entre un tercio del número original R. Al resultado anterior, elevarlo al cubo. Como el título de ser el mejor de matemáticas en la escuela es sumamente importante, tendrás un día para practicar. Escribe un programa que te ayude a verificar los resultados que vas realizando a cada paso.",
        "entrada": "Un real R. Puedes suponer que (1<=R<=20).",
        "salida": "Cinco reales separados por espacios, donde el primer real es el número original y los siguientes cuatro son los resultados obtenidos después de aplicar cada paso en sucesión. Tu programa se considerará correcto si los valores calculados son razonablemente cercanos a las respuestas exactas.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Aritmética",
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "string",
            "getline()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    string z;\n    getline(cin,z);\n    for(auto i=z.size()-1; i>=0; i--){\n        cout<<z[i];\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "8671. Cálculo de la mediana",
        "url": "https://omegaup.com/arena/problem/Calculo-de-la-mediana/",
        "descripcion": "Escribe un programa que lea una secuencia de N enteros distintos A = a_0,a_1,...,a_(n-1) y que determine el valor de la mediana de A así como su índice.",
        "entrada": "Un entero N seguido de los N enteros de A. Puedes suponer que N es impar y menor que 10^5.",
        "salida": "Dos enteros que sean el valor de la mediana de A y su índice.",
        "nivel": "Intermedio (fácil) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Vectores",
            "Ciclos",
            "Ordenamiento"
        ],
        "estructuras": [
            "long long",
            "vector<pair<int,int>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a;\n    vector<pair<int,int>>num(100001);\n    cin>>a;\n    for(auto i=0; i<a; i++){\n        cin>>num[i].first;\n        num[i].second=i;\n    }\n    sort(num,num+a);\n    cout<<num[a/2].first<<\" \"<<num[a/2].second;\n    \n    return 0;\n}"
    },
    {
        "titulo": "8672. Sumando con pilas",
        "url": "https://omegaup.com/arena/problem/Sumando-con-pilas/",
        "descripcion": "Escribe un programa que comience con una pila P de enteros inicialmente vacía y que ejecute una lista de las siguientes operaciones: AGREGA v: Agregar a P. Por ejemplo, si P=(3,1,4) y v = 5 entonces P = (3,1,4,5). CONSUME: Quitar los dos últimos elementos de P, calcular su suma y agregarla a P. Por ejemplo, si P=(3,1,4) entonces P=(3,5). IMPRIME: Imprimir el último elemento de P. Por ejemplo, si P=(3,1,4) entonces se debe imprimir 4.",
        "entrada": "Un entero N seguido de las N operaciones a realizar sobre P. Puedes suponer que (0<=N<=10^5) y que nunca se pedirá consumir o imprimir un elemento que no existe.",
        "salida": "Cada para operación de impresión, el valor del entero correspondiente.",
        "nivel": "Intermedio (fácil) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Aritmética",
            "Ciclos",
            "Pilas",
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "long long",
            "stack<int>",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b;\n    stack<int>falta;\n    string z;\n    cin>>a;\n    while(a--){\n        cin>>z;\n        if(z==\"AGREGA\"){\n            cin>>b;\n            falta.push(b);\n        }\n        else if(z==\"CONSUME\"){\n            b=falta.top();\n            falta.pop();\n            falta.top()+=b;\n        }\n        else{\n            cout<<falta.top()<<\"\\n\";\n        }\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "8673. Nodos alcanzables",
        "url": "https://omegaup.com/arena/problem/Nodos-alcanzables/",
        "descripcion": "Dados N nodos numerados del 0 al N-1 donde cada uno tiene un enlace a su siguiente nodo, escribe un programa que determine si existe una forma de llegar del nodo 0 al nodo N-1.",
        "entrada": "Dos enteros N, M seguidos de M parejas de enteros X, Y que denotan un enlace del nodo X al Y. Pueden existir nodos que no tengan un nodo siguiente. Puedes suponer que (1<=M<=N<=100).",
        "salida": "El valor 1 si existe una forma de llegar del nodo 0 al N-1 y el valor 0 en otro caso.",
        "nivel": "Intermedio (fácil) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Listas ligadas",
            "Vectores",
            "Colas",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "vector<struct>",
            "queue<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct sobra{\n        int aa, bb, cc;\n    };\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d;\n    vector<sobra>num(101);\n    queue<int>falta;\n    cin>>a>>b;\n    a--;\n    for(auto i=0; i<b; i++){\n        cin>>num[i].aa>>num[i].bb;\n        if(num[i].aa==0){\n            if(num[i].bb==a){\n                a=-1;\n            }\n            else{\n                c=num[i].bb;\n                falta.push(c);\n            }\n            num[i].cc=1;\n        }\n    }\n    if(a==-1){\n        cout<<\"1\";return 0;\n    }\n    while(falta.size()){\n        c=falta.size();\n        falta.pop();\n        for(auto i=0; i<b; i++){\n            if(num[i].aa==c && num[i].cc==0){\n                if(num[i].bb==a){\n                    cout<<\"1\";return 0;\n                }\n                d=num[i].bb;\n                falta.push(d);\n                num[i].cc=1;\n            }\n        }\n    }\n    cout<<\"0\";\n    \n    return 0;\n}"
    },
    {
        "titulo": "910. L-OMI2011-La guardia negra",
        "url": "https://omegaup.com/arena/problem/L-OMI2011-La-guardia-negra/",
        "descripcion": "Según la canción del fuego y el hielo, la guardia de los centinelas negros ha defendido al reino de Westeros de las amenazas del norte durante los últimos 8,000 años. A últimas fechas un gran número de huestes enemigas se ha venido concentrando en la frontera norte de Westeros. El comandante de la guardia, Lord Snow, ha mandado llamar por ti para que le ayudes a planear la defensa. La guardia tiene representado el campamento enemigo como una cuadrícula de M filas por N columnas, en cada casilla de la cuadrícula hay un número s_{i,j} que representa la cantidad de soldados enemigos en esa casilla. La guardia cuenta con una catapulta capaz de lanzar un proyectil explosivo a cualquier lugar de esta cuadrícula. Al explotar, el proyectil eliminará a todos los soldados enemigos que se encuentren a una distancia menor o igual a un número d_i que depende del proyectil en cuestión. La distancia entre dos casillas se define como la suma del valor absoluto de la diferencia de sus columnas mas el valor absoluto de la diferencia de sus filas. El comandante de la guardia quiere que desarrolles un programa para calcular la cantidad de soldados que eliminaría un proyectil específico si fuera lanzado en una cierta casilla. Escribe un programa que dada la cuadrícula del campamento, el número de soldados en cada casilla, el número de proyectiles, la distancia de alcance de cada uno y el lugar donde quieres lanzarlo, calcule el número de enemigos que serán eliminados con cada proyectil.",
        "entrada": "Tu programa debe leer del teclado la siguiente información: En la primer línea los números M y N que representan el número de filas y columnas del campamento. En cada una de las siguientes M líneas hay N números enteros (s_{i,j}) separados por un espacio que representan los soldados en cada casilla del campamento. En la siguiente línea el número P de proyectiles que tiene la guardia. En las últimas P líneas hay 3 enteros separados por espacios en cada una que representan la fila y columna donde se lanzará un proyectil y la distancia de alcance del mismo. Tanto las filas como las columnas inician numeradas a partir del 0 y hasta M-1 y N-1 respectivamente. La fila 0 es la fila superior y la columna 0 es la columna hasta la izquierda. Puedes estar seguro de que los proyectiles serán lanzados de tal forma que su alcance no exceda el campamento, es decir, ninguna explosión llegará a una casilla que este fuera de la cuadrícula. (1<=M,N<= 1000), (0<=s_{i,j}<=1000000000), (1<=P<=100000), (0<=di<=500), Para este problema los casos de prueba se agruparán en 3 grupos distintos. Para obtener los puntos de un grupo es necesario que tu programa resuelva correctamente TODOS los casos de ese grupo, de otra forma obtendrás 0 puntos por ese grupo aun cuando hayas resuelto correctamente algunos de los casos. RESTRICCIONES ESPECIALES PARA EL GRUPO 1 (Valor del grupo, 25 puntos): (1<=M, N<=100, 1<=P<=100,0<=s_{i,j}<=10^5 y 0<=di<=50). RESTRICCIONES ESPECIALES PARA EL GRUPO 2 (Valor del grupo, 50 puntos): (1<=M,N<=10^3, 1<=P<=10^3, 0<=s_{i,j}<=10^6 y 0<=di <=500). RESTRICCIONES ESPECIALES PARA EL GRUPO 3 (Valor del grupo, 25 puntos): Las restricciones para el grupo 3 son las especificadas en la primera sección de límites. ",
        "salida": "Tu programa deberá escribir a la pantalla P líneas con un número cada una. La i-ésima línea debe contener la cantidad de enemigos que serían eliminados al lanzar el proyectil i.",
        "nivel": "Avanzado (fácil) - Programación competitiva",
        "categorias": [
            "Matrices",
            "Suma de prefijos",
            "Cálculo matemático"
        ],
        "estructuras": [
            "long long",
            "vector<vector<int>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e, f, g, h;\n    vector<vector<int>>num(1001,vector<int>(1001,0));\n    cin>>a>>b;\n    for(auto i=1; i<=a; i++){\n        for(auto j=1; j<=b; j++){\n            cin>>num[i][j];\n            num[i][j]+=num[i][j-1];\n        }\n    }\n    cin>>c;\n    while(c--){\n        cin>>d>>e>>f;\n        d++;\n        e++;\n        g=num[d][e+f]-num[d][(e-f)-1];\n        h=1;\n        f--;\n        while(f>=0){\n            g+=(num[d-h][e+f]-num[d-h][(e-f)-1]);\n            g+=(num[d+h][e+f]-num[d+h][(e-f)-1]);\n            f--;\n            h++;\n        }\n        cout<<g<<\"\\n\";\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "5837. Diario de tu hermano",
        "url": "https://omegaup.com/arena/problem/Diario-de-tu-hermano/",
        "descripcion": "Has encontrado el diario de tu hermano y quieres revelar sus oscuros secretos a sus amigos pero tienes un problema: ¡todo el diario está al revés! Para poder leerlo (y mostrárselo a sus amigos) necesitas voltear todos los caracteres que se encuentran en el diario.",
        "entrada": "Un string S que representa el diario de tu hermano.",
        "salida": "Un string Z que representa el diario volteado de tu hermano.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "getline()",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    string z;\n    getline(cin,z);\n    for(int i=z.size()-1; i>-1; i--){\n        cout<<z[i];\n    }\n    \n    return 0;\n"
    },
    {
        "titulo": "423. Dos Veces",
        "url": "https://omegaup.com/arena/problem/Formateando-las-letras/",
        "descripcion": "Meta: Leer una línea con caracteres tanto de minúsculas como de mayúsculas e imprimirlos dos veces, una con todo cambiado a mayúsculas y otro con todo convertido a minúsculas. En ocasiones es deseable poder transformar un texto a mayúsculas o también a minúsculas. En este ejercicio haremos eso.",
        "entrada": "Vas a leer por líneas hasta que se llegue al fin de archivo.",
        "salida": "Por cada línea que leas, debes imprimirla dos veces. La primera formateando todas las letras a mayúsculas y en la otra todas a minúsculas.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Ciclos",
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "string",
            "getline()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    string z;\n    while(getline(cin,z)){\n        for(auto i=0; i<z.size(); i++){\n            if(z[i]>='a' && z[i]<='z'){\n                z[i]-=32;\n            }\n            cout<<z[i];\n        }\n        cout<<\"\\n\";\n        for(auto i=0; i<z.size(); i++){\n            if(z[i]>='A' && z[i]<='Z'){\n                z[i]+=32;\n            }\n            cout<<z[i];\n        }\n        cout<<\"\\n\";\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "7066. El tablero en forma de dona",
        "url": "https://omegaup.com/arena/problem/El-tablero-en-forma-de-dona/",
        "descripcion": "Después de jugar un juego de ajedrez con uno de tus amigos se te ocurrió una idea extraña. ¿Qué sucedería si pudieras enrollar el tablero de manera que los bordes del tablero estuvieran conectados?. Es decir el borde izquierdo estaría conectado con el borde derecho y el borde superior estaría conectado con el borde inferior. !El resultado sería un tablero de ajedrez en forma de dona! Cualquier pieza que se moviera más alla de alguno de los bordes del tablero acabaría por pasar al borde opuesto. Esto debería ocurrir incluso si el tablero fuera más pequeño o más grande de lo normal. Para probar tu idea tomaste una hoja de papel y dibujaste un tablero de ajedrez asignando una coordenada a cada casilla, empezando por la esquina superior izquierda a la que le asignaste la coordenada (0, 0). Una vez hecho esto enrollaste el tablero para dejarlo en forma de dona y ver que sucedía con el movimiento de una pieza.",
        "entrada": "Seis enteros W, H, X, Y, R, S que denotan el ancho W y alto H del tablero, la coordenada inicial (X,Y) de la pieza, el número de casillas R que la pieza se mueve de manera horizontal y el número de casillas S que se mueve de manera vertical. Puedes asumir que (1<=W, H<=10, X<=W, Y<=H) y que (-20<=R, S<=20). Asuma que la pieza se mueve primero en la dirección horizontal y después en la dirección vertical.",
        "salida": "Dos enteros que represental las coordenadas finales de la pieza.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Aritmética",
            "Ciclos"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e, f;\n    cin>>a>>b>>c>>d>>e>>f;\n    c+=e;\n    d+=f;\n    if(a!=1){\n        c%=a;\n    }\n    else{\n        c=0;\n    }\n    if(b!=1){\n        d%=b;\n    }\n    else{\n        d=0;\n    }\n    if(c<0){\n        c=a+c;\n    }\n    if(d<0){\n        d=b+d;\n    }\n    cout<<c<<\" \"<<d;\n    \n    return 0;\n}"
    },
    {
        "titulo": "7002. Evaluando fórmulas en sucesión",
        "url": "https://omegaup.com/arena/problem/Evaluando-formulas-en-sucesion/",
        "descripcion": "Cada vez eres mejor en matemáticas y ahora estás practicando con múltiples fórmulas en sucesión. Es decir, el resultado de una fórmula lo usarás para evaluar otra fórmula y así sucesivamente hasta obtener el resultado final. Como estás aprendiendo a programar, crees que podrías ayudarte de programas de computadora para facilitar tu labor. Las fórmulas con las que trabajarás esta vez son: y = (x + 5) / (2 * (x + 1)), z = (y^2 + x * (x - 2 * y)) / (x * y). Escribe un programa que calcule el valor de z dado x.",
        "entrada": "Un real x. Puedes suponer que (1<=x<=100).",
        "salida": "Un real que sea el valor de z. El valor se considerará correcto si está razonablemente cercano a la respuesta exacta.",
        "nivel": "Intermedio (fácil) - Matemáticas en la programación",
        "categorias": [
            "Aritmética"
        ],
        "estructuras": [
            "long double"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long double a, b, c;\n    cin>>a;\n    b=(a+5)/(2*(a+1));\n    c=(pow(b,2)+(a*(a-(2*b))))/(a*b);\n    cout<<c;\n    \n    return 0;\n}"
    },
    {
        "titulo": "5251. Sumas Distanciadas",
        "url": "https://omegaup.com/arena/problem/Sumas-Distanciadas/",
        "descripcion": "Se te da una secuencia S de N enteros y tu trabajo es encontrar cuales son los resultados de algunas sumas distanciadas. Una suma distanciada se defiene con 3 enteros A, B, C donde: A (1<=A<=N) es la posición incial en S. B (1<=B<=N-1) es la distancia. C (1<=A + (C-1) * B<=N) es cuántos números tienes que considerar. Por ejemplo S={1, 2, 3, 4, 5} y la suma distanciada dada por A = 1, B = 2, C = 3 es equivalente a S[1] + S[3] + S[5] = 1 + 3 + 5 = 9. De igual manear el caso A = 2, B = 3, C = 2 es igual a S[2] + S[5] = 2 + 5 = 7.",
        "entrada": "La primera linea consiste en un número N. Las siguientes N lineas contendrán un entero S_i. La siguiente linea contendrá un entero Q. Las siguientes Q lineas contendrán tres enteros A, B, C.",
        "salida": "Q lineas, cada una con un entero, respuesta de la suma Q-ésima.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores",
            "Ciclos"
        ],
        "estructuras": [
            "unsigned long long",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    unsigned long long a, b, c, d, e;\n    vector<int> num(100001, 0);\n    cin>>a;\n    for(auto i=1; i<=a; i++){\n        cin>>num[i];\n    }\n    cin>>a;\n    while(a--){\n        cin>>b>>c>>d;\n        e=0;\n        while(d--){\n            e+=num[b];\n            b+=c;\n        }\n        cout<<e<<\"\\n\";\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "3771. Sumando",
        "url": "https://omegaup.com/arena/problem/Sumando/",
        "descripcion": "Problema simple, dado una lista de N números enteros en el rango -1000000<=A_i<=1000000 se quiere encontrar la subsecuencia tal que su suma sea lo mayor posible. Una subsecuencia es una sublista de números adyacentes entre si, por ejemplo dada la lista: 1 2 3 4 5 6 7. 1 2 3 es una subsecuencia. 1 2 3 4 5 6 7 es una subsecuencia. 2 3 4 es una subsecuencia. 1 3 6 no es una subsecuencia. Escribe un programa que dada una lista de N números positivos y negativos encuentre cuál es la suma de la subsecuencia con mayor suma.",
        "entrada": "La primera línea tendrá un número N (1<=N<=1000000). La segunda línea contiene N números enteros separados por un espacio.",
        "salida": "Un solo número entero, la suma mas grande que se puede obtener de una subsecuencia de la lista dada.",
        "nivel": "Intermedio (medio) - Análisis y diseño de algoritmos",
        "categorias": [
            "Programación dinámica",
            "Ciclos"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c = 0, d = 0, e = 0, f = 0;\n    cin >> a;\n    while (a--)\n    {\n        cin >> b;\n        c += b;\n        if (c > d)\n        {\n            d = c;\n        }\n        if (c < e)\n        {\n            e = c;\n        }\n        f = max(f, d - e);\n    }\n    cout << f;\n\n    return 0;\n}"
    },
    {
        "titulo": "5036. Sumando Alumnos",
        "url": "https://omegaup.com/arena/problem/OMICAMP-Sumando-Alumnos/",
        "descripcion": "Tu preparatoria te contrata para desarrollar un sistema de control de alumnos, pero dentro de las funciones del sistema te piden algo en particular, Es una función donde se efectuaran P preguntas, que calculara dentro de un total de S Aulas un rango de A hasta B, el número y la media de alumnos. Crear un programa que almacene la cantidad de alumnos por salón y que responda a cada pregunta solicitada, la cantidad de alumnos y la media de alumnos entre los salones.",
        "entrada": "En la primera línea un valor entero S (2<=S<=1000000), que representará la cantidad de salones que hay en tu escuela, en las siguientes S líneas recibirás N A (1<=N A<=100) que representará el número de alumnos por cada salón, en la siguiente línea recibirá P (1<=P<=1000) que representa la cantidad de preguntas efectuadas al programa, y siguiente P líneas recibirá dos valores A y B (1<=A,B<=S) el cual es el rango de un salón a otro donde tu programa deberá calcular cuántos alumnos hay y la media.",
        "salida": "Tu programa deberá imprimir P líneas con la cantidad de alumnos y el promedio de alumnos que hay en los salones se parados por un espacio.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Suma de prefijos",
            "Vectores",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "vector<int>",
            "long double"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c = 0, d;\n    vector<int> num(1000000, 0);\n    long double z;\n    cin >> a;\n    for (auto i = 1; i <= a; i++)\n    {\n        cin >> b;\n        c += b;\n        num[i] = c;\n    }\n    cin >> a;\n    while (a--)\n    {\n        cin >> b >> c;\n        d = num[c] - num[b - 1];\n        z = (double)d / ((c - b) + 1);\n        cout << d << \" \" << z << \"\\n\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "5891. Sumando horas",
        "url": "https://omegaup.com/arena/problem/sumando-horas/",
        "descripcion": "Por haber puente y además trabajar semana inglesa, Brandon sólo ha trabajado tres días, sin embargo a él le pagan por la cantidad de tiempo que trabajan en total las máquinas que tiene a su cargo. Para este problema tendrás que sumar la cantidad de tiempo que trabajaron las máquinas cada uno de los tres días, y mostrar el total en un formato de h:mm:ss.",
        "entrada": "La entrada son tres cantidades de tiempo de la forma h:mm:ss, un tiempo en cada línea, con 0<=h<=150 y 00<=mm,ss<=59. Ten en cuenta que h puede representarse con hasta tres dígitos; mm y ss siempre se representan con 2 dígitos.",
        "salida": "Es un único valor h:mm:ss con los mismos criterios para la entrada, es decir, h puede tener hasta 3 dígitos y mm y ss siempre serán de 2 dígitos. ",
        "nivel": "Básico (difícil) - Introducción a la programación",
        "categorias": [
            "Cálculos aritméticos",
            "Vectores",
            "Caracteres y cadenas",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "vector<int>",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c = 0;\n    vector<int> num(11, 0);\n    string z, zz, zzz;\n    cin >> z >> zz >> zzz;\n    if (zz.size() > z.size())\n    {\n        swap(z, zz);\n    }\n    if (zzz.size() > z.size())\n    {\n        swap(z, zzz);\n    }\n    if (zzz.size() > zz.size())\n    {\n        swap(zz, zzz);\n    }\n    a = ((z[z.size() - 1] + zz[zz.size() - 1] + zzz[zzz.size() - 1]) - 144) + b;\n    b = a / 10;\n    a %= 10;\n    num[c] = a;\n    c++;\n    a = ((z[z.size() - 2] + zz[zz.size() - 2] + zzz[zzz.size() - 2]) - 144) + b;\n    b = a / 6;\n    a %= 6;\n    num[c] = a;\n    c++;\n    a = ((z[z.size() - 4] + zz[zz.size() - 4] + zzz[zzz.size() - 4]) - 144) + b;\n    b = a / 10;\n    a %= 10;\n    num[c] = a;\n    c++;\n    a = ((z[z.size() - 5] + zz[zz.size() - 5] + zzz[zzz.size() - 5]) - 144) + b;\n    b = a / 6;\n    a %= 6;\n    num[c] = a;\n    c++;\n    for (auto i = z.size() - 7, j = zz.size() - 7, k = zzz.size() - 7; k > -1; i--, j--, k--)\n    {\n        if (z[i] == ':')\n        {\n            i--;\n            j--;\n            k--;\n        }\n        a = ((z[i] + zz[j] + zzz[k]) - 144) + b;\n        b = a / 10;\n        a %= 10;\n        num[c] = a;\n        c++;\n        if (!k && j)\n        {\n            i--;\n            j--;\n            for (auto yy = 0; j > -1; i--, j--)\n            {\n                a = ((z[i] + zz[j]) - 96) + b;\n                b = a / 10;\n                a %= 10;\n                num[c] = a;\n                c++;\n                if (!j && i)\n                {\n                    i--;\n                    for (auto yyy = 0; i > -1; i--)\n                    {\n                        a = (z[i] - 48) + b;\n                        b = a / 10;\n                        a %= 10;\n                        num[c] = a;\n                        c++;\n                    }\n                }\n            }\n        }\n        else if (!k && i)\n        {\n            i--;\n            for (auto yyy = 0; i > -1; i--)\n            {\n                a = (z[i] - 48) + b;\n                b = a / 10;\n                a %= 10;\n                num[c] = a;\n                c++;\n            }\n        }\n    }\n    if (b)\n    {\n        num[c] = b;\n    }\n    for (auto i = 11; i >= 6; i--)\n    {\n        if (num[i])\n        {\n            cout << num[i];\n        }\n    }\n    cout << num[5] << num[4] << \":\" << num[3] << num[2] << \":\" << num[1] << num[0];\n\n    return 0;\n}"
    },
    {
        "titulo": "5523. Los Taquitos",
        "url": "https://omegaup.com/arena/problem/Los-Taquitos/",
        "descripcion": "Ángel y sus amigos acostumbran a ir cada día al puesto de taquitos fuera de su escuela. En el puesto de tacos podemos encontrar N salsas diferentes, cada una con una intensidad de picante a_i. Además, los amigos de Ángel suman M personas, cada uno con una capacidad de aguante de picante b_j. El plan de hoy es completar un reto especial que los vendedores de tacos han propuesto : Si cada uno de los M amigos pueden probar cada una de las N  salsas mientras se comen sus tacos, obtendrán una membresía de tacos gratis por un mes. Dentro del reto existe una pequeña restricción, una vez que pruebas una salsa, no la puedes volver a probar. Todos están dispuestos a entrar al reto, aunque hay un factor importante en esta situación: Si una persona con aguante b_j come un taco con salsa de intesidad a_i, si los valores difieren la persona adquirirá un disgusto de  |a_i - b_j| el cual es acumulativo. Como podrás darte cuenta, el disgusto total de sus amigos sumado D se puede expresarse como: D =  sum_{i=1}^{N} sum_{j=1}^{M} | a_i - b_j |. Ángel se quiere prevenir y desea conocer disgusto total de sus amigos que tendrá que aguantar durante el día al final del reto.",
        "entrada": "En la primera línea N y M (1<=N,M<=10^5). En la segunda línea enteros a_i indicando las N  intensidades de las salsas. En la tercera línea otros M enteros b_j (1<=a_i,b_j<=10^5) indicando los niveles de aguante de picante de los amigos de Ángel.",
        "salida": "La cantidad de disgusto total D de los amigos de Ángel al final del reto.",
        "nivel": "Intermedio (medio) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Vectores",
            "Ordenamiento",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c = 0, d = 0, e = 0, f = 0;\n    vector<int> num(100000, 0);\n    vector<int> sub(100000, 0);\n    cin >> a >> b;\n    for (auto i = 0; i < a; i++)\n    {\n        cin >> num[i];\n    }\n    for (auto i = 0; i < b; i++)\n    {\n        cin >> sub[i];\n        d += sub[i];\n    }\n    sort(num.begin(), num.end());\n    sort(sub.begin(), sub.end());\n    for (auto i = 0; i < b; i++)\n    {\n        while (sub[i] >= num[c])\n        {\n            e += (abs(((b - i) * num[c]) - d) + abs((i * num[c]) - f));\n            c++;\n            if (c == a)\n            {\n                cout << e;\n                return 0;\n            }\n        }\n        d -= sub[i];\n        f += sub[i];\n        if (i == b - 1)\n        {\n            i++;\n            while (c != a)\n            {\n                e += (abs(((b - i) * num[c]) - d) + abs((i * num[c]) - f));\n                c++;\n            }\n            cout << e;\n            return 0;\n        }\n    }\n    cout << e;\n\n    return 0;\n}"
    },
    {
        "titulo": "4256. Problema C",
        "url": "https://omegaup.com/arena/problem/Problema-C/",
        "descripcion": "Roy tiene una cadena S de longitud N. La cadena S está hecha de letras minúsculas. A Roy le gustan las cadenas ordenadas, por lo tanto, se pregunta cómo se ordenan muchas sub-cadenas de S. Dada la cadena S , su tarea consiste en contar el número de sub-cadenas ordenadas de S. Una cadena S está ordenada lexicográficamente si  S_i<=(S_i+1) donde 1<=i<=N-1 (considere la indexación desde 1).",
        "entrada": "La primera línea del caso de prueba es un número T (0<T<1000) que representa la cantidad de casos de prueba. Cada caso de prueba inicia con una línea con un entero N (1<=N<=1000000) que representa la longitud de la cadena. Luego sigue una línea con una cadena S de longitud N.",
        "salida": "Por cada caso se debe imprimir la cantidad de subcadenas ordenadas.",
        "nivel": "Básico (difícil) - Introducción a la programación",
        "categorias": [
            "Colas",
            "Caracteres y cadenas",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "queue<int>",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d;\n    queue<int> falta;\n    string z;\n    cin >> a;\n    while (a--)\n    {\n        cin >> b >> z;\n        d = b;\n        for (auto i = 0; i < z.size() - 1; ++i)\n        {\n            falta.push(i + 1);\n        }\n        while (falta.size())\n        {\n            c = falta.front();\n            falta.pop();\n            if (z[c] >= z[c - 1])\n            {\n                d++;\n                if ((c + 1) < z.size())\n                {\n                    falta.push(c + 1);\n                }\n            }\n        }\n        cout << d << \"\\n\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "377. Divisores",
        "url": "https://omegaup.com/arena/problem/Divisores/",
        "descripcion": "Durante tu camino al concurso Coding Rush ITAM, había mucho tráfico y como estabas muy aburrido te pusiste a ver los números en las placas de los coches y a calcular sus divisores primos. Después de lo que aprendiste hoy, sabes que calcular los divisores primos de un número es más fácil si lo programas. Recuerda que un número es divisor del otro si cuando realizas la operación de división, no hay residuo. * 5 no es divisor de 12. * 2 sí es divisor de 12.",
        "entrada": "Leerás N (0<=N<=3000) líneas, en cada una de ellas habrá un número.",
        "salida": "Por cada línea leída, debes imprimir los divisores primos que tiene separados por un espacio en orden ascendente sin repetir ningún divisor.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Ciclos"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long b;\n    while (cin >> b)\n    {\n        if (b % 2 == 0)\n        {\n            cout << \"2 \";\n        }\n        if (b % 3 == 0)\n        {\n            cout << \"3 \";\n        }\n        if (b % 5 == 0)\n        {\n            cout << \"5 \";\n        }\n        if (b % 7 == 0)\n        {\n            cout << \"7 \";\n        }\n        cout << \"\\n\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "779. Ancho de un Árbol",
        "url": "https://omegaup.com/arena/problem/Ancho-de-un-arbol/",
        "descripcion": "Supon que deseas dibujar un arbol binario en una cuadricula cuyas columnas estan numeradas de acuerdo a las siguientes reglas: Todos los nodos en un mismo nivel deberan estar en la misma fila. Cada columna de la cuadricula puede tener solamente un nodo. Los nodos en el subarbol izquierdo de un nodo deberan ser dibujados en una columna a la izquierda del mismo, al igual los nodos del subarbol derecho deberan ser dibujados en columnas a la derecha del mismo. Al dibujar el arbol no debe quedar ninguna columna sin nodo entre la columna mas a la izquierda y mas a la derecha del dibujo. El ancho de un nivel se puede obtener restando el numero de la columna derecha menos la columna izquierda del mismo mas uno. La raiz del arbol se considera el nivel 1. La siguiente figura muestra un arbol binario dibujado de acuerdo a la siguiente regla. El ancho del primer nivel es uno mientras que el ancho del segundo es 13, el tercer, cuarto, quindo y sexto nivel tienen los anchos 18, 18, 13 y 12 respectivamente. Debes crear un programa que al dibujar un arbol de esta forma calcule cual es el nivel mas ancho del arbol, si dos niveles tienen el ancho maximo, como en el caso del ejemplo el nivel 3 y el 4, entonces debes tomar el nivel con menor numero.",
        "entrada": "Tu programa debera leer del teclado los siguientes datos, la primera linea contendra un numero N (1<=N<=1000) entre 1 y 1,000 que indica el numero de nodos del arbol. Cada una de las siguientes N lineas contiene 3 enteros, denotando 3 nodos, donde el primer numero indica un nodo, el segundo y tercer numeros de la linea indican el nodo izquierdo y derecho del nodo respectivamente. Cada nodo esta numerado del 1 al N.  Si hay un nodo que no tenga hijos, entonces su hijo tendra el numero -1. El nodo raiz tiene el numero 1.",
        "salida": "Tu programa debera escribir a la pantalla dos numeros en una linea separados por un espacio, el primer numero indica el nivel con el ancho maximo, mientras que el segundo numero indica el ancho del nivel. Si hay mas de un nivel con el ancho maximo imprime el nivel de menor numero.",
        "nivel": "Intermedio (medio) - Análisis y diseño de algoritmos",
        "categorias": [
            "Recursión",
            "Vectores",
            "Ciclos"
        ],
        "estructuras": [
            "vector<pair<long long, long long>>",
            "int",
            "vector<struct>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long a, b = 1, c = 0, d = 1;\nvector<pair<long long, long long>> sub(1001, {0, 0});\n\nstruct sobra\n{\n    int aa, bb, cc;\n};\n\nvector<sobra> num(1001);\n\nint sum(int z)\n{\n    if (num[z].bb != -1)\n    {\n        b++;\n        sum(num[z].bb);\n    }\n    if (!sub[b].first)\n    {\n        sub[b].first = d;\n        sub[b].second = d;\n    }\n    else\n    {\n        sub[b].second = d;\n    }\n    d++;\n    if (num[z].cc != -1)\n    {\n        b++;\n        sum(num[z].cc);\n    }\n    b--;\n    return 0;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    cin >> a;\n    for (auto i = 1; i <= a; i++)\n    {\n        cin >> num[i].aa >> num[i].bb >> num[i].cc;\n    }\n    sum(1);\n    for (auto i = 1; i <= a; i++)\n    {\n        b = ((sub[i].second - sub[i].first) + 1);\n        if (b > c)\n        {\n            c = b;\n            d = i;\n        }\n    }\n    cout << d << \" \" << c;\n\n    return 0;\n}"
    },
    {
        "titulo": "5412. Fer escapando",
        "url": "https://omegaup.com/arena/problem/Fer-escapando/",
        "descripcion": "Fernando estaba viajando en el tiempo cuando terminó siendo perseguido por un robot en el futuro. ¡Oh no! Afortunadamente, Fer programó su máquina del tiempo para teletransportarlo después de T segundos. Fer avanza a una velocidad constante de V metros por segundo. En contraste, el robot avanzará C_i metros del segundo i al i+1, donde C_i puede variar de segundo a segundo. Ayuda a Fer a escapar, es decir, a que en cualquier segundo entero Q tal que 0<=Q<=T, Fer siempre esté adelante del robot por lo menos un metro.",
        "entrada": "Tres enteros T (0<T<=10^5), R y F (0<R<F<=100) que corresponden con el tiempo que durará la persecución, la posición de inicial del robot y la posición inicial de Fer. Las posiciones de Fer y del robot se ubican en una recta numérica. La siguiente línea contiene T enteros que corresponden con los valores de C_i (0<=C_i<=10^4).",
        "salida": "Un entero no negativo que es la velocidad mínima V que Fer necesita tener para poder escapar.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Ciclos"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d = 0, e;\n    cin >> a >> b >> c;\n    for (auto i = 1; i <= a; i++)\n    {\n        cin >> e;\n        b += e;\n        c += d;\n        while (b >= c)\n        {\n            d++;\n            c += i;\n        }\n    }\n    cout << d;\n\n    return 0;\n}"
    },
    {
        "titulo": "8178. Cesar y el modulo",
        "url": "https://omegaup.com/arena/problem/David-y-el-modulo-ETITC/",
        "descripcion": "Cesar acaba de recibir una clase de matemáticas. En esta su profesor le enseñó que se puede saber si un número es múltiplo de otro siempre y cuando a/b tenga como residuo 0 siendo ‘a’ el número en cuestión por el que se quiere saber si es múltiplo de ‘b’. Su profesor le dejó la siguiente tarea: Al sumar los dos números ‘a’ y ‘b’ se quiere saber si es múltiplo de ‘s’. Lastimosamente Cesar tiene un profesor llamado Ardila que lo hace escribir como mil hojas examen para un 3. Ayuda a Cesar a resolver su tarea de matemáticas, pues no tiene tiempo y quiere dormir.",
        "entrada": "Ingresan 3 números a, b y s (0<=a,b,s<=10^11). Los dos primeros representan la suma y s será el número del cual se revisa ser múltiplo.",
        "salida": "Si la suma es múltiplo de s mostrar \"SI\" (exceptuando las comillas) y \"NO\" de lo contrario (exceptuando las comillas).",
        "nivel": "Intermedio (fácil) - Matemáticas en la programación",
        "categorias": [
            "Implementación"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c;\n    cin >> a >> b >> c;\n    if ((a + b) % c)\n    {\n        cout << \"NO\";\n    }\n    else\n    {\n        cout << \"SI\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "6910. pH",
        "url": "https://omegaup.com/arena/problem/pH/",
        "descripcion": "El Sr. pH te ha pedido calcular si su valor n representa un Ácido, Base o Neutro, es por esto, que pide tu ayuda. ¿Te crees capaz?",
        "entrada": "Deberás ingresar un número entero n, dónde n representa al valor del pH.",
        "salida": "La palabra Acido, Base o Neutro dependiendo de los valores del pH, en caso de que el valor del pH no exista imprime Are you kidding me?.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Cálculos aritméticos"
        ],
        "estructuras": [
            "long double"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long double a;\n    cin >> a;\n    if (a > -1 && a < 7)\n    {\n        cout << \"Acido\";\n    }\n    else if (a >= 7 && a < 8)\n    {\n        cout << \"Neutro\";\n    }\n    else if (a <= 14 && a > -1)\n    {\n        cout << \"Base\";\n    }\n    else\n    {\n        cout << \"Are you kidding me?\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "2194. Shift cipher",
        "url": "https://omegaup.com/arena/problem/ShiftCipher/",
        "descripcion": "Debes haber oido de una antigua manera de encriptacion llama Caesar cipher o 'shift cipher'. Esto es, dado el texto y un numero D,tu podrias remplazar cada caracter c en el texto con otro caracter el cual esta D lugares despues de c en el alfabeto. (El alfabeto tomado en cuenta incluye las letras contenidas en un teclado norteamericano). Por ejemplo, si D = 2, tu podrias remplazar 'a' con 'c', remplazar 'b' con 'd', ... remplazar 'y' con 'a', y remplazar 'z' con 'b'. Dado el texto y un entero D, tu podras generar el cipher(texto encriptado).",
        "entrada": "La primera linea es un entero T, El numero de casos de prueba. Cada caso contiene solo una linea, consiste del texto y de un numero D (D<26), separados por un espacio. Asume que hay solo letras minusculas, y el tamaño del texto no es mayor a 100.",
        "salida": "Genera un linea para cada caso, indicando el cipher(texto encriptado).",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c;\n    string z;\n    cin >> a;\n    while (a--)\n    {\n        cin >> z >> b;\n        b %= 26;\n        for (auto i = 0; i < z.size(); i++)\n        {\n            c = z[i];\n            c += b;\n            if (c > 122)\n            {\n                c -= 26;\n            }\n            z[i] = c;\n            cout << z[i];\n        }\n        cout << \"\\n\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "5991. Encuentra el teléfono",
        "url": "https://omegaup.com/arena/problem/find-the-telephone/",
        "descripcion": "En algunos lugares, es común recordar un número de teléfono asociando sus dígitos a letras. De esta forma, la expresión MY LOVE significa 69 5683. Por supuesto que hay algunos problemas, porque algunos números de teléfono no pueden formar una palabra o una frase y los dígitos 1 y 0 no están asociados a ninguna letra. Tu tarea es leer una expresión y encontrar el número de teléfono correspondiente según la tabla a continuación. LetrasNúmeros ABC2DEF3GHI4JKL5MNO6PQRS7TUV8WXYZ9. Una expresión se compone exclusivamente de las letras mayúsculas (A-Z), guiones (-) y los números 1 y 0.",
        "entrada": "Una única línea con una expresión con un máximo de 30 caracteres.",
        "salida": "Mostrar el número correspondiente.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas",
            "Ciclos"
        ],
        "estructuras": [
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    string z;\n    cin >> z;\n    for (auto i = 0; i < z.size(); i++)\n    {\n        if (z[i] < 'A' || z[i] > 'Z')\n        {\n            cout << z[i];\n            continue;\n        }\n        if (z[i] <= 'C')\n        {\n            cout << \"2\";\n        }\n        else if (z[i] <= 'F')\n        {\n            cout << \"3\";\n        }\n        else if (z[i] <= 'I')\n        {\n            cout << \"4\";\n        }\n        else if (z[i] <= 'L')\n        {\n            cout << \"5\";\n        }\n        else if (z[i] <= 'O')\n        {\n            cout << \"6\";\n        }\n        else if (z[i] <= 'S')\n        {\n            cout << \"7\";\n        }\n        else if (z[i] <= 'V')\n        {\n            cout << \"8\";\n        }\n        else\n        {\n            cout << \"9\";\n        }\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "8003. ¿Qué es lo que hace un taxista?",
        "url": "https://omegaup.com/arena/problem/Que-es-lo-que-hace-un-taxista/",
        "descripcion": "Ricardo es un taxista oriundo de Aguascuadrientes, una hermosa ciudad famosa por tener forma de cuadrícula. Esto hace que sólo pueda ir de una celda a aquellas con las que comparte borde. Es decir, sólo se puede mover en cuatro direcciones: arriba, abajo, izquierda y derecha. Cada día a Ricardo le llega un itinerario que muestra a qué celdas deberá de ir y en qué orden. La primera celda a la que tiene que ir está marcada con un 1, la siguiente con un 2, y así sucesivamente. La celda en que vive Ricardo está marcada con un un 0. Ricardo siempre empieza el día en su casa y lo termina ahí. Se te asegura que visitará todas las celdas (todas están numeradas). El vehículo en que viaja Ricardo consume 1  litro de combustible yendo de una celda a otra adyacente. Sabiendo esto, quiere que le ayudes a saber cuál es la menor cantidad posible de combustible en litros que puede usar durar su jornada. Escribe un programa que le ayude a Ricardo a saber cuál es la menor cantidad de combustible que puede usar durante su jornada.",
        "entrada": "En la primera línea habrá dos enteros R y C (1<=R,C<=1000),  que representan la cantidad de renglones y columnas que hay en Aguascadrientes respectivamente. Se te asegura que R o C son mayores o iguales a 2. Después habrá R renglones, cada uno con C  enteros, con el número asignado en el itinerario de Ricardo para la celda en el R-ésimo renglón y la C-ésima columna.",
        "salida": "Un solo entero, representando la menor cantidad de combustible que puede usar Ricardo.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Matrices",
            "Vectores",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "vector<pair<int, int>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d = 0;\n    vector<pair<int, int>> num(1000001, {0, 0});\n    cin >> a >> b;\n    for (auto i = 0; i < a; i++)\n    {\n        for (auto j = 0; j < b; j++)\n        {\n            cin >> c;\n            num[c].first = i;\n            num[c].second = j;\n        }\n    }\n    for (auto i = 1; i < a * b; i++)\n    {\n        d += abs(num[i].first - num[i - 1].first);\n        d += abs(num[i].second - num[i - 1].second);\n    }\n    d += abs(num[0].first - num[(a * b) - 1].first);\n    d += abs(num[0].second - num[(a * b) - 1].second);\n    cout << d;\n\n    return 0;\n}"
    },
    {
        "titulo": "4604. Haches",
        "url": "https://omegaup.com/arena/problem/Haches/",
        "descripcion": "Cuenta cuántas palabras inicial con la letra hache, ya sea mayúscula o minúscula, en determinada frase.",
        "entrada": "Una frase compuesta por a lo más 100 caracteres.",
        "salida": "La frase \"N haches\" donde N es la cantidad de palabras que inician con 'H' o 'h' dentro de la frase.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Ciclos",
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "long long",
            "string",
            "getline()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a = 0;\n    string z;\n    getline(cin, z);\n    for (auto i = 1; i < z.size(); i++)\n    {\n        if (z[i] == ' ' && (z[i + 1] == 'h' || z[i + 1] == 'H'))\n        {\n            a++;\n        }\n    }\n    if (z[0] == 'h' || z[0] == 'H')\n    {\n        a++;\n    }\n    cout << a << \" haches\";\n\n    return 0;\n}"
    },
    {
        "titulo": "4897. Pivote",
        "url": "https://omegaup.com/arena/problem/Pivote_UP/",
        "descripcion": "Dado un arreglo X de n números, x_0,...,x_{n-1} escribe un programa que coloque un elemento del arreglo llamado \"pivote\" en alguna posición, y reordene el arreglo en base a dicho pivote, de tal manera que los elementos a su izquierda sean menores, y los elementos a su derechea sean mayores o iguales. Por ejemplo, suponga el siguiente arreglo: X = 2,4,6,1,3,9,5,7. Si tomamos el número 7 como pivote, un reordamiento válido sería: 3,1,2,5,6,7,9,8. Cómo se puede observar, todos los elementos a la izquierda de 7, son menores a 7, y los elementos a la derecha son mayores a 7, por lo cual es reordamiento válido.",
        "entrada": "La primera línea contiene un número n (2<=n<1000), indicando el número de elementos en el arreglo. Le siguen n numeros en el rango de [0,10^6], que representan a los elementos del arreglo",
        "salida": "En la primera línea imprimir dos números, n y k, indicando la cantidad de elementos en el arreglo y la posición final del pivote. Le siguen n línea, cada uno con los elementos del arreglo reordenado.",
        "nivel": "Intermedio (fácil) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Ciclos",
            "Ordenamiento",
            "Vectores"
        ],
        "estructuras": [
            "long long",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b;\n    vector<int> falta;\n    vector<int> faltas;\n    vector<int> num(1000001, 0);\n    cin >> a;\n    for (auto i = 0; i < a; i++)\n    {\n        cin >> num[i];\n    }\n    b = num[a - 1];\n    for (auto i = 0; i < a - 1; i++)\n    {\n        if (num[i] < b)\n        {\n            falta.push_back(num[i]);\n        }\n        else\n        {\n            faltas.push_back(num[i]);\n        }\n    }\n    cout << a << \" \" << falta.size() << \"\\n\";\n    for (auto i = 0; i < falta.size(); i++)\n    {\n        cout << falta[i] << \"\\n\";\n    }\n    cout << b << \"\\n\";\n    for (auto i = 0; i < faltas.size(); i++)\n    {\n        cout << faltas[i] << \"\\n\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "7389. Si o No en caso se repita",
        "url": "https://omegaup.com/arena/problem/Si-o-No-en-caso-se-repita/",
        "descripcion": "Realiza un programa que solicite tres números e imprima Si o No si algún número se repite.",
        "entrada": "Escribe tres números enteros a, b y c",
        "salida": "Sí ó No, en caso que algún número se repita.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c;\n    cin >> a >> b >> c;\n    if (a == b || a == c || b == c)\n    {\n        cout << \"Si\";\n    }\n    else\n    {\n        cout << \"No\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "8525. Alejando la bomba del origen",
        "url": "https://omegaup.com/arena/problem/Alejando-la-bomba-del-origen/",
        "descripcion": "Hay N robots en la recta y una bomba en el origen: tu objetivo es usar los robots para alejar la bomba lo más posible del origen, sin importar si es a la derecha o a la izquierda. Cada robot cuenta con una posición inicial , una cantidad de energía E y gasta una unidad de energía para recorrer una unidad de distancia sobre la recta. Cuando un robot alcanza la bomba, éste puede cargarla y llevársela (el robot gasta la misma cantidad de energía caminando con o sin la bomba); el robot puede soltar la bomba en cualquier momento o bien, soltarla hasta que se acabe su energía y ya no pueda avanzar más. Si fuera posible, otro robot puede ir a recoger la bomba en la posición en la que quedó para seguir alejándola del origen. Los robots pueden programarse en cualquier orden. Escribe un programa que determine a cuánta distancia del origen puede alejarse la bomba si se usan los robots de manera óptima.",
        "entrada": "Un entero N seguido de N parejas de enteros P, E que determinan la posición y energía de cada robot. Puedes suponer que 0<=N<=10, -100<=P<=100 y 0<=E<=100.",
        "salida": "Un entero positivo que sea la magnitud de la distancia con respecto al origen a la que puede alejarse la bomba.",
        "nivel": "Intermedio (fácil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Fuerza bruta",
            "Permutaciones",
            "Vectores",
            "Colas",
            "Ciclos",
            "Ordenamiento"
        ],
        "estructuras": [
            "long long",
            "vector<pair<int, int>>",
            "queue<pair<int, int>>",
            "pair<int, int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e, f, g;\n    vector<pair<int, int>> num(20, {0, 0});\n    queue<pair<int, int>> falta;\n    pair<int, int> z;\n    cin >> a;\n    for (auto i = 0; i < a; i++)\n    {\n        cin >> num[i].first >> num[i].second;\n    }\n    sort(num.begin(), num.end());\n    for (auto i = 0; i < a; i++)\n    {\n        if (num[i].second > abs(num[i].first))\n        {\n            b = abs(num[i].first) - num[i].second;\n            for (auto j = a - 1; j > -1; j--)\n            {\n                if (j == i)\n                {\n                    continue;\n                }\n                e = falta.size();\n                while (e--)\n                {\n                    z = falta.front();\n                    falta.pop();\n                    if (z.first >= b)\n                    {\n                        c = z.first - z.second;\n                        b = min(c, b);\n                    }\n                    else\n                    {\n                        d = b - z.first;\n                        if (z.second > d)\n                        {\n                            d = z.second - d;\n                            b -= d;\n                        }\n                        else\n                        {\n                            falta.push(z);\n                        }\n                    }\n                }\n                if (num[j].first >= b)\n                {\n                    c = num[j].first - num[j].second;\n                    b = min(c, b);\n                }\n                else\n                {\n                    d = b - num[j].first;\n                    if (num[j].second > d)\n                    {\n                        d = num[j].second - d;\n                        b -= d;\n                    }\n                    else\n                    {\n                        z.first = num[j].first;\n                        z.second = num[j].second;\n                        falta.push(z);\n                    }\n                }\n            }\n            e = falta.size();\n            while (e--)\n            {\n                z = falta.front();\n                falta.pop();\n                if (z.first >= b)\n                {\n                    c = z.first - z.second;\n                    b = min(c, b);\n                }\n                else\n                {\n                    d = b - z.first;\n                    if (z.second > d)\n                    {\n                        d = z.second - d;\n                        b -= d;\n                    }\n                    else\n                    {\n                        falta.push(z);\n                    }\n                }\n            }\n            g = abs(b);\n            f = max(f, g);\n            b = num[i].second - abs(num[i].first);\n            for (auto j = 0; j < a; j++)\n            {\n                if (j == i)\n                {\n                    continue;\n                }\n                e = falta.size();\n                while (e--)\n                {\n                    z = falta.front();\n                    falta.pop();\n                    if (z.first <= b)\n                    {\n                        c = z.first + z.second;\n                        b = max(c, b);\n                    }\n                    else\n                    {\n                        d = z.first - b;\n                        if (z.second > d)\n                        {\n                            d = z.second - d;\n                            b += d;\n                        }\n                        else\n                        {\n                            falta.push(z);\n                        }\n                    }\n                }\n                if (num[j].first <= b)\n                {\n                    c = num[j].first + num[j].second;\n                    b = max(c, b);\n                }\n                else\n                {\n                    d = num[j].first - b;\n                    if (num[j].second > d)\n                    {\n                        d = num[j].second - d;\n                        b += d;\n                    }\n                    else\n                    {\n                        z.first = num[j].first;\n                        z.second = num[j].second;\n                        falta.push(z);\n                    }\n                }\n            }\n            e = falta.size();\n            while (e--)\n            {\n                z = falta.front();\n                falta.pop();\n                if (z.first <= b)\n                {\n                    c = z.first + z.second;\n                    b = max(c, b);\n                }\n                else\n                {\n                    d = z.first - b;\n                    if (z.second > d)\n                    {\n                        d = z.second - d;\n                        b += d;\n                    }\n                }\n            }\n            f = max(f, b);\n        }\n    }\n    cout << f;\n\n    return 0;\n}"
    },
    {
        "titulo": "8450. El amigable Hombre Araña",
        "url": "https://omegaup.com/arena/problem/OMI-2019-Spider-Man/",
        "descripcion": "En últimos meses las acciones de Stark Industries han caído, los empleados de esta empresa están desanimados. Para subir la moral, Tony Stark, CEO de Stark Industries, le pidió ayuda a Spiderman. A cambio Tony Stark le diseñará un nuevo traje. Spiderman debe escalar la Torre Stark y saludar a tantos empleados distintos como pueda. La torre tiene N pisos y en cada piso hay M ventanas. Cada ventana permite ver el interior de la oficina de un empleado diferente (los empleados siempre están en sus oficinas). Sin embargo, Spiderman olvidó desayunar así que sólo tiene K energía. Spiderman sólo puede moverse de forma vertical o de forma horizontal. Cuando se mueve de una ventana a otra horizontalmente gasta X energía y cuando se mueve verticalmente gasta Y energía. Ayuda a Spiderman a saber cuál es la mayor cantidad de empleados distintos a los que podrá saludar. Spiderman inicia en la primer ventana de la izquierda del primer piso.",
        "entrada": "En una sola línea 5 enteros: N, M, K, X y Y (1 <= N,M,K,X,Y < 2^31). Estos enteros representan representan el número de pisos, el número de ventanas por piso, la energía inicial, el costo de moverse horizontalmente y el costo de moverse verticalmente, respectivamente.",
        "salida": "Un entero que indica la máxima cantidad de empleados distintos a los que puede saludar Spiderma",
        "nivel": "Intermedio (fácil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Cálculo matemático"
        ],
        "estructuras": [
            "unsigned long long int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    unsigned long long int a, b, c, d, e, f, g;\n    cin >> a >> b >> c >> d >> e;\n    if (d > c && e > c)\n    {\n        cout << 1;\n        return 0;\n    }\n    if (d <= e)\n    {\n        f = (a * (b - 1) * d) + ((a - 1) * e);\n        if (c >= f)\n        {\n            cout << a * b;\n            return 0;\n        }\n        f = ((b - 1) * d) + e;\n        g = (c / f) * b;\n        c %= f;\n        f = c / d;\n        b--;\n        g += min(f, b);\n        cout << g + 1;\n        return 0;\n    }\n    f = (b * (a - 1) * e) + ((b - 1) * d);\n    if (c >= f)\n    {\n        cout << a * b;\n        return 0;\n    }\n    f = ((a - 1) * e) + d;\n    g = (c / f) * a;\n    c %= f;\n    f = c / e;\n    a--;\n    g += min(f, a);\n    cout << g + 1;\n    return 0;\n\n    return 0;\n}"
    },
    {
        "titulo": "5978. El mejor programador",
        "url": "https://omegaup.com/arena/problem/Comparacion-programadores/",
        "descripcion": "Santiago decidió hacer un programa capaz de decir el mejor de dos programadores conforme su calificación en sus practicas, curiosamente no hubo empates. Dado dos programadores con su calificaciones decir el nombre del mejor.",
        "entrada": "-Primera linea: Un nombre del primer programador y un entero A que que simboliza sus puntos. -Segunda linea: Un nombre del primer programador y un entero B que simboliza sus puntos. Considera que Nombres<5000 caracteres y que 0<=A,B<=2^31.",
        "salida": "Nombre del mejor programador",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Cálculos aritméticos",
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "long long",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b;\n    string z, zz;\n    cin >> z >> a >> zz >> b;\n    if (a > b)\n    {\n        cout << z;\n    }\n    else\n    {\n        cout << zz;\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "4548. La fila de guardias de la Reina Roja",
        "url": "https://omegaup.com/arena/problem/Guardias-de-la-Reina-Roja/",
        "descripcion": "Los guardias de la Reina Roja siempre deben estar atentos a sus exigencias. Recordemos que cada guardia es en realidad una carta de baraja, con un número del 1 al 13 y uno de cuatro tipos. Últimamente se le ocurrió a la Reina Roja que cuando veía un grupo de guardias, estos debían formar una fila de una manera especial: Cada dos guardias consecutivos en la fila deben compartir el mismo número o el mismo tipo. Como esto no siempre se puede, el grupo de guardias intenta formar la fila más larga posible que cumpla estas condiciones. Por supuesto, los que no queden en la fila ¡perderán la cabeza!",
        "entrada": "Un entero M seguido de la descripción de M cartas distintas. Cada carta está descrita por una pareja de enteros N, T que denotan su número y tipo respectivamente. Puedes suponer que 1<=M<=18, que 1<=N<=13 y que 1<=T<=4.",
        "salida": "Un entero que sea la cantidad más grande de guardias que se pueden formar en la fila.",
        "nivel": "Intermedio (difícil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Vectores",
            "Ciclos",
            "Memorización",
            "Búsqueda con retroceso",
            "Ordenamiento",
            "Recursión"
        ],
        "estructuras": [
            "int",
            "vector<pair<int, int>>",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint a, b = 0, c;\nvector<pair<int, int>> num(36, {0, 0});\nvector<int> sub(36, 0);\n\nint falta(int z)\n{\n    int zz = num[z].first, zzz = num[z].second;\n    for (auto i = 0; i < a; i++)\n    {\n        if (!sub[i] && num[i].first == zz)\n        {\n            b++;\n            c = max(c, b);\n            if (b == a)\n            {\n                return 0;\n            }\n            sub[i] = 1;\n            falta(i);\n            if (b == a)\n            {\n                return 0;\n            }\n            b--;\n            sub[i] = 0;\n        }\n    }\n    for (auto i = 0; i < a; i++)\n    {\n        if (!sub[i] && num[i].second == zzz)\n        {\n            b++;\n            c = max(c, b);\n            if (b == a)\n            {\n                return 0;\n            }\n            sub[i] = 1;\n            falta(i);\n            if (b == a)\n            {\n                return 0;\n            }\n            b--;\n            sub[i] = 0;\n        }\n    }\n    return 0;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    cin >> a;\n    for (auto i = 0; i < a; i++)\n    {\n        cin >> num[i].first >> num[i].second;\n    }\n    sort(num.begin(), num.end());\n    for (auto i = 0; i < a; i++)\n    {\n        sub[i] = 1;\n        b++;\n        c = max(c, b);\n        falta(i);\n        sub[i] = 0;\n        if (b == a)\n        {\n            break;\n        }\n        b--;\n    }\n    cout << c;\n\n    return 0;\n}"
    },
    {
        "titulo": "4554. occ16nsfd22b",
        "url": "https://omegaup.com/arena/problem/occ16nsfd22b/",
        "descripcion": "Haga un programa que reciba un número n y a continuación una lista de n números. Y que a continuación la reemplace por una que resulta de sumar las parejas adyacentes, note que la lista resultante tiene un elemento menos que el anterior. Este proceso se debe repetir hasta que solamente quede un número. El programa debe imprimir ese número.",
        "entrada": "",
        "salida": "",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Ciclos",
            "Vectores"
        ],
        "estructuras": [
            "long long",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a;\n    vector<int> num(1000000, 0);\n    cin >> a;\n    for (auto i = 0; i < a; i++)\n    {\n        cin >> num[i];\n    }\n    for (auto i = a - 2; i > -1; i--)\n    {\n        for (auto j = 0; j <= i; j++)\n        {\n            num[j] += num[j + 1];\n        }\n    }\n    cout << num[0];\n\n    return 0;\n}"
    },
    {
        "titulo": "1941. Desorden en el cuarto",
        "url": "https://omegaup.com/arena/problem/Desorden-en-el-Cuarto/",
        "descripcion": "María tiene N libros numerados tirados en su cuarto. Su mamá le ordenó (sin gritarle) que recogiera y ordenara su cuarto. Para ordenarlos, los comenzó a colocar uno por uno en un estante de derecha a izquierda. Al terminar, sin querer chocó con el estante y se cayeron los primeros K libros que estaban ahí, contando desde la izquierda. Los libros que se quedaron en el estante se quedaron en su orden inicial, pero al volver a meter los que se habían caído los puso en el mismo orden en el que estaban, pero al revés.",
        "entrada": "El número N y el número K, seguidos por una línea con los N números de los libros en el orden que los puso en el estante al principio (antes de que se cayeran), separados por un espacio. 0<=K<=N<=20000.",
        "salida": "Los números de los libros en el orden en el que quedaron en el estante, de izquierda a derecha.",
        "nivel": "Intermedio (fácil) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Pilas",
            "Colas",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "stack<int>",
            "queue<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c;\n    stack<int>falta;\n    queue<int>faltas;\n    cin>>a>>b;\n    a-=b;\n    while(a--){\n        cin>>c;\n        falta.push(c);\n    }\n    while(b--){\n        cin>>c;\n        faltas.push(c);\n    }\n    while(faltas.size()){\n        cout<<faltas.front()<<\"\\n\";\n        faltas.pop();\n    }\n    while(falta.size()){\n        cout<<falta.top()<<\"\\n\";\n        falta.pop();\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "1189. CETVRTA (Cuarto)",
        "url": "https://omegaup.com/arena/problem/CETVRTA-Cuarto/",
        "descripcion": "Mirko tiene que elegir cuatro puntos en el plano de manera que formen un rectángulo con lados paralelos a los ejes. Él ya ha elegido a tres puntos y no ha cometido algún error, pero está teniendo problemas para encontrar el último punto. Ayúdalo.",
        "entrada": "Cada uno de los tres puntos se darán en líneas separadas. Todas las coordenadas estarán entre 1 y 1000.",
        "salida": "La coordenada del cuarto vértice del rectángulo.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e, f;\n    cin>>a>>b>>c>>d>>e>>f;\n    if(a!=c && a!=e){\n        cout<<a;\n    }\n    else if(c!=a && c!=e){\n        cout<<c;\n    }\n    else{\n        cout<<e;\n    }\n    cout<<\" \";\n    if(b!=d && b!=f){\n        cout<<b;\n    }\n    else if(d!=b && d!=f){\n        cout<<d;\n    }\n    else{\n        cout<<f;\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "7311. Sobras",
        "url": "https://omegaup.com/arena/problem/Sobras/",
        "descripcion": "Javert va a organizar una fiesta con sus M amigos, y compró N dulces. El problema es que en su casa hay un ratón que le encantan los dulces, por lo que si sobran, el ratón hará de las suyas. Él quiere saber si puede repartir dulces entre todos sus amigos, dándoles cantidades iguales sin que sobre ningún dulce. Él no comerá dulces, así que solo es necesario repartir los N dulces entre sus M amigos. Dado un número N: la cantidad de dulces; y un número M: la cantidad de amigos. Determina si es posible repartir todos los dulces sin que sobre ninguno, de tal manera que el ratón no tenga nada que comer.",
        "entrada": "Un número entero N, el número de dulces, seguido de un número entero M que representa al número de amigos de Javert. N<=1000000000, M<=N.",
        "salida": "Si es posible repartir todos los dulces sin que sobre ninguno, entonces imprimir \"Si\" (sin comillas), de otra forma, imprimir \"No\".",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b;\n    cin>>a>>b;\n    if(a%b){\n        cout<<\"No\";\n    }\n    else{\n        cout<<\"Si\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "8318. Suma de Multiplicación de Pares",
        "url": "https://omegaup.com/arena/problem/Suma-de-Multiplicacion-de-Pares/",
        "descripcion": "Dado un número de entrada n, se procede a capturar una lista de valores numéricos de tamaño n. El objetivo es realizar la suma de la multiplicación de cada pareja de datos.",
        "entrada": "La entrada constará en capturar un numero n, que servirá para determinar la cantidad de elementos que contendrá la lista que será evaluada. La cantidad de elementos de la lista deberá de ser igual al número n ingresado.",
        "salida": "La salida será el resultado de la suma de la multiplicación de cada pareja de datos.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Vectores",
            "Cálculos aritméticos",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c=0;\n    vector<int> num(1001,0);\n    cin>>a;\n    for(auto i=0; i<a; i++){\n        cin>>num[i];\n    }\n    b=num[a-1];\n    for(auto i=a-2; i>-1; i--){\n        c+=(num[i]*b);\n        b+=num[i];\n    }\n    cout<<c;\n\n    return 0;\n}"
    },
    {
        "titulo": "1006. Secuencia creciente máxima",
        "url": "https://omegaup.com/arena/problem/scm/",
        "descripcion": "Sea n un entero positivo y sea a_1, a_2,..., a_n una secuencia de n enteros positivos. Sean h y k dos enteros con 1<=h<=k<=n. Decimos que a_h, a_h+1,..., a_k es una secuencia creciente si a_h<a_h+1<...<a_k y decimos que es máxima si no es parte de otra secuencia creciente más larga. Por ejemplo, si n=7 y a=(3,1,4,1,5,9,2) entonces (1,5) es una secuencia creciente, pero no es máxima porque es parte de (1,5,9). Escribe un programa que encuentre la longitud s de la secuencia creciente máxima más larga de todas y la posición p donde inicia. En caso de existir varias que sean máximas entonces imprima el índice de la que ocurre primero.",
        "entrada": "Un número entero n con 1<=n<=1000 seguido de n números enteros a_1, a_2,..., a_n separados por espacios y en el intervalo de 1 a 1,000,000.",
        "salida": "Un número entero s y un número entero p.",
        "nivel": "Intermedio (fácil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Búsqueda de subarreglos",
            "Ciclos",
            "Vectores"
        ],
        "estructuras": [
            "long long",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b=1, c, d;\n    vector<int> num(1001,0);\n    cin>>a;\n    for(auto i=1; i<=a; i++){\n        cin>>num[i];\n    }\n    for(auto i=2; i<=a; i++){\n        if(num[i]>num[i-1]){\n            b++;\n        }\n        else{\n            if(b>c){\n                c=b;\n                d=i-c;\n            }\n            b=1;\n        }\n    }\n    if(b>c){\n        c=b;\n        d=(a+1)-c;\n    }\n    cout<<c<<\" \"<<d;\n\n    return 0;\n}"
    },
    {
        "titulo": "1100. L-OMI Super Agente",
        "url": "https://omegaup.com/arena/problem/L-OMI-Super-Agente/",
        "descripcion": "En su última misión, el súper agente Jaime Papel Blanco, debe hackear una red mientras se encuentra dentro de un edificio enemigo. El edificio está lleno de guardias y para poder hackear la red, Jaime Papel Blanco necesita esconderse y pasar desapercibido. Ahora debe encontrar el lugar óptimo para esconderse. Jaime Papel Blanco tiene un mapa de la planta del edificio, el cual está representado como una cuadrícula de MxN que tiene tres tipos de cuadros: pared, por la que nadie puede pasar, representado por un '#'; pasillo, representado por '.'; y guardia, representado por 'G'. El edificio no tiene cuartos cerrados, es decir, desde cualquier cuadro se puede llegar a cualquier otro. Jaime Papel Blanco sabe que los guardias solo lo detectaron si se encuentran en el mismo cuadro del mapa que él. Los guardias solo pueden moverse hacia arriba, abajo, izquierda o derecha. Para lograr su misión, debe encontrar un cuadro cuya distancia al guardia más cercano sea la máxima posible. Con distancia, el agente Jaime Papel Blanco, se refiere al mínimo de cuadros que tendrá que recorrer un guardia para llegar a él. Escribe un programa que dado un mapa, encuentra un cuadro óptimo para el escondite de Jaime Papel Blanco, es decir, aquel que maximice la distancia al guardia más cercano y deberás reportar esa distancia.",
        "entrada": "Tu programa debe leer del teclado la siguiente información: En la primer línea los números M y N (1 < N, M <= 2,000), las dimensiones del mapa.  Las siguientes M líneas contendrán N caracteres del tipo '#', '.' o 'G' (1 <= G <= 1,000) indicando si en ese cuadro del mapa hay una pared, un pasillo o un guardia, respectivamente.",
        "salida": "Tu programa debe escribir en la pantalla un único entero D seguido de un salto de línea, representando la distancia máxima al guardia más cercano a Jaime Papel Blanco.",
        "nivel": "Intermedio (medio) - Análisis y diseño de algoritmos",
        "categorias": [
            "Búsqueda en amplitud",
            "Búsqueda en profundidad",
            "Vectores",
            "Caracteres y cadenas",
            "Colas",
            "Ciclos"
        ],
        "estructuras": [
            "vector<vector<char>>",
            "queue<struct>",
            "int",
            "char"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct sobra\n{\n    int aa, bb, cc;\n};\n\nvector<vector<char>> num(2002);\nqueue<sobra> falta;\nint a, b, c;\nsobra l;\nchar m;\n\nvoid llamar()\n{\n    if (num[l.aa][l.bb] == '.')\n    {\n        l.cc++;\n        c = max(c, l.cc);\n        falta.push(l);\n        num[l.aa][l.bb] = '#';\n        l.cc--;\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    cin >> a >> b;\n    for (auto i = 0; i <= b + 1; i++)\n    {\n        num[0].push_back('#');\n        num[a + 1].push_back('#');\n    }\n    for (auto i = 1; i <= a; i++)\n    {\n        num[i].push_back('#');\n        for (auto j = 1; j <= b; j++)\n        {\n            cin >> m;\n            num[i].push_back(m);\n            if (m == 'G')\n            {\n                l.aa = i;\n                l.bb = j;\n                l.cc = 0;\n                falta.push(l);\n            }\n        }\n        num[i].push_back('#');\n    }\n    while (falta.size())\n    {\n        l = falta.front();\n        falta.pop();\n        l.aa++;\n        llamar();\n        l.aa -= 2;\n        llamar();\n        l.aa++;\n        l.bb++;\n        llamar();\n        l.bb -= 2;\n        llamar();\n    }\n    cout << c;\n\n    return 0;\n}"
    },
    {
        "titulo": "5496. Dos Botones",
        "url": "https://omegaup.com/arena/problem/twobuttons/",
        "descripcion": "Vasya ha encontrado un dispositivo algo raro. En la parte frontal del dispositivo hay dos botones, un botón rojo y un botón azul además de una pantalla que muestra algún número positivo. Despues de darle click al botón rojo, el dispositivo multiplica el número mostrado en la pantalla por dos. Al presionar el botón azul, el dispositivo resta uno al número mostrado en pantalla. Si en algún punto el número mostrado en pantalla deja de ser positivo, el dispositivo se congela. El dispositivo puede mostrar números arbitrariamente grandes. Inicialmente muestra el número n. Bob quiere obtener el número m. ¿Cuál es el menor número de clicks que el debe realizar para poder lograr este resultado?",
        "entrada": "En la primera linea tendremos dos números entero n y m (1<=n,m<=10^4) separados por un espacio en blanco.",
        "salida": "Imprime un solo número - El menor número de veces que el necesita presionar los botones para obtener el número m a partir del número n.",
        "nivel": "Intermedio (medio) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Vectores",
            "Colas",
            "Ciclos"
        ],
        "estructuras": [
            "vector<int>",
            "queue<struct>",
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct sobra\n{\n    int aa, bb, cc;\n};\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    vector<int> num(10001, 0);\n    queue<sobra> falta;\n    long long a, b;\n    sobra z;\n    cin >> a >> b;\n    if (a == b)\n    {\n        cout << \"0\";\n        return 0;\n    }\n    z.aa = a;\n    z.bb = 0;\n    num[z.aa] = 1;\n    falta.push(z);\n    while (true)\n    {\n        z = falta.front();\n        falta.pop();\n        z.bb++;\n        z.aa *= 2;\n        if (z.aa == b)\n        {\n            cout << z.bb;\n            return 0;\n        }\n        if (z.aa < 10001 && !num[z.aa])\n        {\n            falta.push(z);\n            num[z.aa] = 1;\n        }\n        z.aa /= 2;\n        z.aa--;\n        if (z.aa == b)\n        {\n            cout << z.bb;\n            return 0;\n        }\n        if (z.aa > 0 && !num[z.aa])\n        {\n            falta.push(z);\n            num[z.aa] = 1;\n        }\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "98. Artista",
        "url": "https://omegaup.com/arena/problem/artista/",
        "descripcion": "En su viaje por Italia, Solid Nieves conoció un extraño artista. Hace sus obras de arte pegando pedazos rectagulares de papel sobre una cartulina de M columnas y N filas. La cartulina es de un color C. Él también puede pegar pedazos de papel sobre otros pedazos de papel, formando así una especie de collage. El artista es tan extraño que todo lo que pega es paralelo a los bordes de la cartulina y las dimensiones de los rectangulos siempre son enteras, y siempre los pega en coordenadas igualmente enteras. También el suele pegar rectangulos adhesivos y despegarlos inmediatamente desgarrando el papel, lo cual deja ver o la cartulina o un pedazo de papel que se encontrara debajo del papel desgarrado; cuando el artista desgarra el papel es tan cuidadoso que solo desgarra la superficie que toca el papel adhesivo. Él también puede desgarrar la cartulina, pero al ser esta más gruesa se necesitan pegar y despegar por lo menos G rectangulos adhesivos. Si en parte de la superficie de un rectangulo adhesivo no queda papel o cartulina debajo no pasa nada. Como andar desgarrando papel es muy costoso, el artista le ha pedido Solid Nieves que le ayude a obtener una idea de como quedaría su obra de arte dada una secuencia de pasos.",
        "entrada": "Primera Línea: M y N, las dimensiones de la cartulina. Segunda Línea: G y C, el grosor y color de la cartulina. Tercer Línea: K, que reprensenta el número de rectangulos que el artísta planea pegar. Siguientes K lineas: Ci, Mi, Ni, Xi, Yi: donde Ci es el color del papel(si es -1, se trata de un rectangulo adhesivo), Mi y Ni son las dimensiones del rectangulo, y finalmente Xi y Yi son las coordenas donde el artista planea poner la esquina superior izquierda del rectangulo. Considera que (M, N <= 200), (Mi, Xi <= M), (Ni, Yi <= N), (K,G <= 1000) y (C, Ci <= 100).",
        "salida": "Deberas imprimir N lineas con M números, representando la obra de arte. Si en alguna posición no queda ni restos de cartulina imprime -1.",
        "nivel": "Intermedio (fácil) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Implementación",
            "Vectores",
            "Pilas",
            "Matrices",
            "Ciclos"
        ],
        "estructuras": [
            "vector<vector<stack<int>>>",
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    vector<vector<stack<int>>> num(202, vector<stack<int>>(202));\n    long long a, b, c, d, e, f, g, h;\n    cin >> a >> b >> c >> d;\n    for (auto i = 1; i <= b; i++)\n    {\n        for (auto j = 1; j <= a; j++)\n        {\n            e = c;\n            while (e--)\n            {\n                num[i][j].push(d);\n            }\n        }\n    }\n    cin >> e;\n    while (e--)\n    {\n        cin >> c >> d >> f >> g >> h;\n        for (auto i = h; i < h + f; i++)\n        {\n            for (auto j = g; j < g + d; j++)\n            {\n                if (c != -1)\n                {\n                    num[i][j].push(c);\n                }\n                else if (c == -1)\n                {\n                    if (num[i][j].size())\n                    {\n                        num[i][j].pop();\n                    }\n                }\n            }\n        }\n    }\n    for (auto i = 1; i <= b; i++)\n    {\n        for (auto j = 1; j <= a; j++)\n        {\n            if (num[i][j].size())\n            {\n                cout << num[i][j].top() << \" \";\n            }\n            else\n            {\n                cout << \"-1 \";\n            }\n        }\n        cout << \"\\n\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "6817. Cuantos Productos",
        "url": "https://omegaup.com/arena/problem/Cuantos-Productos/",
        "descripcion": "Dada una lista de productos que se reciben en un almacen. Escribe un programa que imprima el nombre de todos los productos en orden alfabético junto a la cantidad de unidades en el almacen.",
        "entrada": "La entrada contiene virios nombres de productos, la entrada termina con el string \"#\".",
        "salida": "Varias líneas. En cada línea imprime el nombre del producto y la cantidad de unidades que existen. Los productos deben ir ordenados alfabeticamente.",
        "nivel": "Intermedio (fácil) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Árboles de búsqueda binaria",
            "Vectores",
            "Ordenamiento",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "vector<pair<string, int>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long b, c, d;\nvector<pair<string, int>> num(100001, {\"\", 0});\nstring z;\n\nvoid falta()\n{\n    sort(num.begin(), num.end());\n    c = 0;\n    for (auto i = 1; i < b; i++)\n    {\n        if (num[i].first == num[i - 1].first)\n        {\n            d = num[i - 1].second;\n            while (num[i].first == num[i - 1].first)\n            {\n                d += num[i].second;\n                i++;\n                if (i == b)\n                {\n                    break;\n                }\n            }\n            num[c].first = num[i - 1].first;\n            num[c].second = d;\n            c++;\n        }\n        else\n        {\n            num[c].first = num[i - 1].first;\n            num[c].second = num[i - 1].second;\n            c++;\n        }\n    }\n    if (num[b - 1].first != num[b - 2].first)\n    {\n        num[c].first = num[b - 1].first;\n        num[c].second = num[b - 1].second;\n        c++;\n    }\n    b = c;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    cin >> z;\n    while (true)\n    {\n        num[b].first = z;\n        num[b].second = 1;\n        b++;\n        if (b == 100000)\n        {\n            falta();\n        }\n        cin >> z;\n        if (z == \"#\")\n        {\n            break;\n        }\n    }\n    falta();\n    for (auto i = 0; i < b; i++)\n    {\n        cout << num[i].first << \" \" << num[i].second << \"\\n\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "6352. Cuantos Unos",
        "url": "https://omegaup.com/arena/problem/Cuantos-Unos/",
        "descripcion": "Un número en base 2 contiene sólo 1's y 0's. Por ejemplo el número 6 en base 2 se escribe como 110. Que es igual a (1 * 2^2 + 1 * 2^1 + 0 * 2^0). Escribe un programa que dado un número en base 10, escriba cuantos 1's tiene al escribirlo en base 2.",
        "entrada": "Un número n (0<=n<=3000)",
        "salida": "La cantidad de 1's al representar n en base 2.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Manipulación de bits",
            "Ciclos"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b = 0;\n    cin >> a;\n    while (a)\n    {\n        if (a % 2)\n        {\n            b++;\n        }\n        a /= 2;\n    }\n    cout << b;\n\n    return 0;\n}"
    },
    {
        "titulo": "8463. ¿Cuánto tiene que pagar? occ 2019",
        "url": "https://omegaup.com/arena/problem/cuanto-tiene-que-pagar-occ-2019/",
        "descripcion": "En la libreria de Olimpiadas Colombianas los libros de matemáticas cuestan 15 000 pesos y los de física 20 000 pesos. Pero como Olimpiadas está de aniversario hay descuentos del p% para los libros de matemáticas y del q% para los de física. Haga un programa que diga cuánto tiene que pagar Juan si compra A libros de matemáticas y B libros de física.",
        "entrada": "Su programa recibirá como entrada A, B, p y q en ese orden.",
        "salida": "La cantidad de dinero que tiene que pagar por los libros, puede suponer que el resultado es entero.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e;\n    cin >> a >> b >> c >> d;\n    e = ((15000 - ((15000 / 100) * c)) * a) + ((20000 - ((20000 / 100) * d)) * b);\n    cout << e;\n\n    return 0;\n}"
    },
    {
        "titulo": "3169. occ15pnf22",
        "url": "https://omegaup.com/arena/problem/Cuantos_numeros_distintos_hay/",
        "descripcion": "Haga un programa que reciba como entrada un número entero n (1<=n<=50) y a continuación n números enteros y que dé como salida cuántos números enteros distintos hay en esos n.",
        "entrada": "La primera línea contiene n (2<=n<=50), la segunda línea contiene n números enteros.",
        "salida": "Una línea con el número de números distintos en los n números dados en la segunda línea de la entrada.",
        "nivel": "Básico (difícil) - Introducción a la programación",
        "categorias": [
            "Tablas de dispersión",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "set<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b;\n    set<int> falta;\n    cin >> a;\n    while (a--)\n    {\n        cin >> b;\n        falta.insert(b);\n    }\n    cout << falta.size();\n\n    return 0;\n}"
    },
    {
        "titulo": "5805. ¿Cuánto Sacaste?",
        "url": "https://omegaup.com/arena/problem/Cuanto-Sacaste/",
        "descripcion": "Linette es una chica muy competitiva, siempre que sale de un examen le pregunta a sus 3 amigos por su calificación, dependiendo del resultado de sus amigos tiene distintas reacciones. Cuando ella logra ganarle a un amigo, siempre les dice \"Soy Mejor\", cuando ella obtiene una calificación menor les dice enojada \"Shh\" y, finalmente, si obtiene la misma calificación les dice \"Te gano en la siguiente\". Linette tuvo un examen ayer, tú tarea es preguntarle a ella y a sus 3 amigos por sus calificaciones para conocer anticipadamente las reacciones de Linette.",
        "entrada": "Una entero N, que será la calificación de Linette. Después leerás 3 enteros, que representarán las calificaciones de sus únicos amigos. Considera que todas las calificaciones son enteros y están entre 0 y 10",
        "salida": "Deberás imprimir un 'Soy Mejor' si la calificación de Linette es mayor a la de sus amigos. Si la calificación de sus amigos es mayor a la de ella, imprimirás 'Shh' y finalmente si empatan imprimirás 'Te gano en la siguiente'",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Ciclos"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b = 3, c;\n    cin >> a;\n    while (b--)\n    {\n        cin >> c;\n        if (a > c)\n        {\n            cout << \"Soy Mejor\\n\";\n        }\n        else if (a == c)\n        {\n            cout << \"Te gano en la siguiente\\n\";\n        }\n        else\n        {\n            cout << \"Shh\\n\";\n        }\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "2580. Bisiesto - Es o no bisiesto",
        "url": "https://omegaup.com/arena/problem/Bisiesto---Es-o-no-bisiesto/",
        "descripcion": "Este es un primer ejercicio para ir practicando con instrucciones selectivas. Un año trópico tiene una duración de 365 días 5 h 48 min 45, 25 s. Generalmente se considera un año de 365 días, pero para corregir el desfase que se presenta, cada 4 años se agrega un día. Sin embargo eso sería correcto si la duración de un año fuera exactamente 365 días y 6 horas. De modo que de acuerdo al calendario Gregoriano: Un año es bisiesto si es divisible entre 4, a menos que sea divisible entre 100. Sin embargo, si un año es divisible entre 100 y además es divisible entre 400, también es bisiesto. Lee un número entero que represente un año e imprime a la salida si es bisiesto o no lo es.",
        "entrada": "Un entero A (1582<A<=3000) positivo que represente un año entre 1583 y 3000",
        "salida": "La cadena de texto ES BISIESTO si el número A es Bisiesto o bien la cadena de texto NO ES BISIESTO si no lo es.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a;\n    cin >> a;\n    if (a % 100 == 0 && a % 400 == 0)\n    {\n        cout << \"ES BISIESTO\";\n    }\n    else if (a % 4 == 0 && a % 100)\n    {\n        cout << \"ES BISIESTO\";\n    }\n    else\n    {\n        cout << \"NO ES BISIESTO\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "7092. ¿Cuántos días tiene febrero?",
        "url": "https://omegaup.com/arena/problem/Cuantos-dias-tiene-febrero/",
        "descripcion": "Escribe un programa que lea cuatro años e imprima cuántos días tendrá febrero en esos años.",
        "entrada": "Cuatro enteros A_1, A_2, A_3, A_4 que representan años. Puedes suponer que 1000<=A_1,A_2,A_3,A_4<=3000",
        "salida": "Para cada año, un entero que represente el número de días que tendrá febrero en ese año.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Ciclos"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a;\n    while (b--)\n    {\n        cin >> a;\n        if (a % 100 == 0 && a % 400 == 0)\n        {\n            cout << \"29 \";\n        }\n        else if (a % 4 == 0 && a % 100)\n        {\n            cout << \"29 \";\n        }\n        else\n        {\n            cout << \"28 \";\n        }\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "2651. Secuencia creciente",
        "url": "https://omegaup.com/arena/problem/Secuencia-creciente/",
        "descripcion": "Dada una serie de datos enteros, determinar cuántos números en esa serie están en orden creciente. La lista de datos termina cuando se lee un número menor al anterior. Por Ejemplo: Datos: 2 3 5 7 8 9 4. El número de elementos creciente es 6 (2 ,3, 5, 7, 8 y 9).",
        "entrada": "Una línea con los números de la secuencia separados por un espacio entre ellos.",
        "salida": "El tamaño de la secuencia.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Ciclos",
            "Vectores"
        ],
        "estructuras": [
            "long long",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b=1, c=1, d;\n    vector<int> num(101,0);\n    cin>>a;\n    while(cin>>d){\n        if(d>a){\n            c++;\n        }\n        else{\n            c=1;\n        }\n        b=max(b,c);\n        a=d;\n    }\n    cout<<b;\n\n    return 0;\n}"
    },
    {
        "titulo": "7664. Secuencia Creciente Estricta",
        "url": "https://omegaup.com/arena/problem/Secuencia-Creciente-Estricta/",
        "descripcion": "Dado un vector de N (1<=N<=100) elementos enteros X (1<=X<=100), se quiere determinar la longitud de la secuencia creciente estricta más larga.",
        "entrada": "En la primer línea viene el valor N, y luego vienen N valores enteros X.",
        "salida": "Una línea conteniendo un valor entero L (1 <= L <= N) que indica la longitud de la secuencia creciente estricta más larga en la secuencia de X ingresada.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Ciclos",
            "Vectores"
        ],
        "estructuras": [
            "long long",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b=1, c=1;\n    vector<int> num(101,0);\n    cin>>a;\n    for(auto i=0; i<a; i++){\n        cin>>num[i];\n    }\n    for(auto i=1; i<a; i++){\n        if(num[i]>num[i-1]){\n            b++;\n        }\n        else{\n            c=max(c,b);\n            b=1;\n        }\n    }\n    c=max(c,b);\n    cout<<c;\n\n    return 0;\n}"
    },
    {
        "titulo": "4449. Num Mayor en arreglo",
        "url": "https://omegaup.com/arena/problem/Num-Mayor-en-arreglo/",
        "descripcion": "Escriba un programa que pida 10 numeros y los guarde en un arreglo. Luego debe encontrar el numero mayor en el arreglo y escribirlo así como el indice del lugar donde lo encontró.",
        "entrada": "10 enteros.",
        "salida": "El numero mayor y el indice de su ubicación.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Ciclos"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c=0;\n    for(auto i=0; i<10; i++){\n        cin>>a;\n        if(a>b){\n            b=a;\n            c=i;\n        }\n    }\n    cout<<b<<\" \"<<c;\n\n    return 0;\n}"
    },
    {
        "titulo": "4459. La pirámide Inversa",
        "url": "https://omegaup.com/arena/problem/La-piramide-Inversa/",
        "descripcion": "Se desea forma una piramide comenzando con las letras de la derecha de una cadena de caracteres.",
        "entrada": "Cada caso de prueba contiene únicamente una línea con uno cadena de caracteres.",
        "salida": "Por cada caso de prueba mostrar el número de caso y una pirámide formada con los caracteres del correspondiente case de pruebo alineada a la derecha.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas",
            "Ciclos"
        ],
        "estructuras": [
            "getline()",
            "string",
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a;\n    string z;\n    getline(cin,z);\n    for(auto i=z.size()-1; i>-1; i--){\n        a=i;\n        while(a--){\n            cout<<\" \";\n        }\n        for(auto j=i; j<z.size(); j++){\n            cout<<z[j];\n        }\n        cout<<\"\\n\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "6675. HCF-Diferencia absoluta mínima",
        "url": "https://omegaup.com/arena/problem/HFC-Diferencia-absoluta-minima/",
        "descripcion": "Dado un conjunto de N números enteros, encuentra la diferencia absoluta mínima entre cualquier pareja posible.",
        "entrada": "En la primera línea un entero N que denota el número de elementos a procesar. En la segunda línea N enteros.",
        "salida": "En la primera línea la diferencia absoluta mínima. En la segunda línea los números que generaron la diferencia absoluta mínima, en caso de que dos parejas o más hagan la diferencia mínima, imprimir la primera que aparezca respecto a la entrada. En la tercera línea la posición de los números que tomaste para calcular la respuesta (contando desde 0 de izquierda a derecha).",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Cálculos aritméticos",
            "Ciclos",
            "Vectores"
        ],
        "estructuras": [
            "long long",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e, f, g;\n    vector<int> num(1001,0);\n    cin>>a;\n    for(auto i=0; i<a; i++){\n        cin>>num[i];\n    }\n    b=abs(num[0]-num[1]);\n    c=num[0];\n    d=num[1];\n    e=0;\n    f=1;\n    for(auto i=0; i<a-1; i++){\n        for(auto j=i+1; j<a; j++){\n            g=abs(num[i]-num[j]);\n            if(g<b){\n                b=g;\n                c=num[i];\n                d=num[j];\n                e=i;\n                f=j;\n            }\n        }\n    }\n    cout<<b<<\"\\n\"<<c<<\" \"<<d<<\"\\n\"<<e<<\" \"<<f<<\"\\n\";\n\n    return 0;\n}"
    },
    {
        "titulo": "6170. Contar Valor",
        "url": "https://omegaup.com/arena/problem/Contar-Valor/",
        "descripcion": "Hacer un programa que diga cuantas veces aparece en un arreglo un valor introducido desde teclado.",
        "entrada": "Un entero N que indica la cantidad de elementos del arreglo. Las siguientes N lineas un entero que indica un elemento del arreglo. Un entero K que indica el valor que se quiere contar.",
        "salida": "La cantidad de veces que aparece el valor.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Ciclos",
            "Ordenamiento"
        ],
        "estructuras": [
            "long long",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c=0;\n    vector<int> num(100000,0);\n    cin>>a;\n    for(auto i=0; i<a; i++){\n        cin>>num[i];\n    }\n    cin>>b;\n    sort(num.begin(),num.end());\n    for(auto i=0; i<a; i++){\n        if(num[i]==b){\n            c++;\n        }\n        else if(num[i]>b){\n            break;\n        }\n    }\n    cout<<c;\n\n    return 0;\n}"
    },
    {
        "titulo": "6588. Hora de Meter Materias",
        "url": "https://omegaup.com/arena/problem/Hora-de-Meter-Materias/",
        "descripcion": "Brandon odia tener un horario que no esté balanceado, él prefiere tener el mismo número de horas de clase tanto en la mañana como en la noche, cada semestre se empeña en ordenar sus clases de tal forma que esto suceda. Para el siguiente semestre Brandon no sabe cuántas materias meter, lo único que le interesa es que el número de horas esté balanceado entre la mañana y la noche. Por ejemplo, si mete 6 materias, cada una con duración de 1 hora, su horario quedará de la siguiente manera: [1,1,1,1,1,1], la primera mitad del arreglo son 3 materias con duración de una hora impartidas en la mañana, la segunda mitad son 3 materias impartidas en la noche con la misma duración. A Brandon le gusta este horario porque está balanceado. Por lo general, Brandon no logra tener el horario que le gusta, este semestre metió 4 materias de la siguiente forma: [1,2,3,2], las materias de la mitad izquierda pertenecen a la mañana, mientras que las de la mitad derecha a la noche. Brandon odia este horario porque no está balanceado, en la mañana toma 3 horas de clase y en la noche 5 horas. Dile a Brandon cómo quedará su horario.",
        "entrada": "N un número par, que representa el número de materias, a continuación, N números que representan las horas por materia.",
        "salida": "Debes imprimir \"Genial\" si el horario está balanceado, en caso contrario imprime \"Horrible\".",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Ciclos"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b=0, c=0, d;\n    cin>>a;\n    for(auto i=1; i<=a/2; i++){\n        cin>>d;\n        b+=d;\n    }\n    for(auto i=1; i<=a/2; i++){\n        cin>>d;\n        c+=d;\n    }\n    if(b==c){\n        cout<<\"Genial\";\n    }\n    else{\n        cout<<\"Horrible\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "4576. ParesenRejilla",
        "url": "https://omegaup.com/arena/problem/ParesenRejilla/",
        "descripcion": "Realice un programa pida un número n, luego pedirá los números necesarios para llenar un arreglo de nxn elementos. Despues desplegará el arreglo, renglon por renglon sin espacio entre las columnas. Al final desplegará el modulo 2 de cada elemento del arreglo por renglones, sin espacio entre las columnas.",
        "entrada": "Un entero n.",
        "salida": "El contenido del arreglo, n renglones con n elementos cada uno. Seguido por el modulo 2 de cada elemento en n renglones con n elementos cada uno.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Matrices",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "vector<vector<int>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a;\n    vector<vector<int>> num(1001, vector<int>(1001, 0));\n    cin>>a;\n    for(auto i=0; i<a; i++){\n        for(auto j=0; j<a; j++){\n            cin>>num[i][j];\n            cout<<num[i][j];\n        }\n        cout<<\"\\n\";\n    }\n    for(auto i=0; i<a; i++){\n        for(auto j=0; j<a; j++){\n            cout<<num[i][j]%2;\n        }\n        cout<<\"\\n\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "4243. Coordenadas Cartesianas",
        "url": "https://omegaup.com/arena/problem/Coordenadas-Cartesianas/",
        "descripcion": "Dadas las coordenadas enteras X,Y, de N puntos en un plano cartesiano, determina a qué cuadrante corresponde cada coordenada.",
        "entrada": "En la primera línea el entero N. En cada una de las siguientes N líneas, los enteros X, Y, separados por un espacio. Puedes estar seguro que ninguno de los dos enteros será cero.",
        "salida": "Para cada coordenada, imprime el número romano correspondiente al cuadrante, es decir (I, II, III ó IV).",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Ciclos"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c;\n    cin>>c;\n    while(c--){\n        cin>>a>>b;\n        if(a>0 && b>0){\n            cout<<\"I\\n\";\n        }\n        else if(a<0 && b>0){\n            cout<<\"II\\n\";\n        }\n        else if(a<0 && b<0){\n            cout<<\"III\\n\";\n        }\n        else{\n            cout<<\"IV\\n\";\n        }\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "5321. Misión Imposible",
        "url": "https://omegaup.com/arena/problem/Mision-Imposible-bombas-hgo/",
        "descripcion": "Eres un agente especial, experto en cuestiones de tecnología. Te han mandado llamar debido a la existencia de una situación poco común. Un criminal, reconocido por su inteligencia, ha colocado una red de bombas alrededor de un centro turístico muy importante. Sin embargo, a este maleante le gusta creer que no hay nadie más inteligente que él y, para demostrarlo, le ha dado la oportunidad al gobierno de desactivar las bombas si logran descifrar cómo lograrlo. Cada una de las bombas tiene un contador que indica cuánto falta para que estalle esa bomba. El contador de cada bomba decrece a cierta velocidad; por ejemplo, para una bomba el contador puede disminuir 2 unidades por minuto, para otra 5, etc. A partir del aviso del criminal, todos los contadores comienzan a disminuir a su velocidad correspondiente. Tú puedes detener el contador de cualquier bomba mediante un botón y cada vez que haces esto, te lleva un minuto (esto es, no puedes detener dos contadores al mismo tiempo). Si así lo deseas, puedes dejar pasar tiempo sin detener ninguna bomba. La red de bombas esta configurada de tal manera que si al final, los contadores de todas las bombas marcan el mismo valor, no explotarán. Pero con una sola que quede diferente, tú y todos los turistas, serán historia. Si cualquier bomba llega al valor de cero, o se pasa (negativo) todas las bombas explotarán inmediatamente. Sin embargo, el criminal asegura que su acertijo tiene solución. Al gobierno, obviamente, le interesa que la desactivación de las bombas se lleve a cabo en el menor tiempo posible. Puedes comenzar a detener la primera bomba desde el instante en que comienza el conteo. O sea que puedes congelar el primer contador en su valor inicial. Tu misión, si decides aceptarla, consiste en realizar un programa que: dado el número de bombas, el número inicial de cada contador y la velocidad a la cual disminuye cada bomba, encuentre el contador final que marcarán todas las bombas, si logras desactivarlas.",
        "entrada": "Tu programa deberá leer, en la primera línea, el número N de bombas; en las siguientes N líneas, el valor inicial del contador C y la velocidad V respectiva, para cada bomba. 2<=N<=250, 1<=C<=50000, 1<=V<=100.",
        "salida": "Tu programa deberá escribir, en una sola línea, el valor final que deberán marcar todos los contadores para evitar que las bombas estallen. Si, desafortunadamente, no hay manera de desactivar ninguna de ellas, tu programa deberá imprimir, tristemente, un cero.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Ordenamiento",
            "Vectores",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "vector<struct>",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct sobra{\n    int aa, bb, cc;\n};\n\nbool operator<(sobra x, sobra y){\n    if(x.aa>y.aa)return true;\n    if(y.aa>x.aa)return false;\n    if(x.bb>y.bb)return true;\n    if(y.bb>x.bb)return false;\n    if(x.cc>y.cc)return true;\n    return false;\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a;\n    vector<sobra> num(231);\n    vector<int>falta;\n    cin>>a;\n    for(auto i=0; i<a; i++){\n        cin>>num[i].bb>>num[i].aa;\n    }\n    sort(num.begin(), num.end());\n    while(true){\n        falta.push_back(num[0].cc);\n        for(auto i=1; i<a; i++){\n            while(num[i].bb>num[0].bb){\n                num[i].bb-=num[i].aa;\n                num[i].cc++;\n                if(num[i].bb<=0){\n                    cout<<\"0\";return 0;\n                }\n            }\n            if(num[i].bb!=num[0].bb){\n                falta.clear();break;\n            }\n            else{\n                falta.push_back(num[i].cc);\n            }\n        }\n        if(falta.size()){\n            sort(falta.begin(),falta.end());\n            for(auto i=1; i<falta.size(); i++){\n                if(falta[i]==falta[i-1]){\n                    falta.clear();break;\n                }\n            }\n            if(falta.size()){\n                cout<<num[0].bb;return 0;\n            }\n        }\n        num[0].bb-=num[0].aa;\n        num[0].cc++;\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "6852. Pastes al tanteo",
        "url": "https://omegaup.com/arena/problem/itp18-pastes/",
        "descripcion": "¡Llegó la hora de la comida en el 1er Concurso de Programación del Instituto Tecnológico de Pachuca! Para la comida los organizadores pidieron una caja llena de pastes de los siguientes sabores: Papa con carne, Mole verde, Hawaiano, Zarzamora. Los organizadores habían ya preguntado a cada concursante cuántos pastes iban a querer de cada sabor; pero cuando fueron a comprarlos olvidaron la lista y para no regresar con las manos vacías compraron lo que se les ocurrió en el momento. Tu tarea es decir si los organizadores compraron suficientes pastes para satisfacer lo que los concursantes pidieron originalmente.",
        "entrada": "Cuatro enteros indicando la cantidad de pastes de cada sabor que se compraron. El formato es P M H Z donde: P es la cantidad de pastes de papa con carne, M es la cantidad de pastes de mole verde, H es la cantidad de pastes hawaianos, Z es la cantidad de pastes de zarzamora. Un entero N, indicando el número de concursantes. N renglones, cada renglón seguirá el formato p m h z, donde: p pastes de papa con carne que originalmente pidió el concursante, m pastes de mole verde que originalmente pidió el concursante, h pastes hawaianos que originalmente pidió el concursante, y z pastes de zarzamora que originalmente pidió el concursante. 1<=N<=100, 0<=P,M,H,Z,p,m,h,z<=100.",
        "salida": "Imprime #epicfail si los organizadores no compraron suficientes pastes para satisfacer lo que los concursantes pidieron originalmente. Imprime #win si todos van a poder comer lo que pidieron originalmente (no importa que sobren pastes)",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Ciclos",
            "Cálculos aritméticos"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e, f, g, h, l;\n    cin>>a>>b>>c>>d>>e;\n    while(e--){\n        cin>>f>>g>>h>>l;\n        a-=f;\n        b-=g;\n        c-=h;\n        d-=l;\n    }\n    if(a<0 || b<0 || c<0 || d<0){\n        cout<<\"#epicfail\";\n    }\n    else{\n        cout<<\"#win\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "4452. Rango del arreglo",
        "url": "https://omegaup.com/arena/problem/Rango-del-arreglo/",
        "descripcion": "Escriba un programa que pida 10 numeros y los guarde en un arreglo. Luego debe encontrar el numero mayor en el arreglo y el número menor en el arreglo, y sacar la diferencia entre estos dos números. La salida debe ser el número menor, el numero mayor y la diferencia entre ellos.",
        "entrada": "10 enteros.",
        "salida": "La diferencia entre el número mayor y el menor en el arreglo.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Ordenamiento",
            "Ciclos",
            "Vectores"
        ],
        "estructuras": [
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    vector<int> num(10, 0);\n    for(auto i=0; i<10; i++){\n        cin>>num[i];\n    }\n    sort(num.begin(), num.end());\n    cout<<num[0]<<\" \"<<num[9]<<\" \"<<num[9]-num[0];\n\n    return 0;\n}"
    },
    {
        "titulo": "4108. Matriz Espejo",
        "url": "https://omegaup.com/arena/problem/Matriz-Espejo/",
        "descripcion": "Dada una matriz de MxN (1<=M,N<=100) datos enteros (M filas x N columnas) imprime su matriz espejo, es decir, la matriz reflejada horizontalmente (ver ejemplo)",
        "entrada": "En la primera línea los enteros M, N. Donde M representa el número de filas y N el número de columnas. En cada una de las siguientes M líneas, N enteros. Donde cada entero representa una pieza.",
        "salida": "La matriz espejo.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Ciclos",
            "Matrices"
        ],
        "estructuras": [
            "long long",
            "vector<vector<int>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b;\n    vector<vector<int>> num(101, vector<int>(101, 0));\n    cin>>a>>b;\n    for(auto i=0; i<a; i++){\n        for(auto j=b-1; j>-1; j--){\n            cin>>num[i][j];\n        }\n    }\n    for(auto i=0; i<a; i++){\n        for(auto j=0; j<b; j++){\n            cout<<num[i][j]<<\" \";\n        }\n        cout<<\"\\n\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "4052. Matriz Semejante Diagonal",
        "url": "https://omegaup.com/arena/problem/Matriz-Semejante-Diagonal/",
        "descripcion": "Una matriz semejante es aquella en donde todas las diagonales de derecha a izquierda cumplen la siguiente regla a [ i ][ j ] es igual a a [ j ][ i ]; y una matriz diagonal es aquella donde la diagonal principal cumple la regla: a [ i ][ j ] es igual a a[ i+1 ][ j+1 ]. El problema reside en dado un número N, se recibirá una matriz de N*N números, y si es una matriz semejante diagonal imprima \"SI\" -sin comillas-, en caso contrario (que sea únicamente semejante, únicamente diagonal o ninguna de las anteriores), se imprimirá \"NO\" -sin comillas-.",
        "entrada": "Un número N seguido de N*N números.",
        "salida": "\"SI\" -sin comillas- en caso de ser semejante diagonal o \"NO\" -igual, sin comillas- en caso de que no lo sea.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Matrices",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "vector<vector<int>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a;\n    vector<vector<int>> num(101, vector<int>(101, 0));\n    cin>>a;\n    for(auto i=0; i<a; i++){\n        for(auto j=0; j<a; j++){\n            cin>>num[i][j];\n        }\n    }\n    for(auto i=1; i<a-1; i++){\n        for(auto j=i+1; j<a; j++){\n            if(num[i][j]!=num[j][i]){\n                cout<<\"NO\";return 0;\n            }\n        }\n    }\n    for(auto i=1; i<a; i++){\n        if(num[i][i]!=num[i-1][i-1]){\n            cout<<\"NO\";return 0;\n        }\n    }\n    cout<<\"SI\";\n\n    return 0;\n}"
    },
    {
        "titulo": "1307. Matriz Simétrica",
        "url": "https://omegaup.com/arena/problem/Matriz-Simetrica/",
        "descripcion": "Dados los datos enteros de una matriz de N filas por N columnas. 1<=N<=50. Determina si es una matriz simétrica. Una matriz es simétrica cuando el valor de la casilla i,j es igual al valor de la casilla j,i.",
        "entrada": "En la primera línea el entero N, que denota el número de filas y columnas de la matriz. En cada una de las siguientes N filas, N enteros separados por espacios.",
        "salida": "SI en caso de que la matriz sea simétrica, NO en caso contrario.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Matrices",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "vector<vector<int>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a;\n    vector<vector<int>> num(101, vector<int>(101, 0));\n    cin>>a;\n    for(auto i=0; i<a; i++){\n        for(auto j=0; j<a; j++){\n            cin>>num[i][j];\n        }\n    }\n    for(auto i=1; i<a-1; i++){\n        for(auto j=i+1; j<a; j++){\n            if(num[i][j]!=num[j][i]){\n                cout<<\"NO\";return 0;\n            }\n        }\n    }\n    cout<<\"SI\";\n\n    return 0;\n}"
    },
    {
        "titulo": "3635. Snow White",
        "url": "https://omegaup.com/arena/problem/Snow-White/",
        "descripcion": "Todo los días, mientras los enanos están trabajando en las minas, Blanca Nieves prepara la cena para ellos; Siete sillas, siete platos, siete tenedores, siete cuchillos para siete enanos hambrientos. Un día nueve enanos llegan de las minas en lugar de siete (nadie sabe cómo ni porqué), cada uno de ellos dice ser uno de los siete enanos de Blanca Nieves. Afortunadamente, cada enano tiene un sombrero con un número positivo menor a 100 escrito sobre este. Blanca Nieves, una famosa matemática, realizo la suma de los números que tienen los sombreros de sus siete enanos, la cual era exactamente 100. Escribe un programa que determine cuales son los siete enanos que la suma de sus sombreros sea exactamente 100.",
        "entrada": "Serán 9 líneas de entrada. Cada línea contendrá un número entre 1 y 99 (inclusive). Para cada caso, la solución será unica.",
        "salida": "Tu programa debe producir exactamente siete lienas de salida -los números que tienen los enanos de Blanca Nieves-. Los sombreros deben estar ordenados de menor a mayor.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores",
            "Ordenamiento",
            "Ciclos"
        ],
        "estructuras": [
            "vector<int>",
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<int> num(9, 0);\n\nint falta(int x, int z){\n    for(auto i=0; i<9; i++){\n        if(i!=x && i!=z){\n            cout<<num[i]<<\"\\n\";\n        }\n    }\n    return 0;\n}\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a;\n    cin>>num[0]>>num[1]>>num[2]>>num[3]>>num[4]>>num[5]>>num[6]>>num[7]>>num[8];\n    sort(num.begin(), num.end());\n    a=num[0]+num[1]+num[2]+num[3]+num[4]+num[5]+num[6]+num[7]+num[8];\n    if((a-(num[0]+num[1]))==100){\n        falta(0, 1);return 0;\n    }\n    if((a-(num[0]+num[2]))==100){\n        falta(0, 2);return 0;\n    }\n    if((a-(num[0]+num[3]))==100){\n        falta(0, 3);return 0;\n    }\n    if((a-(num[0]+num[4]))==100){\n        falta(0, 4);return 0;\n    }\n    if((a-(num[0]+num[5]))==100){\n        falta(0, 5);return 0;\n    }\n    if((a-(num[0]+num[6]))==100){\n        falta(0, 6);return 0;\n    }\n    if((a-(num[0]+num[7]))==100){\n        falta(0, 7);return 0;\n    }\n    if((a-(num[0]+num[8]))==100){\n        falta(0, 8);return 0;\n    }\n    if((a-(num[1]+num[2]))==100){\n        falta(1, 2);return 0;\n    }\n    if((a-(num[1]+num[3]))==100){\n        falta(1, 3);return 0;\n    }\n    if((a-(num[1]+num[4]))==100){\n        falta(1, 4);return 0;\n    }\n    if((a-(num[1]+num[5]))==100){\n        falta(1, 5);return 0;\n    }\n    if((a-(num[1]+num[6]))==100){\n        falta(1, 6);return 0;\n    }\n    if((a-(num[1]+num[7]))==100){\n        falta(1, 7);return 0;\n    }\n    if((a-(num[1]+num[8]))==100){\n        falta(1, 8);return 0;\n    }\n    if((a-(num[2]+num[3]))==100){\n        falta(2, 3);return 0;\n    }\n    if((a-(num[2]+num[4]))==100){\n        falta(2, 4);return 0;\n    }\n    if((a-(num[2]+num[5]))==100){\n        falta(2, 5);return 0;\n    }\n    if((a-(num[2]+num[6]))==100){\n        falta(2, 6);return 0;\n    }\n    if((a-(num[2]+num[7]))==100){\n        falta(2, 7);return 0;\n    }\n    if((a-(num[2]+num[8]))==100){\n        falta(2, 8);return 0;\n    }\n    if((a-(num[3]+num[4]))==100){\n        falta(3, 4);return 0;\n    }\n    if((a-(num[3]+num[5]))==100){\n        falta(3, 5);return 0;\n    }\n    if((a-(num[3]+num[6]))==100){\n        falta(3, 6);return 0;\n    }\n    if((a-(num[3]+num[7]))==100){\n        falta(3, 7);return 0;\n    }\n    if((a-(num[3]+num[8]))==100){\n        falta(3, 8);return 0;\n    }\n    if((a-(num[4]+num[5]))==100){\n        falta(4, 5);return 0;\n    }\n    if((a-(num[4]+num[6]))==100){\n        falta(4, 6);return 0;\n    }\n    if((a-(num[4]+num[7]))==100){\n        falta(4, 7);return 0;\n    }\n    if((a-(num[4]+num[8]))==100){\n        falta(4, 8);return 0;\n    }\n    if((a-(num[5]+num[6]))==100){\n        falta(5, 6);return 0;\n    }\n    if((a-(num[5]+num[7]))==100){\n        falta(5, 7);return 0;\n    }\n    if((a-(num[5]+num[8]))==100){\n        falta(5, 8);return 0;\n    }\n    if((a-(num[6]+num[7]))==100){\n        falta(6, 7);return 0;\n    }\n    if((a-(num[6]+num[8]))==100){\n        falta(6, 8);return 0;\n    }\n    if((a-(num[7]+num[8]))==100){\n        falta(7, 8);return 0;\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "2193. Letras Faltantes",
        "url": "https://omegaup.com/arena/problem/LetrasFaltantes/",
        "descripcion": "Los fanáticos del chat quieren escribir cada vez más rápido, con el fin de escribir la mayor cantidad de palabras en el menor tiempo posible. Pero escribir rápido no es para cualquiera, por lo que siempre sucede que hay letras faltantes en las palabras que intentamos escribir. Por ejemplo, si queremos escribir la palabra \"fiesta\" puede ser que la escribamos como \"fsta\" entones las letras faltantes serán \"ie\", o también puede pasar que escribamos \"iest\", entonces las letras faltantes serán \"fa\". Las letras faltantes son aquellas que no fueron escritas mientras tratabas de escribir la palabra completa. Tu amig@ te escribe una palabra S y has identificado como posible palabra (la que crees que quiso escribir) a P. Le quieres decir a tu amig@, según tu palabra P, cuales son las letras que se le olvidaron escribir. Sin embargo no siempre es acertada su palabra P, así que en este caso, decimos que no es posible identificar las letras. Dada la palabra S que te escribieron y tu posible palabra P determina, si es posible, cuales son las letras faltantes.",
        "entrada": "En la primera línea dos números enteros positivos 0 < n, m < 50, que indican la cantidad de letras en la palabra S y P respectivamente. En las siguientes dos líneas, la palabra S y la palabra P. Los caracteres que pueden tener S y P son: letras minúsculas, números comas y puntos.",
        "salida": "Una línea que contenga las letras faltantes, recordar que las letras faltantes son aquellas que fueron omitidas mientras se escribían. Si la palabra P no puede ser generada agregando letras a S, entonces debes escribir \"no entiendo\" (sin comillas).",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c;\n    string z, zz, zzz;\n    while(cin>>a){\n        cin>>b>>z>>zz;\n        c=0;\n        zzz=\"\";\n        for(auto i=0; i<zz.size(); i++){\n            if(zz[i]==z[c]){\n                c++;\n                if(c==a){\n                    i++;\n                    while(i!=b){\n                        zzz=zzz+zz[i];\n                        i++;\n                    }\n                    break;\n                }\n            }\n            else{\n                zzz=zzz+zz[i];\n            }\n        }\n        if(c!=a){\n            cout<<\"no entiendo\\n\";\n        }\n        else{\n            cout<<zzz<<\"\\n\";\n        }\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "6227. Sumas con números grandes",
        "url": "https://omegaup.com/arena/problem/sumas-con-numeros-grandes/",
        "descripcion": "Dados dos enteros A,B(0<=A,B<=10^1000), imprima la suma de ambos números.",
        "entrada": "Recibirás dos valores enteros positivos con hasta 1001 dígitos. Los números no estarán necesariamente en la misma línea.",
        "salida": "Mostrar la suma de A + B.",
        "nivel": "Intermedio (fácil) - Matemáticas en la programación",
        "categorias": [
            "Ciclos",
            "Caracteres y cadenas",
            "Números grandes",
            "Implementación",
            "Cálculos aritméticos"
        ],
        "estructuras": [
            "long long",
            "string",
            "char"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c=0, d;\n    string g, m=\"\", z=\"\";\n    char n=48;\n    cin>>g>>m;\n    if(m.size()>g.size()){\n        swap(m, g);\n    }\n    for(long long i=g.size()-1, j=m.size()-1; i>-1; i--, j--){\n        a=g[i]-48;\n        if(j>-1){\n            b=m[j]-48;\n        }\n        else{\n            b=0;\n        }\n        d=a+b+c;\n        c=d/10;\n        d%=10;\n        n=48+d;\n        z=n+z;\n    }\n    if(c){\n        n=48+c;\n        z=n+z;\n    }\n    cout<<z;\n    \n    return 0;\n}"
    },
    {
        "titulo": "7281. Sumas iguales",
        "url": "https://omegaup.com/arena/problem/Sumas-iguales/",
        "descripcion": "Los organizadores de concursos están buscando equilibrar las edades de los participantes y ponerlos a competir entre equipos. Por lo que son ordenados de menor a mayor y se les asigna un número desde 1 hasta N. Si se considera un participante con un número x la suma de los anteriores a el y los superiores a el son iguales, entonces se considera que están equilibrados. La salida deberá ser el número x un espacio y el número de entrada N.",
        "entrada": "La entrada es un valor entero N. 3 <= N <= 10000000. Tiempo máximo 10s",
        "salida": "La salida deberá constar de dos números. El primero es x la posición que cumple la condición, la suma de sus antecesores es igual a la suma de sus sucesores y N el número de entrada.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Ciclos"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b=0, c, d=1;\n    cin>>a;\n    c=(a*(a+1))/2;\n    c--;\n    while(b!=c){\n        b+=d;\n        d++;\n        c-=d;\n    }\n    cout<<d<<\" \"<<a;\n    \n    return 0;\n}"
    },
    {
        "titulo": "2462. SumasCuadradas",
        "url": "https://omegaup.com/arena/problem/SumasCuadradas/",
        "descripcion": "En esta ocasión nuestro amigo Martín tiene un pequeño problema, como químico loco que se respeta(decimos que se respeta para que no llore...) odia las matemáticas, en la escuela le han pedido resolver un problema matemático que consiste de lo siguiente: Una matríz de nuemros de N*N, el problema consiste en decir la suma de todas las filas y las columnas y decir la suma total de la matriz. Ayuda a Martín a resolver su problema para evitar reprobar Cálculo Integral III.",
        "entrada": "En la primera linea N que representa las dimensiones de la matríz. En las siguientes N líneas habrá N enteros representando el número en esa posición de la matríz.",
        "salida": "Debes dejar N líneas con las sumas de las N filas, N líneas con las sumas de las N columnas, y finalmente una línea con un entero representando la suma total de la matríz.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Cálculos aritméticos",
            "Matrices",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "vector<vector<int>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c=0;\n    vector<vector<int>> num(1001, vector<int>(1001, 0));\n    cin>>a;\n    for(auto i=0; i<a; i++){\n        b=0;\n        for(auto j=0; j<a; j++){\n            cin>>num[i][j];\n            b+=num[i][j];\n            c+=num[i][j];\n            num[a][j]+=num[i][j];\n        }\n        cout<<b<<\"\\n\";\n    }\n    for(auto i=0; i<a; i++){\n        cout<<num[a][i]<<\"\\n\";\n    }\n    cout<<c;\n    \n    return 0;\n}"
    },
    {
        "titulo": "4460. Una Bebida Interesante",
        "url": "https://omegaup.com/arena/problem/Una-Bebida-Interesante/",
        "descripcion": "Marco es una persona que adora tomar descansos luego del trabajo, asi que va a comprar una bebida en una tienda cercana. Él ama InkaCola, que es vendida en n diferentes tiendas en Trujillo, se sabe que el precio de una botella en una tienda \"i\" es igual a x_i monedas. Marco planea comprar InkaCola por q dias consecutivos, él sabe que en un dia \"i\", él puede gastar m_i monedas. Ahora, tu tarea es determinar, para cada uno de los dias, en cuantas tiendas diferentes puede comprar una InkaCola.",
        "entrada": "Un numero n (1 ≤ n ≤ 100 000) que representa el numero de tiendas en Trujillo la segunda linea contiene n numeros enteros x_i (1 ≤ xi ≤ 100 000) que representa los precios de la bebida en la tienda \"i\" la tercera linea contiene un numero q (1 ≤ q ≤ 100 000) que representa el numero de dias que Marco comprara comprar InkaCola luego q lineas que contienen un numero entero m_i(1 ≤ mi ≤ 10^9) que representa el numero de monedas que Marco puede gastar en un dia \"i\".",
        "salida": "Imprimir q numeros.el numero en la posicion \"i\" deben ser igual al numero de tiendas donde Marco sera capaz de comprar una botella de bebida en el dia \"i\".",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Ordenamiento",
            "Ciclos",
            "Vectores"
        ],
        "estructuras": [
            "long long",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b=0, c=0;\n    vector<int> num(100001, 0);\n    vector<int> sub(100001, 0);\n    cin>>a;\n    for(auto i=0; i<a; i++){\n        cin>>num[i];\n    }\n    sort(num.begin(), num.end());\n    for(auto i=1; i<100001; i++){\n        if(i==num[b]){\n            c++;\n            b++;\n        }\n        sub[i]=c;\n    }\n    cin>>a;\n    while(a--){\n        cin>>b;\n        cout<<sub[b]<<\"\\n\";\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "422. E amelborP",
        "url": "https://omegaup.com/arena/problem/E-amelborP/",
        "descripcion": "Aprenderás a leer una cadena e imprimirla al revés.(charAt y print [sin salto de línea]. Hoy en día muchas personas estudian chino porque según algunos gurús este será el idioma más extendido en el futuro. Ahora bien, ¿qué pasaría si el día de mañana el ser humano descubre la forma de expandirse por el espacio? Quizá los idiomas terrícolas empezarían a parecer bastante menos atractivos ¿verdad? Por eso hay que comenzar a ejercitar nuestro cerebro con, por lo menos, nuestro propio idioma pero al revés.",
        "entrada": "Vas a leer por líneas hasta que se llegue al fin de archivo.",
        "salida": "La línea que leíste la debes imprimir en el orden inverso.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas",
            "Ciclos"
        ],
        "estructuras": [
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    string g;\n    while(getline(cin, g)){\n        for(auto i=g.size()-1; i>-1; i--){\n            cout<<g[i];\n        }\n        cout<<\"\\n\";\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "3919. Decimal a Binario | ASINUS",
        "url": "https://omegaup.com/arena/problem/Binario-a-Decimal--ASINUS/",
        "descripcion": "Para complementar la clase de Circuitos Lógicos el profesor pide a los alumnos que hagan un programa en el cual ingrese un número N entero y como resultado imprima el binario de ese número.",
        "entrada": "Un número N entero. El número debe ser 0<=N<=500.",
        "salida": "El número N convertido en binario. Si N>500 o N<0 imprime error.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Pilas",
            "Ciclos",
            "Cálculos aritméticos"
        ],
        "estructuras": [
            "long long",
            "stack<long long>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    stack<long long> falta;\n    long long a, b;\n    cin>>a;\n    if(a<0 || a>500){\n        cout<<\"Error\";\n    }\n    else{\n        while(a){\n            b=a%2;\n            falta.push(b);\n            a/=2;\n        }\n        while(falta.size()){\n            cout<<falta.top()<<\"\\n\";\n            falta.pop();\n        }\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "3964. Lista de Adyacencia",
        "url": "https://omegaup.com/arena/problem/Lista-de-Adyacencia/",
        "descripcion": "Dada una gráfica con n vértices y m aristas, los vértices están numerados del 0 al n-1. Escribe un programa que imprima la lista de adyacencia del la gráfica.",
        "entrada": "La primera línea contiene 2 números, n y m, (2<=n<=10000), (0<=m<=11000), indicando el número de vértices y aristas en la gráfica. Le siguen m líneas, cada una con dos enteros a y b, indicando que hay una arista que conecta el vértice a con el vértice b y viceversa.",
        "salida": "La lista de adyacencia de la gráfica tal como se muestra en el ejemplo.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Colas",
            "Vectores",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "vector<queue<int>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d;\n    vector<queue<int>> num(10000);\n    cin>>a>>b;\n    while(b--){\n        cin>>c>>d;\n        num[c].push(d);\n        num[d].push(c);\n    }\n    for(auto i=0; i<a; i++){\n        cout<<i<<\": \";\n        while(num[i].size()>1){\n            cout<<num[i].front()<<\"->\";\n            num[i].pop();\n        }\n        if(num[i].size()){\n            cout<<num[i].front();\n        }\n        cout<<\"\\n\";\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "4311. La lista de asistencia",
        "url": "https://omegaup.com/arena/problem/ListaAsistencia/",
        "descripcion": "Andrea una profesora de una primaria llamada \"Escuela para gente cool\" ha prometido a sus alumnos que quien falte menos tendrá un 10 absoluto. Como Andrea es muy olvidadiza identifica a sus alumnos por número de lista. Ella tiene un registro de asistencias y te ha pedido ayuda para saber quién tiene un 10 absoluto. Dado una cantidad de alumnos N, una cantidad de días D y los registros de asistencias, determinar cuál alumno merece un 10 absoluto.",
        "entrada": "En la primera línea dos enteros N, D que indican la cantidad de alumnos y la cantidad de días respectivamente. En las siguientes D líneas, N enteros separados por un espacio en los cuales puede estar “1” que indica que si vino ese día o un \"0\" que indica una falta. 1<=N, D<=100. El número de lista de los alumnos esta indexado en 1. Andrea no tiene vocación de maestra. Para un conjunto de casos con un valor de [30 puntos] D=1. Para un conjunto de casos con un valor de [10 puntos] N=1.",
        "salida": "El número de lista del alumno que tiene más asistencias, en caso de haber más de uno, imprimirlos todos en orden ascendente separados por un espacio.",
        "nivel": "Intermedio (difícil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Matrices",
            "Colas",
            "Ciclos"
        ],
        "estructuras": [
            "vector<vector<int>>",
            "long long",
            "queue<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n  vector<vector<int>> num(101, vector<int>(101, 0));\n    long long a, b, c, d=0;\n   queue<int> falta;\n    cin>>a>>b;\n    for(auto i=1; i<=b; i++){\n        for(auto j=1; j<=a; j++){\n            cin>>num[i][j];\n        }\n    }\n    for(auto i=1; i<=a; i++){\n        c=0;\n        for(auto j=1; j<=b; j++){\n            c+=num[j][i];\n        }\n        if(c>d){\n            while(falta.size()){\n                falta.pop();\n            }\n            d=c;\n            falta.push(i);\n        }\n        else if(c==d){\n            falta.push(i);\n        }\n    }\n    while(falta.size()){\n        cout<<falta.front()<<\" \";\n        falta.pop();\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "7353. Calificaciones recursivas",
        "url": "https://omegaup.com/arena/problem/Calificaciones-recursivas/",
        "descripcion": "En cierta escuela, la calificación final de los alumnos es el promedio entero de las calificaciones de sus evaluaciones parciales. Normalmente la calificación de una evaluación parcial se denota por un dígito del 0 al 9 (en esta escuela no ponen 10 de calificación), pero ocasionalmente una evaluación parcial está dividida en subevaluaciones. Cuando esto ocurre, la calificación de la evaluación parcial es el promedio entero de sus subevaluaciones. Por si fuera poco, algunas subevaluaciones pueden estar divididas en subsubevaluaciones y así sucesivamente. Cuentas con una cadena que representa las calificaciones que obtuviste durante el año y quisieras calcular tu calificación final del curso. En esta cadena, un dígito es una calificación y un grupo de caracteres entre paréntesis denota que una calificación está dada por el promedio de las calificaciones del grupo. Por ejemplo, para la cadena (5955) tu promedio final es 6 mientras que para la cadena (5(95)5) primero se calcula el promedio del grupo interno, lo que resulta en (575), y luego se calcula el promedio final, el cual es 5. Escribe un programa que te ayude a calcular tu calificación final.",
        "entrada": "Una cadena de a lo más 200,000 caracteres, la cual consiste de dígitos y paréntesis balanceados. Puedes suponer que la cadena comienza y termina en paréntesis de apertura y cierre respectivamente, que el resto de los paréntesis (si es que existen) están anidados y que ningún grupo de caracteres delimitados por paréntesis contiene una cantidad vacía de calificaciones.",
        "salida": "Un entero que sea tu calificación final.",
        "nivel": "Intermedio (medio) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Recursión",
            "Pilas",
            "Caracteres y cadenas",
            "Ciclos"
        ],
        "estructuras": [
            "stack<pair<int, int>",
            "pair<int, int>",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n  stack<pair<int, int> >falta;\n  pair<int, int>y;\n  string z;\n    cin>>z;\n    for(auto i=1; i<z.size()-1; i++){\n        if(z[i]=='('){\n            falta.push(y);\n            y.first=0;\n            y.second=0;\n        }\n        else if(z[i]==')'){\n            y.first/=y.second;\n            y.first+=falta.top().first;\n            y.second=1+falta.top().second;\n            falta.pop();\n        }\n        else{\n            y.first+=(z[i]-48);\n            y.second++;\n        }\n    }\n    y.first/=y.second;\n    cout<<y.first;\n    \n    return 0;\n}"
    },
    {
        "titulo": "4333. Formula Recursiva Tres",
        "url": "https://omegaup.com/arena/problem/Formula-Recursiva-Tres/",
        "descripcion": "Debes revisar la siguiente definición de la función recursiva para n: Caso base: Si n es menor o igual a 5, la función imprime y devuelve la cadena \"1\". Caso recursivo: Si n es mayor que 5, la función se llama recursivamente con n-2 y almacena el resultado para procesamiento. Debes imprimir cada valor intermedio de la serie, hasta que termine la recursión. n puede tomar un valor de 1 hasta 120 (1<=n <=120).",
        "entrada": "",
        "salida": "",
        "nivel": "Intermedio (medio) - Matemáticas en la programación",
        "categorias": [
            "Recursión",
            "Caracteres y cadenas",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "char",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long a, b, c;\nchar zz;\n\nstring re(long long o){\n    string z;\n    if(o<6){\n        cout<<\"1\\n\";\n        z=\"1\";\n        return z;\n    }\n    else{\n        z=re(o-2);\n        b=0;\n        for(auto i=z.size()-1; i>-1; i--){\n            c=((z[i]-48)*5)+b;\n            b=c/10;\n            c%=10;\n            z[i]=48+c;\n        }\n        if(b){\n            zz=48+b;\n            z=zz+z;\n            b=0;\n        }\n        cout<<z<<\"\\n\";\n        return z;\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    cin>>a;\n    re(a);\n    \n    return 0;\n}"
    },
    {
        "titulo": "5479. Palíndromos especiales",
        "url": "https://omegaup.com/arena/problem/Palindromos-especiales/",
        "descripcion": "Para el Coding Cup se han sacado de la manga dos tipos los palíndromos, los completos y los parciales. Los COMPLETOS son aquellas palabras que se leen igual de adelante hacia atrás y viceversa y además coinciden sus mayúsculas y minúsculas, por ejemplo \"OSO\" es un palíndromo completo y \"oSo\" también lo es. El otro tipo de palíndromos son los PARCIALES. Se definen como aquellos palíndromos que pueden tener variaciones en las mayúsculas y minúsculas, por ejemplo \"IsaacNoRoncaAsi\". Desarrolla un programa que lea N palabras e imprima primero los palíndromos completos y después los palíndromos parciales.",
        "entrada": "En la primera línea se leerá un entero N donde 1<=N<=100, seguido de N cadenas de caracteres. Estas cadenas son palabras sin espacios que contienen solamente letras de la “a” a la “z” del alfabeto inglés y pueden ser mayúsculas o minúsculas.",
        "salida": "Se debe imprimir el texto \"*PALINDROMOS COMPLETOS*\" seguido de todos los palíndromos completos que se encuentren en la lista con su respectivo salto de línea. Al finalizar esta lista se debe imprimir un salto de línea para separar las dos listas. A continuación se debe imprimir el texto \"*PALINDROMOS PARCIALES*\" seguido de todos los palíndromos parciales que se encuentran en la lista de entrada con su respectivo salto de línea. Si no se encuentran palíndromos completos se debe imprimir \"-1\" en lugar de la lista de palíndromos completos. Si no se encuentran palíndromos parciales se debe imprimir \"-1\" en lugar de la lista de palíndromos parciales. Importante: La lista de palíndromos completos y la lista de palíndromos parciales se debe imprimir en el mismo orden en el que se fueron leyendo.",
        "nivel": "Intermedio (fácil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Caracteres y cadenas",
            "Colas",
            "Ciclos"
        ],
        "estructuras": [
            "queue<string>",
            "long long",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    queue<string> falta;\n    queue<string> sobra;\n    long long a, b;\n    string z;\n    cin>>a;\n    while(a--){\n        cin>>z;\n        b=0;\n        for(auto i=0, j=z.size()-1; i<z.size()/2; i++, j--){\n            if(z[i]!=z[j]){\n                if(z[i]!=(z[j]-32) && z[i]!=(z[j]+32)){\n                    z=\"\";break;\n                }\n                else{\n                    b=1;\n                }\n            }\n        }\n        if(z.size()){\n            if(!b){\n                falta.push(z);\n            }\n            else{\n                sobra.push(z);\n            }\n        }\n    }\n    cout<<\"*PALINDROMOS COMPLETOS*\\n\";\n    if(falta.size()){\n        while(falta.size()){\n            cout<<falta.front()<<\"\\n\";\n            falta.pop();\n        }\n    }\n    else{\n        cout<<\"-1\\n\";\n    }\n    cout<<\"\\n*PALINDROMOS PARCIALES*\\n\";\n    if(sobra.size()){\n        while(sobra.size()){\n            cout<<sobra.front()<<\"\\n\";\n            sobra.pop();\n        }\n    }\n    else{\n        cout<<\"-1\\n\";\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "2985. Carretes",
        "url": "https://omegaup.com/arena/problem/Carretes/",
        "descripcion": "En un tipo de caja registradora antigua, para mostrar los precios, se utilizaba un carrete con los dígitos del 0 al 9 escritos alrededor, para representar cada una de las cifras. este carrete podía girar, hacia delante o hacia atrás, avanzando de uno en uno los dígitos hasta legar al numero deseado y girando cada uno hacia el sentido que requiera menor numero de pasos Tu deseas conocer cuantos de estos pasos realiza la maquina para cambiar de un precio a otro. Debes realizar un programa que, conociendo la cantidad de carretes que tiene la maquina, el precio inicial y el precio final, calcule el numero de pasos que realizara el mecanismo para llegar de uno a otro.",
        "entrada": "Tu programa deberá leer del teclado los siguientes datos: en la primera línea el número de carretes N, que puede ser desde 2 hasta 200. En la segunda línea, el precio inicial como una cadena de N caracteres y en la tercera línea el precio final. Como otra cadena de caracteres.",
        "salida": "Tu programa debe escribir en pantala el número total de pasos que realizará la máquina para llegar del precio inicial al precio final",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b=0;\n    string z, zz;\n    cin>>a>>z>>zz;\n    for(auto i=0; i<a; i++){\n        if(z[i]==zz[i]){\n            continue;\n        }\n        if(z[i]>zz[i]){\n            b+=(min(z[i]-zz[i], (zz[i]+10)-z[i]));\n        }\n        else{\n            b+=(min(zz[i]-z[i], (z[i]+10)-zz[i]));\n        }\n    }\n    cout<<b;\n    \n    return 0;\n}"
    },
    {
        "titulo": "8640. John Freddy y los numeros",
        "url": "https://omegaup.com/arena/problem/John-Freddy-y-los-numeros/",
        "descripcion": "John Freddy es un estudiante que le gusta jugar mucho al fútbol, pero por estar jugando se le olvido hacer la tarea, por esa te pide el favor que le ayudes. La tarea consiste en dado un arreglo de N números, quieres saber cuanto es el máximo producto que se puede hacer escogiendo dos números del arreglo.",
        "entrada": "Un número N seguido de N enteros, a_0,a_1,...,a_(n-1). (2<=N<=1000000), (-10000000<=a_i<=10000000).",
        "salida": "El máximo producto que se puede hacer escogiendo dos números del arreglo.",
        "nivel": "Intermedio (medio) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Ordenamiento",
            "Algoritmos voraces"
        ],
        "estructuras": [
            "long long",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<int>falta;\nvector<int>sum;\n\nvoid num(){\n    sort(falta.begin(), falta.end());\n    if(falta.size()){\n        sum.push_back(falta[0]);\n    }\n    if(falta.size()>=2){\n        sum.push_back(falta[1]);\n    }\n    if(falta.size()>=3){\n        sum.push_back(falta[2]);\n    }\n    if(falta.size()>=4){\n        sum.push_back(falta[falta.size()-1]);\n    }\n    if(falta.size()>=5){\n        sum.push_back(falta[falta.size()-2]);\n    }\n    if(falta.size()>=6){\n        sum.push_back(falta[falta.size()-3]);\n    }\n    falta.clear();\n}\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d;\n    cin>>a;\n    while(a--){\n        cin>>b;\n        falta.push_back(b);\n        if(falta.size()==200000){\n            num();\n        }\n    }\n    num();\n    sort(sum.begin(), sum.end());\n    b=sum[0]*sum[1];\n    c=sum[sum.size()-1]*sum[sum.size()-2];\n    d=max(b, c);\n    cout<<d;\n    \n    return 0;\n}"
    },
    {
        "titulo": "6987. Maquina de billetes",
        "url": "https://omegaup.com/arena/problem/Maquina-de-billetes/",
        "descripcion": "Acabas de comprar una máquina de hacer billetes. Al final de cada día la puedes usar para imprimir X_1 billetes. Al principio de cada día, puedes pagar U billetes para mejorar la máquina (se puede hacer máximo una mejora por día). Esto significa que si empiezas el día con una mejora, podrás imprimir X_2 billetes más que antes. Basicamente, si mejoras la máquina K veces, podrás imprimir X_1 + K* X_2 billetes. Inicialmente tienes C billetes. ¿Cuál es la máxima cantidad de dinero que puedes tener al final del día N?.",
        "entrada": "La primera y única línea contiene 5 enteros: N, C, X_1, U, X_2. (1<=N<=100000), (0<=C,U<=1000), (1<=X_1, X_2<=100). Para el 50% de los casos: (1<=N<=100)",
        "salida": "Una línea con la respuesta.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e, f;\n    cin>>a>>b>>c>>d>>e;\n    f=(a*c)+b;\n    for(auto i=1; i<=a; i++){\n        if((b-d)>-1 && (((c+e)*((a-i)+1))+(b-d))>=f){\n            f=(((c+e)*((a-i)+1))+(b-d));\n            b-=d;\n            c+=e;\n        }\n        b+=c;\n    }\n    cout<<f;\n    \n    return 0;\n}"
    },
    {
        "titulo": "1757. IOI 1996 - Ordenando una Secuencia de Tres Valores",
        "url": "https://omegaup.com/arena/problem/Ordenando-Sec-Tres-Val/",
        "descripcion": "Ordenando una Secuencia de Tres Valores. Ordenar es una de las tareas más frecuentes en la computación. Considera el siguiente problema especial de ordenamiento, donde los elementos a ordenar solo tienen tres valores diferentes. Esta situación se presenta, por ejemplo, cuando se quiere ordenar los medallistas de una competencia de acuerdo al valor de su medalla, esto es, los medallistas de oro van primero, seguidos de los medallistas de plata y finalmente vienen los ganadores de medalla de bronce. En esta tarea los posibles valores de una secuencia son los enteros 1, 2 y 3. Se requiere ordenar de menor a mayor. Para ordenar la secuencia es necesario realizar operaciones de intercambio. Una operación de intercambio se define como, dados dos números p y q, intercambiar los elementos de la secuencia S_p y S_q. Dada una secuencia de n valores (1<=n<=200,000), calcula el mínimo número de operaciones de intercambio necesarias para ordenarla. Para hacer esta tarea un poco más difícil, también es necesario que imprimas una serie válida de operaciones de intercambio para lograr el ordenamiento. Cualquier serie de operaciones que ordene la secuencia será considerada correcta.",
        "entrada": "La primer línea de entrada contendrá un entero n. La siguiente línea contendrá n enteros. El i-ésimo entero representa el valor de S_i.",
        "salida": "Imprime en la primer línea k, el mínimo número de operaciones necesarias para ordenar la secuencia. En la siguientes k líneas imprime dos enteros p_i y q_i (1<=p_i, q_i <=n). La i-ésima línea representa los índices p_i y q_i que se intercambiarán en la i-ésima operación.",
        "nivel": "Intermedio (difícil) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Vectores",
            "Algoritmos voraces",
            "Colas"
        ],
        "estructuras": [
            "long long",
            "vector<pair<int, int>>",
            "vector<int>",
            "queue<int>",
            "pair<int, int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b=0, c=0, d;\n    vector<pair<int, int> >falta;\n    vector<int> num(200001, 0);\n    queue<int>sub;\n    pair<int, int>z;\n    cin>>a;\n    for(auto i=1; i<=a; i++){\n        cin>>num[i];\n        if(num[i]==1){\n            b++;\n        }\n        else if(num[i]==3){\n            c++;\n        }\n    }\n    c=(a-c)+1;\n    d=a;\n    for(auto i=1; i<=b; i++){\n        if(num[i]==2){\n            sub.push(i);\n        }\n        else if(num[i]==3){\n            for(a; true; a--){\n                if(num[a]==1){\n                    z.first=i;\n                    z.second=a;\n                    falta.push_back(z);\n                    num[a]=3;break;\n                }\n            }\n        }\n    }\n    while(sub.size()){\n        for(a; true; a--){\n            if(num[a]==1){\n                z.first=sub.front();\n                z.second=a;\n                falta.push_back(z);\n                num[a]=2;break;\n            }\n        }\n        sub.pop();\n    }\n    b++;\n    for(auto i=c; i<=d; i++){\n        if(num[i]==2){\n            for(b; true; b++){\n                if(num[b]==3){\n                    z.first=i;\n                    z.second=b;\n                    falta.push_back(z);\n                    num[b]=2;break;\n                }\n            }\n        }\n    }\n    cout<<falta.size()<<\"\\n\";\n    for(auto i=0; i<falta.size(); i++){\n        cout<<falta[i].first<<\" \"<<falta[i].second<<\"\\n\";\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "4911. Aparición de caracteres en subcadenas",
        "url": "https://omegaup.com/arena/problem/caracteres_subcadenas/",
        "descripcion": "Dada una cadena S de caracteres, escribe un programa que responda correctamente si el caracter C aparece en la subcadena de S que empieza en la posición I y tiene longitud T.",
        "entrada": "La cadena S formada de caracteres alfanuméricos y de longitud a lo más 1,000,000. Posteriormente un entero N seguido de N tripletas C, I, T. Puedes suponer que 1<=N<10,000, que 0<=I<|S| y 1<=T<=|S|-I.",
        "salida": "Para cada pregunta, una línea con un 1 si el caracter aparece en la subcadena indicada y 0 en otro caso.",
        "nivel": "Intermedio (medio) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Caracteres y cadenas",
            "Busqueda binaria",
            "Indices invertidos"
        ],
        "estructuras": [
            "long long",
            "vector<int>",
            "string",
            "char"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e, f;\n    vector<int>num[1000];\n    string z;\n    char zz;\n    cin>>z>>a;\n    for(auto i=0; i<z.size(); i++){\n        num[z[i]].push_back(i);\n    }\n    while(a--){\n        cin>>zz>>b>>c;\n        c=(b+c)-1;\n        d=0;\n        e=num[zz].size()-1;\n        while(d<=e){\n            f=(d+e)/2;\n            if(num[zz][f]>=b && num[zz][f]<=c){\n                cout<<\"1\\n\";b=-1;break;\n            }\n            else if(num[zz][f]<b){\n                d=f+1;\n            }\n            else{\n                e=f-1;\n            }\n        }\n        if(b!=-1){\n            cout<<\"0\\n\";\n        }\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "6212. Llegando al infierno",
        "url": "https://omegaup.com/arena/problem/Llegando-al-infierno/",
        "descripcion": "Tu excelente amigo Santy se siente muy feliz ya que nadie resolvió su último problema anterior (sarcasmo). Porque al parecer en el contrato que hizo con satanás no leyó las letras en pequeño que decían: \"Si nadie de tus alumnos resuelve este problema, tendrás que ir a una aventura al infierno donde tendrás que ganarme\". Como bien sabemos a Santy le gusta cumplir con los tratos (aunque no haya sido su culpa no leer las letras en pequeño), pero este decidió no ir solo; por lo que se llevo a sus alumnos con él de castigo. Al entrar se puede leer un cartel que dice \"no pases, es una muerte segura, si sigues sera tu perdición\", pero a Santy le valió y con una enorme sonrisa se jalo a sus alumnos hacia la entrada. En eso llega el anfitrión (Satanás) y dice \"Uy chavo, mira lo que pasa es que traes a muchos entonces tendrán que dividirse en M grupos, mira así como están voy nombrando quien va a cada grupo\". La forma en la que nombraba los grupos era la siguiente: -El primero va a la fila uno, el segundo en la segunda y así sucesivamente hasta llegar a M, después el que sigue (M+1) va a la fila 1 y por consiguiente el que le sigue (M+2) a la fila 2, así sucesivamente hasta poner a todos en diferentes grupos. Decir como quedaron los grupos divididos al final.",
        "entrada": " N y M que representan el número de alumnos que hay y el número de filas en los se dividirán; respectivamente. Seguido de N números que representan el alumnos N_i. (0<M<=10^3), (0<N<=10^6), (N/M <= 10^3).",
        "salida": " Las M filas con los alumnos que quedaron en cada i grupo en el orden que se fueron poniendo.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores",
            "Colas"
        ],
        "estructuras": [
            "long long",
            "vector<queue<int>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c;\n    vector<queue<int>> num(1001);\n    cin>>a>>b;\n    for(auto i=0; i<a; i++){\n        cin>>c;\n        num[i%b].push(c);\n    }\n    for(auto i=0; i<b; i++){\n        while(num[i].size()){\n            cout<<num[i].front()<<\" \";\n            num[i].pop();\n        }\n        cout<<\"\\n\";\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "2879. Figuras geométricas",
        "url": "https://omegaup.com/arena/problem/Figuras-geometricas/",
        "descripcion": "Escribe un programa que lea un entero N correspondiente al número de vértices de una figura geométrica y determine de que figura se trata.1 vértice PUNTO. 2 vértices LINEA. 3 vértices TRIANGULO. 4 vértices CUADRILATERO. Más de 4 vértices POLIGONO.",
        "entrada": "El entero N que denota el número de vértices de la figura.",
        "salida": "imprime PUNTO, LINEA, TRIANGULO, CUADRILATERO ó POLIGONO según sea el caso. Nota que la salida es en mayúsculas y sin acentos.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Vectores",
            "Ciclos"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a;\n    cin>>a;\n    switch(a){\n        case 1: cout<<\"PUNTO\";break;\n        case 2: cout<<\"LINEA\";break;\n        case 3: cout<<\"TRIANGULO\";break;\n        case 4: cout<<\"CUADRILATERO\";break;\n        default: cout<<\"POLIGONO\";break;\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "7625. DFD a programa",
        "url": "https://omegaup.com/arena/problem/DFD-a-programa/",
        "descripcion": "Realiza un programa como el siguiente diagrama de flujo: Inicio, Leer x, Asignar 1 a b, Asignar x a r, Si x > 1: Asignar x ← x - 1, Asignar r ← r * x, Repetir el proceso desde la condición x > 1, Si no: Si r ≥ 0: Si r == 0: Retornar b, Si no: Retornar r, Si no: Mostrar \"Error\", Fin.",
        "entrada": "Como se especifica en el diagrama de flujo. Tomar en cuenta que la entrada de datos son enteros",
        "salida": "Como se especifica en el diagrama de flujo.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c;\n    cin>>a;\n    b=1;\n    c=a;\n    while(a>1){\n        a--;\n        c*=a;\n    }\n    if(c<0){\n        cout<<\"Error\";return 0;\n    }\n    if(c){\n        cout<<c;\n    }\n    else{\n        cout<<b;\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "2730. Sumatoria",
        "url": "https://omegaup.com/arena/problem/Sumatoria/",
        "descripcion": "Desarrolla un programa que lea N enteros imprime la suma de todos los números leídos, cuantos son positivos y cuantos negativos.",
        "entrada": "En la primera línea el entero N que denota la cantidad de enteros a leer. en la segunda línea los N enteros separados por espacios.",
        "salida": "Tres enteros separados por espacios que denotan la suma, cuantos son positivos y cuantos negativos.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Aritmética",
            "Ciclos"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b=0, c=0, d, e=0;\n    cin>>a;\n    for(auto i=0; i<a; i++){\n        cin>>d;\n        if(d>0){\n            b++;\n        }\n        else{\n            c++;\n        }\n        e+=d;\n    }\n    cout<<e<<\" \"<<b<<\" \"<<c;\n    \n    return 0;\n}"
    },
    {
        "titulo": "8131. Sumatoria de Sumatoria",
        "url": "https://omegaup.com/arena/problem/Sumatoria-de-Sumatoria/",
        "descripcion": "El problema es demasiado sencillo, quiero conocer cual es la sumatoria de la sumatoria de un numero, fácil verdad.",
        "entrada": "De entrada se te dara un entero N (0 < n <= 100000).",
        "salida": "La sumatoria de la sumatoria.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "long long",
            "pow()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b;\n    cin>>a;\n    if(a%2){\n        b=pow((a/2)+1, 2);\n    }\n    for(auto i=1, j=a; i<=a/2; i++, j--){\n        b+=((i*j)*2);\n    }\n    cout<<b;\n    \n    return 0;\n}"
    },
    {
        "titulo": "7151. Una sumatoria muy extraña",
        "url": "https://omegaup.com/arena/problem/Sumatoria-de-sumatorias/",
        "descripcion": "Escribe un programa que evalúe el valor de ∑(i=m, n) i, donde m = ∑(i=1, a) i y n = ∑(i=1, b) i.",
        "entrada": " Dos enteros a,b. Puedes suponer que 1<=a<=b<=100.",
        "salida": " Un entero que sea el valor de la fórmula evaluada.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Aritmética",
            "Ciclos"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c;\n    cin>>a>>b;\n    b=((b+1)*b)/2;\n    a=((a+1)*a)/2;\n    c=(((b+1)*b)/2)-(((a-1)*a)/2);\n    cout<<c;\n    \n    return 0;\n}\n"
    },
    {
        "titulo": "6254. Matriz con Mitades Iguales",
        "url": "https://omegaup.com/arena/problem/Matriz-con-Mitades-Iguales/",
        "descripcion": "Se ingresa un valor entero M (1<=M<=100) y un valor entero N (1<=N<=100 y N es par), y a continuación M filas conteniendo cada una N valores enteros. Si la primer mitad vertical de la matriz (todas las filas y las columnas de 0 a N/2-1), es igual a la segunda mitad vertical, imprimir un \"1\", en otro caso imprimir \"0\".",
        "entrada": "La primer línea de entrada contendrá los valores M y N. Luego vendrán M líneas con los (1<=X_i<=1000) elementos de cada fila separados por un espacio.",
        "salida": "",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Matrices",
            "Vectores"
        ],
        "estructuras": [
            "long long",
            "vector<vector<int>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b;\n    vector<vector<int>> num(200, vector<int>(200, 0));\n    cin>>a>>b;\n    for(auto i=0; i<a; i++){\n        for(auto j=0; j<b; j++){\n            cin>>num[i][j];\n        }\n    }\n    for(auto i=0; i<a; i++){\n        for(auto j=0; j<b/2; j++){\n            if(num[i][j]!=num[i][j+(b/2)]){\n                cout<<\"0\";return 0;\n            }\n        }\n    }\n    cout<<1;\n    \n    return 0;\n}"
    },
    {
        "titulo": "4106. Pivote Reloaded",
        "url": "https://omegaup.com/arena/problem/Pivote-Reloaded/",
        "descripcion": "Un pivote en un conjunto, es un elemento que divide el conjunto en dos, un subconjunto contiene a todos los elementos menores que el pivote y otro subconjunto a todos los mayores. Dado un conjunto de 1<=N<=100 enteros y el pivote K, determina los elementos del conjunto izquierdo del pivote (los menores) y los elementos del conjunto derecho.",
        "entrada": "En la primera línea el entero N que denota cuantos datos hay. En la segunda línea y separados por espacios N enteros. En la tercera línea el pivote K.",
        "salida": "En la primera línea los elementos menores al pivote. En la segunda línea los elemento mayores, en ambos casos separados por un espacio.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Vectores",
            "Colas"
        ],
        "estructuras": [
            "queue<int>",
            "vector<int>",
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int n, m;\n    vector<int> ar(101, 0);\n    queue<int>ar2;\n    cin>>n;\n    for(auto i=0; i<n; i++){\n        cin>>ar[i];\n    }\n    cin>>m;\n    auto i=0;\n    for(; i<n; i++){\n        if(ar[i]>m){\n            ar2.push(ar[i]);\n        }\n        else if(ar[i]<m){\n            cout<<ar[i]<<\" \";\n        }\n    }\n    cout<<\"\\n\";\n    while(ar2.size()){\n        cout<<ar2.front()<<\" \";\n        ar2.pop();\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "4093. El Bryan",
        "url": "https://omegaup.com/arena/problem/El-Bryan/",
        "descripcion": "Ha llegado el final de semestre y todos los alumnos de la ESCOM se están descontrolando, tanto que han dejado de comprar gomitas y nuestro compañero bryan está muy deprimido. Él piensa que la forma en la que organiza la gran variedad de dulces que vende no es lo demasiado atractiva y ha hecho que sus ventas disminuyan, pues hace dos semanas al echarle un vistazo a sus ganancias notó que han bajado un 30% y al revisar nuevamente la semana pasada se llevó un gran susto al ver que éstas habían bajado un 60%. Desde esa tarde bryan comenzó a buscar una estrategia para lograr que su negocio incrementará analizando el tamaño de sus gomitas, vio que muchas de ellas podían ser clasificadas en diferentes tamaños y fue lo que hizo, después las clasificó de acuerdo a su sabor hasta que finalmente se quedó con todas las gomitas de tamaño 1x1 todas ellas de sabores diferentes y decidió organizarlas en una bolsita de tamaño 1xN. Por ejemplo se quedó con 3 gomitas una con sabor a mango otra con sabor a limón y la última con sabor a cereza. Por lo tanto una forma de acomodarlas sería que metiera en el fondo de la bolsita la gomita de sabor a limón, después la gomita de sabor a mango y por último la de sabor a cereza, una forma diferente sería que metiera primero la de mango luego la de cereza y por último la de limón. Bryan quiere que le ayudes a hacer un programa que le diga de cuántas formas diferentes puede organizar sus N gomitas en una bolsita de tamaño 1xN.",
        "entrada": "Un entero N (número de gomitas).",
        "salida": "La cantidad de formas diferentes en que bryan puede acomodar sus gomitas.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Aritmética",
            "Ciclos",
            "Implementación"
        ],
        "estructuras": [
            "unsigned long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    unsigned long long a, b=1;\n    cin>>a;\n    for(auto i=1; i<=a; i++){\n        b*=i;\n    }\n    cout<<b;\n\n    return 0;\n}"
    },
    {
        "titulo": "4912. El Viejo Peter",
        "url": "https://omegaup.com/arena/problem/El-Viejo-Peter/",
        "descripcion": "Mary Jane ha sido secuestrado por el malvado doctor tentaculos. Nuestro querido heroe de ciudad Problema, Peter Parker, debe rescatarla. Desafortunadamente sus poderes no estan funcionando muy bien, por lo que él solo se puede balancear entre ciertos edificios. Especificamente, si Peter esta en el edificio i, el solo puede saltar al primer edificion k (k > i), tal que es el primer edificio mas grande que el edificio i. Podrias ayudar a Peter diciendole a cual edificio puede saltar estando en una posicion especifica. Como esta puede ser una mision suicida para Peter, el te pide que calcules para cada edificio de la ciudad, cual es el la posicion del primer edificio a la derecha que es mas grande que el mismo.",
        "entrada": "La primera linea tiene un entero N, que indica el numero de edificios en la ciudad. La segunda linea contiene N enteros indicando la latura del i-esimo edificio. (1 <= N <= 100000), (1 <= A[i] <= 1000000000).",
        "salida": "Se deben imprimir n numeros. Por cada edificio, debe escribir la posicion (indexado en 0) del primer edificio que es mas grande que él mismo. En caso que no exista dicho edificio, se debe poner un -1.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores"
        ],
        "estructuras": [
            "vector<pair<int,int>>",
            "unsigned long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    unsigned long long a, b;\n    vector<pair<int, int>> num(100001, {0, 0});\n    cin>>a;\n    for(int i=0; i<a; i++){\n        cin>>num[i].first;\n    }\n    num[a-1].second=-1;\n    for(int i=a-2; i>-1; i--){\n        if(num[i].first==num[i+1].first){\n            num[i].second=num[i+1].second;\n        }\n        else if(num[i+1].first>num[i].first){\n            num[i].second=i+1;\n        }\n        else{\n            if(num[i+1].second==-1){\n                num[i].second=-1;\n            }\n            else{\n                b=num[i+1].second;\n                while(true){\n                    if(num[b].first>num[i].first){\n                        num[i].second=b;break;\n                    }\n                    b=num[b].second;\n                    if(b==-1){\n                        num[i].second=-1;break;\n                    }\n                }\n            }\n        }\n    }\n    for(int i=0; i<a; i++){\n        cout<<num[i].second<<\" \";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "4578. UP_CURP",
        "url": "https://omegaup.com/arena/problem/UP_CURP/",
        "descripcion": "La Clave Única de Registro de Población es un código alfanumérico de identidad de 18 caracteres, utilizado para identificar a los mexicanos. Los primeros 10 caracteres de la CURP se determinan mediante los siguientes datos: La primera letra y la primera vocal (que no sea la primera letra) del primer apellido. Primera letra del segundo apellido. Primera letra del nombre de pila. Fecha de nacimiento con el formato aammdd. Escribe un programa que dado el nombre de una persona y su fecha de nacimiento genere los primeros 10 caracteres de la CURP.",
        "entrada": "La primera línea contendrá tres palabras, indicando el nombre, apellido paterno y el apellido materno. Todas las letras son mayúsculas, y ninguna de las palabras excede los 50 caracteres. La segunda línea contendrá 3 números separados por un espacio en el formato dd mm aaaa, indicando el día, el mes y el año de nacimiento.",
        "salida": "Los primeros 10 caracteres de la CURP.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "unsigned long long",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    unsigned long long a;\n    string z, zz, zzz, y, yy, yyy, x=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    cin>>z>>zz>>zzz>>y>>yy>>yyy;\n    for(auto i=0; i<x.size(); i++){\n        if(zz[0]==x[i]){\n            cout<<zz[0];\n            a=1;break;\n        }\n    }\n    sort(faltas.begin(), faltas.end());\n    if(!a){\n        cout<<'X';\n    }\n    for(auto i=1; true; i++){\n        if(zz[i]=='A' || zz[i]=='E' || zz[i]=='I' || zz[i]=='O' || zz[i]=='U'){\n            cout<<zz[i];break;\n        }\n    }\n    a=0;\n    for(auto i=0; i<x.size(); i++){\n        if(zzz[0]==x[i]){\n            cout<<zzz[0];\n            a=1;break;\n        }\n    }\n    if(!a){\n        cout<<'X';\n    }\n    a=0;\n    for(auto i=0; i<x.size(); i++){\n        if(z[0]==x[i]){\n            cout<<z[0];\n            a=1;break;\n        }\n    }\n    if(!a){\n        cout<<'X';\n    }\n    cout<<yyy[yyy.size()-2]<<yyy[yyy.size()-1];\n    if(yy.size()==1){\n        cout<<'0';\n    }\n    cout<<yy;\n    if(y.size()==1){\n        cout<<'0';\n    }\n    cout<<y;\n\n    return 0;\n}"
    },
    {
        "titulo": "4184. Carrera estructurada",
        "url": "https://omegaup.com/arena/problem/Carrera-estructurada/",
        "descripcion": "En una carrera participaron 6<=N<=1000 personas, a cada participante se le asignó un número único (id) que lo identifica y la categoría en la que competirá. Existen dos categorías: 1 Categoría de 5 kilómetros. 2 Categoría de 10 kilométros. Dados el id, el nombre, el tiempo que registró (en minutos) y la categoría en la que participó cada persona, determina los ganadores del primero, segundo y tercer lugar en cada categoría. Puedes estar seguro que la medición del tiempo es tan exacta que nunca habrá empates. SUBTASK Para el 50% de los casos todos los participantes compiten en la categoría uno, por lo tanto solo debes imprimir los primeros tres lugares de esa categoría. Para el otro 50% de los casos, los participantes compiten en las categorías uno o dos, por lo tanto debes imprimir los lugares de cada categoría tal como se especifica en la redacción.",
        "entrada": "En la primera línea el entero N. En cada una de las siguientes 4xN líneas, el id, nombre, tiempo y categoría de cada persona.",
        "salida": "6 líneas, en las primeras tres los ids y nombres de los ganadores de los primeros tres lugares en la categoria 1, en las últimas tres líneas, los ids y nombres de los ganadores de los primeros tres lugares en la categoría 2. Obviamente los ganadores de los primeros tres lugares en cada categoría son aquellos que registren los tres menores tiempos.",
        "nivel": "Intermedio (medio) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Ordenamiento",
            "Caracteres y cadenas",
            "Vectores"
        ],
        "estructuras": [
            "long double",
            "int",
            "string",
            "unsigned long long",
            "vector<struct>",
            "getline()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct sobra{\n    long double aa;\n    int bb;\n    string cc;\n};\n\nbool operator<(sobra x, sobra y){\n    if(x.aa<y.aa)return true;\n    if(y.aa<x.aa)return false;\n    if(x.bb<y.bb)return true;\n    if(y.bb<x.bb)return false;\n    if(x.cc<y.cc)return true;\n    return false;\n}\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    unsigned long long a, b;\n    vector<sobra>falta;\n    vector<sobra>faltas;\n    sobra z;\n    string zz;\n    cin>>a;\n    while(a--){\n        cin>>z.bb;\n        getline(cin,zz);\n        getline(cin,z.cc);\n        cin>>z.aa;\n        cin>>b;\n        if(b==1){\n            falta.push_back(z);\n        }\n        else{\n            faltas.push_back(z);\n        }\n    }\n    sort(falta.begin(),falta.end());\n    sort(faltas.begin(),faltas.end());\n    if(falta.size()>=1){\n        cout<<falta[0].bb<<\" \"<<falta[0].cc<<\"\\n\";\n    }\n    if(falta.size()>=2){\n        cout<<falta[1].bb<<\" \"<<falta[1].cc<<\"\\n\";\n    }\n    if(falta.size()>=3){\n        cout<<falta[2].bb<<\" \"<<falta[2].cc<<\"\\n\";\n    }\n    if(faltas.size()>=1){\n        cout<<faltas[0].bb<<\" \"<<faltas[0].cc<<\"\\n\";\n    }\n    if(faltas.size()>=2){\n        cout<<faltas[1].bb<<\" \"<<faltas[1].cc<<\"\\n\";\n    }\n    if(faltas.size()>=3){\n        cout<<faltas[2].bb<<\" \"<<faltas[2].cc<<\"\\n\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "4572. UP Suma Impares",
        "url": "https://omegaup.com/arena/problem/UP-Suma-Impares/",
        "descripcion": "El arreglo X se compone de n números, X = x_0, x_1,..., x_(n-1). Escribe un programa que calcule la suma de todos los elementos que están en posiciones impares de X.",
        "entrada": "La primera línea contiene un numero n (2<=n<=10^5), indicando la cantidad de elementos en X. Le siguen n líneas que componen los elementos de X (-10^4 <= x_i <= 10^4).",
        "salida": "La suma de todos los elementos en posiciones impares de X.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Aritmética"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c=0;\n    cin>>a;\n    for(auto i=0; i<a; i++){\n        cin>>b;\n        if(i%2){\n            c+=b;\n        }\n    }\n    cout<<c;\n\n    return 0;\n}"
    },
    {
        "titulo": "5661. Triangulos locos",
        "url": "https://omegaup.com/arena/problem/Triangulos-locos/",
        "descripcion": "Tienes un triangulo equilatero de lado L y esta dividido en triangulos nitarios ( triangulos equilateros de lado 1). En la siguiente imagen vemos como seria los triangulos para un triangulo de lado L = 4, 5 y 6. Tu tarea es calcular en numero de triangulos unitarios que hay dentro de un triangulo de lado L. Por ejemplo: si L = 5, hay 25 triangulos unitarios dentro; si L = 2, hay 4 triangulos unitarios.",
        "entrada": "Un entero L. (1<=L<=1000).",
        "salida": "El numero de triangulos unitarios dentro del triangulo de lado L.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Aritmética"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a;\n    cin>>a;\n    cout<<a*a;\n\n    return 0;\n}"
    },
    {
        "titulo": "6775. Porfirio y las Donas",
        "url": "https://omegaup.com/arena/problem/Porfirio-y-las-Donas/",
        "descripcion": "Como sabes, a Porfirio le encantan organizar fiestas e invitar a toda la gente del pueblo. En esta ocasión, el va a celebrar el Día Mundial de la Dona. Un día antes de la fiesta, Porfirio va a la única tienda de donas de la ciudad \"Lazadonas\". Esta tienda es propiedad de su archienemigo Lázaro, por lo que Porfirio no quiere comprar donas extras y así darle más dinero a su archirrival. Sin embargo, tampoco quiere que le falten donas en la celebración, pues la reputación de sus grandes fiestas quedarían en peligro. Es por esto que Porfirio quiere comprar exactamente una dona por cada invitado de la fiesta. El problema es que \"Lazadonas\" solo vende las donas en paquetes. Tienen paquetes pequeños que contienen A donas cada uno, y paquetes grandes que contienen B donas cada uno. La fiesta esta cerca de empezar, y Porfirio no recuerda a cuanta gente invitó. Porfirio sabe que eres muy bueno con los números, es por eso que te hará N preguntas: Si asisten X personas a la fiesta, ¿sería posible comprar exactamente X donas? Ayuda a Porfirio y contesta sus preguntas para que decida si puede realizar la fiesta, o si tendrá que cancelarla para evitar arruinar su reputación. En \"Lazadonas\" existen cajas de donas ilimitadas A<=B.",
        "entrada": "La primera linea contendrá tres enteros: N ( el número de preguntas de Porfirio ), A ( el número de donas que contienen los paquetes pequeños ) y B ( el número de donas que contienen los paquetes grandes ) Las siguientes N lineas contendrán cada un entero: X_i. (1<=N<=300), (1<= A,B<=300), (1<=X_i<=300) Para el 30% de los casos: A=B.",
        "salida": "Deberás imprimir N lineas. Para la i-esima linea deberás imprimir \"Si\" (sin las comillas ) si es posible comprar exactamente X_i donas para la fiesta, o \"No\" ( sin las comillas ) si no es posible.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Aritmética",
            "Fuerza bruta"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e;\n    cin>>a>>b>>c;\n    while(a--){\n        cin>>d;\n        if(d%b==0 || d%c==0){\n            cout<<\"Si\\n\";continue;\n        }\n        e=d;\n        while(e>-1){\n            e-=b;\n            if(e%c==0){\n                break;\n            }\n        }\n        if(e%c==0 && e>-1){\n            cout<<\"Si\\n\";continue;\n        }\n        e=d;\n        while(e>-1){\n            e-=c;\n            if(e%b==0){\n                break;\n            }\n        }\n        if(e%b==0 && e>-1){\n            cout<<\"Si\\n\";continue;\n        }\n        cout<<\"No\\n\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "4141. Matriz X",
        "url": "https://omegaup.com/arena/problem/Matriz-X/",
        "descripcion": "Dada una matriz de MxN (1<=M,N<=100) datos enteros ((M filas x N columnas)) imprime los elementos que esten en coordenadas pares. por ejemplo 0, 0; 2,4; etc.",
        "entrada": "En la primera línea los enteros M, N. Donde M representa el número de filas y N el número de columnas. En cada una de las siguientes M líneas, N enteros.",
        "salida": "Todos los números de las coordenadas pares de la matriz, recorriendola de abajo hacia arriba y de izquierda a derecha.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Matrices",
            "Condicionales",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "vector<vector<int>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b;\n    vector<vector<int>> num(101, vector<int>(101, 0));\n    cin>>a>>b;\n    for(auto i=0; i<a; i++){\n        for(auto j=0; j<b; j++){\n            cin>>num[i][j];\n        }\n    }\n    a--;\n    if(a%2){\n        a--;\n    }\n    for(a; a>-1; a-=2){\n        for(auto i=0; i<b; i+=2){\n            cout<<num[a][i]<<\" \";\n        }\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "1030. Matriz con entradas en diagonal",
        "url": "https://omegaup.com/arena/problem/med/",
        "descripcion": "Dados dos enteros m y n, escribe un programa que construya una matriz con m renglones y n columnas cuyas entradas sean los números 1,2,...,mn acomodados en diagonal, comenzando con el 1 en la entrada que está en la esquina superior izquierda, siguiendo con el 2 a la derecha del 1 y el 3 abajo del 1, y así sucesivamente.",
        "entrada": "Dos números enteros 2<= m, n<= 100, separados por un espacio.",
        "salida": "La matriz requerida (ver el ejemplo de salida para el formato).",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Ciclos",
            "Matrices",
            "Vectores"
        ],
        "estructuras": [
            "long long",
            "vector<vector<int>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c=1;\n    vector<vector<int>> num(101, vector<int>(101, 0));\n    cin>>a>>b;\n    for(auto i=0; i<(a+b)-1; i++){\n        for(auto j=0, k=i; j<=i; j++, k--){\n            if(j<a && k<b){\n                num[j][k]=c;\n                c++;\n            }\n        }\n    }\n    for(auto i=0; i<a; i++){\n        for(auto j=0; j<b; j++){\n            cout<<num[i][j]<<\" \";\n        }\n        cout<<\"\\n\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "4472. Matriz Transpuesta UP",
        "url": "https://omegaup.com/arena/problem/Matriz-Transpuesta-UP/",
        "descripcion": "La matriz transpuesta de una matriz A se denota como A^T, y donde la primera columna de A representa el primer renglón de A^T, la segunda columna de A representa el segundo renglón de A^T, y así sucesivamente. Así que si A es de tamaño n x m, A^T tendrá un tamaño de m x n. Por ejemplo definamos A como: [[4, 2, 3], [5, 7, 1]], La matriz transpuesta A^T es: A^T = [[4, 5], [2, 7], [3, 1]]. Escribe un programa que dada una matriz A imprima A^T.",
        "entrada": "La primera línea contiene dos enteros n, y m (1<=n, m<=20). Indicando la cantidad de renglones y de columnas de A respectivamente. Le siguen n líneas cada una con m enteros separados por espacios representando los elementos de la matriz A.",
        "salida": "La matriz A^T.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Matrices"
        ],
        "estructuras": [
            "long long",
            "vector<vector<int>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b;\n    vector<vector<int>> num(101, vector<int>(101, 0));\n    cin>>a>>b;\n    for(auto i=0; i<a; i++){\n        for(auto j=0; j<b; j++){\n            cin>>num[j][i];\n        }\n    }\n    for(auto i=0; i<b; i++){\n        for(auto j=0; j<a; j++){\n            cout<<num[i][j]<<\" \";\n        }\n        cout<<\"\\n\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "7294. ¿Cuántos valen 7?",
        "url": "https://omegaup.com/arena/problem/Cuantos-valen-7/",
        "descripcion": "Escribe un programa que lea dos enteros e imprima cuántos de ellos valen 7.",
        "entrada": "Dos enteros en el rango de -1000 a +1000.",
        "salida": "La cantidad de enteros iguales a 7.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Condicionales"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b;\n    cin>>a>>b;\n    if(a==7 && b==7){\n        cout<<2;\n    }\n    else if(a==7 || b==7){\n        cout<<1;\n    }\n    else{\n        cout<<0;\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "7377. Modificando secuencias a lo loco",
        "url": "https://omegaup.com/arena/problem/Modificando-secuencias-a-lo-loco/",
        "descripcion": "Dada una secuencia de N enteros donde el entero 5 aparece al menos dos veces, realiza lo siguiente: Sea p_1 la posición de la primera ocurrencia del entero 5 en la secuencia, invierte la subsecuencia anterior a p_1. Sea p_2 la posición de la segunda ocurrencia del entero 5 en la secuencia, invierte la subsecuencia posterior a p_2. Busca la primera ocurrencia del entero 7 en la subsecuencia posterior a p_1 pero anterior a p_2. Si existe, reemplázala por el entero 0. En caso contrario, ordena la subsecuencia mencionada. Escribe un programa que imprima el estado final de la secuencia.",
        "entrada": "Un entero N seguido de los N enteros de la secuencia. Puedes suponer que 2 <= N <= 100, que los enteros de la secuencia están en el rango de 0 a 100 y que el entero 5 aparece al menos dos veces.",
        "salida": "Los N enteros de la secuencia después de realizar las operaciones.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Vectores",
            "Ordenamiento",
            "Búsqueda lineal"
        ],
        "estructuras": [
            "long long",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b=0, c, d=0;\n    vector<int> num(101, 0);\n    vector<int> sub(101, 0);\n    cin>>a;\n    for(auto i=0; i<a; i++){\n        cin>>num[i];\n    }\n    for(auto i=0; i<a; i++){\n        if(num[i]==5 && !b){\n            for(auto j=0, k=i-1; j<i/2; j++, k--){\n                swap(num[j], num[k]);\n            }\n            b=1;\n        }\n        else if(num[i]==7 && b==1){\n            num[i]=0;\n            b=2;\n        }\n        else if(num[i]==5 && b==1){\n            c=i-1;\n            while(num[c]!=5){\n                sub[d]=num[c];\n                d++;\n                c--;\n            }\n            sort(sub.begin(), sub.end());\n            c++;\n            for(auto j=0; j<d; j++){\n                num[c]=sub[j];\n                c++;\n            }\n            c=(a-i)/2;\n            for(auto j=i+1, k=a-1; j<=i+c; j++, k--){\n                swap(num[j], num[k]);\n            }\n            b=2;break;\n        }\n        else if(num[i]==5 && b==2){\n            c=(a-i)/2;\n            for(auto j=i+1, k=a-1; j<=i+c; j++, k--){\n                swap(num[j], num[k]);\n            }\n            b=2;break;\n        }\n    }\n    for(auto i=0; i<a; i++){\n        cout<<num[i]<<\" \";\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "7169. Secuencias iguales",
        "url": "https://omegaup.com/arena/problem/Secuencias-iguales/",
        "descripcion": "Escribe un programa que determine si dos secuencias de N enteros son iguales.",
        "entrada": "Un entero N seguido de los N enteros de la primera secuencia y posteriormente los N enteros de la segunda secuencia. Puedes suponer que 1<=N<=100.",
        "salida": "Un 1 si las dos secuencias son iguales y un 0 en otro caso.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Condicionales",
            "Vectores",
            "Ciclos"
        ],
        "estructuras": [
            "vector<int>",
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    vector<int> num(101, 0);\n    long long a, b, c=0;\n    cin>>a;\n    for(auto i=0; i<a; i++){\n        cin>>num[i];\n    }\n    for(auto i=0; i<a; i++){\n        cin>>b;\n        if(num[i]!=b){\n            c=1;\n        }\n    }\n    if(c==1){\n        cout<<0;\n    }\n    else{\n        cout<<1;\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "2396. Secuencias saltarinas",
        "url": "https://omegaup.com/arena/problem/Secuencias-saltarinas/",
        "descripcion": "Una secuencia de N enteros se llama una secuencia saltarina si el valor absoluto de las diferencias entre elementos consecutivos toman todos los posibles valores desde 1 hasta N-1. Por ejemplo, la secuencia de 4 enteros 1,4,2,3 es una secuencia saltarina porque las diferencias absolutas son 3, 2 y 1, respectivamente. Por otro lado, la secuencia de 5 enteros 3, 1, 5, 2 no es una secuencia saltarina porque las diferencias absolutas son 2, 4, 4 y 1, respectivamente, es decir, falta el número 3.Dado un número N y una secuencia de N números X_1,..., X_N podemos decidir si esta secuencia es saltarina ó, si no lo es, podemos encontrar el número más pequeño que no aparece en las diferencias.",
        "entrada": "La entrada consiste de un número entero N, que tendrá un valor entre 2 y 1000, seguido de N números enteros X_1, X_2,..., X_N cada uno con valor entre -999 y 999.",
        "salida": "La salida consiste de un número entero M definido como sigue: M=0 si la secuencia es saltarina, en otro caso M debe ser el número más pequeño que no aparece en las diferencias.",
        "nivel": "Intermedio (medio) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Búsqueda binaria"
        ],
        "estructuras": [
            "vector<int>",
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    vector<int> num(1001, 0);\n    vector<int> sub(1001, 0);\n    long long a, b;\n    cin>>a>>num[0];\n    for(auto i=1; i<a; i++){\n        cin>>num[i];\n        b=abs(num[i-1]-num[i]);\n        sub[b]++;\n    }\n    for(auto i=1; i<a; i++){\n        if(!sub[i]){\n            cout<<i;return 0;\n        }\n    }\n    cout<<0;\n    \n    return 0;\n}"
    },
    {
        "titulo": "100. Adivina",
        "url": "https://omegaup.com/arena/problem/adivina/",
        "descripcion": "Existe una estructura de datos desconocida que soporta dos operaciones: Meter un elemento X en la estructura de datos. Sacar un elemento X de la estructura de datos. Dado una secuencia de estas operaciones con los valores que devolvieron, tienes que adivinar qué tipo de estructura de datos es: Pila (Stack). Cola (Queue). Cola de prioridad (priority-queue), ésta siempre devuelve el elemento más grande. Alguna estructura de datos que posiblemente no puedas imaginar.",
        "entrada": "El caso inicia con un entero n. Cada una de las siguientes n líneas contienen 2 enteros que pueden ser de la siguiente forma: Meter elemento: el primer entero siempre es 1 y el segundo entero es el elemento X que debe ser insertado en la estructura de datos. Sacar elemento: el primer entero siempre es 2 y el segundo entero es el elemento X que devuelve la estructura de datos. (0), (0<=X<=100).",
        "salida": "Debes imprimir alguna de las siguientes palabras: Pila, si la estructura de datos se comportó como una pila y no como alguna de las otras mencionadas. Cola, si la estructura de datos se comportó como una cola y no como alguna de las otras mencionadas. Prioridad si la estructura de datos se comportó como una cola de prioridad y no como alguna de las otras mencionadas. Imposible si la estructura de datos no es ninguna de las tres anteriores. Ambiguo si la estructura de datos puede ser dos o más de las tres estructuras de datos mencionadas.",
        "nivel": "Intermedio (fácil) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Ordenamiento",
            "Vectores",
            "Pilas",
            "Colas"
        ],
        "estructuras": [
            "long long",
            "stack<int>",
            "queue<int>",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d=1, e=1, f=1;\n    vector<int> num(1000, 0);\n    stack<int> faltass;\n    queue<int> faltas;\n    vector<int> falta;\n    vector<int>::iterator it=falta.begin();\n    cin>>a;\n    for(auto i=0; i<a; i++){\n        cin>>b>>c;\n        if(b==1){\n            if(d){\n                falta.push_back(c);\n            }\n            if(e){\n                faltas.push(c);\n            }\n            if(f){\n                faltass.push(c);\n            }\n        }\n        else{\n            if(e && faltas.size() && c==faltas.front()){\n                faltas.pop();\n            }\n            else{\n                e=0;\n            }\n            if(f && faltass.size() && c==faltass.top()){\n                faltass.pop();\n            }\n            else{\n                f=0;\n            }\n            if(d && falta.size()){\n                sort(falta.begin(), falta.end());\n                it=falta.end()-1;\n                if(c==*it){\n                    falta.pop_back();\n                }\n                else{\n                    d=0;\n                }\n            }\n            else{\n                d=0;\n            }\n        }\n    }\n    if(!d && !e && !f){\n        cout<<\"Imposible\";\n    }\n    else if(d==1 && !e && !f){\n        cout<<\"Prioridad\";\n    }\n    else if(!d && e==1 && !f){\n        cout<<\"Cola\";\n    }\n    else if(!d && !e && f==1){\n        cout<<\"Pila\";\n    }\n    else{\n        cout<<\"Ambiguo\";\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "4594. Ecuaciones de Sesos",
        "url": "https://omegaup.com/arena/problem/Ecuaciones-de-Sesos/",
        "descripcion": "Ricardo ama los tacos y hace dos semanas fue a comer con sus amigos a los famosos tacos de sesos fuera de una famosa estación del metro, pero la poca higiene del lugar le provocó una enfermedad en los sesos (LOL). Debido a los deliciosos tacos Ricardo olvidó cómo resolver ecuaciones de segundo grado, es decir, de la forma: ax^2+bx+c. Como él está muy orgulloso de ser matemático y no quiere perder su prestigio, te ha pedido que hagas un programa que le diga si algunas ecuaciones tienen solución o no. Nota: Recuerda que para encontrar la solución de una ecuación de segundo grado se puede usar la fórmula cuadrática: x = (-b ± sqrt(b^2 - 4ac)) / 2a.",
        "entrada": "Un entero N, que representa la cantidad de ecuaciones que Ricardo debe resolver. A continuación leerás N casos, que constan de 3 líneas cada uno, donde en cada línea están los números a, b y c de la ecuación a resolver. Nota 2: a, b y c son números enteros, y a != 0.",
        "salida": "Para cada caso debes imprimir \"SI\" en caso de que la ecuación tenga solución (en los números reales) o \"NO\" en caso contrario.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Aritmética"
        ],
        "estructuras": [
            "int",
            "pow()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int a, b, c, d, e;\n    cin>>a;\n    while(a){\n        a--;\n        cin>>b>>c>>d;\n        e=pow(c, 2)-4*b*d;\n        if(e>-1){\n            cout<<\"SI\"<<endl;\n        }\n        else{\n            cout<<\"NO\"<<endl;\n        }\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "4474. Impresora inteligente",
        "url": "https://omegaup.com/arena/problem/Impresora-inteligente/",
        "descripcion": "Hace unos años la UN contaba sólo con una impresora, por supuesto, era demasiado utilizada a tal punto que tocaba esperar varias horas para obtener una simple página. Cómo algunos trabajos son más importantes que otros, Manuel el hacker ha implementado un sistema simple de prioridades. A cada tarea se le asigna un número de prioridad donde 1 es la más baja y k es la más alta. La impresora funciona de la siguiente manera: Se toma el primer trabajo de la cola J. Si hay algún trabajo en la cola que tiene una prioridad estrictamente mayor a la prioridad del trabajo J, entonces coloque J al final de la cola. Sino procese J, y ya J no vuelve a la cola. Usted, un estudiante de la UN, desea imprimir un documento y no quiere quedarse todo el tiempo junto a la impresora esperando a que su documento salga, por lo que decide realizar un programa que permita saber cuantos minutos tardará la impresora en procesar su documento con el sistema que ha implementado Manuel, y de esta manera usted solo tendrá que llegar en ese tiempo recoger el documento e irse.",
        "entrada": "La primera línea de la entrada contiene tres números enteros: n el número de trabajos en la cola de la impresora, m la posición inicial de su trabajo (indexado desde 1) y k la máxima prioridad que podrá tener una tarea. La siguiente línea contiene n números separados por un espacio entre ellos y que corresponden al estado de la cola actualmente, el primer número tendrá la prioridad del primer trabajo, el segundo número tendrá la prioridad del segundo trabajo, y así sucesivamente.",
        "salida": "De como salida una línea con un único número que corresponde al tiempo en que su trabajo será impreso completamente. Asuma que el proceso de desencolar, el proceso de impresión y encolar toma 1 minuto.",
        "nivel": "Intermedio (fácil) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Ordenamiento",
            "Vectores",
            "Colas"
        ],
        "estructuras": [
            "long long",
            "queue<pair<int,int>>",
            "pair<int,int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d;\n    vector<int> impresion(5001, 0);\n    queue<pair<int, int> >falta;\n    pair<int, int>z;\n    cin>>a>>b>>c;\n    for(auto i=0; i<a; i++){\n        cin>>impresion[i];\n        if(i==b-1){\n            d=impresion[i];\n            z.second=1;\n        }\n        z.first=impresion[i];\n        falta.push(z);\n    }\n    sort(impresion.begin(), impresion.end());\n    c=0;\n    b=a-1;\n    while(true){\n        c+=2;\n        if(impresion[b]==d && falta.front().first==d && falta.front().second==1){\n            cout<<c;return 0;\n        }\n        else if(falta.front().first==impresion[b]){\n            falta.pop();\n            b--;\n        }\n        else{\n            falta.push(falta.front());\n            falta.pop();\n        }\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "2627. Rotaciones",
        "url": "https://omegaup.com/arena/problem/Rotaciones/",
        "descripcion": "Tienes un arreglo A de 1<=N<1000000 enteros. Tu deberás responder M ordenes que se te serán dadas. Cada orden puede ser de uno de los siguientes tres tipos: D d : Rotas los elementos d veces a la izquierda. I d : Rotas los elementos d veces a la derecha. R d : Pregunta por el valor del elemento que está actualmente en la posición d del arreglo A. Nota: Rotar una vez implica recorrer todos los elemento una posición.",
        "entrada": "La primera línea contiene dos números - N y M respectivamente. La siguiente línea contiene N enteros separados por un espacio, denotando el arreglo A, Cada una de las siguientes M lineas contiene una orden de la forma descrita anteriormente.",
        "salida": "Para cada orden Q deberás responder el elemento que se encuentra en la posición d en ese momento, seguido de un espacio en blanco.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores"
        ],
        "estructuras": [
            "long long",
            "vector<int>",
            "char"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d=0, e;\n    vector<int> num(1000000, 0);\n    char z;\n    cin>>a>>b;\n    for(auto i=0; i<a; i++){\n        cin>>num[i];\n    }\n    while(b--){\n        cin>>z>>c;\n        if(z=='D'){\n            d+=c;\n        }\n        else if(z=='I'){\n            d-=c;\n        }\n        else{\n            e=d%a;\n            if(!e){\n                cout<<num[c-1]<<\"\\n\";\n            }\n            else if(e>0){\n                e+=c;\n                e%=a;\n                if(!e){\n                    e=a;\n                }\n                cout<<num[e-1]<<\"\\n\";\n            }\n            else{\n                e+=c;\n                if(e<1){\n                    e+=a;\n                }\n                cout<<num[e-1]<<\"\\n\";\n            }\n        }\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "6563. @Davidiano y sus Parciales",
        "url": "https://omegaup.com/arena/problem/Guillermo-y-sus-Parciales/",
        "descripcion": "David es un niño muy estudioso (Cuando no lo vemos no sabemos que hace :v). Siempre esta preocupado por la calificacion de sus parciales. Hoy se enteró en el COBAEV 34 de que en algunas tareas y puntajes sacó 0 puntos, por lo cual quiere ingeniarselas para que sus papás no lo descubran. Va a ir checando la tareas y el puntaje que sacó en total de cada una de ellas. Si o la tarea o el puntaje valen 0, entonces David no la sumará a su calificación final, sino que agregará un diez para cubrir las huellas del engaño. De lo contrario, sumará el puntaje a su calificacion final. Y luego le sacará el promedio para asi estar seguro de que su atraco ha sido completado y no lo atrapen \"in fraganti\" (en fragancia). Dado un numero n de tareas y puntajes por revisar, y dos valores x y y que indican el valor de la tarea y el puntaje, respectivamente de cada una de las n cosas por revisar, determina el promedio de la calificación total de David (La Engañosa).",
        "entrada": "Un numero n, que indica el numero de tareas y puntajes que se van a revisar. En las siguientes n lineas habrá dos valores x y y, que indican el valor de la tarea y el puntaje, respectivamente (0 <= x, y, n <= 1,000,000).",
        "salida": "El promedio total de la calificacion de David, expresada en decimales si es que los hay (Pueden haber valores decimales).",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "long double"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long double a, b, c, d=0, e;\n    cin>>a;\n    e=a;\n    while(a--){\n        cin>>b>>c;\n        if(!b || !c){\n            d+=10;\n        }\n        else{\n            d+=c;\n        }\n    }\n    d/=e;\n    cout<<d;\n    \n    return 0;\n}"
    },
    {
        "titulo": "2612. El Triángulo",
        "url": "https://omegaup.com/arena/problem/triangulo/",
        "descripcion": "Abajo se muestra un triángulo de números. Escriba un programa que calcule la suma más grande de números usados en una ruta que empiece en la cima del triángulo, y finalice en algún lugar de la base. Cada avance va diagonalmente hacia abajo a la izquierda o diagonalmente hacia abajo a la derecha. En número de renglones r en el triángulo es (2<=r<=100). Todos los números del triángulo son enteros entre el 0 y 99.",
        "entrada": "La primer línea contiene el número r de renglones del triángulo, seguido de r líneas como lo muestra el ejemplo.",
        "salida": "Despliegue la suma más grande que puede realizarse en un recorrido desde la parte superior del triángulo hasta un lugar en la base.",
        "nivel": "Intermedio (fácil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Programación dinámica",
            "Matrices"
        ],
        "estructuras": [
            "int",
            "vector<vector<pair<int,int>>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    vector<vector<pair<int, int>>> num(101, vector<pair<int, int>>(101, {0, 0}));\n    int a, b, c=0;\n    cin>>a;\n    for(auto i=0; i<a; i++){\n        for(auto j=0; j<=i; j++){\n            cin>>num[i][j].first;\n        }\n    }\n    num[0][0].second=num[0][0].first;\n    for(auto i=0; i<a-1; i++){\n        for(auto j=0; j<=i; j++){\n            b=num[i][j].second+num[i+1][j].first;\n            num[i+1][j].second=max(num[i+1][j].second, b);\n            b=num[i][j].second+num[i+1][j+1].first;\n            num[i+1][j+1].second=max(num[i+1][j+1].second, b);\n        }\n    }\n    for(auto i=0; i<a; i++){\n        c=max(num[a-1][i].second, c);\n    }\n    cout<<c;\n    \n    return 0;\n}"
    },
    {
        "titulo": "3079. Amigos Misteriosos",
        "url": "https://omegaup.com/arena/problem/Amigos-Misteriosos/",
        "descripcion": "Rodrigo es una persona muy misteriosa, por lo que no quiere que nadie sepa sobre de qué está hablando con su amigo Pablo. Juntos idearon una forma de encriptar sus mensajes. Para encriptar sus mensajes y asegurarse que nadie los pueda leer, deberán cambiar todas las ‘a’ por ‘x’, las ’e’ por ‘w’, las ’i’ por ‘y’, las ’o’ por ‘k’ y las ’u’ por ‘z’.Nota: No debes cambiar las letras mayúsculas.",
        "entrada": "El texto que Rodrigo quiere encriptar.",
        "salida": "El texto de Rodrigo encriptado, listo para enviarlo a Pablo.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas",
            "Ciclos"
        ],
        "estructuras": [
            "getline()",
            "string",
            "auto"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    string z;\n    while (getline(cin, z))\n    {\n        for (auto i = 0; i < z.size(); i++)\n        {\n            if (z[i] == 'a')\n            {\n                z[i] = 'x';\n            }\n            else if (z[i] == 'e')\n            {\n                z[i] = 'w';\n            }\n            else if (z[i] == 'i')\n            {\n                z[i] = 'y';\n            }\n            else if (z[i] == 'o')\n            {\n                z[i] = 'k';\n            }\n            else if (z[i] == 'u')\n            {\n                z[i] = 'z';\n            }\n        }\n        cout << z << \"\\n\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "6901. Avogadro",
        "url": "https://omegaup.com/arena/problem/Avogadro/",
        "descripcion": "Amedeo Avogadro te ha pedido calcular qué volumen v ocupará n moles de una molécula cualquiera en condiciones normales de temperatura y presión.",
        "entrada": "El número n (moles)",
        "salida": "El número v (volumen), redondeado a 3 decimales.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Cálculos aritméticos"
        ],
        "estructuras": [
            "long double",
            "fixed",
            "setprecision()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long double a;\n    cin >> a;\n    a *= 22.414;\n    cout << fixed << setprecision(3) << a << \" l\";\n\n    return 0;\n}"
    },
    {
        "titulo": "2880. Blancas Vs Negras",
        "url": "https://omegaup.com/arena/problem/Blancas-Vs-Negras/",
        "descripcion": "Dado un tablero de ajedrez de MxN (1<=M,N<=100) casillas con piezas blancas y negras, determina cuantas piezas de cada color hay y si algún jugador ha perdido a su rey. Las piezas negras están representadas con enteros pares y las blancas con enteros impares. El rey negro está representado por el entero K y el blanco con el entero L.",
        "entrada": "En la primera línea los enteros M, N. Donde M representa el número de filas y N el número de columnas. En cada una de las siguientes M líneas, N enteros. Donde cada entero representa una pieza. En la última línea los enteros K y L.",
        "salida": "En la primera línea, los enteros A y B que denotan el número de piezas negras y blancas que hay en el tablero. En la segunda línea la frase JAQUE MATE si ALGÚN rey no está en el tablero, en caso contrario imprime NO JAQUE.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Matrices",
            "Vectores",
            "Ciclos"
        ],
        "estructuras": [
            "vector<vector<long long>>",
            "long double",
            "vector<long long>",
            "auto"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    vector<vector<long long>> num(101, vector<long long>(101, 0));\n    long double a, b, c = 0, d = 0, e, f, g = 0;\n    cin >> a >> b;\n    for (auto i = 0; i < a; i++)\n    {\n        for (auto j = 0; j < b; j++)\n        {\n            cin >> num[i][j];\n            if (num[i][j] % 2 == 0)\n            {\n                c++;\n            }\n            else\n            {\n                d++;\n            }\n        }\n    }\n    cin >> e >> f;\n    for (auto i = 0; i < a; i++)\n    {\n        for (auto j = 0; j < b; j++)\n        {\n            if (num[i][j] == e || num[i][j] == f)\n            {\n                g++;\n            }\n            if (g == 2)\n            {\n                break;\n            }\n        }\n    }\n    cout << c << \" \" << d << \"\\n\";\n    if (g == 2)\n    {\n        cout << \"NO JAQUE\";\n    }\n    else\n    {\n        cout << \"JAQUE MATE\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "5722. CB-Intro-Arbol Milagroso",
        "url": "https://omegaup.com/arena/problem/CB-Intro-Arbol-Milagroso/",
        "descripcion": "Cuentan que en un terreno baldío, cerca del Carol Baur, crece un árbol milagroso. Lo milagroso de este árbol radica en que si comes una de sus frutas puedes memorizar durante 7 días cualquier cantidad de información que quieras sin ningún esfuerzo (algo muy útil en semana de exámenes). Además, el árbol tiene la propiedad de que al caer la noche, cada una de sus frutas se convierte en dos. Sólo un grupo selecto de 10 estudiantes conoce la ubicación del árbol y este grupo te ha seleccionado para ser su nuevo integrante. Pero para ser aceptado primero deberás ser capaz de contestar la siguiente pregunta: Dado el número de frutas actualmente en el árbol y el número de integrantes del grupo (11 contándote a ti), calcula ¿cuántas noches tienen que pasar para que si cosechan TODAS las frutas del árbol menos 1 (para que puedan seguir multiplicándose) a cada miembro del grupo le toque el mismo número de frutas? Escribe un programa que dado f el número de frutas acualmente en el árbol calcule la cantidad de noches que es necesario esperar para que, si se cosechan TODAS las frutas del árbol menos 1, a cada miembro del grupo le toquen la misma cantidad de frutas.",
        "entrada": "Tu programa deberá leer del teclado un único número entero f (0 < f <= 1000) que representa la cantidad de frutas en el árbol.",
        "salida": "Tu programa deberá escribir un único número entero que represente la cantidad de noches que es necesario esperar. RETO: Es posible que el número de frutas en el árbol haga que sea imposible llegar a la configuración deseada. Si este es el caso tu programa deberá escribir un -1. La cantidad de casos así en este problema equivale a 10% de los puntos totales.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "pow()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b = 0;\n    cin >> a;\n    while (a % 11 != 1)\n    {\n        b++;\n        a *= 2;\n        if (a >= pow(2, 60))\n        {\n            cout << \"-1\";\n            return 0;\n        }\n    }\n    cout << b;\n\n    return 0;\n}"
    },
    {
        "titulo": "430. CR Diciendo Hola",
        "url": "https://omegaup.com/arena/problem/CR-Diciendo-Hola/",
        "descripcion": "En tu nuevo trabajo, que conseguiste aprendiendo a programar en el Coding Rush, tu jefe te ha pedido una tarea muy tediosa: mandar el mismo correo a muchas personas, cambiando únicamente el encabezado, de manera que diga \"hola Fulanito\", \"Hola Juanito\", \"Hola Bob\", etc. Como eres muy buen programador has decidido hacer un programa que escriba el nombre respectivo en cada carta, en lugar de escribir cada nombre uno por uno.",
        "entrada": "Leerás varias líneas, cada una con un nombre diferente.",
        "salida": "Por cada nombre leído (), tendrás que imprimir: \"Hola \", respetando el mismo formato en el que viene el nombre.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas",
            "Ciclos"
        ],
        "estructuras": [
            "string",
            "getline()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    string z;\n    while (getline(cin, z))\n    {\n        cout << \"Hola \" << z << \"\\n\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "4104. Cap Hydra",
        "url": "https://omegaup.com/arena/problem/Cap-Hydra/",
        "descripcion": "El capitán américa se ha revelado como un agente de hydra, ante este suceso shield está muy preocupado porque teme que otros agentes o superheroes puedan ser miembros de hydra. Shield ha desarrollado un sistema que escanea a una persona y determina si miente o no. Para limpiar shield de dobles agentes, ha reunido a todos los agentes y superheroes, les ha dado a cada uno un identificador numérico y los ha formado en una fila para evaluarlos uno por uno. El cap, se ha enterado del plan de shield y ha infiltrado a un programador que implantó un virus que hace que la máquina falle cada K escaneos. Cap ha instruido a todos sus agentes para que se formen en las posiciones múltiplos de K y así eviten ser descubiertos. Dados Los N identificadores de los agentes y superhéroes, y el entero K, determina cuales agentes son miembros de hydra. Fury te ha pedido que descubras a los agentes y que listes sus ids en orden decreciente.",
        "entrada": "En la primera línea los enteros n (1<=n<=1000) y k, en la segunda linea los n enteros que denotan los ids de cada agente o superhéroe formado (los ids de los agentes y superhéroes siempre serán enteros positivos.).",
        "salida": "Los ids que identifican a los agentes de hydra, en orden decreciente.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas",
            "Ciclos",
            "Vectores",
            "Ordenamiento"
        ],
        "estructuras": [
            "auto",
            "vector<long long>",
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    vector<long long> num(1001, 0);\n    vector<long long> sub(1001, 0);\n    long long a, b, c = 0;\n    cin >> a >> b;\n    for (auto i = 0; i < a; i++)\n    {\n        cin >> num[i];\n    }\n    for (auto i = 0; i < a; i++)\n    {\n        if (i % b == 0)\n        {\n            sub[c] = num[i];\n            c++;\n        }\n    }\n    sort(sub.begin(), sub.end());\n    for (auto i = c - 1; i > -1; i--)\n    {\n        cout << sub[i] << \" \";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "1251. Chavos y Reyes",
        "url": "https://omegaup.com/arena/problem/Chavos-y-Reyes/",
        "descripcion": "En el año 2048, en un universo diferente al nuestro se desencadenó una gran pelea entre chavos y caballeros (Caballeros como los de la era medieval), esto lo hacían mediante cartas, cada carta con valores y ganaban los que tuvieran la mayor suma. Frente a este el rey que gobernaba las tierras donde se dio esta pelea se enteró de tal y decidió ir a acabar con el escándalo que hicieron los chavos. Se sabe que había N chavos numerados del 1 al N y además el rey llevaba consigo una carta con un valor K. Algo curioso es que el chavo C_i tenía una carta con valor i, es decir el chavo 1 tenía una carta con valor 1, el chavo 2 con una carta de valor 2, el 3 una carta con valor 3...,  el chavo N una carta con valor N. Uno de los asistentes del rey va a llamar a los chavos que su número se encuentre entre I y D (inclusive) , estos van a sumar los valores de sus cartas y pelearan contra el rey. Esto se va a repetir Q veces y un programador que se encontraba cerca decidió ir registrando resultados. Dado N (El número de chavos en la pelea), Q (El número de veces que un grupo de chavos se enfrentó al rey), K (El valor de la carta del rey), y los rangos I y D para cada enfrentamiento, dar el registro de quien ganó en cada enfrentamiento. Si el rey gana el enfrentamiento i-ésimo enfrentaminto, el i-ésimo registro debe decir \"Rey :(\\n\" , si ganan los chavos \"Chavos :(\\n\"  , en caso de empate \"Tablas\\n\".",
        "entrada": "En la primera línea los números enteros N, Q (1<=N,Q<=30,000) y K (1<=K<=90,000,000). En las siguientes Q líneas 2 enteros I y D (1<=I<=D<=N) para cada enfrentamiento.",
        "salida": "Los registros que hizo el programador como se menciona en la descripción.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Cálculos aritméticos",
            "Ciclos"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e, f;\n    cin >> a >> b >> c;\n    while (b)\n    {\n        b--;\n        cin >> d >> e;\n        f = ((e * (e + 1)) / 2) - ((d * (d - 1)) / 2);\n        if (f > c)\n        {\n            cout << \"Chavos :)\\n\";\n        }\n        else if (f == c)\n        {\n            cout << \"Tablas\\n\";\n        }\n        else\n        {\n            cout << \"Rey :(\\n\";\n        }\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "6749. Las tareas de Briaares",
        "url": "https://omegaup.com/arena/problem/Las-tareas-de-Briaares/",
        "descripcion": "Últimamente Briaares ha estado muy atareado por lo que necesita tu ayuda. Él debe resolver tareas de las que tiene, en el menor tiempo posible. Para facilitar las cosas le asignó un valor de tiempo a cada tarea. Por el mismo motivo -- que está muy apurado -- necesita tu ayuda para que le digas cuál es el menor tiempo que debe invertir para acabar K tareas. Supongamos que decide hacer las tareas x_1 , x_2, x_3 , ... , x_k (en ese orden). Entonces, el tiempo que le toma resolver estas tareas juntas lo definió como: Sumatoria con limits_{1 <= i < j <=k} |x_i - x_j|. ¿Por qué una formula tan rara y no solo sumar los tiempos? Solo Briaares lo sabe...",
        "entrada": "En la primera linea dos enteros, N y K (2<=K<=N<=10^5), la cantidad de tareas que tiene y la cantidad que debe resolver. En la siguiente linea N enteros separados por un espacio, donde el i-esimo valor representa el tiempo que le asignó a la tarea i (0<=x_i<=10^9, donde x_i es el tiempo asignado a la tarea i).",
        "salida": "La mínima cantidad de tiempo para que Briaares acabe K tareas.",
        "nivel": "Intermedio (medio) - Análisis y diseño de algoritmos",
        "categorias": [
            "Ventana deslizante",
            "Ordenamiento",
            "Vectores",
            "Ciclos",
            "Ordenamiento"
        ],
        "estructuras": [
            "long long",
            "vector<int>",
            "auto"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c = 0, d = 0, e = 0, f = 0, g, h = 10000000000000000000000000;\n    vector<int> num(100001, 0);\n    cin >> a >> b;\n    for (auto i = 0; i < a; i++)\n    {\n        cin >> num[i];\n    }\n    sort(num.begin(), num.end());\n    for (long long i = 1; i <= a; i++)\n    {\n        c += num[i - 1];\n        d += c;\n        e += (num[i - 1] * (min(b, i)));\n        if (i >= b)\n        {\n            if (i > b)\n            {\n                d -= ((num[(i - b) - 1]) * (b + 1));\n                c -= (num[(i - b) - 1]);\n                e -= f;\n                f -= num[(i - b) - 1];\n            }\n            g = e - d;\n            if (g < h)\n            {\n                h = g;\n            }\n        }\n        f += num[i - 1];\n    }\n    cout << h;\n\n    return 0;\n}"
    },
    {
        "titulo": "3597. El Albañil Descuidado",
        "url": "https://omegaup.com/arena/problem/El-Albanil-Descuidado/",
        "descripcion": "A un albañil le encargaron hacer una escalera formada por cubos del mismo tamaño. El primer escalón debía tener un cubo, el segundo dos cubos, el tercero tres cubos y así sucesivamente hasta el último escalón, el cual debía tener n cubos. Al albañil le importó poco lo que le pidieron y puso los cubos como le dio su gana. Ahora se trata de acomodar bien los cubos. El trabajo que cuesta trasladar un cubo de un escalón a otro escalón es igual a la distancia que hay entre los escalones. Veamos el siguiente caso: se pidió hacer una escalera que tuviera cuatro escalones, por lo cual necesitaríamos que los escalones tuvieran altura 1, 2, 3 y 4. El albañil dejó la escalera como se muestra en la siguiente figura. Una forma de acomodar bien los cubos es primero pasar tres cubos del primer escalón (el de la izquierda) al tercer escalón. El trabajo que cuesta hacer esto es 3×2=6, ya que son tres cubos y se van a trasladar dos escalones. Después, se puede pasar un cubo del cuarto escalón al segundo. El trabajo que cuesta hacer esto es 1×2=2, ya que es un cubo y se va a trasladar dos escalones. El trabajo total realizado de esa forma sería 6+2=8. Sin embargo, existe otra forma de hacerlo con un trabajo total de 6. Dada la configuración que dejó el albañil, dar la cantidad mínima de trabajo necesario para que la escalera quede como se deseaba. ",
        "entrada": "Primera línea n, la cantidad de escalones, 0 < n = 100,000. Segunda línea, n números dando la cantidad de cubos que puso el albañil en cada escalón.",
        "salida": "Un único entero, la cantidad mínima de trabajo necesario para que la escalera quede como se deseaba. Siempre se podrá hacer ese trabajo.",
        "nivel": "Intermedio (medio) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Tablas de dispersión",
            "Vectores",
            "Colas",
            "Ciclos"
        ],
        "estructuras": [
            "queue<pair<long long, long long>>",
            "vector<long long>",
            "pair<long long, long long>",
            "long long",
            "auto"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    queue<pair<long long, long long>> falta;\n    queue<pair<long long, long long>> faltas;\n    vector<long long> num(100002, 0);\n    pair<long long, long long> zz;\n    pair<long long, long long> z;\n    long long a, b, c = 0, d;\n    cin >> a;\n    for (auto i = 1; i <= a; i++)\n    {\n        cin >> num[i - 1];\n        if (num[i - 1] > i)\n        {\n            z.first = i;\n            z.second = num[i - 1] - i;\n            falta.push(z);\n        }\n        else if (num[i - 1] < i)\n        {\n            z.first = i;\n            z.second = i - num[i - 1];\n            faltas.push(z);\n        }\n    }\n    if (falta.size() == 0)\n    {\n        cout << \"0\";\n        return 0;\n    }\n    z = falta.front();\n    zz = faltas.front();\n    while (true)\n    {\n        if (z.second > zz.second)\n        {\n            d = abs(z.first - zz.first);\n            d *= zz.second;\n            c += d;\n            z.second -= zz.second;\n            faltas.pop();\n            zz = faltas.front();\n        }\n        else if (z.second < zz.second)\n        {\n            d = abs(z.first - zz.first);\n            d *= z.second;\n            c += d;\n            zz.second -= z.second;\n            falta.pop();\n            z = falta.front();\n        }\n        else\n        {\n            d = abs(z.first - zz.first);\n            d *= z.second;\n            c += d;\n            falta.pop();\n            faltas.pop();\n            if (falta.size() == 0)\n            {\n                cout << c;\n                return 0;\n            }\n            z = falta.front();\n            zz = faltas.front();\n        }\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "6797. La playera de Pablo",
        "url": "https://omegaup.com/arena/problem/La-playera-de-Pablo/",
        "descripcion": "A Pablo le han dicho que le regalaran cualquier playera que él desee de una tienda. Para no verse tan avaricioso, él ha decidido llevarse la tercera playera más costosa de la tienda. Ayuda a Pablo a encontrar el precio de la playera que se llevará.",
        "entrada": "La entrada consistirá de dos líneas. En la primera habrá un entero n (n <= 1500000), la cantidad de playeras que hay en la tienda. En la segunda, n números x_i (x_i <= 10^9) separados por espacio, cada uno representando el precio de cada playera de la tienda.",
        "salida": "Un solo entero indicando el valor de la playera que eligio.",
        "nivel": "Avanzado (fácil) - Programación competitiva",
        "categorias": [
            "Ciclos",
            "Montículos"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e;\n    cin >> a >> b >> c >> d;\n    a -= 3;\n    if (c > b)\n    {\n        swap(b, c);\n    }\n    if (d > b)\n    {\n        swap(d, b);\n    }\n    if (d > c)\n    {\n        swap(c, d);\n    }\n    while (a)\n    {\n        a--;\n        cin >> e;\n        if (e > d)\n        {\n            if (c > b)\n            {\n                swap(b, c);\n            }\n            if (d > b)\n            {\n                swap(d, b);\n            }\n            if (e > b)\n            {\n                swap(e, b);\n            }\n            if (d > c)\n            {\n                swap(d, c);\n            }\n            if (e > c)\n            {\n                swap(e, c);\n            }\n            if (e > d)\n            {\n                swap(e, d);\n            }\n        }\n    }\n    cout << d;\n\n    return 0;\n}"
    },
    {
        "titulo": "5506. Mensajería",
        "url": "https://omegaup.com/arena/problem/OMI-2017-Mensajeria/",
        "descripcion": "Andrea, la matemágica alfa, administra toda la mensajería ultra secreta de la logia de los matemágicos. Como Andrea es muy buena en su trabajo, quiere minimizar el costo de enviar un mensaje a todos los cuarteles de la logia. Andrea sabe que la logia tiene N cuarteles ultra secretos en el estado de Querétaro y que están numerados de 0 a N-1. También sabe que las rutas para enviar los mensajes van de cuartel a cuartel y funcionan de la siguiente manera: El cuartel 0 tiene una ruta de envío con el cuartel 1. El cuartel 1 tiene una ruta de envío con el cuartel 2. Y así sucesivamente hasta el cuartel N-1 que tiene una ruta de mensajería con el cuartel 0. Las rutas de envío de un cuartel a otro tienen un costo (a_i) y funcionan en ambos sentidos, es decir, la ruta del cuartel 0 al cuartel 1 también funciona del cuartel 1 al 0 con el mismo costo. Para minimizar los costos, Andrea puede poner centrales de envío en cualquier cuartel y enviar el mensaje desde todas las centrales disponibles al mismo tiempo. Poner una central de envío tiene un costo K. Sin embargo, la ventaja de poner nuevas centrales de envío en otros cuarteles es que estos cuarteles ahora pueden enviar mensajes a los demás cuarteles sin ningún costo adicional más que el de las rutas usadas. Para poder enviar el mensaje, Andrea siempre debe poner al menos la primer central de envío en alguno de los cuarteles. Ayuda a Andrea a minimizar el costo total de enviar un mensaje a todos los cuarteles de la logia.",
        "entrada": "En la primera línea se encuentran los enteros N (2<= N <=1,000,000) y K (1 <= a_i,K <= 1,000).  En la segunda línea se encuentran N enteros separados por un espacio. Cada entero a_i representando el costo de la ruta de mensajería del cuartel i al al cuartel i+1. Considera que para un 36% de los casos, N <= 1,000",
        "salida": "La suma que minimice el costo de enviar un mensaje, considerando el costo de poner las nuevas centrales de envío y el costo de todas las rutas usadas para enviar el mensaje a toda la logia.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Cálculos aritméticos",
            "Ciclos",
            "Implementación"
        ],
        "estructuras": [
            "long long",
            "auto"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d = 0, e = 0, f = 0;\n    cin >> a >> b;\n    for (auto i = 0; i < a; i++)\n    {\n        cin >> c;\n        if (c >= b)\n        {\n            d = 1;\n            e += b;\n        }\n        else\n        {\n            e += c;\n            if (c > f)\n            {\n                f = c;\n            }\n        }\n    }\n    if (d == 1)\n    {\n        cout << e;\n        return 0;\n    }\n    e += (b - f);\n    cout << e;\n\n    return 0;\n}"
    },
    {
        "titulo": "6918. Convertidor",
        "url": "https://omegaup.com/arena/problem/OMI2018-Convertidor/",
        "descripcion": "La numeración biyectiva es un sistema en que todos los enteros positivos pueden ser representados de exactamente una forma. La numeración biyectiva base 26 usa el alfabeto para representar 26 dígitos del 1 al 26 (A=1, B=2, C=3, ..., Z=26, AA=27, AB=28, ...). En la numeración biyectiva 26 no se usa la letra Ñ. Esta numeración se usa en las hojas de cálculo. Escribe un programa que convierta un entero de sistema decimal a una cadena que representa su valor biyectivo 26 y viceversa.",
        "entrada": "En la primera línea un entero T que indica el tipo de conversión que vas a hacer (0 = de decimal a cadena, 1 = de cadena a decimal) En la segunda línea un entero X (1<=X<2^63) o una cadena S (La longitud de la cadena es menor a 15) dependiendo del tipo de conversión.",
        "salida": "La cadena S que representa a X si la conversión es de tipo 0, o el entero X que representa a la cadena S si si la conversión es de tipo 1.",
        "nivel": "Avanzado (medio) - Programación competitiva",
        "categorias": [
            "Cálculos aritméticos",
            "Caracteres y cadenas",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "string",
            "char",
            "pow()",
            "auto"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c = 0;\n    string z = \"\";\n    char zz;\n    cin >> a;\n    if (!a)\n    {\n        cin >> a;\n        while (a)\n        {\n            b = a % 26;\n            if (!b)\n            {\n                b = 26;\n            }\n            a -= b;\n            a /= 26;\n            zz = 64 + b;\n            z = zz + z;\n        }\n        cout << z;\n        return 0;\n    }\n    cin >> z;\n    for (auto i = z.size() - 1, j = 0; i > -1; i--, j++)\n    {\n        a = z[i] - 64;\n        b = pow(26, j) * a;\n        c += b;\n    }\n    cout << c;\n\n    return 0;\n}"
    },
    {
        "titulo": "1113. Tablero",
        "url": "https://omegaup.com/arena/problem/tablero/",
        "descripcion": "Un muchacho tiene un tablero (no importa el tamaño) muy grande, coloreado al estilo del tablero de ajedrez (cada casilla puede ser blanca o negra, no hay dos blancas juntas y no hay dos negras juntas). Él quiere saber de qué colores son ciertas casillas, pero sólo recuerda el color de una casilla. Ayúdale a responder sus preguntas, para esto, se han numerado las filas de abajo hacia arriba y las columnas de izquierda a derecha. Dado el color de cierta casilla de un tablero, decir el color de otras N casillas.",
        "entrada": "La primera línea tendrá tres enteros X, Y y C. X y Y (0<X<=Y<=1000) son los números de la fila (X) y y columna (Y) respectivamente, de la casilla de la que se conoce el color. La C representa el color (C es cero “0” si la casilla es blanca, y es uno “1” si es negra). La segunda línea tendrá un entero N, el número de casillas de las cuales deseas conocer el color. A partir de la tercera línea, habrá N líneas. En la i-ésima de estas líneas habrá dos enteros A_i y B_i (0<A_i <=B_i<=1000) que representan el número de fila y columna respectivamente de la casilla de la cual se quiere conocer el color. Todos los números serán menores a 1000.",
        "salida": "Por cada una de las últimas N líneas de la entrada escribir un uno “1” si la casilla es negra, o un cero “0” si la casilla es blanca.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Cálculos aritméticos",
            "Ciclos"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e = 0, f, g, h, l;\n    cin >> a >> b >> c;\n    if (!c)\n    {\n        d = 1;\n    }\n    else\n    {\n        d = 0;\n    }\n    if (a % 2 != b % 2)\n    {\n        e = 1;\n    }\n    cin >> f;\n    while (f)\n    {\n        f--;\n        l = 0;\n        cin >> g >> h;\n        if (g % 2 != h % 2)\n        {\n            l = 1;\n        }\n        if (e == l)\n        {\n            cout << c << \"\\n\";\n        }\n        else\n        {\n            cout << d << \"\\n\";\n        }\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "463. CR Helsinki",
        "url": "https://omegaup.com/arena/problem/CR-Helsinki/",
        "descripcion": "En la ciudad de Helsinki viven varios conejitos con distintos colores. Como estás haciendo un censo les hiciste la siguiente pregunta: \"¿Cuántos conejitos además de ti tienen el mismo color?\". Como son conejitos honestos, todos contestaron el número correcto. Además, ningún conejito contestó dos veces. Tu tarea es determinar el menor número de conejitos que puede haber en Helsinki que coincidan con las respuestas que te dieron los conejitos. Nota que no encuestaste a todos los conejitos.",
        "entrada": "En la primer línea, un entero: N, el número de conejitos encuestados. En la siguiente línea, las N respuestas de cada conejito.",
        "salida": "El menor número de conejitos que pueden haber en Helsinki",
        "nivel": "Intermedio (fácil) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Vectores",
            "Ciclos",
            "Ordenamiento"
        ],
        "estructuras": [
            "vector<int>",
            "long long",
            "auto"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    vector<int> num(60, 0);\n    long long a, b = 0;\n    cin >> a;\n    for (auto i = 0; i < a; i++)\n    {\n        cin >> num[i];\n    }\n    sort(num.begin(), num.end());\n    for (auto i = 0; i < a; i++)\n    {\n        if ((i + num[i] < 50) && num[i + num[i]] == num[i])\n        {\n            b += (num[i] + 1);\n            i += num[i];\n        }\n        else\n        {\n            while (num[i] == num[i + 1])\n            {\n                i++;\n            }\n            b += (num[i] + 1);\n        }\n    }\n    cout << b;\n\n    return 0;\n}"
    },
    {
        "titulo": "5416. A+B",
        "url": "https://omegaup.com/arena/problem/ASUMAB/",
        "descripcion": "El primer problema de hoy es tan simple como a+b. Recibirás una cadena de caracteres con dígitos. Tendrás que reacomodar esos dígitos para construir dos enteros no negativos, a y b, tal que la suma de a+b sea la más grande posible. Cada número debe tener al menos un dígito. No se permitirán ceros a la izquierda, sin embargo el número cero hecho con un solo 0 es permitido. Tendrás que usar cada digito exactamente la misma cantidad de veces que aparezca en la cadena de caracteres inicial.",
        "entrada": "La primera línea contendrá un entero t (t<=1000) especificando el número de casos. Cada caso consistirá en una línea con una cadena de caracteres con dígitos de tamaño n (n<=16).  Si hay más de dos dígitos, no todos serán ceros. Considera que para un tercio de los casos n<=3, y para los dos tercios restantes n<=9",
        "salida": "Por cada caso, imprime una línea con la suma más grande que puede ser conseguida.",
        "nivel": "Intermedio (medio) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Cálculos aritméticos",
            "Caracteres y cadenas",
            "Ordenamiento",
            "Vectores",
            "Ciclos"
        ],
        "estructuras": [
            "vector<char>",
            "long long",
            "string",
            "auto"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    vector<char> num(16, '');\n    long long a, b;\n    string z = \"\";\n    cin >> a;\n    while (a)\n    {\n        a--;\n        b = 0;\n        cin >> z;\n        for (auto i = 0; i < z.size(); i++)\n        {\n            num[i] = z[i];\n        }\n        sort(num.begin(), num.end()));\n        for (auto i = z.size() - 1; i > 0; i--)\n        {\n            b *= 10;\n            b += (num[i] - 48);\n        }\n        b += (num[0] - 48);\n        cout << b << \"\\n\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "7424. Adivina el numero2",
        "url": "https://omegaup.com/arena/problem/Adivina-el-numero2/",
        "descripcion": "Un amigo le propone que piense en número y que haga una serie de operaciones (+, -, *, /) una a la vez. A continuación su amigo pide que le diga cual es el resultado, con el cual su amigo adivina el número que pensó. Para evitar errores de redondeo aseguramos que en todos los casos de prueba la división es exacta.",
        "entrada": "La primera línea tiene un número C (C<=100) que indica la cantidad de casos. A continuación vendrá una línea con el número de operaciones N (0<=N<=100). Las siguientes N líneas indican las operaciones realizadas en el formato operador número. La última línea de cada test será el resultado de hacer las N operaciones indicadas en el número pensado.",
        "salida": "Por cada test, se debe dar como resultado el número inicial. La salida deberá seguir estrictamente el formato del ejemplo a seguir.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Tablas de dispersión",
            "Caracteres y cadenas",
            "Vectores",
            "Ciclos"
        ],
        "estructuras": [
            "vector<pair<char, int>>",
            "long long",
            "char"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    vector<pair<char, int>> num(1000, {'', 0});\n    long long a, b = 1, c, d;\n    char z;\n    cin >> a;\n    while (b <= a)\n    {\n        cin >> c;\n        for (auto i = 0; i < c; i++)\n        {\n            cin >> num[i].first >> num[i].second;\n        }\n        cin >> d;\n        for (auto i = c - 1; i > -1; i--)\n        {\n            if (num[i].first == '+')\n            {\n                d -= num[i].second;\n            }\n            else if (num[i].first == '-')\n            {\n                d += num[i].second;\n            }\n            else if (num[i].first == '*')\n            {\n                d /= num[i].second;\n            }\n            else\n            {\n                d *= num[i].second;\n            }\n        }\n        cout << \"Caso #\" << b << \": \" << d << \"\\n\";\n        b++;\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "1053. Buscando Parejas",
        "url": "https://omegaup.com/arena/problem/Buscando-Parejas/",
        "descripcion": "En una sociedad extraña acaban de pasar una ley sobre cómo se deben casar las personas. Como las reglas son muy complicadas, te pidieron que escribieras un programa para saber cuántos y cuáles hombres se quedarían solteros si las siguieran. El procedimiento para encontrar pareja es así: El hombre más viejo se debe casar con la mujer que tenga la edad más cercana a él. El proceso se repite hasta que ya no haya parejas posibles. La ley decreta que sólo se pueden casar hombres con mujeres, siempre y cuando se sigan las reglas anteriores. (Les dijimos que era una sociedad extraña.) Por ejemplo, si hay 3 hombres con 26, 24 y 28 años y 4 mujeres con 20, 25, 26 y 29 años, las parejas serían: el hombre de 28 con la mujer de 29, el hombre de 26 con la mujer de 26, el hombre de 24 con la mujer de 25, y la mujer de 20 se queda sola.",
        "entrada": "Dos enteros, H y M: la cantidad de hombres y mujeres. En la siguiente línea H enteros: las edades de los hombres. En la siguiente línea M enteros: las edades de las mujeres. Por el 50% de los puntos N,M<=1000, y para el resto de los puntos N,M<=100000.",
        "salida": "En caso de que no queden hombres solteros, imprime “No hay solteros”. Si quedan hombres solteros, imprime cuántos y la edad del más joven.",
        "nivel": "Intermedio (fácil) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Vectores",
            "Ciclos",
            "Ordenamiento"
        ],
        "estructuras": [
            "vector<int>",
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    vector<int> num(100000, 0);\n    vector<int> sub(100000, 0);\n    long long a, b;\n    cin >> a >> b;\n    for (auto i = 0; i < a; i++)\n    {\n        cin >> num[i];\n    }\n    for (auto i = 0; i < b; i++)\n    {\n        cin >> sub[i];\n    }\n    if (a <= b)\n    {\n        cout << \"No hay solteros\";\n        return 0;\n    }\n    sort(num.begin(), num.end());\n    cout << a - b << \" \" << num[0];\n\n    return 0;\n}"
    },
    {
        "titulo": "4086. Conjunto",
        "url": "https://omegaup.com/arena/problem/Conjunto/",
        "descripcion": "Escribe un programa que decida si una cadena pertenece al conjunto S de cadenas formadas por los caracteres 'a', 'b', 'c', 'd', '(', ')' y que tienen sus paréntesis balanceados (es decir, cada paréntesis que abre tiene un paréntesis de cierre, el cual aparece después).",
        "entrada": "Una cadena de a lo más 100 caracteres.",
        "salida": "Un 1 si la cadena de entrada pertenece a S, o un en caso contrario.",
        "nivel": "Intermedio (medio) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Pilas",
            "Caracteres y cadenas",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "string",
            "auto"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a;\n    string z;\n    cin >> z;\n    for (auto i = 0; i < z.size(); i++)\n    {\n        if (z[i] != 'a' && z[i] != 'b' && z[i] != 'c' && z[i] != 'd' && z[i] != '(' && z[i] != ')')\n        {\n            cout << \"0\";\n            return 0;\n        }\n        else if (z[i] == '(')\n        {\n            a++;\n        }\n        else if (z[i] == ')')\n        {\n            a--;\n            if (a == -1)\n            {\n                cout << \"0\";\n                return 0;\n            }\n        }\n    }\n    if (a)\n    {\n        cout << \"0\";\n    }\n    else\n    {\n        cout << \"1\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "3428. COCI-Timsko",
        "url": "https://omegaup.com/arena/problem/Timsko/",
        "descripcion": "Cada año, la universidad de Zagred organiza un competecia de informática por equipos. Cada equipo debe estar compuesto por tres estudiantes. Normalmente, los mejores competidores de la universidad son chicas, y ellas superan significativamente en número a los chicos. Este año los chicos se han levantado la voz y se hizo una regla que hace que cada equipos deba estar formado exactamente por un chico y dos chicas. Para hacerle la vida más dificil a los competidores, el director de la univesidad ha decicido mandar a K estudiantes de intercambio a un país lejano. Estos competidores no estarán disponibles para la competencia. Dado el número de competidoras (M), el número de competidores (N) y número de competidores que tienen que ser enviados de intercambio (K),  el director tiene que crear el número máximo de equipos disponibles para asistir a la competencia. Por ejemplo, si M es 6, N es 3 y K es 2, el director puede enviar una chica y un chico de intercambio. Después el puede crear 2 equipos a partir de los competidores sobrantes. (Una chica quedaría sin equipo).",
        "entrada": "La primera y única línea contiene tres enteros: M (0<=M<=100), el número de chicas; N (0<=N<=100), el número de chicos; y K (0<=K<= N+M), el número de competidores que tienen que ser mandados de intercambio.",
        "salida": "La primera y única línea debe contener un único número , el máximo número de equipos que pueden ser formados.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d;\n    cin >> a >> b >> c;\n    if (!a || !b)\n    {\n        cout << \"0\";\n        return 0;\n    }\n    if (!c)\n    {\n        a /= 2;\n        c = min(a, b);\n        cout << c;\n        return 0;\n    }\n    if (a % 2)\n    {\n        a--;\n        c--;\n        if (!c)\n        {\n            a /= 2;\n            c = min(a, b);\n            cout << c;\n            return 0;\n        }\n    }\n    if (b > (a / 2))\n    {\n        d = b - (a / 2);\n        c -= d;\n        b -= d;\n        if (c < 1)\n        {\n            a /= 2;\n            c = min(a, b);\n            cout << c;\n            return 0;\n        }\n    }\n    if (b < (a / 2))\n    {\n        d = (a / 2) - b;\n        c -= (d * 2);\n        a -= (d * 2);\n        if (c < 1)\n        {\n            a /= 2;\n            c = min(a, b);\n            cout << c;\n            return 0;\n        }\n    }\n    d = c / 3;\n    if (c % 3)\n    {\n        d++;\n    }\n    b -= d;\n    cout << b;\n\n    return 0;\n}"
    },
    {
        "titulo": "6200. Flock triangle",
        "url": "https://omegaup.com/arena/problem/flock_triangle/",
        "descripcion": "Muestra un triángulo que se genera a partir de dos números: el tamaño y la semilla. El tamaño n (1<=n<=20) indica cuantos renglones tendrá el triángulo, y la semilla s (1<=s<=9) será el primer número del triángulo.",
        "entrada": "Dos enteros separados por un espacio: n y s.",
        "salida": "Muestra un triángulo de n renglones empezando en scomo primer número del triángulo, como se indica en los ejemplos.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Matrices",
            "Ciclos"
        ],
        "estructuras": [
            "vector<vector<int>>",
            "long long",
            "auto"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    vector<vector<int>> num(30, vector<int>(30, 0));\n    long long a, b;\n    cin >> a >> b;\n    for (auto i = 1; i <= a; i++)\n    {\n        for (auto j = 1; j <= i; j++)\n        {\n            num[j][i] = b;\n            b++;\n            if (b == 10)\n            {\n                b = 1;\n            }\n        }\n    }\n    for (auto i = 1; i <= a; i++)\n    {\n        for (auto j = 1; j <= a; j++)\n        {\n            if (j < i)\n            {\n                cout << \"  \";\n            }\n            else\n            {\n                cout << num[i][j] << \" \";\n            }\n        }\n        cout << \"\\n\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "6599. Divisores Training Gate",
        "url": "https://omegaup.com/arena/problem/Divisores-Training-Gate/",
        "descripcion": "Se dice que un número entero a es divisor de b,  si y solo sí existe un sólo número natural d, tal que a * d = b. En este problema recibirás un número y se requiere saber cuantos divisores tiene este número, y cuales son.",
        "entrada": "Para cada caso de prueba recibirás N (1 <= N < 2^31), los casos terminan cuando N=0.",
        "salida": "Para cada caso de prueba debes imprimir en numero de divisores que tiene el numero N, y en la siguiente línea todos sus divisores ordenados de menor a mayor.",
        "nivel": "Intermedio (medio) - Matemáticas en la programación",
        "categorias": [
            "Teoría de números",
            "Vectores",
            "Ciclos",
            "Ordenamiento"
        ],
        "estructuras": [
            "vector<int>",
            "long long",
            "sqrt()",
            "auto"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    vector<int> num(100000, 0);\n    long long a, b, c;\n    cin >> a;\n    while (a)\n    {\n        b = 1;\n        c = 0;\n        while (b < sqrt(a))\n        {\n            if (a % b == 0)\n            {\n                num[c] = b;\n                num[c + 1] = a / b;\n                c += 2;\n            }\n            b++;\n        }\n        if (b * b == a)\n        {\n            num[c] = b;\n            c++;\n        }\n        sort(num.begin(), num.end());\n        cout << c << \"\\n\";\n        for (auto i = 0; i < c; i++)\n        {\n            cout << num[i] << \" \";\n        }\n        cout << \"\\n\";\n        cin >> a;\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "6177. Saltador alegre",
        "url": "https://omegaup.com/arena/problem/Saltador-alegre/",
        "descripcion": "Una secuencia de n>0 enteros es llamada \"saltador alegre\" si el valor absoluto de la diferencia entre elementos sucesivos toman todos los valores desde el 1 hasta n-1. Por ejemplo: es un saltador alegre, porque las diferencias absolutas son 3, 2 y 1 respectivamente. La definición implica que cualquier secuencia de un solo entero es un saltador alegre. Escribe un programa que determine si una secuencia es un saltador alegre o no.",
        "entrada": "En la primera linea tendrás un número t (t <= 100) , que representa la cantidad de casos que resolverás. En las siguientes t líneas encontrarás el número n (n <= 3,000), seguido de n valores que representan la secuencia. Considera que |n_i| <= 10,000 (cada elemento de la secuencia).",
        "salida": "Para cada caso debes imprimir una linea diciendo \"Alegre\" o \"No alegre\".",
        "nivel": "Intermedio (fácil) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Vectores",
            "Ciclos",
            "Ordenamiento"
        ],
        "estructuras": [
            "vector<int>",
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    vector<int> num(100000, 0);\n    long long a, b, c, d, e;\n    cin >> a;\n    while (a)\n    {\n        a--;\n        e = 0;\n        cin >> b;\n        cin >> c;\n        b--;\n        while (b)\n        {\n            cin >> d;\n            num[e] = abs(c - d);\n            e++;\n            c = d;\n            b--;\n        }\n        sort(num.begin(), num.end());\n        for (auto i = 0; i < e; i++)\n        {\n            if (i + 1 != num[i])\n            {\n                e = -1;\n                break;\n            }\n        }\n        if (e == -1)\n        {\n            cout << \"No alegre\\n\";\n        }\n        else\n        {\n            cout << \"Alegre\\n\";\n        }\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "5037. Bello Campo",
        "url": "https://omegaup.com/arena/problem/Bello-Campo/",
        "descripcion": "Tienes un campo de 5 x 5 metros dividido en cuadros de 1x1, de los cuales 24 están vacíos y hay un único brote de árbol. Para que el campo se vea bello el árbol debe crecer en el centro, por lo tanto, si nació ahí se deberá mover. Solo puedes mover el árbol un cuadro a la vez y únicamente se permiten movimientos horizontales(izquierda-derecha) y verticales (arriba-abajo). Necesitas saber cuál es la mínima cantidad de pasos que necesitas para llevar el árbol de su posición inicial al centro del campo.",
        "entrada": "Consiste en 5 líneas, y cada línea contiene 5 enteros. Donde existen 24 cero (0) los cuales representan un espacio vacío en el campo y un único uno (1) que representa el brote de árbol que deberás mover al centro del campo.",
        "salida": "Imprime un único numero entero – El mínimo número de movimientos que necesitas para llevar el árbol al centro.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Ciclos",
            "Cálculos aritméticos"
        ],
        "estructuras": [
            "long long",
            "auto"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b;\n    for (auto i = 0; i < 5; i++)\n    {\n        for (auto j = 0; j < 5; j++)\n        {\n            cin >> b;\n            if (b)\n            {\n                a = abs(2 - i) + abs(2 - j);\n            }\n        }\n    }\n    cout << a;\n\n    return 0;\n}"
    },
    {
        "titulo": "7410. Buddy y el pollo.",
        "url": "https://omegaup.com/arena/problem/Buddy-y-el-pollo/",
        "descripcion": "En un día normal, Buddy el perro iba caminando por la calle, pensando en lo rico que sería comerse un pollo. Al tratar de comunicarle a su dueña su necesidad de comer pollo, se dio cuenta de que no tenía suficientes croquetas para decirle este mensaje (sí, Buddy y su dueña se entienden con croquetas). Triste pero no derrotado, Buddy se decidió salir de casa en busca de delicioso pollo frito, rostizado o en salsa verde. Al cabo de unos días, un misterioso pollo de tamaño n  apareció en su camino, este fue el mejor día de su vida. Como Buddy es un perro muy compartido, consideró repartirlo entre sus amigos perrunos, y analizó de qué manera podía repartir el pollo en partes iguales sin que sobrara ningún pellejito, hueso o carne. Ayuda a Buddy dándole todas las opciones en las que puede repartir su pollo.",
        "entrada": "La entrada consiste de una sola línea con n: el tamaño del pollo. Considera que: Para un conjunto agrupado del 25% 0<=n<=2*10^7. Para un conjunto agrupado del 25% 0<=n<=7*10^7. Para un conjunto agrupado del 50% 0<=n<=10^9.",
        "salida": "Deberás imprimir en una sola línea una lista con las opciones en las que Buddy puede repartir su pollo en partes iguales. Como Buddy quiere evitar la fatiga, deberás imprimir esta lista en orden ascendente. Si dicha lista no existe entonces deberás dejar una línea en blanco.",
        "nivel": "Intermedio (fácil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Teoría de números",
            "Números grandes",
            "Ordenamiento",
            "Pilas",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "stack<int>",
            "sqrt()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b = 1;\n    stack<int> falta;\n    cin >> a;\n    while (b < sqrt(a))\n    {\n        if (a % b == 0)\n        {\n            cout << b << \" \";\n            falta.push(a / b);\n        }\n        b++;\n    }\n    if (b * b == a)\n    {\n        cout << b << \" \";\n    }\n    while (falta.size())\n    {\n        cout << falta.top() << \" \";\n        falta.pop();\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "191. L-OMI98-Calculos",
        "url": "https://omegaup.com/arena/problem/OIEG2013SSA/",
        "descripcion": "Tienes una calculadora de 4 dígitos decimales que sólo puede realizar 2 operaciones: multiplicar por A y dividir entre B. Si el resultado de multiplicar un número por A es un número de más de 4 dígitos la calculadora da como resultado 1. Si el resultado de dividir entre B no es un número entero, entonces la calculadora trunca el resultado entregando únicamente la parte entera. Por ejemplo, si A=2 y B=3 entonces 20*A=40 y 20/B=6 mientras que 6000*A=1 y 6000/B=2000. La calculadora siempre comienza con el número 1 y almacena el último resultado obtenido para utilizarlo en la siguiente operación. Escribe un programa que dados A y B encuentre el número mínimo de pasos que se tienen que realizar con la calculadora para obtener un número N comenzando en el 1 y utilizando únicamente las dos operaciones válidas.",
        "entrada": "En la primera linea los enteros A, B y N. Dónde 1<=A,B,N<=10^4.",
        "salida": "En la primera linea la cantidad mínima de pasos para obtener N.",
        "nivel": "Intermedio (medio) - Análisis y diseño de algoritmos",
        "categorias": [
            "Búsqueda en amplitud",
            "Colas",
            "Vectores",
            "Ciclos"
        ],
        "estructuras": [
            "queue<pair<int, int>>",
            "vector<int>",
            "long long",
            "pair<int, int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    queue<pair<int, int> >falta;\n    vector<int> num(10000, 0);\n    long long a, b, c;\n    pair<int, int>z;\n    cin>>a>>b>>c;\n    z.first++;\n    num[1]=1;\n    falta.push(z);\n    while(true){\n        z=falta.front();\n        falta.pop();\n        z.second++;\n        z.first*=a;\n        if(z.first==c){\n            cout<<z.second;return 0;\n        }\n        else if(z.first<10000 && !num[z.first]){\n            falta.push(z);\n            num[z.first]=1;\n        }\n        z.first/=a;\n        z.first/=b;\n        if(z.first==c){\n            cout<<z.second;return 0;\n        }\n        else if(z.first && !num[z.first]){\n            falta.push(z);\n            num[z.first]=1;\n        }\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "3077. occ04pnsf24",
        "url": "https://omegaup.com/arena/problem/Vueltas-Minuto-de-Dios/",
        "descripcion": "En cierta cadena de almacenes están redondeando hacia arriba la cifra que el cliente paga para que se acerque a un múltiplo de 50 pesos. La diferencia es donada ala Fundación MInuto de Dios.",
        "entrada": "La cantidad pagada por un cliente.",
        "salida": "La cantidad de la donación por redondeo al Minuto de Dios.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a;\n    cin>>a;\n    a%=50;\n    if(!a){\n        cout<<\"0\";return 0;\n    }\n    cout<<50-a;\n    \n    return 0;\n}"
    },
    {
        "titulo": "2223. Anagramas",
        "url": "https://omegaup.com/arena/problem/Anagramas/",
        "descripcion": "Una palabra A y una palabra B son anagramas si A y B tienen las mismas letras, por ejemplo \"paso\" y \"sopa\". Todas las palabras seran minusculas. Determinar si dos cadenas son anagramas.",
        "entrada": "Un entero N que indica el numero de casos de prueba, seguido por N lineas que contienen 2 cadenas de caracteres separadas por un espacio en blanco.",
        "salida": "N líneas de salida con \"si\" o \"no\" segun corresponda, \"si\" si son anagramas y \"no\" en caso contrario.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas",
            "Vectores",
            "Ciclos"
        ],
        "estructuras": [
            "vector<int>",
            "long long",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    vector<int> num(26, 0);\n    long long a, b;\n    string z, zz;\n    cin>>a;\n    while(a--){\n        cin>>z>>zz;\n        if(z.size()!=zz.size()){\n            cout<<\"no\\n\";continue;\n        }\n        for(auto i=0; i<z.size(); i++){\n            num[z[i]-97]++;\n        }\n        for(auto i=0; i<zz.size(); i++){\n            num[zz[i]-97]--;\n        }\n        b=0;\n        for(auto i=0; i<26; i++){\n            if(num[i]){\n                b=1;\n            }\n            num[i]=0;\n        }\n        if(b){\n            cout<<\"no\\n\";\n        }\n        else{\n            cout<<\"si\\n\";\n        }\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "996. Bajo el cielo estrellado",
        "url": "https://omegaup.com/arena/problem/bce/",
        "descripcion": "De grande te gustaría ser astrónomo y muchas veces te has preguntado cuántas estrellas hay en el universo. Te queda claro que esta pregunta no la podrás responder únicamente mirando hacia el cielo, pues es posible que el brillo de una estrella cercana oculte a las que están atrás. Lo que sí podrás contestar es cuántas estrellas visibles hay en el firmamento. Como nosotros miramos el cielo desde abajo, diremos que el brillo de una estrella con coordenadas X_0,Y_0 oculta a todas las estrellas que están arriba (es decir, a aquéllas con coordenadas X_0,Y_i con Y_i>Y_0). Escribe un programa que dadas las coordenadas de N estrellas calcule las E estrellas visibles en el firmamento.",
        "entrada": "Un entero N seguido de N coordenadas enteras X,Y. Puedes suponer que 0<=N,X,Y<=50000 y que todas las estrellas tendrán coordenadas diferentes. 0<=N,X,Y<=50000.",
        "salida": "Un entero E seguido de las coordenadas X,Y de las E estrellas visibles, una por línea y ordenadas de forma creciente con respecto a la componente X. Las componentes de las coordenadas deberán ir separadas por un espacio.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Vectores",
            "Tablas de dispersión",
            "Ciclos",
            "Ordenamiento"
        ],
        "estructuras": [
            "vector<pair<int, int>>",
            "map<int, int>",
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    vector<pair<int, int>> num(50001, {0, 0});\n    map<int, int>falta;\n    long long a;\n    cin>>a;\n    for(auto i=0; i<a; i++){\n        cin>>num[i].first>>num[i].second;\n    }\n    sort(num.begin(), num.end());\n    falta[num[0].first]=num[0].second;\n    for(auto i=1; i<a; i++){\n        if(num[i].first!=num[i-1].first){\n            falta[num[i].first]=num[i].second;\n        }\n    }\n    cout<<falta.size()<<\"\\n\";\n    map<int, int>::iterator it=falta.begin();\n    while(it!=falta.end()){\n        cout<<it->first<<\" \"<<it->second<<\"\\n\";\n        it++;\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "5638. Los cuadrados semimágicos",
        "url": "https://omegaup.com/arena/problem/Los-cuadrados-semimagicos/",
        "descripcion": "Te gustan mucho los acertijos y estás estudiando el tema de los cuadrados semimágicos (los cuadrados mágicos todavía se te complican un poco). Un cuadrado semimágico es una matriz de NxN números que tiene la propiedad de que la suma de los elementos de cada fila, cada columna y ambas diagonales vale lo mismo. Crees ser capaz de escribir un programa que te diga si una matriz cuadrada es o no un cuadrado semimágico.",
        "entrada": "Un entero N seguido de NxN enteros que representan los elementos de una matriz cuadrada dada de arriba hacia abajo y de izquierda a derecha. Puedes suponer que 1<=N<=100 y que los enteros de la matriz caben en un int.",
        "salida": "Un 1 si la matriz dada es un cuadrado semimágico y un 0 en otro caso.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Cálculos aritméticos",
            "Matrices",
            "Ciclos"
        ],
        "estructuras": [
            "vector<vector<int>>",
            "long double"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    vector<vector<int>> num(101, vector<int> (101, 0));\n    long double a, b=0, c, e=0;\n    cin>>a;\n    for(auto j=0; j<a; j++){\n        cin>>num[0][j];\n        b+=num[0][j];\n    }\n    for(auto i=1; i<a; i++){\n        c=0;\n        for(auto j=0; j<a; j++){\n            cin>>num[i][j];\n            c+=num[i][j];\n        }\n        if(c!=b){\n            e=1;\n        }\n    }\n    if(e){\n        cout<<0;return 0;\n    }\n    for(auto i=0; i<a; i++){\n        c=0;\n        for(auto j=0; j<a; j++){\n            c+=num[j][i];\n        }\n        if(c!=b){\n            cout<<0;return 0;\n        }\n    }\n    c=0;\n    for(auto i=0; i<a; i++){\n        c+=num[i][i];\n    }\n    if(c!=b){\n        cout<<0;return 0;\n    }\n    c=0;\n    for(auto i=0, j=a-1; i<a; i++, j--){\n        c+=num[i][j];\n    }\n    if(c!=b){\n        cout<<0;return 0;\n    }\n    cout<<1;\n\n    return 0;\n}"
    },
    {
        "titulo": "7444. UP-HeapSort",
        "url": "https://omegaup.com/arena/problem/UP-HeapSort/",
        "descripcion": "Dado un arreglo numérico, aplicar el ordenamiento por montículo para regresarlo ordenado, de menor a mayor.",
        "entrada": "Una sóla línea con un conjunto de n números enteros separados por espacio. n<1000000.",
        "salida": "Los números de la entrada, ordenados de menor a mayor, separados por espacio.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Ordenamiento",
            "Vectores",
            "Ciclos"
        ],
        "estructuras": [
            "vector<int>",
            "long double"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    vector<int> falta;\n    long double b=0;\n    while(cin>>b){\n        falta.push_back(b);\n    }\n    sort(falta.begin(), falta.end());\n    vector<int>::iterator it=falta.begin();\n    while(it!=falta.end()){\n        cout<<*it++<<\" \";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "1582. La Lista de Reservaciones",
        "url": "https://omegaup.com/arena/problem/reservaciones/",
        "descripcion": "Eres el gerente de operaciones del Teatro de la Ópera de tu ciudad. En este teatro no se presentan únicamente cantantes de ópera, sino también grupos musicales, obras de teatro, exhibiciones de productos y otros eventos especiales. El día de hoy llegó a tus manos una lista de r reservaciones para futuros eventos. Sin embargo, en esta lista existen eventos diferentes que desean presentarse en la misma fecha, y por motivos de montaje y desmontaje sólo puede haber un evento por dia. La lista está de acuerdo al orden en el que se hicieron las reservaciones, así es que debes respetar ese orden. Es decir, si hay 2 o más eventos para la misma fecha, debes aceptar el primero que aparezca en la lista y rechazar los demás. Dada una lista de reservaciones con sus respectivas fechas, escribe un programa que cuente el número n de reservaciones que fueron rechazadas, y que obtenga una lista con la fecha y el nombre de dichas reservaciones. No importa el orden en el que estén estos eventos rechazados, lo importante es que enumeres todos y cada uno de ellos.",
        "entrada": "Linea 1: r, el número de reservaciones en la lista. Siguientes r lineas: dia, mes, año de presentacion, y nombre del evento, separados por un espacio. 10<=r<=20000. Todas las fechas son válidas y estarán comprendidas entre el 1 de enero de 2000 y 31 de diciembre de 2199. El nombre del evento será una sola palabra sin espacios. La longitud del nombre será entre 1 y 255 caracteres inclusive.",
        "salida": "Linea 1:, número n de reservaciones rechazadas. Siguientes n lineas: Lista de reservaciones rechazadas, una por linea.",
        "nivel": "(medio)",
        "categorias": [
            "Vectores",
            "Caracteres y cadenas",
            "Colas",
            "Ciclos",
            "Ordenamiento"
        ],
        "estructuras": [
            "vector<pair<long double, int>>",
            "vector<string>",
            "queue<pair<long double, string>>",
            "pair<long double, string>",
            "long double",
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    vector<pair<long double, int>> num(20001, {0, 0});\n    vector<string> sub(20001, \"\");\n    queue<pair<long double, string> >falta;\n    pair<long double, string>z;\n    long double a, b, c, d;\n    long long zz;\n    cin>>a;\n    zz=a;\n    for(auto i=0; i<a; i++){\n        cin>>b>>c>>d>>sub[i];\n        num[i].first=d+(c/100)+(b/10000);\n        num[i].second=i;\n    }\n    sort(num.begin(), num.end());\n    for(auto i=1; i<a; i++){\n        if(num[i].first==num[i-1].first){\n            z.first=num[i].first;\n            z.second=sub[num[i].second];\n            falta.push(z);\n        }\n    }\n    cout<<falta.size()<<\"\\n\";\n    while(falta.size()){\n        z=falta.front();\n        falta.pop();\n        zz=(z.first*10000);\n        zz%=100;\n        if(zz<10){\n            cout<<0;\n        }\n        cout<<zz<<\" \";\n        zz=(z.first*100);\n        zz%=100;\n        if(zz<10){\n            cout<<0;\n        }\n        cout<<zz<<\" \";\n        zz=z.first;\n        cout<<zz<<\" \"<<z.second<<\"\\n\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "4081. ADMISIÓN ASINUS INSTITUTE",
        "url": "https://omegaup.com/arena/problem/ADMISION-ASINUS-INSTITUTE/",
        "descripcion": "La tercera generación del ASINUS INSTITUTE está por ingresar, los estudiantes están a días de presentar su examen de admisión; según la estadística, indica que aquellos estudiantes que han sido aceptados, es porque logran una puntuación > o = a 200 reactivos. Existen tres categorías para ser aceptado, EXCELENCIA que se obtiene con una puntuación de 300, BUENO con puntuación de 250 y REGULAR de 200 puntos. Si para alcanzar 20 reactivos es necesario que se estudien 4 horas, ayuda a Rafael a saber si será aceptado o no, y que tipo de estudiante es.",
        "entrada": "El número de horas que ha estudiado. Las horas no pueden ser menor que 0, de lo contrario marcará \"ERROR\".",
        "salida": "La puntuación que obtendrá en su examen de admisión dependiendo del número de horas que estudio. ACEPTADO-EXCELENTE, ACEPTADO-BUENO, ACEPTADO-REGULAR según sea el caso o bien NO ACEPTADO. El puntaje máximo a obtener es 300. El puntaje mínimo para ser aceptado es de 200.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a;\n    cin>>a;\n    a*=5;\n    if(a<0){\n        cout<<\"ERROR\";return 0;\n    }\n    cout<<a<<\"\\n\";\n    if(a>299){\n        cout<<\"ACEPTADO-EXCELENTE\";\n    }\n    else if(a>249){\n        cout<<\"ACEPTADO-BUENO\";\n    }\n    else if(a>199){\n        cout<<\"ACEPTADO-REGULAR\";\n    }\n    else{\n        cout<<\"NO ACEPTADO\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "2576. Bacterias",
        "url": "https://omegaup.com/arena/problem/mirBacterias/",
        "descripcion": "Un grupo de biólogos computacionales ha diseñado un experimento para decidir si una colonia de microbios es capaz de resolver problemas cuando se le estimula de ciertas formas específicas. En este experimento se construye un recipiente con la forma de una cuadricula rectangular con m renglones y n columnas. En cada uno de los cuadritos de la cuadricula se coloca cierta cantidad de un compuesto químico que le es muy desagradable a los microbios y que, por lo tanto, los microbios preferirían evitar lo más posible. El recipiente está inclinado de tal forma que los microbios solo puede avanzar hacia el este o hacia el sur. Por supuesto, los microbios tampoco pueden salir del recipiente. Al principio la colonia de microbios está localizada en el cuadrito correspondiente al primer renglón y primera columna del recipiente. Al final se espera que la colonia de microbios termine en el cuadrito correspondiente al último renglón y última columna del recipiente. En términos de un sistema de coordenadas, los microbios comienzan en la coordenada (1, 1) y terminan en la coordenada (m, n). Antes de llevar a cabo el experimento, los científicos desean calcular la cantidad c de unidades del compuesto químico que deberá soportar la colonia en su trayecto, esto es, la suma de todas las cantidades del compuesto químico que fueron depositadas en todos los cuadritos por los que pasen. En el ejemplo se muestra un recipiente donde el mínimo valor posible de c es 17.",
        "entrada": "Dos enteros m y n separados por un espacio, seguidos de m renglones cada uno con n enteros separados por espacios. Estos enteros representan las cantidades del compuesto químico. Puedes suponer que 2 ≤ m ≤ 100, 2 ≤ n ≤ 100 y que todas las demás cantidades están entre 1 y 9, incluyéndolos.",
        "salida": "Deberás escribir en pantalla un entero c el cual representa la cantidad mínima del compuesto químico al que puede estar expuesto la colonia durante su recorrido. Consideraciones Tu programa se evaluará con varios casos de prueba.",
        "nivel": "Intermedio (medio) - Análisis y diseño de algoritmos",
        "categorias": [
            "Programación dinámica",
            "Búsqueda en amplitud",
            "Matrices",
            "Colas",
            "Ciclos"
        ],
        "estructuras": [
            "vector<vector<pair<int, int>>>",
            "long long",
            "queue<struct>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct sobra{\n    int aa, bb, cc;\n};\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    vector<vector<pair<int, int>>> num(101, vector<pair<int, int>>(101, {0, 0}));\n    long long a, b, c=102010;\n    queue<sobra> falta;\n    sobra z, zz;\n    cin>>a>>b;\n    for(auto i=0; i<a; i++){\n        for(auto j=0; j<b; j++){\n            cin>>num[i][j].first;\n        }\n    }\n    z.cc=num[0][0].first;\n    num[0][0].second=1;\n    falta.push(z);\n    while(falta.size()){\n        z=falta.front();\n        falta.pop();\n        z.aa++;\n        if(z.aa==a-1 && z.bb==b-1){\n            z.cc+=num[z.aa][z.bb].first;\n            if(z.cc<c){\n                c=z.cc;\n            }\n            z.cc-=num[z.aa][z.bb].first;\n        }\n        else if(z.aa<a){\n            z.cc+=num[z.aa][z.bb].first;\n            if(num[z.aa][z.bb].second){\n                while(true){\n                    zz=falta.front();\n                    falta.pop();\n                    if(zz.aa==z.aa && zz.bb==z.bb){\n                        break;\n                    }\n                    falta.push(zz);\n                }\n                if(zz.cc<z.cc){\n                    falta.push(zz);\n                }\n                else{\n                    falta.push(z);\n                }\n            }\n            else{\n                falta.push(z);\n                num[z.aa][z.bb].second=1;\n            }\n            z.cc-=num[z.aa][z.bb].first;\n        }\n        z.aa--;\n        z.bb++;\n        if(z.aa==a-1 && z.bb==b-1){\n            z.cc+=num[z.aa][z.bb].first;\n            if(z.cc<c){\n                c=z.cc;\n            }\n            z.cc-=num[z.aa][z.bb].first;\n        }\n        else if(z.bb<b){\n            z.cc+=num[z.aa][z.bb].first;\n            if(num[z.aa][z.bb].second){\n                while(true){\n                    zz=falta.front();\n                    falta.pop();\n                    if(zz.aa==z.aa && zz.bb==z.bb){\n                        break;\n                    }\n                    falta.push(zz);\n                }\n                if(zz.cc<z.cc){\n                    falta.push(zz);\n                }\n                else{\n                    falta.push(z);\n                }\n            }\n            else{\n                falta.push(z);\n                num[z.aa][z.bb].second=1;\n            }\n            z.cc-=num[z.aa][z.bb].first;\n        }\n    }\n    cout<<c;\n\n    return 0;\n}"
    },
    {
        "titulo": "7430. Lucky Purchase",
        "url": "https://omegaup.com/arena/problem/Lucky-Purchase/",
        "descripcion": "Sharon quiere comprar una computadora portátil para programar. Planea comprar una computadora portátil cuyo precio esté formado únicamente por los dígitos 4 y 7. La cantidad de 4 y 7 en el precio debe ser igual. Se te proporcionan las marcas de las computadoras portátiles y sus precios. Busque e imprima el nombre de la marca de la computadora portátil que cumpla con los criterios anteriores. Si hay varias marcas que cumplen con los criterios, imprima el nombre de la que tenga el menor precio. Si ninguna de las computadoras portátiles cumple con los criterios, imprima -1. Por ejemplo, si Sharon tiene que elegir entre las computadoras portátiles 'BestBook', cuyo precio es de 444777 y 'LapBook', cuyo precio es de 7744, la solución debería indicar que la opción ideal es 'LapBook'. Aunque tanto 'BestBook' como 'LapBook' tienen la misma cantidad de 4 y 7 en el precio, 'LapBook' tiene un precio más bajo, lo que la convierte en la opción correcta para Sharon.",
        "entrada": "La primera línea contiene un número entero n, que indica la cantidad de computadoras portátiles. Las siguientes n líneas contienen una cadena (nombre de la computadora portátil de la empresa) y un número entero que describe el valor de cada computadora portátil. 1<=n<=10^5. 1<=longitud del nombre de la laptop<=10. El nombre de la computadora portátil debe estar formado únicamente por letras incluidas en el alfabeto inglés. 1<=precio de la computadora portátil<=10^9. Tanto el nombre como el precio deben ser únicos.",
        "salida": "Si la respuesta no existe, imprima -1. De otra manera, imprima el nombre de la marca cuya computadora portátil cueste menos (número mínimo de la suerte) y cumpla con los criterios requeridos.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d=0, e;\n    string z=\"\", zz, y, yy;\n    cin>>a;\n    while(a){\n        a--;\n        cin>>y>>yy;\n        b=0;\n        c=0;\n        e=0;\n        for(auto i=yy.size()-1, j=0; i>-1; i--, j++){\n            if(yy[i]!='4' && yy[i]!='7'){\n                b=-1;break;\n            }\n            else if(yy[i]=='4'){\n                b++;\n            }\n            else{\n                c++;\n            }\n            e+=((yy[i]-48)*pow(10, j));\n        }\n        if(b!=c || b==-1){\n            continue;\n        }\n        if(z==\"\"){\n            z=y;\n            zz=yy;\n            d=e;\n        }\n        else{\n            if(e<d){\n                d=e;\n                z=y;\n                zz=yy;\n            }\n        }\n    }\n    if(z==\"\"){\n        cout<<\"-1\";\n    }\n    else{\n        cout<<z;\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "1028. Dos bases numéricas",
        "url": "https://omegaup.com/arena/problem/dbn/",
        "descripcion": "Si un entero n se escribe en base b como (a_m)(a_m-1)...(a_1)(a_0) esto quiere decir que n=(a_m)(b^m)+(a_m-1)(b^m-1)+...+(a_1)(b^1)+(a_0)(b^0) y que0<=a_i<b para cada 0<=i<=m. Por supuesto, al escribir el mismo número n en bases distintas se obtienen expresiones distintas, por ejemplo, el número decimal n=31 se escribe 11111 en base 2 y 1011 en base 3. Escribe un programa al cual se le dan dos expresiones A y B en bases desconocidas p y q que representan al mismo número n y que encuentre ese valor. Si hay varios números que se puedan escribir de esas dos formas, debe encontrar al más pequeño de ellos. Por ejemplo, si se dan las expresiones 11111 y 1011 entonces n=31, ya que 11111 en base 2 es igual a 1011 en base 3 que es igual a 31 en decimal.",
        "entrada": "Dos expresiones A y B, cada una con un máximo de 64 dígitos, separadas por un espacio. La primera expresión estará en base p y la segunda en base q. Puedes suponer que 2<=p,q<=10 y que 1<=n<=4,000,000,000.",
        "salida": "Tres números enteros n, p y q (en decimal) separados por espacios.",
        "nivel": "Básico (difícil) - Introducción a la programación",
        "categorias": [
            "Ciclos",
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "pow()",
            "unsigned long long",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    unsigned long long a=2, b=0, c, d=0;\n    string z, zz;\n    cin>>z>>zz;\n    if(z.size()<zz.size()){\n        swap(z, zz);\n        d=1;\n    }\n    while(true){\n        for(auto i=z.size()-1, j=0; i>-1; i--, j++){\n            b+=((z[i]-48)*pow(a, j));\n            if((z[i]-48)>=a){\n                b=-1;break;\n            }\n        }\n        if(b!=-1){\n            cout<<b<<\" \";\n            c=a;\n            a++;\n            b=0;break;\n        }\n        b=0;\n        a++;\n    }\n    while(true){\n        for(auto i=zz.size()-1, j=0; i>-1; i--, j++){\n            b+=((zz[i]-48)*pow(a, j));\n            if((zz[i]-48)>=a){\n                b=-1;break;\n            }\n        }\n        if(b!=-1){\n            if(d){\n                cout<<a<<\" \"<<c;return 0;\n            }\n            else{\n                cout<<c<<\" \"<<a;return 0;\n            }\n        }\n        b=0;\n        a++;\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "1296. Matriz",
        "url": "https://omegaup.com/arena/problem/Matriz/",
        "descripcion": "Dados los datos enteros de una matriz cuadrada de F filas por C columnas. 1<=F,C<=50. Imprime sus datos desde la última fila hasta la primera.",
        "entrada": "En la primera línea los enteros F,C separados por espacios, que denotan el número de filas y columnas de la matriz. En cada una de las siguientes F filas, C enteros separados por espacios.",
        "salida": "F líneas, en cada línea. Los C datos separados por un espacio.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Matrices",
            "Ciclos"
        ],
        "estructuras": [
            "vector<vector<int>>",
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    vector<vector<int>> num(51, vector<int> (51, 0));\n    long long a, b;\n    cin>>a>>b;\n    for(auto i=0; i<a; i++){\n        for(auto j=0; j<b; j++){\n            cin>>num[i][j];\n        }\n    }\n    for(auto i=a-1; i>-1; i--){\n        for(auto j=0; j<b; j++){\n            cout<<num[i][j]<<\" \";\n        }\n        cout<<\"\\n\";\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "129. Buscaminas",
        "url": "https://omegaup.com/arena/problem/buscaminas1/",
        "descripcion": "Todos hemos jugado el clásico juego de computadora conocido como \"Buscaminas\". Pues bien, este problema está inspirado en dicho juego, pero, por supuesto, con pequeñas variaciones. Para empezar, comenzaremos con una matriz cuyos valores solo pueden ser 0 o 1, como esta: [[0, 1, 0, 1],[1, 0, 1, 1],[0, 1, 1, 0]]. A partir de esta matriz, debes generar una segunda matriz (de las mismas dimensiones) a la cual denotaremos por B, en la que el número contenido en cada casilla representará el número de bombas con las cuales está en contacto esa casilla en específico (incluyéndose a sí misma). Considerar una matriz a la que denotaremos por A de MxN (1<=M,N<=200) con M filas y N columnas cuyos valores solo pueden ser 0 o 1, a partir de esta se genera una segunda matriz a la que denotaremos por B de las mismas dimensiones, en la que cada casilla X de B tiene una valor entre 0 y 9 inclusive, que es igual a la suma de las casillas de la matriz A que son adyacentes a la casilla X en A más el valor de la casilla X en A (dos casillas son adyacentes si tienen un vértice en común). Genera la matriz B a partir de la matriz A.",
        "entrada": "En la primera línea dos números M y N separados por un único espacio que nos indica el tamaño de la matriz. En las siguientes M líneas habrá por línea N números separados por un espacio entre ellos que serán los datos de la matriz.",
        "salida": "M líneas cada una con N números separados por un espacio entre ellos que nos demuestra la cantidad de bombas que tiene en contacto cada una de las casillas.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Cálculos aritméticos",
            "Matrices",
            "Ciclos"
        ],
        "estructuras": [
            "vector<vector<int>>",
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    vector<vector<int>> num(201, vector<int> (201, 0));\n    long long a, b, c;\n    cin>>a>>b;\n    for(auto i=0; i<a; i++){\n        for(auto j=0; j<b; j++){\n            cin>>num[i][j];\n        }\n    }\n    for(auto i=0; i<a; i++){\n        for(auto j=0; j<b; j++){\n            c=num[i][j];\n            if(i+1<a){\n                c+=num[i+1][j];\n            }\n            if(j+1<b){\n                c+=num[i][j+1];\n            }\n            if(i-1>-1){\n                c+=num[i-1][j];\n            }\n            if(j-1>-1){\n                c+=num[i][j-1];\n            }\n            if(i+1<a && j+1<b){\n                c+=num[i+1][j+1];\n            }\n            if(i+1<a && j-1>-1){\n                c+=num[i+1][j-1];\n            }\n            if(i-1>-1 && j+1<b){\n                c+=num[i-1][j+1];\n            }\n            if(i-1>-1 && j-1>-1){\n                c+=num[i-1][j-1];\n            }\n            cout<<c<<\" \";\n        }\n        cout<<\"\\n\";\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "3010. String Manipulation 2",
        "url": "https://omegaup.com/arena/problem/Manipula-Cadenas-2/",
        "descripcion": "La UP (Unidad de Programadores) esta analizando un texto que les acaba de llegar, al parecer tiene un mensaje oculto, pero tu no debes preocuparte por eso, tu trabajo es escribir un programa que ejecute un cierto número de operaciones, cada una de ellas puede ser de este tipo: 0: Voltea el texto al revés. 1: Cambia mayúsculas por minúsculas.",
        "entrada": "La primera línea contendrá un número n (1<=n<=1000000), indicando el número de operaciones a realizar. La segunda será el texto a manipular, la longitud del texto no sobrepasará los 1000 caracteres, y sólo contendra letras. Le siguen n números indicando el tipo de operación a ejecutar.",
        "salida": "El texto resultante.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b=0, c=0, d;\n    string z;\n    cin>>a>>z;\n    while(a){\n        a--;\n        cin>>d;\n        if(!d){\n            b++;\n        }\n        else{\n            c++;\n        }\n    }\n    b%=2;\n    c%=2;\n    if(b){\n        for(auto i=0, j=z.size()-1; i<z.size()/2; i++, j--){\n            swap(z[i], z[j]);\n        }\n    }\n    if(c){\n        for(auto i=0; i<z.size(); i++){\n            if(z[i]>96){\n                z[i]-=32;\n            }\n            else{\n                z[i]+=32;\n            }\n        }\n    }\n    cout<<z;\n    \n    return 0;\n}"
    },
    {
        "titulo": "7071. ¿Qué probabilidad hay?",
        "url": "https://omegaup.com/arena/problem/Que-probabilidad-hay/",
        "descripcion": "Como es bien sabido, cuando dejas a olímpicos juntos sin cuidador, pronto empezaran a realizar juegos y travesuras. Esta noche, después de comer pizza se dispusieron a jugar \"¿Qué probabilidad hay?\" Un juego de retos en el que dos personas dicen dos números entre 1, 2 y 3; si son iguales, la persona retada debe cumplir lo que se acordó; si no, no pasa nada. Pasado el rato se empezaron a aburrir, por lo que decidieron cambiar las reglas. Ahora el retador escribirá un numero oculto, el retado dirá tres números diferentes entre 1 y K, si uno de ellos es el mismo que el numero escrito, entonces el retado debe cumplir el reto. Con estas reglas se preguntaron cual debería ser la mejor K, por ello decidieron crear un programa que dado la les diga la posibilidad de que se tenga que cumplir el reto.",
        "entrada": "El número K (3<=K<=200).",
        "salida": "La probabilidad de que el reto se deba cumplir con una precision de 10^-5.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Cálculos aritméticos"
        ],
        "estructuras": [
            "long double"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long double a;\n    cin>>a;\n    a=3/a;\n    if(a==1){\n        cout<<\"1.00000\";return 0;\n    }\n    cout<<a<<\"00000\";\n    \n    return 0;\n}"
    },
    {
        "titulo": "7408. ¡Fabulosos números triangulares!",
        "url": "https://omegaup.com/arena/problem/Fabulosos-numeros-triangulares/",
        "descripcion": "Ricardo es un matemático en el ITAM, por lo tanto es natural su fascinación por los números. En particular, le interesan los números que caen en categorías particulares, números primos, números perfectos, números de taxista etc. y justo esta semana descubrió una nueva categoría: ¡Los números triangulares! Un número t se dice triangular si al tener t pelotitas estas se pueden acomodar para formar un triángulo equilátero. Ahora, aunque Ricardo es muy listo, también es muy flojo. Por esto, el quiere una manera rápida de saber cual es el el n-ésimo numero triangular, pero al ser tan flojo, el te encarga a ti que escribas un programa que le resuelva este problema. Además, el quiere que tu programa pueda encontrar no solo uno sino varios números triangulares en una sola ejecución.",
        "entrada": "La primera entrada será un número entero N seguido de N números M para los cuales deberás encontrar el M-ésimo número triangular.",
        "salida": "N números siendo cada uno el resultado de encontrar un número triangular.",
        "nivel": "Intermedio (fácil) - Matemáticas en la programación",
        "categorias": [
            "Combinaciones",
            "Problemas de conteo",
            "Diseños combinatorios",
            "Ciclos"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c;\n    cin>>a;\n    while(a){\n        a--;\n        cin>>b;\n        c=((b+1)*b)/2;\n        cout<<c<<\"\\n\";\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "3106. occ04pnf12",
        "url": "https://omegaup.com/arena/problem/Concatenando_palabras/",
        "descripcion": "Dadas dos palabras hay que formar una tercera intercalando letras de la primera y de la segunda hasta agotar las letras de una de ellas o de ambas. Si solo se agota una de las palabras, la palabra a formar se completa con las letras sobrantes de la palabra no agotada.",
        "entrada": "Dos palabras a formar.",
        "salida": "Una tercera palabra formada de acuerdo a las reglas dadas.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas",
            "Ciclos"
        ],
        "estructuras": [
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    string z, zz;\n    cin>>z>>zz;\n    for(auto i=0, j=0; i<100000001; i++, j++){\n        if(i==z.size()){\n            while(j<zz.size()){\n                cout<<zz[j];\n                j++;\n            }\n            return 0;\n        }\n        else if(j==zz.size()){\n            while(i<z.size()){\n                cout<<z[i];\n                i++;\n            }\n            return 0;\n        }\n        cout<<z[i]<<zz[j];\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "5983. Problema del diablo",
        "url": "https://omegaup.com/arena/problem/Problema-del-diablo/",
        "descripcion": "Seguir leyendo bajo tu propio riesgo, no me hago responsable de convulsiones cerebrales, muertes o invocaciones repentinas a satanas. Santiago ha visto que tienes las hallagas de leer su ultimo problema de este examen (si llegaste aquí después de resolver los anteriores muy bien, si dejaste los demás incompletos y vienes a probar suerte pues... estas como el 96% de los participantes) Santiago no se le ocurría un problema para que Roberto no saque todos los puntos, así que hizo empezó un ritual satánico para pedirle ayuda al diablo. Después de una larga charla el diablo le dio el problema a resolver pero con la condición de que si alguien lo resuelve durante el examen tiene que dar chocolates a todos la siguiente clase. El diablo le dijo \"Para entender el problema debes hipotecar tu casa y comprar una nueva\". La casa nueva es un rectángulo de N x M dimensiones y los cuartos fueron hechos de la siguiente forma: 1-Te vas a la esquina superior izquierda de la parte de la casa aun no construida y formas el cuadro más grande que puedas. 2-Repites el primer paso hasta llenar toda la casa. Y tu debes averiguar cuantos cuartos hay. Dada las dimensiones de las casa decir cuantos cuartos tiene la casa.",
        "entrada": "N y M que representan las dimensiones de la casa. Para un conjunto de casos con 60 puntos 1<N,M,10^6. Para un conjunto de casos con 40 puntos 10^6<N,M,10^8.",
        "salida": "Número de cuartos de la casa.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Ciclos"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n  \nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c=0;\n    cin>>a>>b;\n    if(a==b){\n        cout<<\"1\";\n    }\n    else if(a%b==0){\n        a/=b;\n        cout<<a;\n    }\n    else if(b%a==0){\n        b/=a;\n        cout<<b;\n    }\n    else{\n        while(a && b){\n            if(b>a){\n                swap(b, a);\n            }\n            c+=a/b;\n            a%=b;\n        }\n        cout<<c;\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "7104. Narrando la carrera de caballos",
        "url": "https://omegaup.com/arena/problem/Narrando-la-carrera-de-caballos/",
        "descripcion": "Todo está listo para la carrera de los dos caballos más famosos del mundo, pero el narrador se enfermó y no podrá asistir al evento. Afortunadamente, en la era de la información existen programas que leen lo que se les escribe con voces chistosas, pero el problema ahora es determinar qué texto darle al programa para que lo lea. Los organizadores del evento decidieron ponerles sensores a los caballos para que la narración de la carrera pueda generarse con los datos entregados por los mismos. Tu labor será la de escribir un programa que lea la información de los sensores y genere la narración correspondiente.",
        "entrada": "Inicialmente, un entero T que es la duración en minutos de la carrera. Posteriormente, T parejas de enteros A_1,A_2 que representan la cantidad de metros que avanzaron los caballos 1 y 2 durante cada minuto de la carrera, respectivamente. Puedes suponer que 1<=T<=1000 y que 0<=A_1,A_2<=10.",
        "salida": "Cada vez que un caballo tome la delantera, se debe imprimir el mensaje \"Al minuto m el caballo c toma la delantera\" donde m es el minuto tras el que ocurre el rebase y c es el número del caballo que toma la delantera. Cada vez que el caballo que iba en segundo lugar alcance al que iba en primer lugar (sin rebasarlo), se debe imprimir el letrero \"Al minuto m los caballos van empatados\" donde m es el minuto tras el que ocurre el alcance. No se deben imprimir mensajes en los minutos en los que no ocurren cambios de posiciones (es decir, el caballo que iba ganando sigue ganando o bien, cuando los caballos iban empatados y siguen empatados). Cada mensaje debe imprimirse en su propia línea. Se considera que los caballos comienzan empatados. Al término de la carrera, se debe imprimir el mensaje \"Termina la carrera y gana el caballo c\" donde c es el número del caballo que ganó, o bien, el mensaje \"Termina la carrera y empatan los caballos\" si los caballos quedaron empatados. Posteriormente, se debe imprimir el mensaje \"La distancia maxima entre los caballos fue de d\" donde d es la magnitud de la distancia más grande que hubo entre los caballos durante la carrera.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores",
            "Ciclos"
        ],
        "estructuras": [
            "vector<int>",
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b=0, c=0, d, e, f=0, g, h=0;\n    vector<int> num(1000, 0);\n    cin>>a;\n    for(auto i=1; i<=a; i++){\n        cin>>d>>e;\n        b+=d;\n        c+=e;\n        if(!f && b>c){\n            cout<<\"Al minuto \"<<i<<\" el caballo 1 toma la delantera\\n\";\n            f=1;\n        }\n        else if(!f && c>b){\n            cout<<\"Al minuto \"<<i<<\" el caballo 2 toma la delantera\\n\";\n            f=2;\n        }\n        else if(f==1 && b==c){\n            cout<<\"Al minuto \"<<i<<\" los caballos van empatados\\n\";\n            f=0;\n        }\n        else if(f==1 && c>b){\n            cout<<\"Al minuto \"<<i<<\" el caballo 2 toma la delantera\\n\";\n            f=2;\n        }\n        else if(f==2 && b==c){\n            cout<<\"Al minuto \"<<i<<\" los caballos van empatados\\n\";\n            f=0;\n        }\n        else if(f==2 && b>c){\n            cout<<\"Al minuto \"<<i<<\" el caballo 1 toma la delantera\\n\";\n            f=1;\n        }\n        g=abs(b-c);\n        if(g>h){\n            h=g;\n        }\n    }\n    if(!f){\n        cout<<\"Termina la carrera y empatan los caballos\\n\";\n    }\n    else if(f==1){\n        cout<<\"Termina la carrera y gana el caballo 1\\n\";\n    }\n    else{\n        cout<<\"Termina la carrera y gana el caballo 2\\n\";\n    }\n    cout<<\"La distancia maxima entre los caballos fue de \"<<h<<\"\\n\";\n    \n    return 0;\n}"
    },
    {
        "titulo": "2288. El caballo de John Carter",
        "url": "https://omegaup.com/arena/problem/El-caballo-de-John-Carter/",
        "descripcion": "John Carter, temiendo que su amigo Powell fuera capturado por los indios hostiles en su búsqueda de equipo minero, decidió seguir sus huellas a través de un sendero montañoso. Aunque el caballo de John iba a todo galope, lo irregular del terreno hacían que el caballo variara su velocidad. En terreno plano, el caballo de John era capaz de recorrer una unidad de distancia en P segundos, mientras que le tomaba S segundos recorrerla si el terreno estaba inclinado (de subida) y B segundos si estaba declinado (de bajada). Calcula el tiempo total en segundos que le tomó al caballo de John Carter recorrer todo el terreno.",
        "entrada": "Tres enteros P, S, B y una cadena de no más de 1000 caracteres, donde el caracter - representa una unidad de terreno plano, / una unidad de terreno inclinado y \\ una unidad de terreno declinado. Puedes suponer que 1<=B<=P<=S<=1000.",
        "salida": "Un entero T que sea el tiempo total en segundos que le tomó al caballo recorrer el terreno.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Cálculos aritméticos",
            "Caracteres y cadenas",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d=0;\n    string z;\n    cin>>a>>b>>c>>z;\n    for(auto i=0; i<z.size(); i++){\n        if(z[i]=='-'){\n            d+=a;\n        }\n        else if(z[i]=='/'){\n            d+=b;\n        }\n        else{\n            d+=c;\n        }\n    }\n    cout<<d;\n    \n    return 0;\n}"
    },
    {
        "titulo": "6473. Lanzando Misiles",
        "url": "https://omegaup.com/arena/problem/Lanzando-Misiles/",
        "descripcion": "La bitácora de la Organización de Misiles Idénticos (OMI) cuenta con un listado de los misiles que han sido lanzados hasta la fecha. Cada misil tiene un número de identificación (ID). Tu trabajo es, dada la bitácora de la OMI y una lista de IDs, decir cuales de esos misiles ya han sido lanzados.",
        "entrada": "Un entero N de misiles que han sido lanzados. Una lista de N enteros N_i, cada uno el ID de un misil en la bitácora. Un entero Q de misiles por los que se preguntará si ya han sido lanzados. Una lista de Q enteros Q_i, los IDs de los misiles por los que se pregunta. Limitaciones: 0<=N,Q<=10^6. 0<=N_i,Q_i<=10^6.",
        "salida": "Por cada misil preguntado. Una linea: '1' si ya se ha lanzado '0' si aún no se ha lanzado.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores",
            "Ciclos"
        ],
        "estructuras": [
            "vector<int>",
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    vector<int> num(1000000, 0);\n    long long a, b;\n    cin>>a;\n    for(auto i=0; i<a; i++){\n        cin>>b;\n        num[b]++;\n    }\n    cin>>a;\n    for(auto i=0; i<a; i++){\n        cin>>b;\n        if(!num[b]){\n            cout<<\"0\\n\";\n        }\n        else{\n            cout<<\"1\\n\";\n        }\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "4934. La ciudad de Mate-Itza",
        "url": "https://omegaup.com/arena/problem/Mate-Itza/",
        "descripcion": "En la antigüedad existía un pueblo llamado Mate-Itza donde vivan grandes mentes matemáticas, el 50% de las personas poseían habilidades matemáticas fuera de su época, era un bello lugar, sin presidentes con copete como cerebro, toda melodía que sonaba al reguetón era extermina de forma inmediata, las personas pensaban en formulas matemáticas, áreas de volúmenes, teorías del universo. La desventaja es que era un pueblo que sufría de hambre y personas morían a causa de esto varias veces. Un día llego una persona de otra parte del mundo con muchos panes y le dio a elegir a cada persona \"puedo darte A+B panes ahorita o puedo darte A panes hoy y los días siguientes te voy a dar 1 más que el anterior, así hasta llegar al B; pero esta segunda solo se cumplirá si me dices cuantos panes habrás recibido al final\". Todas las personas hasta los matemáticos desesperados sin saber como sumar tantos números eligieron la primera opción; excepto por una persona llamada \"Chavelo\" respondió en menos de 1 segundo, nadie sabia como lo había hecho, hasta el extranjero quedo sorprendido. Resulta que Chavelo había creado un sistema computacional capaz de sacar el total de panes que tendría. Descifra el programa que hizo chavelo y recréalo. Se te darán dos enteros A y B deberás sacar A+(A+1)+...+B.",
        "entrada": "Se te darán los dos enteros A y B. Límites: 0<A<B<(5*10^10). Para el 40% de los casos: (B-A)<10^6. Para el 60% de los casos: (B-A)<10^8.",
        "salida": "El resultado de la suma A+(A+1)+(A+2)+...+B.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "unsigned long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    unsigned long long a, b, c;\n    string z;\n    cin>>a>>b;\n    c=(((b-a)+1)*a)+(((b-a)*((b-a)+1))/2);\n    cout<<c;\n    \n    return 0;\n}"
    },
    {
        "titulo": "4253. FuzzBuzz",
        "url": "https://omegaup.com/arena/problem/FuzzBuzz/",
        "descripcion": "Dados números cualquiera entre 1 y 1000 a la entrada del programa debe imprimir el número dado , pero si el número es múltiplo de 3 imprimirá la palabra \"Fuzz\", en el caso que sea múltiplo de 5 deberá imprimir \"Buzz\", y en caso de ser múltiplo de ambos (3 y 5) imprimirá \"FuzzBuzz\".",
        "entrada": "Números entre 1 y 1000.",
        "salida": "Por cada número en la entrada, imprimir la salida descrita en el enunciado (uno por línea).",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Ciclos"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);    \n    long long a;\n    while(cin>>a){\n        if(a%3==0 && a%5==0){\n            cout<<\"FuzzBuzz\\n\";\n        }\n        else if(a%5==0){\n            cout<<\"Buzz\\n\";\n        }\n        else if(a%3==0){\n            cout<<\"Fuzz\\n\";\n        }\n        else{\n            cout<<a<<\"\\n\";\n        }\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "4990. El zorro y las uvas",
        "url": "https://omegaup.com/arena/problem/El-zorro-y-las-uvas/",
        "descripcion": "Un hambriento zorro vio unos espléndidos racimos de uvas colgados de una viña sostenida de una reja muy alta. El zorro hizo su mejor intento de alcanzarlas brincando tan alto como pudo, pero todo esto fue en vano pues los racimos siempre quedaron un poco fuera de su alcance. Al final desistió y se alejó con un cierto aire de dignidad. En su camino meditó \"la verdad es que las uvas no estaban maduras, así que si hubiera brincado más alto de nada hubiera servido\". Escribe un programa que calcule cuántas uvas hubiera alcanzado el zorro si hubiera saltado más alto.",
        "entrada": "Un entero N seguido de las alturas de los N racimos de uvas. Posteriormente un entero M seguido de las M alturas a las que hubiera podido brincar el zorro. Puedes suponer que 1<=N,M<=100,000 y que todas las alturas están entre 0 y 1,000,000,000.",
        "salida": "Para cada posible brinco del zorro, la cantidad de racimos que hubiera podido alcanzar.",
        "nivel": "Intermedio (fácil) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Búsqueda binaria",
            "Ordenamiento",
            "Vectores",
            "Ciclos"
        ],
        "estructuras": [
            "vector<pair<int, int>>",
            "long long",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    vector<pair<int, int>> sub(100000, {0, 0});\n    long long a, b=0, c, d, e, f;\n    vector<int> num(100000, 0);\n    cin>>a;\n    for(auto i=0; i<a; i++){\n        cin>>num[i];\n    }\n    sort(num.begin(), num.end());\n    for(auto i=1; i<a; i++){\n        if(num[i]!=num[i-1]){\n            sub[b].first=num[i-1], \n            sub[b].second=i;\n            b++;\n        }\n    }\n    sub[b].first=num[a-1];\n    sub[b].second=a;\n    b++;\n    cin>>a;\n    while(a){\n        a--;\n        cin>>c;\n        if(c<sub[0].first){\n            cout<<\"0 \";\n        }\n        else if(c>sub[b-1].first){\n            cout<<sub[b-1].second<<\" \";\n        }\n        else{\n            d=0;\n            e=b-1;\n            while(d<=e){\n                f=(d+e)/2;\n                if(sub[f].first==c){\n                    break;\n                }\n                else if(sub[f].first>c){\n                    e=f-1;\n                }\n                else{\n                    d=f+1;\n                }\n            }\n            if(sub[f].first>c){\n                f--;\n            }\n            cout<<sub[f].second<<\" \";\n        }\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "2359. MUH",
        "url": "https://omegaup.com/arena/problem/muh/",
        "descripcion": "Mario y Ugo, dos osos polares del zoológico de San Petersburgo y Horacio, un elefante del zoológico de Kiev, tienen 6 palitos para jugar y evaluar la creatividad de los animales. Mario, Ugo y Horacio han decidido hacer, o un elefante o un oso con esos palitos. Ellos pueden formar un animal con los palitos de la siguiente manera: 1.- Cuatro palitos representan las patas del animal, estos deben de tener la misma longitud. 2.- Los dos palitos restantes representan la cabeza y el cuerpo del animal. La cabeza del oso debe de ser más corta que el palito del cuerpo. El elefante, además, tiene un tronco largo, como su palito de la cabeza debe de ser tan largo como el del cuerpo. Note que aquí no hay límites en relación entre los palitos que forman las patas y los que forman la cabeza y el cuerpo. Tu tarea es encontrar que animal puede formarse dado el conjunto de palitos. El cuidador del zoológico quiere de regreso los palitos, así que no deben de ser quebrados; esto lo entiende hasta un oso.",
        "entrada": "La única línea de la entrada contiene seis enteros separados por un espacio l_i(1<=l_i<=9), la longitud de los seis palitos. Se garantiza que la entrada no permite hacer dos animales a la vez.",
        "salida": "Si se puede hacer un oso con todos los palitos, muestre la cadena \"Bear\" (sin las comillas). Si se puede hacer un elefante, despliegue la cadena \"Elephant\" (sin las comillas). Si no se puede hacer ni un oso o elefante, muestre la cadena \"Alien\" (sin las comillas).",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores",
            "Ordenamiento"
        ],
        "estructuras": [
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    vector<int> num(6, 0);\n    cin>>num[0]>>num[1]>>num[2]>>num[3]>>num[4]>>num[5];\n    sort(num.begin(), num.end());\n    if(num[0]==num[1] && num[0]==num[2] && num[0]==num[3]){\n        if(num[4]==num[5]){\n            cout<<\"Elephant\";\n        }\n        else{\n            cout<<\"Bear\";\n        }\n    }\n    else if(num[1]==num[2] && num[1]==num[3] && num[1]==num[4]){\n        cout<<\"Bear\";\n    }\n    else if(num[2]==num[3] && num[2]==num[4] && num[2]==num[5]){\n        if(num[0]==num[1]){\n            cout<<\"Elephant\";\n        }\n        else{\n            cout<<\"Bear\";\n        }\n    }\n    else{\n        cout<<\"Alien\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "3293. DFD-IMC",
        "url": "https://omegaup.com/arena/problem/DFD-IMC/",
        "descripcion": "Desarrolla un DFD que lea el peso y la estatura de una persona, calcula e imprime su imc y determina si es normal o tiene sobrepeso. Una persona se considera con sobrepeso si su imc es mayor o igual a 25.",
        "entrada": "En la primera línea el valor correspondiente al peso. En la segunda línea el valor correspondiente a la estatura en metros. Nota: el imc se calcula dividiendo el peso entre el cuadrado de la estatura. imc=peso/estatura^2.",
        "salida": "En la primera línea el valor del IMC. En la segunda línea el mensaje NORMAL o SOBREPESO, según sea el caso.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "pow()",
            "long double"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long double a, b;\n    cin>>a>>b;\n    b=pow(b, 2);\n    a/=b;\n    cout<<a<<\"\\n\";\n    if(a>24){\n        cout<<\"SOBREPESO\";\n    }\n    else{\n        cout<<\"NORMAL\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "3297. DFD-Contando Estaturas",
        "url": "https://omegaup.com/arena/problem/DFD-Contando-Estaturas/",
        "descripcion": "Desarrolla un DFD que lea la estatura de N personas e imprima cuantas miden más de 1.70.",
        "entrada": "En la primera línea el enetero N. En cada una de las siguientes N líneas, una estatura.",
        "salida": "Un valor entero correpondiente al número de personas que miden más de 1.70.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Ciclos"
        ],
        "estructuras": [
            "long double"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long double a, b=0, z;\n    cin>>a;\n    while(a){\n        a--;\n        cin>>z;\n        if(z>=1.71){\n            b++;\n        }\n    }\n    cout<<b;\n\n    return 0;\n}"
    },
    {
        "titulo": "7469. Creo que ya funciona",
        "url": "https://omegaup.com/arena/problem/Creo-que-ya-funciona/",
        "descripcion": "En tu nuevo trabajo en la NASA, se te pidió realizar un programa que codificara en binario (solo 0s y 1s) los mensajes entre la estación terrestre y los astronautas en el espacio. A pesar de haberle dedicado casi toda la tarde a la importante tarea, tus superiores te reportan que cuando ejecutaron el programa, éste recibía de vez en cuando mensajes no binarios. Recordando los mejores años de tu vida en la universidad, se te ocurre \"parchar\" temporalmente el programa para que parezca funcionar correctamente por unos días (cuando tu equipo de lectura de comprensión competitiva por fin despegue, ya no tendrás que preocuparte por estas nimiedades). Para resolver el problema rápidamente, se te ha ocurrido el \"Brillante Filtro Doble Estrella\", que dejará pasar los mensajes binarios sin modificarlos, mientras que aquellos no binarios serán reemplazados por la cadena '10101'.",
        "entrada": "1 linea con el mensaje al cual se le debe aplicar el \"brillante filtro doble estrella\".",
        "salida": "1 línea con el resultado de aplicar el filtro.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas",
            "Ciclos"
        ],
        "estructuras": [
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    string z;\n    cin>>z;\n    for(auto i=0; i<z.size(); i++){\n        if(z[i]!='0' && z[i]!='1'){\n            cout<<\"10101\"; return 0;\n        }\n    }\n    cout<<z;\n\n    return 0;\n}"
    },
    {
        "titulo": "5710. Contando Dvisores fast",
        "url": "https://omegaup.com/arena/problem/Contando-Dvisores-fast/",
        "descripcion": "Dado un numero entero N, quieres saber si la cantidad de divisores de N es par o impar. Por ejemplo, si N=12, tiene de divisores a 1, 2, 3, 4, 6, 12. Por lo tanto tiene 6 divisores y 6 es par.",
        "entrada": "Un numero N.",
        "salida": "\"PAR\", si la cantidad de divisores de N es par, de lo contrario \"IMPAR\".",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "sqrt()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b;\n    cin>>a;\n    b=sqrt(a);\n    if(b*b==a){\n        cout<<\"IMPAR\";\n    }\n    else{\n        cout<<\"PAR\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "2694. Cena",
        "url": "https://omegaup.com/arena/problem/Cena-oficial/",
        "descripcion": "Los alumnos de Naty son muy necios acerca de sus compañeros de comida. Ellos se han organizado en dos grupos alimenticios(convenientemente numerados 1 y 2) que insisten en comer juntos, con el grupo 1 al inicio de la fila y el grupo 2 al final de la misma. El problema comienza cuando ellas se forman para entrar al área de alimentación. Cada alumnos i lleva con el una pequeña tarjeta en la cual está grabado D_i(1<=D_i<=2) indicando su pertenencia a un grupo alimenticio. Todo el conjunto de N(1<=N<=30,000) alumnos se ha alineado para la comida pero es fácil para cualquiera ver, que ellos no están agrupadas según sus tarjetas de grupo alimenticio. El trabajo de la mestra Naty no es tan difícil. Ella simplemente recorre la línea de alumnos cambiando su asignación de grupo alimenticio tachando el número antiguo y escribiendo uno nuevo. Haciendo eso, ella crea grupos de alumnos como 1112222 o 1111122 en los que los grupos alimenticios de los alumnos están ordenados ascendentemente. En pocas ocasiones, ella podría cambiar las tarjetas de tal manera que solamente quede un grupo de alumnos (por ejemplo, 1111111 o 2222222). Naty esta cansada y es curiosa: ¿cuál el número mínimo absoluto de tarjetas que ella debe cambiar para crear un grupo apropiado de socios alimentarios? El únicamente debe cambiar los números de las tarjetas y no debe reorganizar a los alumnos en la fila",
        "entrada": "Línea 1: Un solo entero: N. Líneas 2..N+1: La línea i+1 describe la preferencia alimentaria del alumno i con un solo entero: D_i.",
        "salida": "Línea 1: Un solo entero que es el número mínimo de tarjetas que la maestra Naty debe cambiar para asignar los alumnos a los grupos alimentarios como se ha descrito.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores",
            "Ciclos"
        ],
        "estructuras": [
            "vector<pair<int, int>>",
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    vector<pair<int, int>> num(30001, {0, 0});\n    long long a, b=30000, c=0, d;\n    cin>>a;\n    for(auto i=0; i<a; i++){\n        cin>>num[i].first;\n    }\n    for(auto i=a-1; i>-1; i--){\n        if(num[i].first==1){\n            c++;\n        }\n        else{\n            num[i].second=c;\n        }\n    }\n    c=0;\n    for(auto i=0; i<a; i++){\n        if(num[i].first==2){\n            d=c+num[i].second;\n            if(d<b){\n                b=d;\n            }\n            c++;\n        }\n    }\n    if(c<b){\n        b=c;\n    }\n    cout<<b;\n\n    return 0;\n}"
    },
    {
        "titulo": "376. Calificaciones",
        "url": "https://omegaup.com/arena/problem/Calificaciones/",
        "descripcion": "Hoy conociste a tu nuevo profesor de matemáticas y les explicó su método de calificaciones. Como es muy radical decidió que solo iba a poner como calificaciones 0, 7 ó 10. Tu calificación final será aquella que se acerque más, sumando o restando, al 0, 7 ó 10 según tu calificación del examen.",
        "entrada": "Leerás varias líneas, cada una con una calificación M de examen.",
        "salida": "Por cada línea leída deberás imprimir cuál es la calificación final según el criterio del profesor.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Ciclos"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a;\n    while(cin>>a){\n        if(a<4){\n            cout<<\"0\\n\";\n        }\n        else if(a<9){\n            cout<<\"7\\n\";\n        }\n        else{\n            cout<<\"10\\n\";\n        }\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "4019. Agregando Tareas Reloaded",
        "url": "https://omegaup.com/arena/problem/Agregando-Tareas-Reloaded/",
        "descripcion": "Diego es un alumno muy organizado con sus tareas, y las tiene apiladas por el tiempo que le toma realizar cada una. La tarea que le toma menos tiempo está en el fondo de la pila y la que le lleva más tiempo está en el tope. Además, Diego siempre hace la tarea que le lleva más tiempo antes que todas las demás. Sin embargo, Diego olvidó agregar una de sus tareas y como es un poco flojo no quiere tener que revisar todas sus tareas para acomodar de nuevo la pila. Tu tarea es decirle a Diego cuántas tareas tiene que terminar antes de poder hacer la que olvidó agregar.",
        "entrada": "En la primera línea, dos números, N y P, que representan la cantidad de tareas de Diego y el tiempo que le toma a Diego hacer la tarea que olvidó agregar, respectivamente. En las siguientes N líneas, N números que representan el tiempo que le toma a Diego realizar cada tarea. 1<=N<=1000. 1<=P<=10^6. La tarea olvidada nunca será la que le lleva menos tiempo a Diego. No hay 2 o más tareas que le lleven el mismo tiempo a Diego.",
        "salida": "La cantidad de tareas que Diego tiene que terminar antes de acomodar la tarea olvidada.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Ciclos"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c=0, d;\n    cin>>a>>b;\n    for(auto i=0; i<a; i++){\n        cin>>d;\n        if(d>b){\n            c++;\n        }\n    }\n    cout<<c;\n\n    return 0;\n}"
    },
    {
        "titulo": "5754. 2018_1_CONDICIONES3",
        "url": "https://omegaup.com/arena/problem/2018_1_CONDICIONES3/",
        "descripcion": "El impuesto del ISR es escalonado, lo que quiere decir que mientras más ganas, más porcentaje de impuestos debes pagar, pero sólo si pasas de ciertos límites. La manera de calcularlo es viendo en qué nivel de la tabla se encuentra un salario. Dependiendo de ese nivel, se paga una cuota fija. La parte del salario que se pase del límite inferior en nuestro nivel de la paga, paga una tasa porcentual de ISR. Al final se unen esos dos valores. Una tabla simplificada de impuestos es como sigue: \"tablaISR\": [{\"limite_inferior\": 0.01, \"limite_superior\": 969.5, \"cuota_fija\": 0, \"tasa_ISR\": 1.92},{\"limite_inferior\": 969.51, \"limite_superior\": 1703.80, \"cuota_fija\": 56.91, \"tasa_ISR\": 10.88},{\"limite_inferior\": 1703.81, \"limite_superior\": 4782.61, \"cuota_fija\": 136.85, \"tasa_ISR\": 16},{\"limite_inferior\": 4782.62, \"limite_superior\": 14391.44, \"cuota_fija\": 766.15, \"tasa_ISR\": 23.52},{\"limite_inferior\": 14391.45, \"limite_superior\": 19188.61, \"cuota_fija\": 3470.25, \"tasa_ISR\": 32},{\"limite_inferior\": 19188.62, \"limite_superior\": 57565.76, \"cuota_fija\": 5005.35, \"tasa_ISR\": 34},{\"limite_inferior\": 57565.77, \"limite_superior\": \"En adelante\", \"cuota_fija\": 18053.63, \"tasa_ISR\": 35}]. A partir de la tabla, calcular el ISR para un salario dado.",
        "entrada": "El salario de una persona, como número decimal. 0<=N<=200,000.",
        "salida": "La cantidad de impuesto ISR que se debe pagar, como número decimal.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Cálculos aritméticos"
        ],
        "estructuras": [
            "long double"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long double a;\n    cin>>a;\n    if(a>=0.01 && a<=969.5){\n        a=a-0.01;\n        a=((a*1.92)/(100))+0;\n        cout<<a;\n    }\n    else if(a>=969.51 && a<=1703.80){\n        a=a-969.51;\n        a=((a*10.88)/(100))+56.91;\n        cout<<a;\n    }\n    else if(a>=1703.81 && a<=4782.61){\n        a=a-1703.81;\n        a=((a*16)/(100))+136.85;\n        cout<<a;\n    }\n    else if(a>=4782.62 && a<=14391.44){\n        a=a-4782.62;\n        a=((a*23.52)/(100))+766.15;\n        cout<<a;\n    }\n    else if(a>=14391.45 && a<=19188.61){\n        a=a-14391.45;\n        a=((a*32)/(100))+3470.25;\n        cout<<a;\n    }\n    else if(a>=19188.62 && a<=57565.76){\n        a=a-19188.62;\n        a=((a*34)/(100))+5005.35;\n        cout<<a;\n    }\n    else if(a>=57565.77){\n        a=a-57565.77;\n        a=((a*35)/(100))+18053.63;\n        cout<<a;\n    }\n    else{\n        cout<<\"0\";\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "5260. Andy trabaja en el Oxxo",
        "url": "https://omegaup.com/arena/problem/Andy-trabaja-en-el-Oxxo-c/",
        "descripcion": "¿Recuerdas la vez que Andrea rompió el jarrón de su mamá? Si no lo recuerdas te platicare un poco acerca de aquella ocasión, ella rompió el jarrón de su mamá mientras ella estaba de vacaciones, accidentalmente alzó su brazo y tiró el jarrón. Debido a ello tuvo que conseguir un trabajo en el Oxxo, a ella le tocaba atender una caja registradora que contaba con N pesos. Durante una jornada laboral hubieron M personas (Entre ellas incluidas clientes y gerentes) que retiraron o abonaron P_M pesos. Tu tarea será crear un programa en el cual según los datos ingresados digas con cuánto dinero quedó al final, en caso de que trates de retirar una cantidad mayor a la que tienes en caja da un aviso de que no hay suficiente dinero para retirar. Consideraciones: Los clientes abonan, los gerentes retiran. En caso de que se trate de retirar una cantidad que no se posee, el programa debe terminar y decir: \"No hay suficiente dinero\". Los clientes siempre pagaran sus productos exactamente. Se debe preceder el signo de peso ($) antes de escribir el total que quedó en la caja. En caso de tratar de retirar una cantidad que no se tiene, será el último gerente que tratará de retirarlo.",
        "entrada": "En la primera linea un número N que indica cuánto dinero posee la caja al inicio del día. En la segunda linea, un número M indicando la cantidad de personas que atendió Andrea en el Oxxo. En las siguientes M lineas, un caracter sea G o C, representando a Gerentes o Clientes que visitaron la caja de Andrea seguido de un espacio, seguido de los P pesos que llevaron consigo.",
        "salida": "La cantidad de pesos con la que quedó la caja registradora al final del día precedida de un signo de peso ($), en caso de que se haya tratado de retirar una cantidad de pesos que no se tiene imprimir \"No hay suficiente dinero\".",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas",
            "Ciclos"
        ],
        "estructuras": [
            "long double",
            "char"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long double a, b, c;\n    char z;\n    cin>>a>>b;\n    while(b){\n        b--;\n        cin>>z>>c;\n        if(z=='C'){\n            a+=c;\n        }\n        else{\n            a-=c;\n            if(a<0){\n                cout<<\"No hay suficiente dinero\"; \n                while(b--){\n                    cin>>c;\n                }\n                return 0;\n            }\n        }\n    }\n    cout<<\"$\"<<a;\n    \n    return 0;\n}"
    },
    {
        "titulo": "7760. Ayudando a Santa",
        "url": "https://omegaup.com/arena/problem/Ayudando-a-Santa/",
        "descripcion": "La Navidad ya esta a la vuelta de la esquina y como sabes que te portaste bien todo el año, Santa te traerá aquel regalo que tanto quieres y mueres por tener. Llega el día 24 y te quedas muy despierto a un lado de tu arbolito de Navidad con chocolate caliente esperando su llegada, de pronto escuchas que abren la puerta y gritan tu nombre, ¡es Santa! quien en vez de darte tu regalo, pide tu ayuda para salvar la Navidad. Resulta que por la tormenta de nieve que tuvo que atravesar, la computadora que controla el trineo se averió y necesita reprogramarse. La computadora necesita una ecuación de calibración que hace que el trineo pueda navegar por sí solo. Como Santa sabe que eres buen programador, logró llegar hasta tu casa para que lo ayudes a reprogramarla y salvar la Navidad. La computadora del trineo de santa funciona con la siguiente ecuación: (Velocidad/PesoTrineo)*Distancia. Tu tarea consiste en generar un programa que reciba dichas variables descritas por la ecuación, la resuelva y devuelva el resultado. Ya que el trineo de Santa viaja a muchos destinos la computadora tiene que recalcular los datos dependiendo como vayan cambiando las variables, así que recibirás muchos casos para probar que en verdad funcione correctamente.",
        "entrada": "Recibirás una linea que contiene las variables enteras V[metros*seg], P[gramos] y D[metros], cada uno representa la velocidad, peso del trineo y distancia, respectivamente. 0<V<2^31. 1<P<=100. 0<D<2^31.",
        "salida": "La computadora del trineo de Santa no soporta decimales por lo que solo deberás imprimir un sólo número entero sin decimales indicando el resultado de la ecuación de calibración del trineo, si hay numeros decimales en el resultado, debes truncar este resultado.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [],
        "estructuras": [
            "fixed",
            "setprecision",
            "long double"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long double a, b, c, d;\n    cin>>a>>b>>c;\n    d=(a/b)*c;\n    cout<<fixed<<setprecision(0)<<d;\n    \n    return 0;\n}"
    },
    {
        "titulo": "1377. Abriendo La Puerta",
        "url": "https://omegaup.com/arena/problem/abre/",
        "descripcion": "El primer paso esta dado, ya encontraste la tumba, sin embargo, tus problemas apenas comienzan, primero deberá abrir la puerta y una vez adentro deberás sortear todas la trampas en el camino al tesoro. ¡Pero comencemos por el principio, antes que cualquier cosa hay que abrir la puerta! Al llegar a la tumba te encuentras con una puerta repleta de palancas, todas las palancas son negras, salvo una de ellas, la cual es de un color rojo sangre. En la puerta hay además una inscripción y una secuencia de números. Tras leer la inscripción descubres que para abrir la puerta es necesario bajar todas las palancas, sin embargo, las palancas se deberán ir bajando siguiendo la secuencia de números en la puerta, con la condición de que la última palanca que se baje sea la palanca roja. Hay que ser muy cuidadoso, porque la inscripción dice que si se rompe la secuencia o si se baja la palanca roja antes de bajar todas las negras \"... su alma será condenada a los fuegos eternos mientras dure la era del quinto sol\". La forma de ir bajando las palancas es la siguiente: inicialmente se baja una palanca, que puede ser cualquiera. A partir de ésta se cuenta un número x1 de palancas, donde x1 es el primer número de la secuencia escrita en la puerta y se baja la palanca en donde quedaste, de ahí, cuentas x2 palancas dónde x2 es el segundo número de la secuencia y nuevamente bajas la palanca correspondiente. Continuando con la secuencia hasta que todas las palancas estén abajo. Las palancas siempre se cuentan en el mismo sentido, es decir, siempre hacia la derecha y si llegas al final debes de seguir contando por el principio. Al contar las palancas no debes tomar en cuenta las que ya estén abajo. Debes escribir un programa que conociendo el número de palancas, la posición de la palanca roja y la secuencia de números, te diga cual es la primera palanca que debes bajar para que siguiendo la secuencia de números, la última palanca que bajes sea la palanca roja.",
        "entrada": "Tu programa deberá leer los siguientes datos: en la primera línea el número 9<=P<=20000 de palancas en la puerta, en la segunda línea el número R, dónde 1<=R<=P que indica la posición de la palanca roja contando a partir de 1 y por último en la tercera línea P-1 números separados por un espacio que indican la secuencia que se debe llevar en el conteo de palancas.Los números de la secuencia de saltos son todos entre 1 y 16. 9<=P<=20000. 1<=R<=P. Los números de la secuencia de saltos son todos entre 1 y 16.",
        "salida": "Tu programa deberá un único número indicando la posición de la primera palanca que se debe bajar.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Implementación",
            "Cálculos aritméticos",
            "Vectores",
            "Ciclos"
        ],
        "estructuras": [
            "vector<int>",
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d=0, e, f=1, g, h;\n    vector<int> num(20001, 0);\n    vector<int> sub(20001, 0);\n    cin>>a>>b;\n    b--;\n    e=a;\n    num[0]=1;\n    a--;\n    while(a){\n        cin>>c;\n        if(a==1){\n            break;\n        }\n        c%=a;\n        if(c){\n            while(c){\n                d++;\n                if(d==e){\n                    d=0;\n                }\n                if(!num[d]){\n                    c--;\n                }\n            }\n        }\n        else{\n            while(num[d]==1){\n                d--;\n                if(d<0){\n                    d=e-1;\n                }\n            }\n        }\n        num[d]=1;\n        if(d==b){\n            g=0;\n            h=d;\n            while(num[h]==1){\n                g++;\n                h--;\n                if(h<0){\n                    h=e-1;\n                }\n            }\n            f+=g;\n            for(auto i=0; i<e; i++){\n                sub[i]=num[((((i-g)%e)+e)%e)];\n            }\n            for(auto i=0; i<e; i++){\n                num[i]=sub[i];\n            }\n        }\n        a--;\n    }\n    cout<<f;\n    \n    return 0;\n}"
    },
    {
        "titulo": "4023. A Esparcir Rumores",
        "url": "https://omegaup.com/arena/problem/Rumores/",
        "descripcion": "En una ciudad de N habitantes se esparce un rumor de modo que cada hora se duplica la cantidad de personas que se enteran del mismo. Muy bien, pues TU Quieres saber cuantas personas han iniciado este rumor y cuantas lo sabrán después de y horas.",
        "entrada": "Dado un entero N y la cantidad X horas que tardara en esparcirse este rumor por toda tu ciudad calcula cuantas personas iniciaron el rumor. Seguido de esto recibirás un numero M El cual sera una pregunta sobre cuantas personas sabrán el rumor tras esas horas. 1<=N<=10^12. 1<=M<=100000000.",
        "salida": "En la primera linea deberás imprimir cuantas personas iniciaron el rumor en la siguiente la respuesta a la pregunta sobre cuantas personas lo sabían después de M Horas.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Cálculos aritméticos",
            "Ciclos"
        ],
        "estructuras": [
            "unsigned long long",
            "long double"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long double a, b, c;\n    unsigned long long z;\n    cin>>a>>b>>c;\n    z=a;\n    while(b--){\n        z/=2;\n        a/=2;\n    }\n    cout<<z<<\"\\n\";\n    while(c--){\n        a*=2;\n    }\n    z=a;\n    cout<<z;\n    \n    return 0;\n}"
    },
    {
        "titulo": "5654. Suma de reales",
        "url": "https://omegaup.com/arena/problem/Suma-de-reales/",
        "descripcion": "Elabora un programa que sume dos numeros.",
        "entrada": "Dos numeros reales. -2^8 < x < 2^8",
        "salida": "La suma de los dos numeros con dos decimales",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Cálculos aritméticos",
            "Vectores"
        ],
        "estructuras": [
            "long double",
            "fixed",
            "setprecision",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    vector<int> num(30001, 0);\n    long double a, b, c;\n    cin>>a>>b;\n    c=a+b;\n    cout<<fixed<<setprecision(2)<<c;\n    \n    return 0;\n}"
    },
    {
        "titulo": "1460. Las Cuentas del Hippie",
        "url": "https://omegaup.com/arena/problem/cuentas/",
        "descripcion": "Hace algún tiempo conociste a un hippie que se dedica a hacer collares con cuentas (bolitas) de vidrio, como anda muy escaso de dinero tu amigo tiene únicamente un hilo en donde guarda todas las cuentas que utiliza. Hace poco tu amigo recibió un pedido de un collar que debe llevar únicamente C cuentas negras. En su hilo tu amigo puede tener cuentas de diversos colores, y cada vez que hace un collar saca todas las cuentas, escoge las que necesita y vuelve a meter las que le sobraron. Como éste método le resulta muy tedioso, te ha pedido que le ayudes a encontrar una forma de optimizarlo. Cuando abres el hilo, puedes obtener una a una cuentas de cualquiera de los lados del hilo que abriste, si la cuenta que obtienes es negra, la puedes utilizar en el collar, si es de otro color deberás \"desperdiciar\" esa cuenta. Debes escribir un programa que determine donde abrir el hilo para que puedas obtener las C cuentas negras desperdiciando el menor número de cuentas posibles de otro color.",
        "entrada": "Tu programa deberá leer del teclado de la PC los siguientes datos: En la primera línea el número 0<C<=3,000 de cuentas negras que necesitas. En la segunda línea el número C<N<=30,000 que indica la cantidad de cuentas en el hilo. En la tercera línea habrá N números enteros separados cada uno por un espacio que indican el color de las cuentas del hilo, si el número es un 0 indica que la cuenta en esa posición es negra, si el número es 1 indica que la cuenta es de un color distinto. NOTA: El número de cuentas negras en el hilo siempre será mayor o igual al número de cuentas que necesitas.",
        "salida": "Tu programa deberá escribir en la pantalla de la PC un número entero que indique el mínimo número de cuentas que debes \"desperdiciar\" para poder obtener todas las cuentas negras que necesitas.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c=-1, d=0, e=0, f, g=300000;\n    vector<int> num(30001, 0);\n    cin>>b>>a;\n    for(auto i=0; i<a; i++){\n        cin>>num[i];\n        if(c==-1 && !num[i]){\n            c=i;\n        }\n        if(d<b){\n            if(num[i]==1 && c!=-1){\n                e++;\n            }\n            else if(!num[i]){\n                d++;\n            }\n            f=i;\n        }\n    }\n    if(e<g){\n        g=e;\n    }\n    while(true){\n        c++;\n        if(c==a){\n            break;\n        }\n        while(num[c]==1){\n            e--;\n            c++;\n            if(c==a){\n                break;\n            }\n        }\n        if(c==a){\n            break;\n        }\n        f++;\n        if(f==a){\n            f=0;\n        }\n        while(num[f]==1){\n            e++;\n            f++;\n            if(f==a){\n                f=0;\n            }\n        }\n        if(e<g){\n            g=e;\n        }\n    }\n    cout<<g;\n    \n    return 0;\n}"
    },
    {
        "titulo": "842. Agencia matrimonial",
        "url": "https://omegaup.com/arena/problem/agencia_matrimonial/",
        "descripcion": "Una agencia matrimonial tiene n clientes de ambos sexos. Se conoce la edad de todos los clientes (expresada en la misma unidad para todos, la cual no tiene porqué ser años; podrían ser meses, días, etcétera). Los dos encargados de la agencia tienen opiniones diferentes acerca de cómo deberían emparejarse los clientes. Uno piensa que debería minimizarse la suma de las diferencias de edades de cada pareja formada. El otro opina justamente lo contrario, es decir, que debería maximizarse esa suma de diferencias. Escribe un programa que calcule la mínima suma posible de diferencias y la máxima suma posible de diferencias. Por ejemplo, si n=2, los hombres tienen edades 25 y 40, y las mujeres tienen edades 20 y 50, entonces sólo hay dos posibilidades: 25 - 20, 40 - 50 (con suma total 15) y 40 - 20, 25 - 50 (con suma total 45).",
        "entrada": "La entrada consiste en 1<=n<=50000, seguido de n números en una línea con las edades de los hombres, seguido de n números en otra línea con las edades de las mujeres.",
        "salida": "Escribe una línea con dos números separados por un espacio: La mínima suma posible de las diferencias de edades, y la máxima suma posible de las diferencias de edades.",
        "nivel": "Intermedio (fácil) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Vectores",
            "Ciclos",
            "Ordenamiento"
        ],
        "estructuras": [
            "vector<int>",
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b=0, c=0;\n    vector<int> num(50001, 0);\n    vector<int> sub(50001, 0);\n    cin>>a;\n    for(auto i=0; i<a; i++){\n        cin>>num[i];\n    }\n    for(auto i=0; i<a; i++){\n        cin>>sub[i];\n    }\n    sort(num.begin(), num.end());\n    sort(sub.begin(), sub.end());\n    for(auto i=0; i<a; i++){\n        b+=abs(num[i]-sub[i]);\n    }\n    cout<<b<<\" \";\n    for(auto i=0, j=a-1; i<a; i++, j--){\n        c+=abs(num[i]-sub[j]);\n    }\n    cout<<c;\n    \n    return 0;\n}"
    },
    {
        "titulo": "6180. sumar matrices",
        "url": "https://omegaup.com/arena/problem/sumar-matrices/",
        "descripcion": "Hacer un programa que sume dos arreglos bidimensionales de NxN elementos hacia un tercer arreglo.",
        "entrada": "En la primera linea el entero N. En los siguientes N conjuntos de lineas, N enteros que indican los elementos de una fila de la primer matriz. En los siguientes N conjuntos de lineas, N enteros que indican los elementos de una fila de la segunda matriz.",
        "salida": "La matriz final.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Cálculos aritméticos",
            "Matrices",
            "Ciclos"
        ],
        "estructuras": [
            "vector<vector<int>>",
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b;\n    vector<vector<int>> num(1000, vector<int> (1000, 0));\n    cin>>a;\n    for(auto i=0; i<a; i++){\n        for(auto j=0; j<a; j++){\n            cin>>num[i][j];\n        }\n    }\n    for(auto i=0; i<a; i++){\n        for(auto j=0; j<a; j++){\n            cin>>b;\n            num[i][j]+=b;\n        }\n    }\n    for(auto i=0; i<a; i++){\n        for(auto j=0; j<a; j++){\n            cout<<num[i][j]<<\" \";\n        }\n        cout<<\"\\n\";\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "4059. Las Cartas del Dr. Lira (Adaptacion)",
        "url": "https://omegaup.com/arena/problem/Cartas-Lira/",
        "descripcion": "Dr. Lira tiene N cartas acomodadas en una secuencia. Él numeró las cartas de izquierda a derecha con números de 0 a N-1. Cada carta está coloreada negra de un lado y blanco del otro. Algunas de las cartas (posiblemente ninguna o todas) estarán acomodadas con el lado negro hacia arriba y otras con el blanco. Para activar su arsenal de armas, Dr. Lira necesita voltear algunas cartas tal que queden acomodadas de forma alternada: cada par de cartas consecutivas deben tener colores diferentes. Para no cansarse, Dr. Lira ha contratado tus servicios para que encuentres cuál es el mínimo número de cartas que tienes que voltear para que todas las cartas queden alternadas.",
        "entrada": "Tendrás como entrada un entero 3<=N<=50 que indica el número de cartas de Dr. Lira. En la siguiente línea encontrarás la configuración actual de las cartas, cada una representada por un numero 1 o 0: si el caracter en la i-ésima posición es 1, quiere decir que la carta está actualmente mostrando su lado negro, si es 0, quiere decir que está mostrando su lado blanco.",
        "salida": "Cuenta e imprime un entero representando el mínimo número de cartas que necesitas voltear para obtener la configuración que alterne las cartas.",
        "nivel": "Intermedio (fácil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Vectores",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b=0, c=0, d=0;\n    vector<int> num(500, 0);\n    cin>>a;\n    for(auto i=0; i<a; i++){\n        cin>>num[i];\n        if(i%2==0){\n            b+=num[i];\n        }\n        else{\n            c+=num[i];\n        }\n    }\n    if(b>c){\n        for(auto i=0; i<a; i++){\n            if(i%2==0 && !num[i]){\n                d++;\n            }\n            else if(i%2==1 && num[i]==1){\n                d++;\n            }\n        }\n    }\n    else{\n        for(auto i=0; i<a; i++){\n            if(i%2==0 && num[i]==1){\n                d++;\n            }\n            else if(i%2==1 && !num[i]){\n                d++;\n            }\n        }\n    }\n    cout<<d;\n    \n    return 0;\n}"
    },
    {
        "titulo": "2421. Las ventanas del dormitorio marciano",
        "url": "https://omegaup.com/arena/problem/ventanas_dormitorio_marciano/",
        "descripcion": "John Carter fue capturado por los marcianos verdes, pero recibe un trato preferencial por sus grandes habilidades de salto. Sola, la marciana encargada de cuidarlo, condujo a John a su dormitorio: un cuarto con grandes ventanas en una pared y con un estilo antiguo bastante peculiar. El clima en Marte es extremo, pero cuando las ventanas del lugar están cerradas entonces John puede evitar los gélidos vientos nocturnos. Para su mala fortuna, las marcianas del lugar abren y cierran constantemente las ventanas, por lo que John debe cambiarse de lugar con frecuencia. Ayuda a John a determinar si una posición en el dormitorio está libre de viento, dada la situación de las ventanas.",
        "entrada": "Un entero N seguido de los intervalos [I_i, F_i] de las posiciones cubiertas por cada una de las N ventanas de la pared, inicialmente abiertas. Posteriormente un entero M seguido de M renglones, cada uno con un caracter Q y un entero K: si Q = C entonces la ventana que cubre la posición K acaba de cambiar su estado; si Q = P entonces se desea conocer si la posición K del dormitorio está libre de viento en ese momento. Puedes suponer que 1 <= N, M <= 100000, que 1 <= I_i, F_i, K <= 1000000000 con I_i <= F_i para 1 <= i <= N, que no hay ventanas sobrepuestas y que existe una ventana que cubre la posición K cuando Q = C.",
        "salida": "Para cada pregunta con Q = P, un 1 si la posición K está libre de viento en ese momento y un 0 en otro caso.",
        "nivel": "Intermedio (medio) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Búsqueda binaria",
            "Ordenamiento",
            "Vectores",
            "Tablas de dispersión",
            "Ciclos",
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "vector<pair<int, int>>",
            "vector<int>",
            "auto",
            "long long",
            "char"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e, f, h;\n    vector<pair<int, int>> venta(100000, {0, 0});\n    vector<int> num(100000, 0);\n    char n;\n    cin >> a;\n    for (auto i = 0; i < a; i++)\n    {\n        cin >> venta[i].first >> venta[i].second;\n    }\n    sort(venta.begin(), venta.end());\n    cin >> b;\n    while (b)\n    {\n        b--;\n        cin >> n >> c;\n        if (n == 'C')\n        {\n            d = 0;\n            e = a - 1;\n            while (d <= e)\n            {\n                h = (d + e) / 2;\n                if (venta[h].first <= c && venta[h].second >= c)\n                {\n                    if (!num[h])\n                    {\n                        num[h] = 1;\n                    }\n                    else\n                    {\n                        num[h] = 0;\n                    }\n                    break;\n                }\n                else if (venta[h].second < c)\n                {\n                    d = h + 1;\n                }\n                else\n                {\n                    e = h - 1;\n                }\n            }\n        }\n        else\n        {\n            d = 0;\n            e = a - 1;\n            f = -1;\n            while (d <= e)\n            {\n                h = (d + e) / 2;\n                if (venta[h].first <= c && venta[h].second >= c)\n                {\n                    f = 1;\n                    cout << num[h] << \"\\n\";\n                    break;\n                }\n                else if (venta[h].second < c)\n                {\n                    d = h + 1;\n                }\n                else\n                {\n                    e = h - 1;\n                }\n            }\n            if (f == -1)\n            {\n                cout << \"1\\n\";\n            }\n        }\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "1549. Paredes Movedizas",
        "url": "https://omegaup.com/arena/problem/paredes/",
        "descripcion": "Tras haber formado el nombre del dios OMInca, fue tal tu emoció al ver el tesoro entre tus manos que lo tomaste y saliste corriendo sin observar hacia dónde te dirigías, con lo que equivocaste el camino y en vez de regresar por donde habías llegado, entraste a un lugar completamente obscuro. Justo al entrar, la puerta detrás de ti se cerró de un golpe, en ese momento te das cuenta que te encuentras dentro de un laberinto. Mientras haces esfuerzos por hallar la salida, sin querer presionas una de las piedras preciosas que se encuentran en la figura de oro que traes cargando y escuchas ruido de que algunas paredes dentro del laberinto se mueven, abriéndose y cerrándose. Desesperado comienzas a apretar las piedras una tras otra tratando de descubrir cuál es el acertijo, ya que cada que presionas una se vuelven a escuchar a tu alrededor paredes abriendo y cerrando. Después de un buen rato de estar presionando piedras y sin entender qué es lo que pasa a tu alrededor, te das cuenta de que en la parte de abajo de la figura se encuentran grabados unos números y un mapa de lo que seguramente es tu laberinto. Al analizarlos te das cuenta de que explican qué es lo que sucede cada que aprietas una de las piedras preciosas. Según parece, esta figurilla es una especie de \"control remoto\" utilizado por los OMIncas, ya que para cada piedra una o varias de las paredes del laberinto se mueven, si la pared estaba abierta se cierra y si estaba cerrada se abre. En la figurilla existen varias piedras, cada una mueve un grupo distinto de paredes en el laberinto, en la inscripción se indica qué paredes se mueven al apretarse cada piedra. En el mapa se muestran las paredes y se indica que al entrar ahí cualquier profanador, todas las paredes se cerrarán. Con estos datos, tu podrías haber encontrado una manera de salir, sin embargo, tu problema ahora es que ya no sabes como quedaron las puertas después de apretar tantas piedras, por lo que primero debes entender qué paso con todas las paredes que te rodean, afortunadamente recuerdas cuáles fueron las piedras que presionaste y en que orden. Debes escribir un programa que conociendo el grupo de paredes que se mueven con cada piedra y cuales fueron las piedras que presionaste, encuentre cual es la configuración actual del laberinto, o sea que paredes se encuentran cerradas y cuáles abiertas. Partiendo de que todas las paredes se cerraron cuando entraste.",
        "entrada": "Tu programa deberá leer los siguientes datos, en la primera línea el número 8 <= p <= 3000 de paredes que existen en el laberinto, en la segunda línea el número 2 <= n <= 16 e piedras en la figurilla. En la tercera línea el número 2 <= m <= p de paredes que se mueven al apretar cada piedra (todas las piedras mueven la misma cantidad de paredes). En cada una de las siguientes n líneas habrá m números separados por espacios, que indican las paredes que se mueven al presionar la piedra correspondiente, es decir, el primero de estos renglones se refiere a las puertas que mueve la piedra 1, el segundo a las de la piedra 2 y así sucesivamente. Tanto las piedras como las paredes se cuentan a partir de uno. A continuación, se encuentra el número 5 <= a <= 30000, que indica el número de \"botonazos\" que diste, finalmente en la última línea, hay a números, separados por un espacio que corresponden al número de la piedra que presionaste en cada \"botonazo\", listados en el orden en el que fueron efectuados.",
        "salida": "Tu programa deberá escribir el número de paredes que quedaron abiertas al final y cuáles fueron. En la primera línea el número de paredes abiertas y en la siguiente línea separados por espacios y en orden ascendente, los números correspondientes a cada una de ellas.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Matrices",
            "Vectores",
            "Ciclos"
        ],
        "estructuras": [
            "vector<vector<int>>",
            "long long",
            "vector<int>",
            "auto"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    vector<vector<int>> sub(17, vector<int>(3001, 0));\n    long long a, b, c, d, e, f, h = 0;\n    vector<int> num(3001, 0);\n    cin >> a >> b >> c;\n    for (auto i = 1; i <= b; i++)\n    {\n        for (auto j = 1; j <= c; j++)\n        {\n            cin >> sub[i][j];\n        }\n    }\n    cin >> d;\n    while (d--)\n    {\n        cin >> e;\n        for (auto i = 1; i <= c; i++)\n        {\n            f = sub[e][i];\n            if (!num[f])\n            {\n                num[f] = 1;\n                h++;\n            }\n            else\n            {\n                num[f] = 0;\n                h--;\n            }\n        }\n    }\n    cout << h << \"\\n\";\n    for (auto i = 1; i <= a; i++)\n    {\n        if (num[i] == 1)\n        {\n            cout << i << \" \";\n        }\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "1623. Trampas",
        "url": "https://omegaup.com/arena/problem/trampas/",
        "descripcion": "El aventurero Ah Balam se perdió accidentalmente en un laberinto lleno de trampas. Por fortuna, en su intento por salir, Ah Balam encontró un mapa del laberinto. El mapa del laberinto consta de una cuadricula de N filas por M columnas. Las filas estan numeradas de 1 a N de arriba hacia abajo(norte a sur), las columnas estan numeradas de 1 a M de izquierda a derecha(oeste a este). Cada casilla de la cuadricula contiene solo uno de estos 4 caracteres: 'S', '.', 'x' y '#', que representan la salida, suelo sin trampa, suelo con trampa y pared. Ah Balam, como todo mortal, no puede caminar a través de las paredes, y solo puede moverse hacia 4 direcciones(norte, sur, este y oeste), NO se puede mover en diagonal. Por ejemplo, si en el siguiente laberinto Ah Balam se encuentra inicialmente en la fila 2 columna 6, tendría que pasar por al menos 2 trampas para llegar a la salida: ######## #.S.#..# #xxx#.## #...x.## #...#x## #...x.## ######## Ah Balam ha solicitado tu ayuda. Escribe un programa que dada la posición inicial de Ah Balam y el mapa del laberinto, determine cual es el minimo número de trampas por las que Ah Balam tiene que pasar para llegar a la salida.",
        "entrada": "Línea 1: 2 enteros separados por un espacio que representan a N y M (0<=N, M<=300) respectivamente. Línea 2: La fila y la columna donde se encuentra inicialmente Ah Balam. Siguientes N líneas: M caracteres en cada una donde el j-ésimo caracter de la i+2-ésima línea representa la celda j de la fila i. Nota: Ah Balam nunca se encontrará inicialmente dentro de una pared.",
        "salida": "Línea 1: Un solo entero: el mínimo de trampas por las que Ah Balam tiene que pasar para llegar a la salida.",
        "nivel": "Avanzado (medio) - Programación competitiva",
        "categorias": [
            "Montículos",
            "Búsqueda en amplitud",
            "Caminos más cortos",
            "Matrices",
            "Colas",
            "Ciclos"
        ],
        "estructuras": [
            "vector<vector<char>>",
            "long long",
            "queue<struct>",
            "auto"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct sobra\n{\n    int g, m, x;\n};\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    vector<vector<char>> num(301, vector<char>(301, ''));\n    long long a, b, c -= 90000;\n    queue<sobra> falta;\n    queue<sobra> sub;\n    sobra z;\n    cin >> a >> b >> z.g >> z.m;\n    for (auto i = 1; i <= a; i++)\n    {\n        for (auto j = 1; j <= b; j++)\n        {\n            cin >> num[i][j];\n        }\n    }\n    if (num[z.g][z.m] == 'x')\n    {\n        z.x++;\n    }\n    falta.push(z);\n    num[z.g][z.m] = '#';\n    while (falta.size() || sub.size())\n    {\n        while (falta.size())\n        {\n            z = falta.front();\n            falta.pop();\n            if (num[z.g - 1][z.m] == 'S' || num[z.g + 1][z.m] == 'S' || num[z.g][z.m + 1] == 'S' || num[z.g][z.m - 1] == 'S')\n            {\n                if (z.x < c)\n                {\n                    c = z.x;\n                }\n            }\n            if (num[z.g - 1][z.m] == '.')\n            {\n                z.g--;\n                falta.push(z);\n                num[z.g][z.m] = '#';\n                z.g++;\n            }\n            if (num[z.g + 1][z.m] == '.')\n            {\n                z.g++;\n                falta.push(z);\n                num[z.g][z.m] = '#';\n                z.g--;\n            }\n            if (num[z.g][z.m - 1] == '.')\n            {\n                z.m--;\n                falta.push(z);\n                num[z.g][z.m] = '#';\n                z.m++;\n            }\n            if (num[z.g][z.m + 1] == '.')\n            {\n                z.m++;\n                falta.push(z);\n                num[z.g][z.m] = '#';\n                z.m--;\n            }\n            if (num[z.g - 1][z.m] == 'x')\n            {\n                z.g--;\n                z.x++;\n                sub.push(z);\n                num[z.g][z.m] = '#';\n                z.g++;\n                z.x--;\n            }\n            if (num[z.g + 1][z.m] == 'x')\n            {\n                z.g++;\n                z.x++;\n                sub.push(z);\n                num[z.g][z.m] = '#';\n                z.g--;\n                z.x--;\n            }\n            if (num[z.g][z.m - 1] == 'x')\n            {\n                z.m--;\n                z.x++;\n                sub.push(z);\n                num[z.g][z.m] = '#';\n                z.m++;\n                z.x--;\n            }\n            if (num[z.g][z.m + 1] == 'x')\n            {\n                z.m++;\n                z.x++;\n                sub.push(z);\n                num[z.g][z.m] = '#';\n                z.m--;\n                z.x--;\n            }\n        }\n        if (sub.size())\n        {\n            while (sub.size())\n            {\n                falta.push(sub.front());\n                sub.pop();\n            }\n        }\n    }\n    cout << c;\n\n    return 0;\n}"
    },
    {
        "titulo": "1493. Herd Sums",
        "url": "https://omegaup.com/arena/problem/herdsums/",
        "descripcion": "Hay 4 formas de obtener 15 como suma de uno o mas enteros positivos consecutivos: 15, 7+8, 4+5+6, 1+2+3+4+5. Escribe un programa que dado un numero entero positivo N, encuentre el número de formas de obtener N como suma de uno o mas números enteros consecutivos.",
        "entrada": "Línea 1: un solo número entero positivo N (0<=N<=10000000(diez millones))",
        "salida": "Línea 1: un solo número entero positivo, el número de formas de obtener N como suma de uno o mas enteros positivos consecutivos.",
        "nivel": "Intermedio (fácil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Programación dinámica",
            "Ciclos"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    ll n, m, a = 0, b, c;\n    cin >> n;\n    a++;\n    b = 1;\n    c = 1;\n    while (c < n)\n    {\n        if ((n - c) % (b + 1) == 0)\n        {\n            a++;\n        }\n        b++;\n        c += b;\n    }\n    cout << a;\n\n    return 0;\n}"
    },
    {
        "titulo": "5595. Escasez de agua",
        "url": "https://omegaup.com/arena/problem/Escasez-de-agua/",
        "descripcion": "Debido a la reciente escasez de agua has pensado en construir N recipientes que son capaces de almacenar, purificar y mantener el agua limpia. Como eres un genio, los recipientes también son capaces de recolectar agua de lluvia y de convertir la humedad del ambiente en agua. Cada semana se verifica la capacidad (cuanta agua tienen) de cada recipiente y se mide en litros, de modo que obtienes una lista de enteros que denotan cuantos litros almacenó cada uno de los recipientes. Como además de genio, eres muy obsesivo, quieres comprar agua para rellenar los recipientes de modo que todos queden a la misma capacidad del recipiente que más agua recolectó. Dados el número de recipientes y cuantos litros recolectó cada uno, determina el mínimo número de litros de agua que tendrías que comprar para rellenar los recipientes, de modo que todos queden con el mismo número de litros que el recipiente que más agua recolectó.",
        "entrada": "En la primera línea el entero N (1<=N<=1000) que denota el número de recipientes. En la segunda línea, N  enteros separados por espacios, cada entero denota los litros de agua que recolectó un recipiente.",
        "salida": "El entero correspondiente al número de litros de agua que tendrás que comprar para lograr tu obsesiva tarea.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Ciclos",
            "Vectores"
        ],
        "estructuras": [
            "vector<int>",
            "long long",
            "auto"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    vector<int> num(1000, 0);\n    long long a, b = 1, c = 0;\n    cin >> a;\n    for (auto i = 0; i < a; i++)\n    {\n        cin >> num[i];\n        if (num[i] > b)\n        {\n            b = num[i];\n        }\n    }\n    for (auto i = 0; i < a; i++)\n    {\n        c += (b - num[i]);\n    }\n    cout << c;\n\n    return 0;\n}"
    },
    {
        "titulo": "4185. Martontito lanza dardos",
        "url": "https://omegaup.com/arena/problem/Martontito-lanza-dardos/",
        "descripcion": "Martontito está jugando tiro al blanco con un tablero de N circulos concéntricos (imagina un tablero para lanzar dardos). Quiere saber que tanta punteria tiene, por lo que ha asignado un puntaje entre 1 y N a cada uno de los círculos del tablero empezando de afuera hacia adentro, es decir, el circulo más externo vale 1 punto y el central vale N puntos. Martontito lanzó M dardos y todos cayeron en alguno de los círculos del tablero. Como es un poco tonto, no puede calcular el puntaje que obtuvo. Escribe un programa que lea los enteros M y N, e imprima cuantos dardos cayeron en cada círculo y cuantos puntos logró Martontito.",
        "entrada": "En la primera línea los enteros M (1<=M<=10000), N (1<=N<=100) separados por un espacio. En la segunda línea y separados por un espacio, M números, cada número representa en que círculo cayó ese dardo. por ejemplo si un número en la lista de los M números es 3, significa que el dardo se clavó en el círculo marcado con valor 3, que sería el tercer círculo de afuera hacia adentro.",
        "salida": "En la primera línea el puntaje total que logró Martontito. en cada una de las siguientes N líneas, el valor del círculo (de 1 a N) y la cantidad de dardos que Martontito clavó en ese círculo.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores",
            "Ciclos"
        ],
        "estructuras": [
            "long long",
            "vector<int>",
            "auto"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d = 0;\n    vector<int> num(101, 0);\n    cin >> a >> b;\n    for (auto i = 0; i < a; i++)\n    {\n        cin >> c;\n        d += c;\n        num[c]++;\n    }\n    cout << d << \"\\n\";\n    for (auto i = 1; i <= b; i++)\n    {\n        cout << i << \" \" << num[i] << \"\\n\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "1291. Consecutivos",
        "url": "https://omegaup.com/arena/problem/Consecutivos/",
        "descripcion": "Dado un conjunto de 1<=N<=1000 elementos enteros, determina si después de ordenarse forman un conjunto de números consecutivos. Imprime SI cuando se trate de un conjunto de números consecutivos, NO en caso contrario.",
        "entrada": "En la primera línea el entero N. En la segunda línea y separados por un espacio, los N datos enteros.",
        "salida": "Imprime SI, si el conjunto está formado por números consecutivos, NO en caso contrario.",
        "nivel": "Intermedio (fácil) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Ciclos",
            "Ordenamiento",
            "Vectores"
        ],
        "estructuras": [
            "vector<int>",
            "long long",
            "auto"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    vector<int> num(1000, 0);\n    long long a;\n    cin >> a;\n    for (auto i = 0; i < a; i++)\n    {\n        cin >> num[i];\n    }\n    sort(num.begin(), num.end());\n    for (auto i = 1; i < a; i++)\n    {\n        if (num[i] == num[i - 1])\n        {\n            a = 0;\n            break;\n        }\n    }\n    if (!a)\n    {\n        cout << \"NO\";\n    }\n    else\n    {\n        cout << \"SI\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "1871. Los árboles del Bosque de los Cedros",
        "url": "https://omegaup.com/arena/problem/arboles/",
        "descripcion": "Los árboles del bosque de los cedros dan frutos de una forma peculiar. El primer fruto que nace en el árbol se coloca en la parte central del árbol. Los frutos que nacen después van descendiendo en relación a los ya existentes dependiendo de su peso: si el peso del fruto nuevo es menor al peso del fruto central del árbol entonces éste descenderá del lado izquierdo, de lo contrario descenderá del lado derecho; en caso de que el espacio ya esté ocupado por otro fruto, se comparará nuevamente hasta determinar en dónde nacerá el nuevo fruto. Dado el orden de nacimiento y los pesos de los F frutos del árbol, determine la cantidad de frutos después de los cuales ya no descendió ningún otro fruto.",
        "entrada": "Un entero F que determina el número de frutos que nacerán del árbol. La siguiente línea contendrá F enteros separados por un espacio que denotan los pesos p_i de los frutos del 1 al F. Puede suponer que 1<=F, p_i<=10000.",
        "salida": "Un entero H que representa el número de frutos en las hojas del árbol, seguido de una línea con H enteros, es decir, los pesos de dichos frutos en orden ascendente.",
        "nivel": "Intermedio (medio) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Recorridos en árboles",
            "Árboles de búsqueda binaria",
            "Ciclos",
            "Vectores",
            "Ordenamiento"
        ],
        "estructuras": [
            "long long",
            "vector<int>",
            "vector<struct>",
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct sobra\n{\n    int aa, bb, cc;\n};\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c;\n    vector<int> num(10000, 0);\n    vector<sobra> sub(10000);\n    cin >> a >> sub[0].aa;\n    sub[0].bb = -1;\n    sub[0].cc = -1;\n    for (auto i = 1; i < a; i++)\n    {\n        cin >> sub[i].aa;\n        sub[i].bb = sub[i].cc = -1;\n        b = 0;\n        c = sub[i].aa;\n        while (a)\n        {\n            if (c < sub[b].aa && sub[b].bb == -1)\n        "
    },
    {
        "titulo": "5546. Logias",
        "url": "https://omegaup.com/arena/problem/OMI-2017-Logias/",
        "descripcion": "Hace mucho tiempo, N olímpicos de la OMI fueron de visita a la escuela de Matemágicos. Charly, el director de dicha escuela, decidió separar a los N olímpicos en M grupos, de tal manera que en cada grupo hubiera al menos una persona. Al hacer esto algo muy curioso sucedió: después de la visita a la escuela de Matemágicos, cada pareja de olímpicos que estuvo en el mismo grupo se volvieron amigos. Dados N y M , el número de participantes y el número de grupos respectivamente, escribe un programa que encuentre el mínimo y el máximo número de parejas de amigos que se pudieron haber formado después de la visita a la escuela de Matemágicos.",
        "entrada": "La primera y única línea de entrada consta de dos enteros N (1<=N) y M (M<=10^9) representando el número de olímpicos y el número de equipos respectivamente. Para un 60% de los casos N, M<=2^15",
        "salida": "La única línea de salida debe contener dos enteros k_min y k_max:  el mínimo número posible de parejas de amigos, y el máximo número posible de parejas de amigos respectivamente.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Cálculos aritméticos"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e, f, g;\n    cin >> a >> b;\n    if (b == 1)\n    {\n        a--;\n        c = (a * (a + 1)) / 2;\n        cout << c << \" \" << c;\n    }\n    else\n    {\n        if (a % b == 0)\n        {\n            d = a / b;\n            d--;\n            c = (d * (d + 1)) / 2;\n            c *= b;\n            cout << c << \" \";\n            d = a - b;\n            c = (d * (d + 1)) / 2;\n            cout << c;\n        }\n        else\n        {\n            d = a / b;\n            e = a % b;\n            d = (d * (d + 1)) / 2;\n            d *= e;\n            f = b - e;\n            g = a / b;\n            g--;\n            g = (g * (g + 1)) / 2;\n            g *= f;\n            d += g;\n            cout << d << \" \";\n            d = a - b;\n            c = (d * (d + 1)) / 2;\n            cout << c;\n        }\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "1979. Noticias",
        "url": "https://omegaup.com/arena/problem/Noticias/",
        "descripcion": "Siempre que se quiere dar a conocer una noticia se busca que esta información llegue a la mayor cantidad de personas posible, pero no siempre se pude saber que tanto se dispersara la noticia. Una empresa de publicidad tiene identificada a N personas importantes y ha registrado las amistades entre ellas, con esta información se puede saber que tanto se puede dispersar una noticia. Si la persona a conoce a la persona b y a sabe la noticia x entonces b eventualmente conocerá la noticia x , igualmente si b también conoce a la persona c, c eventualmente conocerá la noticia. Como transcurre el tiempo se van creando nuevas amistades y suponemos que las amistades entre personas importantes perduran para siempre. Tu tarea consiste en crear un programa que pueda responder a cuantas personas puede alcanzar una noticia si se envía a la persona p.",
        "entrada": "La primera linea contiene dos entero: N (1<=N<=1000000) que es el numero de personas, seguido por I (1<=I<=1000000) que es el numero de instrucciones que recibiras. Las siguientes I lineas pueden contener la letra A seguido de dos enteros x y y (donde 1<=x<=N y 1<=y<=N), que indica que la persona x se convirtió en amigo de la persona y. O puede contener la letra E, seguido por un entero p (donde 1<=p<=N), en este caso tienes que responder a cuantas personas le puede llegar la noticia si se lo cuentan a la persona p. Para un total del 40% de los puntos solo existirá una consulta del tipo E al final.",
        "salida": "Tu programa deberá imprimir los respuesta a las consultas que se le hagan.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Ciclos",
            "Vectores"
        ],
        "estructuras": [
            "int",
            "long long",
            "char",
            "auto",
            "vector<struct>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct sobra\n{\n    int aa, bb;\n};\nvector<sobra> num(1000001);\n\nint falta(int z)\n{\n    int hh;\n    if (num[z].aa != z)\n    {\n        hh = falta(num[z].aa);\n        num[z].aa = hh;\n    }\n    return num[z].aa;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e, f;\n    char n;\n    cin >> a >> b;\n    for (auto i = 1; i <= a; i++)\n    {\n        num[i].aa = i;\n        num[i].bb = 1;\n    }\n    while (b--)\n    {\n        cin >> n;\n        if (n == 'A')\n        {\n            cin >> c >> d;\n            e = falta(c);\n            f = falta(d);\n            if (e != f)\n            {\n                if (num[e].bb > num[f].bb)\n                {\n                    num[e].bb += num[f].bb;\n                    num[f].aa = e;\n                }\n                else\n                {\n                    num[f].bb += num[e].bb;\n                    num[e].aa = f;\n                }\n            }\n        }\n        else\n        {\n            cin >> c;\n            d = falta(c);\n            cout << num[d].bb << \"\\n\";\n        }\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "192. L-OMI98-Submarino",
        "url": "https://omegaup.com/arena/problem/OIEG2013SSB/",
        "descripcion": "Un submarino tiene N  secciones numeradas del 1 al N De estas secciones, algunas se encuentran interconectadas entre sí. Además se sabe que hay un total de E interconexiones y que la sección N es la salida de emergencia. Si hubiera un marinero en cada sección, excepto la de salida, y si éste tardara una unidad de tiempo en llegar a una sección adyacente, determina cuántos marineros llegarían a la salida de emergencia en menos de T unidades de tiempo.",
        "entrada": "En la primera linea los enteros N (2<=E<=100), E y T (1<=T<=100). Las siguientes E líneas contienen, cada una, los números de dos secciones interconectadas entre sí.",
        "salida": "En la primera línea el número de marineros que pueden llegar a la salida de emergencia en menos de T unidades de tiempo.",
        "nivel": "Intermedio (medio) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Tablas de dispersión",
            "Vectores",
            "Colas",
            "Ciclos"
        ],
        "estructuras": [
            "queue<pair<int, int>>",
            "pair<int, int>",
            "vector<pair<int, int>>",
            "long long",
            "set<int>",
            "auto"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nqueue<pair<int, int>> falta;\npair<int, int> zz;\n\nbool sub(int z, int x)\n{\n    while (z--)\n    {\n        zz = falta.front();\n        falta.pop();\n        falta.push(zz);\n        if (zz.first == x)\n        {\n            return true;\n        }\n    }\n    return false;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    vector<pair<int, int>> num(100001, {0, 0});\n    long long a, b, c, d = 0, e, f, g;\n    queue<pair<int, int>> faltas;\n    set<int> sobra;\n    cin >> a >> b >> c;\n    c -= 2;\n    sobra.insert(a);\n    e = b - 1;\n    for (auto i = 0; i < b; i++)\n    {\n        cin >> num[i].first >> num[i].second;\n        if (num[i].second == a)\n        {\n            f = sobra.size();\n            sobra.insert(num[i].first);\n            if (f != sobra.size())\n            {\n                falta.push(num[i]);\n            }\n            num[i].second = num[i].first = -1;\n            if (i == d)\n            {\n                d++;\n            }\n            if (i == e)\n            {\n                while (num[e].second == -1)\n                {\n                    e--;\n                }\n                break;\n            }\n        }\n        else if (num[i].first == a)\n        {\n            f = sobra.size();\n            sobra.insert(num[i].second);\n            if (f != sobra.size())\n            {\n                swap(num[i].first, num[i].second);\n                falta.push(num[i]);\n            }\n            num[i].second = num[i].first = -1;\n            if (i == d)\n            {\n                d++;\n            }\n            if (i == e)\n            {\n                while (num[e].second == -1)\n                {\n                    e--;\n                }\n                break;\n            }\n        }\n    }\n    if (c == -1)\n    {\n        cout << 0;\n    }\n    else\n    {\n        while (c--)\n        {\n            for (auto i = d; i <= e; i++)\n            {\n                f = sub(falta.size(), num[i].second);\n                if (f == 1)\n                {\n                    g = sobra.size();\n                    sobra.insert(num[i].first);\n                    if (f != sobra.size())\n                    {\n                        faltas.push(num[i]);\n                    }\n                    num[i].second = num[i].first = -1;\n                    while (num[d].second == -1)\n                    {\n                        d++;\n                    }\n                    if (i == e)\n                    {\n                        while (num[e].second == -1)\n                        {\n                            e--;\n                        }\n                        break;\n                    }\n                }\n                f = sub(falta.size(), num[i].first);\n                if (f == 1)\n                {\n                    g = sobra.size();\n                    swap(num[i].first, num[i].second);\n                    sobra.insert(num[i].first);\n                    if (f != sobra.size())\n                    {\n                        faltas.push(num[i]);\n                    }\n                    num[i].second = num[i].first = -1;\n                    while (num[d].second == -1)\n                    {\n                        d++;\n                    }\n                    if (i == e)\n                    {\n                        while (num[e].second == -1)\n                        {\n                            e--;\n                        }\n                        break;\n                    }\n                }\n            }\n            while (falta.size())\n            {\n                falta.pop();\n            }\n            while (faltas.size())\n            {\n                falta.push(faltas.front());\n                faltas.pop();\n            }\n            if (!falta.size())\n            {\n                break;\n            }\n        }\n        cout << sobra.size() - 1;\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "1040. Sumas de números consecutivos",
        "url": "https://omegaup.com/arena/problem/snc/",
        "descripcion": "Escribe un programa que determine la cantidad f de formas en las que se puede escribir un número entero positivo n como suma de uno o más números enteros positivos consecutivos. Tu programa también debe determinar el número más pequeño p que forma parte de alguna de estas sumas. Por ejemplo, si n = 33, entonces f = 4 y p = 3 ya que 3 + 4 + 5 + 6 + 7 + 8 = 10 + 11 + 12 = 16 + 17 = 33.",
        "entrada": "Un número entero n en el intervalo de 1 a 1,000,000 (incluyendolos).",
        "salida": "Dos números enteros f y p.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Ciclos"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b = 1, c = 2, d = 0, e = 1;\n    cin >> a;\n    while (a > 0)\n    {\n        a -= b;\n        if (a < 1)\n        {\n            break;\n        }\n        if (a % c == 0)\n        {\n            d = a / c;\n            e++;\n        }\n        b++;\n        c++;\n    }\n    cout << e << \" \" << d;\n\n    return 0;\n}"
    },
    {
        "titulo": "3078. occ04pnsf25",
        "url": "https://omegaup.com/arena/problem/Suma-de-numeros-consecutivos/",
        "descripcion": "Hay que encontrar la suma de los números entre dos números enteros n y m dados (n <= m)",
        "entrada": "n y m",
        "salida": "n + n + 1 + n + 2 +....+ m",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Cálculos aritméticos",
            "Ciclos"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c = 0;\n    cin >> a >> b;\n    while (b >= a)\n    {\n        c += b;\n        b--;\n    }\n    cout << c;\n\n    return 0;\n}"
    },
    {
        "titulo": "6148. Traductor",
        "url": "https://omegaup.com/arena/problem/COMI-Traductor/",
        "descripcion": "En un lejano planeta coexisten dos culturas ancestrales, la Numírica y la Enteral. Pese a sus similitudes culturales, se comunican en lenguajes totalmente diferentes. Por ejemplo, en numírico podrías decir \"hola\" con \"53134\" mientras que en enteral sería \"46952\". Tu tarea será realizar traducciones entre ambos idiomas. Escribe un programa que pueda traducir entre los dos lenguajes, dada la lista de palabras de un diccionario.",
        "entrada": "a primer linea tendrá dos enteros: d y w (0<=d,w<=1000). Las siguientes d lineas representan las traducciones del diccionario, cada una con un par de enteros: n_i y e_i (0<=n_i,e_i<=10000), separados por un espacio. n_i representa una palabra en numírico y e_i su traducción a enteral. Puedes estar seguro de que las palabras no se repetirán en el diccionario. Las siguientes w líneas contienen un entero, representando la palabra en numírico que tendrás que traducir.",
        "salida": "Por cada palabra a traducir, deberás imprimir una línea que contenga su respectiva traducción en enteral. Si una palabra no tiene traducción debes imprimir C? en esa línea.",
        "nivel": "Intermedio (fácil) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Ciclos",
            "Dispersión",
            "Árboles de búsqueda binaria",
            "Matrices"
        ],
        "estructuras": [
            "long long",
            "vector<vector<long long>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e, f;\n    cin >> a >> b;\n    vector<vector<long long>> num(2, vector<long long>(a, 0));\n    for (long long i = 0; i < a; i++)\n    {\n        cin >> num[0][i] >> num[1][i];\n    }\n    for (long long i = 0; i < a; i++)\n    {\n        c = 0;\n        for (long long j = 0; j < (a - i) - 1; j++)\n        {\n            if (num[0][j + 1] < num[0][j])\n            {\n                swap(num[0][j], num[0][j + 1]);\n                swap(num[1][j], num[1][j + 1]);\n                c = 1;\n            }\n        }\n        if (!c)\n        {\n            break;\n        }\n    }\n    while (b--)\n    {\n        cin >> c;\n        d = 0;\n        e = a - 1;\n        while (d <= e)\n        {\n            f = (d + e) / 2;\n            if (num[0][f] == c)\n            {\n                cout << num[1][f] << \"\\n\";\n                break;\n            }\n            else if (num[0][f] > c)\n            {\n                e = f - 1;\n            }\n            else\n            {\n                d = f + 1;\n            }\n        }\n        if (d > e)\n        {\n            cout << \"C?\\n\";\n        }\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "6113. Paseo por el Bosque",
        "url": "https://omegaup.com/arena/problem/COMI-Paseo-por-el-Bosque/",
        "descripcion": "Troyo ha estado paseando por el bosque, y está harto de no encontrar patrones en un árbol magistral. Ayúdale a encontrar algún patrón. Pero tú que eres un gran programador, decidiste darle la orden de recorrer el árbol en pre-orden, in-orden y post-orden. Dado un arreglo de tamaño N, deberás insertar cada uno de ellos en un árbol binario de búsqueda según vienen en la entrada, e imprimir los recorridos del árbol en pre-orden, in-orden y post-orden respectivamente. El primer elemento que leas será la raíz del árbol.",
        "entrada": "En la primera línea un entero, N (1<=N<=10^5) que indica el tamaño del arreglo, en la siguiente línea están los N elementos del arreglo.",
        "salida": "En la primera línea deberás imprimir el recorrido en pre-orden, en la segunda deberás imprimir el recorrido en inorden, y en la tercera y última el post-orden.",
        "nivel": "Intermedio (medio) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Recorridos en árboles",
            "Ciclos",
            "Vectores",
            "Recursión"
        ],
        "estructuras": [
            "int",
            "long long",
            "vector<struct>",
            "auto"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct sobra{\n    int aa, bb, cc;\n};\n\nlong long a, b=1, c, d, e, f, g, h;\nvector<sobra> num(100000);\n\nvoid falta(int z){\n    cout<<num[z].aa<<\" \";\n    if(num[z].bb!=-1){\n        falta(num[z].bb);\n    }\n    if(num[z].cc!=-1){\n        falta(num[z].cc);\n    }\n    return;\n}\n\nvoid sub(int x){\n    if(num[x].bb!=-1){\n        sub(num[x].bb);\n    }\n    if(num[x].cc!=-1){\n        sub(num[x].cc);\n    }\n    cout<<num[x].aa<<\" \";\n    return;\n}\n\nvoid sums(int y){\n    if(num[y].bb!=-1){\n        sums(num[y].bb);\n    }\n    cout<<num[y].aa<<\" \";\n    if(num[y].cc!=-1){\n        sums(num[y].cc);\n    }\n    return;\n}\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    cin>>a>>num[0].aa;\n    num[0].bb=num[0].cc=-1;\n    for(auto i=1; i<a; i++){\n        cin>>num[i].aa;\n        num[i].bb=num[i].cc=-1;\n        b=0;\n        while(a){\n            if(num[i].aa<num[b].aa && num[b].bb==-1){\n                num[b].bb=i;break;\n            }\n            else if(num[i].aa>num[b].aa && num[b].cc==-1){\n                num[b].cc=i;break;\n            }\n            else if(num[i].aa<num[b].aa){\n                b=num[b].bb;\n            }\n            else{\n                b=num[b].cc;\n            }\n        }\n    }\n    falta(0);\n    cout<<\"\\n\";\n    sums(0);\n    cout<<\"\\n\";\n    sub(0);\n    cout<<\"\\n\";\n    \n    return 0;\n}"
    },
    {
        "titulo": "5010. Las pistas de azul",
        "url": "https://omegaup.com/arena/problem/Las-pistas-de-azul/",
        "descripcion": "Seguramente has escuchado hablar del programa \"las pistas de Blue\", donde un perro dejaba huellas para que su amo Steve encontrara ciertos objetos. \"Azul\" es el primo de \"Blue\" que vive en México y él utiliza números para que su amo Esteban encuentre objetos. El mundo está dividido en un conjunto de casillas donde en cada una se encuentra un PAR de números (fila, columna) que indica la posición donde está la siguiente pista. Esteban al encontrar el objeto que buscaba, notó que su casa estaba llena de pistas y por lo tanto, su casa estaba muy sucia por el andar de Azul, así que él quisiera saber en qué partes de la casa pudo haber estado Azul para poder limpiar. Dada un conjunto de pistas y las ubicaciones de estas, deberás decirle a Esteban el número de casillas desde las cuales, empezando en cada una de ellas y siguiendo las pistas, se puede llegar a la casilla donde está el objeto. Al menos te tienes que mover a una casilla para que puedas contarla, es decir, empezar en la casilla del objeto no deberá contarse. Las casillas que están marcadas con -1,-1 indica que no hay pista que te lleve a otra casilla. Subtarea 1 Para un conjunto de 60% de los casos no se creará un ciclo dentro del mundo(Un ciclo es una secuencia de pistas que eventualmente te llevan a repetir una casilla). Subtarea 2 Para el 100% de los casos, puede o no haber un ciclo en el mundo",
        "entrada": "En la primera línea, un entero 1<=N<=50 que denota las dimensiones de la casa (Siempre será de N filas por N columnas). En la segunda línea dos enteros 0 <= F, C<= N-1 separados por espacios que denotan las coordenadas de la casilla donde está el objeto. En cada una de las siguientes N líneas, 2*N números, donde cada par indica la coordenada de la siguiente pista en cada casilla.",
        "salida": "Un entero que indica el número de casillas desde las cuales, se puede llegar a la casilla donde está el objeto.",
        "nivel": "Intermedio (medio) - Análisis y diseño de algoritmos",
        "categorias": [
            "Tablas de dispersión",
            "Matrices",
            "Colas",
            "Ciclos"
        ],
        "estructuras": [
            "vector<vector<pair<int, int>>>",
            "long long",
            "queue<pair<int, int>>",
            "pair<int, int>",
            "auto"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    vector<vector<pair<int, int>>> num(51, vector<pair<int, int>>(51, {0, 0}));\n    long long a, b, c, d, e, f = 0;\n    queue<pair<int, int>> falta;\n    queue<pair<int, int>> sub;\n    pair<int, int> z;\n    cin >> a >> b >> c;\n    z.first = b;\n    z.second = c;\n    falta.push(z);\n    for (auto i = 0; i < a; i++)\n    {\n        for (auto j = 0; j < a; j++)\n        {\n            cin >> num[i][j].first >> num[i][j].second;\n            if (i == b && j == c)\n            {\n                num[i][j].first = num[i][j].second = -1;\n            }\n        }\n    }\n    while (falta.size())\n    {\n        d = falta.size();\n        for (auto i = 0; i < a; i++)\n        {\n            for (auto j = 0; j < a; j++)\n            {\n                if (num[i][j].first != -1)\n                {\n                    e = d;\n                    while (e--)\n                    {\n                        z = falta.front();\n                        falta.pop();\n                        falta.push(z);\n                        if (z.first == num[i][j].first && z.second == num[i][j].second)\n                        {\n                            z.first = i;\n                            z.second = j;\n                            sub.push(z);\n                            num[i][j].first = num[i][j].second = -1;\n                            f++;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        while (falta.size())\n        {\n            falta.pop();\n        }\n        while (sub.size())\n        {\n            falta.push(sub.front());\n            sub.pop();\n        }\n    }\n    cout << f;\n\n    return 0;\n}"
    },
    {
        "titulo": "6134. Round Robin",
        "url": "https://omegaup.com/arena/problem/COMI-Round-Robin/",
        "descripcion": "Cierta computadora tiene un procesador que puede atender un proceso a la vez por unidades de tiempo. Si el proceso necesita más de K unidades para terminar, el procesador lo atiende exactamente K unidades y deja pendientes las unidades excedentes. Cuando un proceso es atendido y no finaliza, se forma al final de la lista de procesos pendientes. Escribe un programa que lea el número de procesos, K, los IDs y el tiempo de ejecución de cada uno de los N procesos y determine el orden en que los procesos finalizarán.",
        "entrada": "En la primera línea dos enteros, N (1<=N<=1000) y K (1<=K<=100). En cada una de las siguientes N líneas, dos enteros X, Y, separados por un espacio. Que denotan el ID del proceso y el tiempo de ejecución que necesita para concluir. Considera que 1<=t_i<=1000",
        "salida": "N  líneas con los ID de los procesos en el orden que concluyeron. Considera que los procesos de la entrada ya se encuentran en la lista de espera.",
        "nivel": "Intermedio (fácil) - Análisis y diseño de algoritmos",
        "categorias": [
            "Colas",
            "Vectores",
            "Tablas de dispersión",
            "Ciclos",
            "Ordenamiento"
        ],
        "estructuras": [
            "vector<pair<int, int>>",
            "long long",
            "auto"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    vector<pair<int, int>> num(1000, {0, 0});\n    long long a, b, c = 0;\n    cin >> a >> b;\n    for (auto i = 0; i < a; i++)\n    {\n        cin >> num[i].second >> c;\n        if (c % b == 0)\n        {\n            c /= b;\n        }\n        else\n        {\n            c /= b;\n            c++;\n        }\n        num[i].first = c;\n    }\n    sort(num.begin(), num.end());\n    for (auto i = 0; i < a; i++)\n    {\n        cout << num[i].second << \" \";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "6131. Derrame de Petróleo",
        "url": "https://omegaup.com/arena/problem/COMI-Derrame-de-Petroleo/",
        "descripcion": "Ha habido un derrame de petroleo en el golfo y una organización ecologista internacional te ha contratado para escribir un programa que los ayude a calcular la gravedad del impacto ambiental. Te van a dar una cuadrícula de R filas y C columnas, que representan el entorno que rodea la plataforma petrolera. El derrame se originó en la plataforma, que se marcará en su mapa con un '$'. Las casillas de tierra se marcarán con un '#' y las casillas del mar se marcarán con un '.'. Cada día que pasa después de la explosión inicial, cada cuadrado de mar adyacente (norte, este, sur u oeste) a la plataforma petrolera o a una plaza marítima, previamente cubierta de petróleo, queda cubierto por el petróleo. Las plazas terrestres nunca son cubiertas por petróleo. Tu programa debe simular la propagación del derrame de petróleo durante K días, luego imprime un mapa del entorno circundante con cuadrados marinos cubiertos de petróleo representados por '*'.",
        "entrada": "Tu programa debe leer de teclado tres enteros separados por un espacio R, C (1<=R,C<=2000, donde R y C son el número de filas y columnas de la cuadrícula, respectivamente.) y K (0<=K<=10000000, donde K es el número de días para los cuales debe simular el derrame de petróleo.). Las siguientes R líneas contendrán cada una C caracteres, cada uno de los cuales será '#' o '.' representando cuadrados terrestres y marítimos, respectivamente. Exactamente sólo habrá un sólo '$', que representa la plataforma petrolera en el mar. Considera que para el 75% de los casos, 1<=R,C<=50.",
        "salida": "Tu programa debe mostrar R líneas, cada una con C caracteres. Cada carácter en esta cuadrícula debe ser el mismo que el carácter correspondiente en la cuadrícula de entrada, a excepción de las casillas marinas que han sido cubiertas por petróleo después de K días. Estos deberían estar representados por caracteres '*'.",
        "nivel": "Intermedio (medio) - Análisis y diseño de algoritmos",
        "categorias": [
            "Búsqueda en profundidad",
            "Búsqueda en amplitud",
            "Matrices",
            "Colas",
            "Ciclos"
        ],
        "estructuras": [
            "vector<vector<char>>",
            "long long",
            "queue<struct>",
            "auto"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct sobra{\n    int aa, bb, cc;\n};\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    vector<vector<char>> num(2000, vector<char> (2000, ''));\n    long long a, b, c;\n    queue<sobra> falta;\n    sobra z;\n    cin>>a>>b>>c;\n    for(auto i=0; i<a; i++){\n        for(auto j=0; j<b; j++){\n            cin>>num[i][j];\n            if(num[i][j]=='$'){\n                z.aa=i;\n                z.bb=j;\n                z.cc=0;\n                falta.push(z);\n            }\n        }\n    }\n    while(falta.size()){\n        z=falta.front();\n        falta.pop();\n        z.cc++;\n        if(z.cc>c){\n            break;\n        }\n        if(z.aa-1>-1 && num[z.aa-1][z.bb]=='.'){\n            num[z.aa-1][z.bb]='*';\n            z.aa--;\n            falta.push(z);\n            z.aa++;\n        }\n        if(z.bb-1>-1 && num[z.aa][z.bb-1]=='.'){\n            num[z.aa][z.bb-1]='*';\n            z.bb--;\n            falta.push(z);\n            z.bb++;\n        }\n        if(z.aa+1<a && num[z.aa+1][z.bb]=='.'){\n            num[z.aa+1][z.bb]='*';\n            z.aa++;\n            falta.push(z);\n            z.aa--;\n        }\n        if(z.bb+1<b && num[z.aa][z.bb+1]=='.'){\n            num[z.aa][z.bb+1]='*';\n            z.bb++;\n            falta.push(z);\n            z.bb--;\n        }\n    }\n    for(auto i=0; i<a; i++){\n        for(auto j=0; j<b; j++){\n            cout<<num[i][j];\n        }\n        cout<<\"\\n\";\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "4188. Los laboratoristas",
        "url": "https://omegaup.com/arena/problem/Los-laboratoristas/",
        "descripcion": "¡Terminó laboratorio! Es hora de que Laurencio entregue su material. Para su desgracia los laboratoristas son malignos y atienden a los alumnos de la siguiente forma: Primero ordenan a los alumnos en una fila con respecto a su número de lista en forma ascendente. Para molestar a los alumnos los laboratoristas les ordenan realizar cuantas veces lo pidan una de las siguientes acciones: 1.Todos los alumnos de la fila deben recorrerse un lugar atrás, donde el último alumno de la fila se mueve al inicio de esta (representado en la entrada como “M -1”). 2.Todos los alumnos deben recorrerse un lugar adelante, donde el primer alumno de la fila se mueve al final de esta (representado en la entrada como “M 1”). Cuando se aburren de esto los laboratoristas atienden al alumno con mayor o menor número de lista, sacándolo de la fila y haciendo que todas las personas que se encontraban detrás suyo se recorran un lugar adelante (representado en la entrada como “Q k”, donde k=1 implica quitar al de mayor número de lista y  k=-1 implica quitar al de menor número de lista). Obviamente Laurencio desconoce este proceso y, para matar el tiempo y no a los laboratoristas, te pide que le digas, para una determinada configuración, cuál es la posición en la fila del alumno con número de lista x_i.",
        "entrada": "La primera línea contiene un número n, el número inicial de alumnos en la fila. La segunda línea contiene el acomodo en la fila de los alumnos, representado como n números en orden ascendente, donde cada número es equivalente al número de lista del i-ésimo alumno. La tercera línea contiene un número Q, el número de acciones y preguntas que se llevarán a cabo. En las siguientes Q líneas contendrá una serie de acciones, donde estas pueden ser las descritas anteriormente o una pregunta de Laurencio, representada por la letra L seguida de un número X_i, representando el número de lista de algún alumno. (1<=n,Q<=1000000), (1<=x_i<=1000000000).",
        "salida": "Para cada pregunta deberás imprimir la posición del alumno con número de lista x_i. En caso que el alumno ya no se encuentre en la fila deberás imprimir \"No Laurencio\" sin comillas.",
        "nivel": "",
        "categorias": [
            "Vectores"
        ],
        "estructuras": [
            "vector<int>",
            "long long",
            "char"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d=0, e=0, f=1, h, l, p, q, z;\n    vector<int> sub(1000000, 0);\n    char zz;\n    cin>>a;\n    f=a-1;\n    for(auto i=0; i<a; i++){\n        cin>>sub[i];\n    }\n    cin>>b;\n    while(b){\n        b--;\n        cin>>zz>>c;\n        if(zz=='M'){\n            if(c==1){\n                d--;\n            }\n            else{\n                d++;\n            }\n        }\n        else if(zz=='Q'){\n            if(c==1){\n                f--;\n                if(d>0){\n                    d--;\n                }\n            }\n            else{\n                e++;\n                if(d<0){\n                    d++;\n                }\n            }\n        }\n        else{\n            if(c<sub[e] || c>sub[f]){\n                cout<<\"No Laurencio\\n\";\n            }\n            else{\n                h=0; l=a-1;\n                while(h<=l){\n                    z=(h+l)/2;\n                    if(sub[z]==c){\n                        c=-1;break;\n                    }\n                    else if(sub[z]<c){\n                        h=z+1;\n                    }\n                    else{\n                        l=z-1;\n                    }\n                }\n                q=d;\n                p=f-e;\n                p++;\n                d%=p;\n                if(c!=-1){\n                    cout<<\"No Laurencio\\n\";\n                }\n                else if(!d){\n                    z-=e;\n                    cout<<z+1<<\"\\n\";\n                }\n                else if(d>0){\n                    z+=d;\n                    if(z>f){\n                        z-=f;\n                        z--;\n                    }\n                    else{\n                        z-=e;\n                    }\n                    cout<<z+1<<\"\\n\";\n                }\n                else{\n                    z+=d;\n                    if(z<e){\n                        z=e-z;\n                        z=f-z;\n                        z-=e;\n                        z++;\n                    }\n                    else{\n                        z-=e;\n                    }\n                    cout<<z+1<<\"\\n\";\n                }\n                d=q;\n            }\n        }\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "4466. Buscaminas UP",
        "url": "https://omegaup.com/arena/problem/Buscaminas-UP/",
        "descripcion": "El juego consiste en despejar todas las casillas de una pantalla que no oculten una mina. Algunas casillas tienen un número, el cual indica la cantidad de minas que hay en las casillas circundantes. Así, si una casilla tiene el número 3, significa que de las cuatro casillas que hay alrededor (si no es en una esquina o borde) hay 3 con minas y 1 sin minas. Escribe un programa que dadas las posiciones de las minas imprima el tablero del juego.",
        "entrada": "La primera línea contiene tres enteros n, m (5<=n, m<=50), y k. Indicando la cantidad de renglones del tablero, la cantidad de columnas del tablero y la cantidad de minas respectivamente. Le siguen k líneas, cada una con dos números indicando el renglon y columna de cada una de las minas.",
        "salida": "Imprime el tablero resultante. En las casillas donda hay una mina imprime el caracter \"*\", en caso contrario imprime el número de minas que hay alrededor. Ejemplo de Entrada 1 | Ejemplo de Salida 1 ------------- |---------------- 3 3 3 0 0 2 1 0 2 | *2* 111 1*1",
        "nivel": "",
        "categorias": [
            "Matrices"
        ],
        "estructuras": [
            "vector<vector<char>>",
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    vector<vector<char>> num(51, vector<char> (51, ''));\n    long long a, b, c, d, e, f;\n    cin>>a>>b>>c;\n    while(c){\n        c--;\n        cin>>d>>e;\n        num[d][e]='*';\n    }\n    for(auto i=0; i<a; i++){\n        for(auto j=0; j<b; j++){\n            if(num[i][j]=='*'){\n                cout<<num[i][j];continue;\n            }\n            f=0;\n            if(i-1>-1 && num[i-1][j]=='*'){\n                f++;\n            }\n            if(j-1>-1 && num[i][j-1]=='*'){\n                f++;\n            }\n            if(i+1<a && num[i+1][j]=='*'){\n                f++;\n            }\n            if(j+1<b && num[i][j+1]=='*'){\n                f++;\n            }\n            num[i][j]=48+f;\n            cout<<num[i][j];\n        }\n        cout<<\"\\n\";\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "5408. Buscando Productos",
        "url": "https://omegaup.com/arena/problem/Buscando-Productos/",
        "descripcion": "Fernando sigue en el almacen cuando le pidieron que revisara la ubicación de R productos. Cada producto tiene una etiqueta C_i, la cual es un entero. Por fortuna para Fer en este almacen son muy cuidadosos y tienen ordenados los productos de menor a mayor por su etiqueta.",
        "entrada": "Un entero N representando la cantidad de productos distintos. En la siguiente linea N  enteros, representando C_i. En la siguiente linea R. En las siguiente linea, R enteros Q_i representando la pregunta por la ubicacion del producto Q_i. (1<=N<=10^5), (1<=R<= 10^5), (1 <= C_i, Q_i <= 10^9), (i != j ➝ C_i != C_j).",
        "salida": "Por cada pregunta, una linea indicando la ubicación del producto, si no existe imprime -1",
        "nivel": "",
        "categorias": [
            "Vectores"
        ],
        "estructuras": [
            "long long",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e, f;\n    vector<int> num(100000, 0);\n    cin>>a;\n    for(auto i=0; i<a; i++){\n        cin>>num[i];\n    }\n    cin>>b;\n    while(b){\n        b--;\n        cin>>c;\n        d=0;\n        e=a-1;\n        while(d<=e){\n            f=(d+e)/2;\n            if(num[f]==c){\n                cout<<f+1<<\"\\n\";\n                f=-1;break;\n            }\n            else if(num[f]<c){\n                d=f+1;\n            }\n            else{\n                e=f-1;\n            }\n        }\n        if(f!=-1){\n            cout<<\"-1\\n\";\n        }\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "3518. Mayor a la Izquierda",
        "url": "https://omegaup.com/arena/problem/Mayor-a-la-Izquierda/",
        "descripcion": "Dado un arreglo a[] de n enteros (a[i]<=10^9 y 1<=n<=10^6), decir para cada a[i] a que distancia está el último número a su izquierda que es mayor que él, o -1 si todos los números a su izquierda son menores o iguales a él.",
        "entrada": "En la primera línea n (1<=n<=10^6) el tamaño del arreglo. En la segunda línea n enteros (con valor absoluto menor o igual que 10^9) separados por un espacio, los elementos del arreglo.",
        "salida": "Una línea con n números con la información pedida en el enunciado.",
        "nivel": "",
        "categorias": [
            "Vectores"
        ],
        "estructuras": [
            "long long",
            "vector<pair<int,int>>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    vector<pair<int, int>> num(1000000, {0, 0});\n    long long a, b;\n    cin>>a;\n    for(auto i=0; i<a; i++){\n        cin>>num[i].first;\n    }\n    cout<<\"-1 \";\n    num[0].second=-1;\n    for(auto i=1; i<a; i++){\n        b=i-1;\n        while(true){\n            if(num[b].first>num[i].first){\n                num[i].second=b;\n                cout<<i-b<<\" \";break;\n            }\n            else if(num[b].first==num[i].first){\n                num[i].second=num[b].second;\n                if(num[b].second>-1){\n                    cout<<i-num[i].second<<\" \";break;\n                }\n                else{\n                    cout<<\"-1 \";break;\n                }\n            }\n            else{\n                if(num[b].second==-1){\n                    cout<<\"-1 \";\n                    num[i].second=-1;break;\n                }\n                else{\n                    b=num[b].second;\n                }\n            }\n        }\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "6223. Máquina descompuesta",
        "url": "https://omegaup.com/arena/problem/Maquina-descompuesta/",
        "descripcion": "En algún rincón de tu casa debe haber una máquina de escribir. Si la llegaras a usar, tal vez notarías que está descompuesta. En este caso, tenemos una máquina de escribir que cambia entre mayúsculas y minúsculas de manera arbitraria. Por ejemplo, podrías obtener el siguiente resultado: hOLa. eStoY DesComPUEsta. cuando en realidad deseabas teclear: Hola. Estoy descompuesta. Por supuesto, un lector que domine la gramática podría saber cuáles letras deben ser mayúsculas y cuáles minúsculas. Para este ejercicio consideraremos una regla simplificada de los casos de mayúscula inicial: la primera letra de cada enunciado (que terminaremos con punto) debe ser mayúscula, todas las demás letras deben ser minúsculas.",
        "entrada": "Consiste de una cadena S de longitud entre 1 y 80. Los caracteres de esa cadena podrán ser letras (sin acentos), dígitos, puntos y espacios.",
        "salida": "Consiste de una cadena T en la cual se han arreglado las mayúsculas y las minúsculas de acuerdo a la regla simplificada.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "long long",
            "string",
            "getline()",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a=0;\n    string z;\n    getline(cin, z);\n    if(z[0]>96 && z[0]<123){\n        z[0]-=32;\n    }\n    for(auto i=1; i<z.size(); i++){\n        if(z[i]=='.'){\n            a++;\n        }\n        else if(z[i]==' '){\n            continue;\n        }\n        else if(z[i]>47 && z[i]<58){\n            continue;\n        }\n        else if(a){\n            if(z[i]>96 && z[i]<123){\n                z[i]-=32;\n            }\n            a=0;\n        }\n        else{\n            if(z[i]>64 && z[i]<91){\n                z[i]+=32;\n            }\n        }\n    }\n    cout<<z;\n    \n    return 0;\n"
    },
    {
        "titulo": "1025. Números menores que dos mil",
        "url": "https://omegaup.com/arena/problem/nmd/",
        "descripcion": "Imagina que tienes una lista de números enteros (sin ceros y todos ellos menores que dos mil) a la cual se le han suprimido las separaciones. Por ejemplo, si se comienza con la lista 12, 34, 5, 678 entonces se obtiene la cadena a = 12345678. Ahora tú quieres recuperar una lista de números enteros (todos ellos menores que dos mil) agrupando los dígitos tanto como sea posible desde el principio de la cadena. En nuestro caso, obtendrás la lista 1234, 567, 8 con p = 3 elementos. Por diversión, después realizas la misma operación pero comenzando desde el final de la lista. En nuestro caso, obtendrás la lista 12, 345, 678 con f = 3 elementos. Escribe un programa que dada la cadena de dígitos encuentre cuántos elementos p y f contienen cada una de las listas.",
        "entrada": "Una cadena s que contiene entre 1 y 1000 dígitos. Puedes suponer que no hay dígitos 0.",
        "salida": "Dos números enteros p y f separados por un espacio.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Loops",
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "long long",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a=0, b=0, c=0;\n    string z, zz;\n    cin>>z;\n    zz=z;\n    for(auto i=0; i<z.size(); i++){\n        a*=10;\n        if(a>1999){\n            a=0;\n            b++;\n        }\n        a+=(z[i]-48);\n    }\n    if(a){\n        b++;\n    }\n    z=zz;\n    cout<<b<<\" \";\n    a=0;\n    b=0;\n    for(auto i=z.size()-1; i>-1; i--){\n        a+=((z[i]-48)*pow(10, c));\n        c++;\n        if(a>1999){\n            b++;\n            c=1;\n            a=z[i]-48;\n        }\n    }\n    if(a){\n        b++;\n    }\n    cout<<b;\n    \n    return 0;\n}"
    },
    {
        "titulo": "4933. Alfa buena maravilla onda dinamita escuadrón lobo",
        "url": "https://omegaup.com/arena/problem/abmodel/",
        "descripcion": "El equipo Alfa buena maravilla onda dinamita escuadrón lobo está en una misión para rescatar a Shrek. Ellos han entrado al castillo en Muy Muy Lejano. Este castillo es muy moderno por lo cual ahora cuenta con elevador en una de sus torres. Burro, como lider del equipo, es quien opera este elevador pero los botones son muy pequeños y no logra atinar a los correctos. Después de N intentos el equipo al fin llega al piso correspondiente. Durante estos N intentos Jengibre se dió cuenta que hubo ocasiones en donde después de alguna cantidad de movimientos(subir o bajar pisos) ellos regresaban a algún piso donde ya habían estado. Dado cuantos pisos subian y bajaban en cada movimiento, tu tarea consiste en decir cuantos intervalos existen donde el equipo regresa al piso en donde estaban exactamente antes de ese intervalo (ver ejemplo). Ejemplo: Se tiene una lista de 5 movimientos 2 -1 1 -1 -1. Existen tres intervalos donde vuelven al mismo piso (2,3), (3,4), (1,5), esto es. Para el intervalo (2, 3) Antes de empezar el intervalo ellos estaban en el piso 2, después del intervalo (2, 3) ellos vuelven al piso 2. Para el intervalo (3, 4) Antes de empezar el intervalo ellos estaban en el piso 1, después del intervalo (3, 4) ellos vuelven al piso 1. Para el intervalo (1, 5) Antes de esto, ellos estaban en el piso 0(piso inicial), después del intervalo (1, 5) ellos vuelven al piso 0.",
        "entrada": "En la primera linea un entero N que indica el número de movimientos que se van a hacer (1<=N<=1,000,000).  En las siguiente linea N enteros a_i, donde a_i  indica la cantidad de pisos que suben o bajan en cada movimiento. Los números positivos indican que suben y los negativos que bajan. (-10^9 <= a_i <=10^9). Subtarea 1 (50 puntos) (1<=N<=1,000). Subtarea 2 (20 puntos) (1<=N<=10,000). Subtarea 3 (30 puntos) (1<=N<=1,000,000).",
        "salida": "Un entero que indica la cantidad de intervalos que existen tales que cumplen con lo antes pedido.",
        "nivel": "",
        "categorias": [
            "Ordenamiento",
            "Vectores"
        ],
        "estructuras": [
            "vector<pair<int,int>>",
            "long long",
            "set<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<pair<int, int>> num(100000, {0, 0});\nlong long a, b=0, c, d=0, e=0, f, g, h;\nset<int> falta;\n\nint sub(){\n    sort(num.begin(), num.end());\n    g=num[0].second;\n    h=0;\n    for(auto i=1; i<100000; i++){\n        if(num[i].first==num[i-1].first){\n            g+=num[i].second;\n        }\n        else{\n            num[h].first=num[i-1].first;\n            num[h].second=g;\n            g=num[i].second;\n            h++;\n        }\n    }\n    num[h].first=num[99999].first;\n    num[h].second=g;\n    h++;\n    return h;\n}\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    cin>>a;\n    falta.insert(0);\n    for(auto i=0; i<a; i++){\n        cin>>c;\n        b+=c;\n        f=falta.size();\n        falta.insert(b);\n        if(f==falta.size()){\n            num[e].first=b;\n            num[e].second=1;\n            e++;\n            if(e==100000){\n                e=sub();\n            }\n        }\n    }\n    sort(num.begin(), num.end());\n    a=num[0].second;\n    for(auto i=1; i<e; i++){\n        if(num[i].first==num[i-1].first){\n            a+=num[i].second;\n        }\n        else{\n            d+=(((a+1)*a)/2);\n            a=num[i].second;\n        }\n    }\n    d+=(((a+1)*a)/2);\n    cout<<d;\n    \n    return 0;\n}"
    },
    {
        "titulo": "3270. Arbol de navidad estrellado",
        "url": "https://omegaup.com/arena/problem/Arbol-de-navidad-estrellado/",
        "descripcion": "Ahora que ya casi es Navidad, preso se quiere dedicar vender árboles de navidad y sacar algo de dinero extra. Pero como es muy innovador decido construirlos a la medida y con un diseño propio. Los árboles que construye son de altura N+1 ya que en el último nível tiene una estrella. Los árboles tienen la siguiente forma: La estrella es un * y los otros niveles están formados por letras \"o\" minúsculas. Tu trabajo ayudar a preso con su propósito navideño.",
        "entrada": "En la primera línea un entero n el número de niveles en el árbol (n no incluye la estrella). (0<n<=500)",
        "salida": "El árbol de n+1 niveles ya con la estrella incluida.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Loops"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c=3, d;\n    cin>>a;\n    b=a;\n    while(b){\n        cout<<\" \";\n        b--;\n    }\n    cout<<\"*\\n\";\n    while(a){\n        a--;\n        b=a;\n        while(b){\n            cout<<\" \";\n            b--;\n        }\n        d=c;\n        while(d){\n            cout<<\"o\";\n            d--;\n        }\n        cout<<\"\\n\";\n        c+=2;\n    }\n    \n    return 0;\n"
    },
    {
        "titulo": "457. CR Cadenas Suaves",
        "url": "https://omegaup.com/arena/problem/Cadenas-Suaves/",
        "descripcion": "Decimos que una cadena es suave si todos sus caracteres son iguales. Como te gustan las cadenas suaves, quieres calcular cuánto tiempo te tomaría transformar cualquier cadena a una cadena suave. La única operación que puedes hacer sobre la cadena es escoger una letra X y una letra Y y cambiar todas las letras de la cadena que sean X a Y. Cada letra que cambies te toma un segundo. Por ejemplo, la cadena “cadena”, si X=’a’ y Y=’c’, después de dos segundos quedaría como “ccdenc”. La cadena sólo tendrá letras minúsculas del alfabeto inglés. Para los primeros 50 puntos, no tendrá más de 50 caracteres. Para el resto de los puntos, puede tener hasta 100000 caracteres.",
        "entrada": "Varias cadenas, una por línea.",
        "salida": "Para cada cadena, imprime la menor cantidad de segundos que tomaría volver la cadena en suave.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Loops",
            "Caracteres y cadenas",
            "Arreglos",
            "Condicionales",
            "Aritmética",
            "Vectores",
            "Ordenamiento"
        ],
        "estructuras": [
            "string",
            "vector<int>",
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    vector<int> num(26, 0);\n    long long a;\n    string z;\n    cin>>z;\n    for(auto i=0; i<z.size(); i++){\n        num[z[i]-97]++;\n    }\n    sort(num.begin(), num.end());\n    a=z.size()-num[25];\n    cout<<a;\n\n    return 0;\n}"
    },
    {
        "titulo": "5431. Haunted Tower",
        "url": "https://omegaup.com/arena/problem/Haunted-Tower/",
        "descripcion": "Alfonso ha llegado a una torre hechizada y quiere llegar a la cima lo más rápido posible para poder escapar de ahí. Sin embargo se ha encontrado con un extraño fenómeno la torre, en cada piso tiene dos opciones, subir al piso siguiente por las escaleras o usar un elevador embrujado que no le permite elegir a que piso ir, sino que cada piso en la puerta del elevador hay un letrero con un número entero que indica la cantidad de pisos que el elevador subirá o bajará a Alfonso. Por suerte Alfonso ha conseguido los planos de la torre y sabe como funcionan los elevadores en cada piso, como es flojo y no quiere subir todos los pisos por las escaleras te ha pedido que lo ayudes a descubrir cual es el número mínimo de pisos por los que debe pasar para llegar a la cima.",
        "entrada": "La primera linea contendrá un entero n que indica el número de pisos de la torre. Las siguientes n lineas contendrán un número entero p_i que indica cuantos pisos sube o baja Alfonso si decide tomar el elevador en el piso i (considera que la planta baja es el piso cero y Alfonso siempre comienza ahi). Nota: si p_i<0 indica que Alfonso bajara |p_i| pisos. (1 <= n <= 20), (-17 <= p_i <= 17 y p_i != 0).",
        "salida": "Debes regresar un número m que indique el número mínimo de pisos que debe recorrer Alfonso para llegar a la \"azotea\" o piso n del edificio.",
        "nivel": "",
        "categorias": [
            "Colas"
        ],
        "estructuras": [
            "long long",
            "queue<>",
            "vector<int>",
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct sobra{\n    int aa, bb, cc;\n};\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    vector<int> num(30, 0);\n    queue<sobra> falta;\n    long long a;\n    sobra z;\n    cin>>a;\n    for(auto i=0; i<a; i++){\n        cin>>num[i];\n    }\n    z.aa++;\n    z.bb++;\n    if(z.aa==a){\n        cout<<z.bb;return 0;\n    }\n    falta.push(z);\n    z.aa--;\n    z.aa+=num[z.aa];\n    if(z.aa==a){\n        cout<<z.bb;return 0;\n    }\n    if(z.aa>-1){\n        falta.push(z);\n    }\n    while(true){\n        z=falta.front();\n        falta.pop();\n        z.bb++;\n        z.aa++;\n        if(z.aa==a){\n            cout<<z.bb;return 0;\n        }\n        falta.push(z);\n        z.aa--;\n        z.aa+=num[z.aa];\n        if(z.aa==a){\n            cout<<z.bb;return 0;\n        }\n        if(z.aa>-1){\n            falta.push(z);\n        }\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "6001. Invertir palabras",
        "url": "https://omegaup.com/arena/problem/word-scramble/",
        "descripcion": "Escribe un programa que invierta las letras y/o símbolos que forman cada palabra, sin perder el orden de las palabras. Debes conservar la cantidad de espacios entre las palabras.",
        "entrada": "Habrán múltiples líneas con palabras y otros caracteres imprimibles. Las palabras están delimitadas por espacios en blanco.",
        "salida": "Mostrar cada una de las líneas de palabras invertidas de la entrada. Recuerda invertir cada palabra.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Caracteres y cadenas",
            "Loops"
        ],
        "estructuras": [
            "string",
            "getline()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    string z, zz=\"\";\n    while(getline(cin, z)){\n        for(auto i=0; i<z.size(); i++){\n            if(z[i]==' '){\n                cout<<zz<<\" \";\n                zz=\"\";\n            }\n            else{\n                zz=z[i]+zz;\n            }\n        }\n        cout<<zz<<\"\\n\";\n        zz=\"\";\n    }\n    \n    return 0;\n}\n"
    },
    {
        "titulo": "3362. Moda Wachin",
        "url": "https://omegaup.com/arena/problem/Moda-Wachin/",
        "descripcion": "Dicen que Wachin es un chico pintudo(que se viste bien), y que siempre le gusta andar a la moda. Por ejemplo: Si 5 jovenes estan vestidos con colores 1, 2, 3, 4, 2, la moda que domina y la cual Wachin debe seguir es el 2. Tu tarea consiste en ayudar a Wachin a estar en la mejor moda posible y asi ser el mas pintudo. Si hay varias modas empatadas, Wachin escogera la que este representada por el numero menor. Ejemplo 1 1 3 5 7 9 7 8 5 4, las modas 1, 5, y 7 estan empatadas pero Wachin escoge el 1.",
        "entrada": "La primera linea esta un numero entero T, que indica los casos de prueba a seguir. Seguido de T casos, cada caso esta compuesto por dos lineas, en la primera linea de cada caso viene un entero N que indica el numero de jovenes que imponen moda, y en la segunda linea vienen N enteros indicando el color que cada joven viste.",
        "salida": "Por cada caso de prueba imprimir un unico numero entero indicando la moda a la cual Wachin debe seguir. Si existen varias modas en empate, Wachin escogera la del color menos intenso. Por ejemplo si hay 5 jovenes con 1, 2, 3, 3, 2, hay 2 modas el 3 y el 2, pero Wachin escogera el 2.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Vectores"
        ],
        "estructuras": [
            "long long",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e=0;\n    vector<int> num(100000, 0);\n    cin>>a;\n    while(a){\n        a--;\n        cin>>b;\n        for(auto i=0; i<b; i++){\n            cin>>num[i];\n        }\n        sort(num.begin(), num.end());\n        c=1;\n        d=0;\n        for(auto i=1; i<b; i++){\n            if(num[i]==num[i-1]){\n                c++;\n            }\n            else{\n                if(c>d){\n                    d=c;\n                    e=num[i-1];\n                }\n                c=1;\n            }\n        }\n        if(c>d){\n            d=c;\n            e=num[b-1];\n        }\n        cout<<e<<\"\\n\";\n    }\n    \n    return 0;\n}\n"
    },
    {
        "titulo": "921. Wall·E",
        "url": "https://omegaup.com/arena/problem/WallE/",
        "descripcion": "Has sido llamado de último momento para unirte en el equipo para el nuevo concurso de robótica Wall-E 2014. El concurso de desarrolla sobre un terreno de 5x5 metros como el siguiente mapa: Tu robot siempre inicia en la misma posición (esquina inferior izquierda), con la misma orientación, tal como se indica en el mapa anterior. El objetivo del concurso, es recolectar la mayor cantidad de esferas verdes posible. El robot ya está casi acabado, es capaz de decidir por su propia cuenta, si va a avanzar o retroceder (exactamente 1 metro por cada instrucción), girar a la izquierda o a la derecha (sobre su propio eje). Además, siempre que está sobre una esfera, es capaz de recolectarla sin ningún problema. Tu tarea es, con base en las instrucciones que decida el robot, contar la cantidad de esferas que recolectó.",
        "entrada": "En la primera línea, un número N representando la cantidad de instrucciones que ejecutó el robot. En las siguientes N líneas, habrá un número (del 1 al 4) representando la instrucción que el robot ejecutó. 1. Avanzar, 2. Retroceder, 3. Girar a la Izquierda, 4. Girar a la Derecha. El número de instrucciones siempre será menor a 100. Solo hay una esfera en cada metro cuadrado del mapa, habiendo un total de 25 esferas en todo el mapa.",
        "salida": "Un sólo número, representando la cantidad de esferas que recolectó durante su trayecto. Pero si en algún momento el robot se sale del mapa, será descalificado y deberás imprimir el número 0.",
        "nivel": "",
        "categorias": [
            "Matrices"
        ],
        "estructuras": [
            "long long",
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c=5, d=1, e=1, f=1;\n    int num[7][7]={-1, -1, -1, -1, -1, -1, -1, \n        -1, 1, 1, 1, 1, 1, -1, \n        -1, 1, 1, 1, 1, 1, -1, \n        -1, 1, 1, 1, 1, 1, -1, \n        -1, 1, 1, 1, 1, 1, -1, \n        -1, 0, 1, 1, 1, 1, -1, \n        -1, -1, -1, 1, -1, -1, -1, \n    };\n    cin>>a;\n    while(a){\n        a--;\n        cin>>b;\n        if(b==4){\n            e++;\n            if(e==5){\n                e=1;\n            }\n        }\n        else if(b==3){\n            e--;\n            if(!e){\n                e=4;\n            }\n        }\n        else if(b==1){\n            if(e==1){\n                d++;\n            }\n            else if(e==2){\n                c++;\n            }\n            else if(e==3){\n                d--;\n            }\n            else{\n                c--;\n            }\n            if(num[c][d]==-1){\n                cout<<0; return 0;\n            }\n            f+=num[c][d];\n            num[c][d]=0;\n        }\n        else{\n            if(e==1){\n                d--;\n            }\n            else if(e==2){\n                c--;\n            }\n            else if(e==3){\n                d++;\n            }\n            else{\n                c++;\n            }\n            if(num[c][d]==-1){\n                cout<<0; return 0;\n            }\n            f+=num[c][d];\n            num[c][d]=0;\n        }\n    }\n    cout<<f;\n    \n    return 0;\n}\n"
    },
    {
        "titulo": "4618. ExamBidi4",
        "url": "https://omegaup.com/arena/problem/ExamBidi4/",
        "descripcion": "Realice un programa que pida un número n, que sea par, este número determinará el tamaño de un arreglo bidimensional cuadrado. Es decir con n renglones y n columnas. Todos los elementos se rellenan con 0. El arreglo se dividirá en dos partes en sentido horizontal y 2 partes en sentido vertical. Se rellenarán los cuadrantes de arriba ala derecha y de abajo a la izquierda con 1s.",
        "entrada": "Un entero n",
        "salida": "El contenido del arreglo, n renglones con n elementos cada uno.",
        "nivel": "",
        "categorias": [
            ""
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b;\n    cin>>a;\n    b=a/2;\n    for(auto i=1; i<=a; i++){\n        for(auto j=1; j<=a; j++){\n            if(i<=b && j<=b){\n                cout<<0;\n            }\n            else if(i>b && j>b){\n                cout<<0;\n            }\n            else{\n                cout<<1;\n            }\n        }\n        cout<<\"\\n\";\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "1295. Examen",
        "url": "https://omegaup.com/arena/problem/ChnExamen/",
        "descripcion": "Chando es un joven estudiante de Guanajuato. Y la próxima semana en su clase de programación tendrán un examen. Sin embargo, su profesor dijo que exentaría del examen a quien le entregara el siguiente problema correctamente: Dada una lista R formada por N números, escribir la suma de todos los números que pueden ser representados como la suma de números impares consecutivos desde uno. 16 puede ser reprensentado como 1 + 3 + 5 + 7. 32 no puede ser representado de esta forma pues 1 + 3 + 5 + 7 + 9 es menor que 32, y si agregamos el 11 a la lista la suma sería mayor. Ayuda a Chando a resolver el problema para así poder evitar el examen.",
        "entrada": "Un número N, seguido de N líneas con los valores de R_i. (N <= 10000), (R_i <= 10^12), Se asegura que la respuesta siempre será menor a (2^50).",
        "salida": "La suma de todos los elementos de R que cumplan con lo explicado arriba.",
        "nivel": "",
        "categorias": [
            ""
        ],
        "estructuras": [
            "long long",
            "sqrt()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d=0;\n    cin>>a;\n    while(a){\n        a--;\n        cin>>b;\n        c=sqrt(b);\n        if((c*c)==b){\n            d+=b;\n        }\n    }\n    cout<<d;\n    \n    return 0;\n}\n"
    },
    {
        "titulo": "6242. Existe Columna Nula",
        "url": "https://omegaup.com/arena/problem/Existe-Columna-Nula/",
        "descripcion": "Se ingresa un valor entero N (1<=N<=100), y a continuación N filas conteniendo cada una N valores enteros. Si existe alguna columna cuyos elementos son todos nulos (ceros), imprimir una línea con el mensaje \"Hay Columna Nula\", en otro caso, imprimir una línea con el mensaje \"No Hay Columna Nula\".",
        "entrada": "La primer línea de entrada contendrá el valor N. Luego vendrán N líneas con los (1<=N_i<=1000) elementos separados por un espacio.",
        "salida": "",
        "nivel": "",
        "categorias": [
            "Ordenamiento",
            "Vectores"
        ],
        "estructuras": [
            "long long",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    vector<int> num(1000, 0);\n    long long a, b;\n    cin>>a;\n    for(auto i=0; i<a; i++){\n        for(auto j=0; j<a; j++){\n            cin>>b;\n            num[j]+=b;\n        }\n    }\n    sort(num.begin(), num.end());\n    if(!num[0]){\n        cout<<\"Hay Columna Nula\";\n    }\n    else{\n        cout<<\"No Hay Columna Nula\";\n    }\n    \n    return 0;\n}\n"
    },
    {
        "titulo": "2673. Extraño Videojuego",
        "url": "https://omegaup.com/arena/problem/Extrano-Videojuego/",
        "descripcion": "En un rincón oscuro de tu sótano te encontraste un videojuego muy viejo. Las reglas son simples. El juego se desarrolla en una cuadrícula muy alta, con N casillas de ancho y tú controlas a una persona con una canasta de W casillas de ancho. De la nada, comienzan a caer manzanas del cielo y debes recoger todas en tu canasta. Para ello, puedes moverte a la derecha o la izquierda sin salirte del mapa. Este juego es muy lento, por lo que siempre atraparás las manzanas sin importar cuánto tiempo te tome colocar tu canasta debajo de ellas. Sin embargo, el puntaje depende de cuántas veces oprimas los botones para moverte a la derecha y la izquierda. Además, pierdes el juego si dejas caer alguna manzana al suelo. Calcula la menor cantidad de veces que debes oprimir los botones para atrapar todas las manzanas. Inicialmente la canasta está pegada hasta la izquierda de la cuadrícula (es decir, en la casilla 1).",
        "entrada": "En la primera línea N y W, el ancho de la cuadrícula y de la canasta, respectivamente. En la segunda línea, Q, la cantidad de manzanas que caerán. En las siguientes Q líneas, un entero denotando la columna por la que caerá cada manzana. La entrada va en el orden en el que caerán las manzanas, y nunca cae una manzana hasta que no hayas atrapado la anterior. (1<=W<N<=20), (1<=Q<=20).",
        "salida": "La menor cantidad de veces que debes oprimir los botones para ganar el juego.",
        "nivel": "",
        "categorias": [
            "Vectores"
        ],
        "estructuras": [
            "long long",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d=1, e, f, g, h=0;\n    vector<int> num(1000, 0);\n    cin>>a>>b>>c;\n    e=b;\n    while(c){\n        c--;\n        cin>>f;\n        if(f>=d && f<=e){\n            continue;\n        }\n        else if(f<d){\n            g=d-f;\n            h+=g;\n            d=f;\n            e-=g;\n        }\n        else{\n            g=f-e;\n            h+=g;\n            e=f;\n            d+=g;\n        }\n    }\n    cout<<h;\n    \n    return 0;\n}\n"
    },
    {
        "titulo": "6289. Felix Y Los Mangos",
        "url": "https://omegaup.com/arena/problem/Felix-Y-Los-Mangos/",
        "descripcion": "Félix está de visita en México y quiere llevar mangos de regreso a casa. Por esto, Félix quiere comprar N mangos en la tienda. Tiene que pagar k dólares por el primer mango, 2k dólares por el segundo, 3k dólares por el tercero y así sucesivamente (en otras palabras, tiene que pagar i*k dólares por el i-ésimo mango). Él tiene D dólares. ¿Cuántos dólares tiene que pedir prestado a su amigo Pedro para comprar N Mangos?",
        "entrada": "Una línea con tres enteros positivos: K (El precio del primer mango), D (la cantidad de dinero que tiene Félix), N (la cantidad de mangos que Félix desea comprar). Ten en cuenta que la respuesta puede no caber en un entero normal, por lo que deberías de considerar usar algo más grande, como un long long int. Se asegura que la respuesta siempre cabra dentro de un long long int. (1 <= N, K <= 10^8), (0 <= D <= 10^17). Para el 40% de los casos los límites serán mas pequeños, por lo que si no se te ocurre una solución por los 100 puntos, tal vez puedas idear una solución por 40 puntos. Limites (40 puntos): (1<= N, K<= 1000), (0<=D <=10^9).",
        "salida": "Imprime un entero: la cantidad de Dólares que Félix debe pedir prestado a su amigo para poder comprar los mangos. Si no tiene que pedir dinero prestado, imprime como resultado 0.",
        "nivel": "",
        "categorias": [
            ""
        ],
        "estructuras": [
            "unsigned long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    unsigned long long a, b, c, d;\n    cin>>a>>b>>c;\n    d=((c+1)*c)/2;\n    d*=a;\n    if(b>=d){\n        cout<<0;\n    }\n    else{\n        cout<<d-b;\n    }\n    \n    return 0;\n}\n\n"
    },
    {
        "titulo": "5620. Fracciones de Mixta a Impropia",
        "url": "https://omegaup.com/arena/problem/Fracciones-de-Mixta-a-Impropia/",
        "descripcion": "Dado tres números A siendo el número entero, B siendo el numerador y C el denominador, convertir la fracción de mixta a impropia. 13 5/7 = 96/7. Dato La fracción mixta se convierte en impropia, multiplicando el entero por el denominador y sumando el numerador. Y el denominador sigue siendo el mismo.",
        "entrada": "Tres números enteros A, B y C separados por un espacio.",
        "salida": "Dos números enteros D el numerador y E el denominador. D y E están separados por \"/\".",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Aritmética",
            "Múltiplos y divisores comunes"
        ],
        "estructuras": [
            "long long",
            "int"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int num[25]={2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n    long long a, b, c, d=0;\n    cin>>a>>b>>c;\n    b+=(a*c);\n    while(b>=num[d] && c>=num[d]){\n        while(b%num[d]==0 && c%num[d]==0){\n            b/=num[d];\n            c/=num[d];\n        }\n        d++;\n    }\n    cout<<b<<\"/\"<<c;\n    \n    return 0;\n}\n"
    },
    {
        "titulo": "193. L-OMI98-El explorador",
        "url": "https://omegaup.com/arena/problem/OIEG2013SSC/",
        "descripcion": "Un explorador tiene que decidir donde construir un camino para llegar de un punto A a un punto B. Para auxiliarse el explorador ha hecho un mapa con los obstáculos que existen. Cuadriculó su mapa y quiere un camino que pase por el menor número de cuadros. El camino sólo puede ir de un cuadro a otro si tienen un lado en común, es decir, no puede avanzar en diagonal, y no puede pasar por un cuadro que contenga un obstáculo. Cada cuadro del mapa se identifica por sus coordenadas, primero la fila y después la columna. Las filas están numeradas de arriba hacia abajo iniciando con el 0. Las columnas están numeradas de izquierda a derecha iniciando con el 0. El objetivo de la construcción del camino es encontrar el menor número de cuadros por los que debe pasar un camino que vaya del punto A al punto B, incluyendo a los cuadros que contienen a A y a B.",
        "entrada": "En la primera línea los enteros N y M, el número de filas y columnas del mapa. En cada una de las siguientes N líneas hay M números que pueden ser 0 ó 1, 0  si no hay obstáculo en el cuadro correspondiente y 1 si lo hay. En la siguiente línea (la penúltima), la fila (A_f) y columna (A_c) del punto A. En la última línea, la fila (B_f) y columna (B_f) del punto B.",
        "salida": "Una única línea con el número de cuadros por los que pasa un camino mínimo entre A y B.",
        "nivel": "Intermedio (medio) - Análisis y diseño de algoritmos",
        "categorias": [
            "Búsqueda en amplitud",
            "Búsqueda en profundidad",
            "Colas",
            "Matrices"
        ],
        "estructuras": [
            "long long",
            "vector<vector<int>>",
            "queue<>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct sobra{\n    int aa, bb, cc;\n};\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d;\n    vector<vector<int>> num(51, vector<int> (51, 0));\n    queue<sobra> falta;\n    sobra z;\n    cin>>a>>b;\n    for(auto i=0; i<a; i++){\n        for(auto j=0; j<b; j++){\n            cin>>num[i][j];\n        }\n    }\n    cin>>z.aa>>z.bb;\n    z.cc=1;\n    falta.push(z);\n    num[z.aa][z.bb]=2;\n    cin>>c>>d;\n    num[c][d]=3;\n    while(true){\n        z=falta.front();\n        falta.pop();\n        z.cc++;\n        if(z.aa+1<a && num[z.aa+1][z.bb]==0){\n            z.aa++;\n            falta.push(z);\n            num[z.aa][z.bb]=2;\n            z.aa--;\n        }\n        else if(z.aa+1<a && num[z.aa+1][z.bb]==3){\n            cout<<z.cc;return 0;\n        }\n        if(z.bb+1<b && num[z.aa][z.bb+1]==0){\n            z.bb++;\n            falta.push(z);\n            num[z.aa][z.bb]=2;\n            z.bb--;\n        }\n        else if(z.bb+1<b && num[z.aa][z.bb+1]==3){\n            cout<<z.cc;return 0;\n        }\n        if(z.aa-1>-1 && num[z.aa-1][z.bb]==0){\n            z.aa--;\n            falta.push(z);\n            num[z.aa][z.bb]=2;\n            z.aa++;\n        }\n        else if(z.aa-1>-1 && num[z.aa-1][z.bb]==3){\n            cout<<z.cc;return 0;\n        }\n        if(z.bb-1>-1 && num[z.aa][z.bb-1]==0){\n            z.bb--;\n            falta.push(z);\n            num[z.aa][z.bb]=2;\n            z.bb++;\n        }\n        else if(z.bb-1>-1 && num[z.aa][z.bb-1]==3){\n            cout<<z.cc;return 0;\n        }\n    }\n    \n    return 0;\n}\n"
    },
    {
        "titulo": "5303. Ayudante de cocina",
        "url": "https://omegaup.com/arena/problem/Ayudante-de-cocina/",
        "descripcion": "Después de mucho de mucho tiempo Ángel se dio cuenta de que su verdadera pasión era la cocina por lo que abrió un restaurante. Pero como el no se puede encargar de todo solo contrato a Isaías como su ayudante. Un día Ángel se enfermo y dejo solo a Isaías a cargo del restaurante, pero como solo es un ayudante no sabe cocinar y solo puede calentar los N platillos que Ángel le dejo el día anterior. Cada platillo tiene un valor a_i. Ese día llegaron M clientes al restaurante cada uno con un hambre b_i que no puede ser saciada a menos que le sirvan un platillo a_j  tal que (a_j => b_i), por lo que pagara a_i pesos (el precio del platillo). Si no le sirven nada o el platillo no lo satisface, no pagara nada. Como Isaías quiere impresionar a su jefe Ángel para que ya le enseñe a cocinar, quiere obtener la mayor ganancia posible, pero como Isaías esta muy ocupado calentando los platillos, necesita tu ayuda para que le digas cual es la máxima ganancia que puede obtener.",
        "entrada": "En la primer linea: Dos enteros N y M, representando el numero de platillos y clientes respectivamente. En la segunda linea: N números enteros representando el valor de cada platillo. En la tercer linea: M números enteros representando el hambre de cada cliente. (1 <= N, M <= 10^6), (1 <= a_i, b_i <= 10^6).",
        "salida": "Un único entero representando el valor de la ganancia máxima que Isaías puede obtener.",
        "nivel": "",
        "categorias": [
            "Vectores",
            "Ordenamiento"
        ],
        "estructuras": [
            "long long",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, e=0;\n    vector<int> falta;\n    vector<int> num;\n    cin>>a>>b;\n    while(a){\n        a--;\n        cin>>c;\n        falta.push_back(c);\n    }\n    while(b){\n        b--;\n        cin>>c;\n        num.push_back(c);\n    }\n    sort(falta.begin(), falta.end());\n    sort(num.begin(), num.end());\n    vector<int>::iterator it=falta.end()-1; \n    vector<int>::iterator jt=num.end()-1;\n    while(it>=falta.begin()){\n        if(*it>=*jt){\n            e+=*it;\n            it--;\n            if(jt==num.begin()){\n                cout<<e;return 0;\n            }\n            jt--;\n        }\n        else{\n            if(jt==num.begin()){\n                cout<<e;return 0;\n            }\n            jt--;\n        }\n    }\n    cout<<e;\n    \n    return 0;\n}"
    },
    {
        "titulo": "455. CR Angry Birds",
        "url": "https://omegaup.com/arena/problem/CR-Angry-Birds/",
        "descripcion": "Juan Memo está jugando Angry Birds. En cada nivel puede ganar de 0 a 3 estrellas. Como juega mucho se hartó de contar cuántas estrellas ha ganado, así que te pidió que contaras por él. El número de estrellas que Juan Memo ganó en cada nivel está representado como una cadena. \"---\" si consiguió 0, \"o--\" si consiguió 1, \"oo-\" si consiguió 2, y \"ooo\" si consiguió 3.",
        "entrada": "Varias líneas, representando cuantas estrellas ganó Juan Memo en cada nivel.",
        "salida": "El total de estrellas que ganó Juan Memo a lo largo de la partida.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Loops",
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "long long",
            "string"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a=0;\n    string z;\n    while(cin>>z){\n        for(auto i=0; i<3; i++){\n            if(z[i]=='o'){\n                a++;\n            }\n        }\n    }\n    cout<<a;\n    \n    return 0;\n}\n"
    },
    {
        "titulo": "2370. El cactus más alto en el horizonte",
        "url": "https://omegaup.com/arena/problem/cactus_horizonte/",
        "descripcion": "Mientras John Carter huía de los indios, él observó varios cactus en el horizonte. Además de correr por su vida no tenía nada mejor que hacer, así que se aprendió las alturas de los cactus. Posteriormente, en la seguridad de una cueva, se hizo varias preguntas como ¿cuál es la altura del cactus más alto en el horizonte? ¿cuál es la altura del tercer cactus más alto en el horizonte? Ayuda a John Carter a salir de la duda.",
        "entrada": "Un entero N seguido de las N alturas H_1, ...,H_N de los cactus en el horizonte. Posteriormente un entero P seguido de las P preguntas Q_1, ..., Q_P, donde la pregunta Q_J se lee ¿cuál es la altura del Q_J cactus más alto en el horizonte? Puedes suponer que 1 ≤ N, P ≤ 1,000,000, que 1 ≤ H_1 ≤ 1,000,000,000, que 1 ≤ Q_J ≤ N y que las alturas de todos los cactus son distintas.",
        "salida": "Salida: Las P alturas que responden a las preguntas dadas.",
        "nivel": "Intermedio (medio) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Arreglos",
            "Ordenamiento",
            "Vectores"
        ],
        "estructuras": [
            "vector<int>",
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    vector<int> num;\n    long long a, b;\n    cin>>a;\n    while(a){\n        a--;\n        cin>>b;\n        num.push_back(b);\n    }\n    sort(num.begin(), num.end());\n    vector<int>::iterator it=num.end();\n    cin>>a;\n    while(a){\n        a--;\n        cin>>b;\n        it=num.end()-b;\n        cout<<*it<<\" \";\n    }\n    \n    return 0;\n}\n"
    },
    {
        "titulo": "3252. El viaje de Grazni",
        "url": "https://omegaup.com/arena/problem/El-viaje-de-Grazni/",
        "descripcion": "El pato Grazni va a realizar un viaje de Puebla a Monterrey. Para realizarlo tiene la opción de irse por n caminos diferentes, cada uno de los caminos pasa por m ciudades diferentes, cada una de estas cuenta con una caseta de cobro con un costo de c_i, (número entero) que el pato deberá cruzar para continuar su camino. El pato Grazni quiere saber cuál de los n caminos es el más barato. Ayúdale a encontrarlo.",
        "entrada": "En la primera linea encontraras los números n y m separados por un espacio. En las siguientes n lineas encontraras m números: {c_1, c_2, ... c_m} que son el costo de cada una de las casetas, para cada una de las ciudades. (1<=n<=700), (1<=m<=700), (0<=c_i<=3,000,000).",
        "salida": "En la linea de salida deberás imprimir el numero de camino que minimiza sus gastos y el costo de este.",
        "nivel": "",
        "categorias": [
            "Matrices"
        ],
        "estructuras": [
            "vector<vector<int>>",
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    vector<vector<int>> num(701, vector<int> (701, 0));\n    long long a, b, c, d=0, e;\n    cin>>a>>b;\n    for(auto i=0; i<b; i++){\n        cin>>num[0][i];\n        d+=num[0][i];\n    }\n    for(auto i=1; i<a; i++){\n        c=0;\n        for(auto j=0; j<b; j++){\n            cin>>num[i][j];\n            c+=num[i][j];\n        }\n        if(c<d){\n            d=c;\n            e=i+1;\n        }\n    }\n    cout<<e<<\" \"<<d;\n    \n    return 0;\n}\n"
    },
    {
        "titulo": "6119. Troyo el cometriángulos",
        "url": "https://omegaup.com/arena/problem/COMI-Troyo/",
        "descripcion": "Troyo el cometriángulos está hambriento! El requiere de tus asosmbrosas habilidades como programador, para alimentarlo. El tiene infinitos triángulos, pero solo quiere comerse uno de ellos, el triángulo N. Los triángulos de Troyo son algo especial, el triángulo k tiene exactamente k puntos en cada uno de sus tres lados, y sus triángulos están ordenados de acuerdo a cuantos puntos tienen sus lados. Tu sabes que Troyo tiene en su colección todos los triángulos con una cantidad de puntos entre 1 y n. Ve el ejemplo para que te quede más claro. Tu tarea es decirle a Troyo cuantos puntos tiene el n-ésimo triángulo.",
        "entrada": "La primera y única linea de entrada consiste unicamente de un entero n. (1<=n<=10^8).",
        "salida": "En la primera y única linea deberás imprimir la cantidad de puntos que tiene el n-ésimo triángulo.",
        "nivel": "",
        "categorias": [
            ""
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b;\n    cin>>a;\n    b=(a*(a+1))/2;\n    cout<<b;\n    \n    return 0;\n}\n"
    },
    {
        "titulo": "6150. Jugando con Congruencias",
        "url": "https://omegaup.com/arena/problem/COMI-Congruencias/",
        "descripcion": "Por muchos años, a los matemáticos les ha gustado divertirse con lo que se conoce como Congruencias. Pero, ¿qué son las congruencias?. Primeramente lucen de esta manera: A = B mod C. La anterior expresión se lee cómo A es congruente con B, módulo C. Ahora, para que entiendas mejor el concepto de congruencias, te lo explicaremos mediante un pequeño experimento que utiliza la operación normal de módulo que conoces. Imagina que calculamos mod(5) para TODOS los números enteros. Supongamos que rebanamos un circulo en 5 partes y las etiquetamos como 0, 1, 2, 3 y 4. Entonces para cada uno de los enteros a los que se le aplicó la operación mod(5), los pondremos dentro de la rebanada con la cual corresponda. Piensa que estas rebanadas son como contenedores los cuales van a guardar conjuntos de números. Por ejemplo, el número 26 iría en la rebanada marcada con 1, porque 26 mod 5 = 1. Ahora bien, ¿acaso no sería muy útil tener una manera de expresar los números que pertenecen a una misma rebanada?. Por ejemplo, el número 26 está en la misma rebanada que los números 1, 6, 11, 16, 21, .... La forma más común de decir que dos números pertencen a la misma rebanada, es decir, que ellos están en la misma clase de equivalencia. Y, ¿cuál crees que sea la forma en la que se expresa esto matemáticamente?... ¡Exacto! Se expresa como A = B mod C. Si hacemos la analogía con el ejemplo del número 26 y 11, quedaría expresado como 26 = 11 mod 5. Ahora bien, en este problema se te pide algo sencillo. Tomando en cuenta la simbología A = B mod C, se te proporcionará los valores de B y C, y posteriormente se te darán N valores los cuales tendrás que analizar y decir, cuántos de ellos pertenecen a la misma rebanada, es decir, a la misma clase de equivalencia.",
        "entrada": "En la primera línea recibirás 2 números que representarán a B y C respectivamente. Como este es uno de nuestros primeros acercamientos a las congruencias, los valores de estas variables siempre serán positivas. En la segunda línea recibirás el valor de N, y en las siguientes N líneas recibirás 1 número por línea (llamemos a estos números n_i). (2 <= C <= 100), (1 <= B <= 1,000), (1 <= N <= 1,000,000), (1 <= n_i <= 10,000).",
        "salida": "Un entero que represente cuántos de los números n_i pertenecen a la misma clase de equivalencia.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Aritmética",
            "Condicionales",
            "Loops"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e=0;\n    cin>>a>>b>>c;\n    a%=b;\n    while(c){\n        c--;\n        cin>>d;\n        d%=b;\n        if(d==a){\n            e++;\n        }\n    }\n    cout<<e;\n    \n    return 0;\n}\n\n"
    },
    {
        "titulo": "6124. Simplificar Fracciones",
        "url": "https://omegaup.com/arena/problem/COMI-Simplificar-Fracciones/",
        "descripcion": "Uno de los problemas con el que todos nos enfrentamos en algún momento de la vida, es el de simplificar una fracción. En la escuela nos enseñaron diversos métodos para ello, sin embargo, el más usado está basado en la obtención del Maximo Común Divisor (MCD). La regla para realizar lo anterior se enuncia a continuación. Regla Para reducir una fracción cualquiera a/b, sólo se necesita dividir a y b entre su máximo común divisor (MCD). Está muy fácil la regla, ¿no?. Entonces ahora te preguntarás, ¿cómo cáculo el MCD?. No te asustes, eso es muy fácil. El MCD se puede calcular fácilmente mediante lo que se conoce como el Algoritmo de Euclides, el cual nos dice lo siguiente: Se tienen dos números a y b. El MCD se obtiene cómo sigue. Paso 1: Se divide el número mayor entre el menor. Paso 2: Si, 1.- La división es exacta, el divisor es el m.c.d. 2.- La división no es exacta, dividimos el divisor entre el resto obtenido y se continúa de esta forma hasta obtener una división exacta, siendo el último divisor el m.c.d. En este problema se te darán N fracciones las cuales tendrás que simplificar utilizando lo anteriormente mencionado.",
        "entrada": "En la primera línea recibirás un número N el cual representa el número de líneas que recibirás posteriormente. En las siguientes N líneas recibirás dos números por línea, a y b, dónde a será el denominador y b el denominador de la fracción. (1 <= N <= 100000), (1 <= a, b <= 2^63).",
        "salida": "Tu salida deberán de ser N líneas que representarán las fracciones simplificadas de la entrada. Es importante destacar que las N líneas que escribas en la salida, deberán de estar en el mismo orden en que se puso en la entrada, sino se considerará como fallida la salida. Además, también las tendrás que poner por parejas de números, donde el primer número será el numerador y el segundo el denominador.",
        "nivel": "Intermedio (fácil) - Matemáticas en la programación",
        "categorias": [
            "Aritmética",
            "Loops",
            "Múltiplos y divisores comunes"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d;\n    cin>>a;\n    while(a--){\n        cin>>b>>c;\n        d=__gcd(b, c);\n        b/=d;\n        c/=d;\n        cout<<b<<\" \"<<c<<\"\\n\";\n    }\n    \n    return 0;\n}\n\n"
    },
    {
        "titulo": "6152. Variacion con repeticion",
        "url": "https://omegaup.com/arena/problem/COMI-Variaciones/",
        "descripcion": "Teorema variación con repetición. El número de variaciones de un conjunto de n elementos es n^k. Hay n formas de seleccionar un elemento del conjunto para cada una de las k posiciones, ya que para cada posición están disponibles los n elementos, según la regla del producto n^k. Supongamos que una tarea se puede dividir en dos subtareas consecutivas. Si hay n_1 formas de realizar la primera y n_2 formas de hacer la segunda subtarea después de que la primera haya sido realizada, entonces hay (n_1)(n_2) formas de completar la tarea. Se desea la j-ésima cadena lexicográficamente menor con k letras utilizando solo las primeras n letras del abecedario.",
        "entrada": "Una sola línea con tres enteros n, k y j. (1 <= n <= 10), (1 <= k <= 18), (1 <= j <= n^k).",
        "salida": "La j-ésima cadena lexicográficamente menor.",
        "nivel": "",
        "categorias": [
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "long long",
            "char",
            "pow()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e;\n    char n=97;\n    cin>>a>>b>>c;\n    c--;\n    b--;\n    d=pow(a, b);\n    while(b>-1){\n        e=c/d;\n        n=n+e;\n        cout<<n;\n        n=97;\n        c%=d;\n        b--;\n        d=pow(a, b);\n    }\n    \n    return 0;\n}\n"
    },
    {
        "titulo": "1331. Lada",
        "url": "https://omegaup.com/arena/problem/lada/",
        "descripcion": "Lee un número entero que es la Lada de Larga Distancia usada en el marcaje telefónico. Después despliega a la salida estándar, el destino de acuerdo a la siguiente tabla: (61: Brasilia), (71: Salvador), (11: Sao Paulo), (21: Rio de Janeiro), (32: Juiz de Fora), (19: Campinas), (27: Vitoria), (31: Belo Horizonte). Si el número de entrada de la lada telefónica no se encuentra en la tabla de arriba, la salida deberá ser \"LD no encontrada\" (sin las comillas).",
        "entrada": "La entrada consiste en un único número entero.",
        "salida": "Despliega el nombre de la ciudad que corresponda a la entrada como LD (Larga Distancia); si el código de LD no existe, despliega \"LD no encontrada\" (sin las comillas).",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Condicionales"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a;\n    cin>>a;\n    if(a==61){\n        cout<<\"Brasilia\";\n    }\n    else if(a==71){\n        cout<<\"Salvador\";\n    }\n    else if(a==11){\n        cout<<\"Sao Paulo\";\n    }\n    else if(a==21){\n        cout<<\"Rio de Janeiro\";\n    }\n    else if(a==32){\n        cout<<\"Juiz de Fora\";\n    }\n    else if(a==19){\n        cout<<\"Campinas\";\n    }\n    else if(a==27){\n        cout<<\"Vitoria\";\n    }\n    else if(a==31){\n        cout<<\"Belo Horizonte\";\n    }\n    else{\n        cout<<\"LD no encontrada\";\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "7952. Progresión Aritmética",
        "url": "https://omegaup.com/arena/problem/Progresion-Aritmetica-/",
        "descripcion": "Cuando hablamos sobre la progresión aritmética (o secuencia aritmética) nos referimos a una serie de números con una propiedad especial - cada valor es seguido por otro que es mayor por una cantidad predefinida (incremento), ej.: la diferencia del (K+1)-ésimo and K-ésimo valor es una constante. A continuación, ejemplos de tales secuencias: 1 2 3 4 5 6 7 ... 4 6 8 10 12 14 16... 10 13 16 19 22 25 28... Dado que la secuencia aritmética puede ser completamente definida por el primer término (A) y el valor del incremento - (B), sus primeros términos pueden ser expresados como: A + (A + B) + (A + 2B) + (A + 3B) + ... Vas a calcular la suma de los primeros miembros de la secuencia aritmética.",
        "entrada": "Contienen los casos de prueba en forma de tríos de valores A B N donde A es el primer valor de la secuencia, B es el tamaño del incremento y N es el número de términos que deberían ser calculados. N, A y B > 0 y <= 10000.",
        "salida": "Muestra los resultados (la suma de N términos) de cada secuencia.",
        "nivel": "",
        "categorias": [
            ""
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d;\n    cin>>a>>b>>c;\n    d=a*c;\n    c=(c*(c-1))/2;\n    c*=b;\n    d+=c;\n    cout<<d;\n    \n    return 0;\n}"
    },
    {
        "titulo": "5478. Baby Groot",
        "url": "https://omegaup.com/arena/problem/Baby-Groot/",
        "descripcion": "Guardianes de la galaxia Volumen 2 ha desvelado el misterio acerca del padre de StarLord. Resultó ser un planeta viviente llamado EGO de la raza de los celestiales, creadores y destructores de universos. Ego planea acabar con toda la vida en la galaxia para que solo exista él, tras descubrir los planes de EGO, los guardianes han decidido detenerlo plantando una bomba en el núcleo del planeta, por supuesto, no será nada fácil. Rocket perforó un túnel hasta el núcleo del planeta y construyó la bomba con un dispositivo que la activa, desafortunadamente, el túnel es tan pequeño que solo Baby Groot cabe. Rocket ha puesto en el dispositivo un conjunto de botones de diferentes colores, cada botón activa una cuenta regresiva a excepción de un botón, el botón de la destrucción que hace que la bomba explote al presionarlo. Rocket ha repetido muchas veces a Baby Groot que el botón de la destrucción es el último en el dispositivo y no debe presionarlo !Don't push the button¡ sin embargo, baby groot parece no comprender. Dada la distribución de los botones en el dispositivo y el botón que Baby Groot presionó, determina si todos en la galaxia morimos o nos salvamos.",
        "entrada": "En la primera línea los enteros N y K, donde N es el número de botones en el dispositivo y K el botón que Baby Groot presionó. En la segunda línea, N enteros separados por un espacio donde cada número representa el color de un botón. CONSIDERA QUE EL COLOR DE CADA BOTÓN ES ÚNICO, es decir los números (colores) de los botones no se repiten.",
        "salida": "Imprime el mensaje \"TODOS VAMOS A MORIR\" si el botón que presionó BG es el último en la entrada, \"SALVADOS\" si no es así.",
        "nivel": "",
        "categorias": [
            ""
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c;\n    cin>>a>>b;\n    while(a--){\n        cin>>c;\n    }\n    if(b==c){\n        cout<<\"TODOS VAMOS A MORIR\";\n    }\n    else{\n        cout<<\"SALVADOS\";\n    }\n    \n    return 0;\n}\n"
    },
    {
        "titulo": "657. Árbol de navidad",
        "url": "https://omegaup.com/arena/problem/arbol_de_navidad/",
        "descripcion": "Dibuja, con asteriscos * y símbolos de gato # un árbol de Navidad como el de los ejemplos. No escribas más espacios de los estrictamente necesarios.",
        "entrada": "Un número N entre 3 y 25, indicando la altura del árbol.",
        "salida": "Escribe N + 2 líneas con el árbol resultante.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Loops",
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d=-1, e;\n    cin>>a;\n    b=a-2;\n    for(auto i=a-1; i>-1; i--){\n        c=i;\n        while(c--){\n            cout<<\" \";\n        }\n        d+=2;\n        e=d;\n        while(e--){\n            cout<<\"*\";\n        }\n        cout<<\"\\n\";\n    }\n    c=b;\n    while(c--){\n        cout<<\" \";\n    }\n    cout<<\"###\\n\";\n    while(b--){\n        cout<<\" \";\n    }\n    cout<<\"###\\n\";\n    \n    return 0;\n}"
    },
    {
        "titulo": "1351. Sobre ruedas",
        "url": "https://omegaup.com/arena/problem/sobre_ruedas/",
        "descripcion": "Boudreaux y Thibodeaux están de nuevo en carretera... -Boudreaux, tenemos que llevar este cargamento de insectos a Baton Rouge antes de que anochezca -No te preocupes Thibodeaux, ya me cercioré de todo. Hay tres puentes adelante y nuestro camión de 18 ruedas tendrá que pasar debajo de ellos, sólo manten el acelerador a fondo -No la vamos a hacer, le dije. Así es esto, habrá un pequeño accidente en la Interestatal 10, o es que a Thibodeaux, el sonido de las ruedas, le han vuelto loco?",
        "entrada": "Una sólo línea que contiene 3 números separados por un espacio. Cada uno representa la altura en pulgadas de cada uno de los puentes. Cada número estará entre 0 y 300, inclusive.",
        "salida": "Habrá una sólo línea de salida. Con NO CRASH, si la altura del camión de 18 ruedas es menor a la altura de todos los puentes, o: CRASH X, en caso contrario, donde X es la altura del primer puente en que el camión de 18 ruedas no le es posible pasar por debajo (lo que significa, que la altura del puentes es menor o igual a la altura del camión de 18 ruedas). La altura del camión de 18 ruedas es de 168 pulgadas.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Condicionales"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c;\n    cin>>a>>b>>c;\n    if(a>168 && b>168 && c>168){\n        cout<<\"NO CRASH\";\n    }\n    else if(a<169){\n        cout<<\"CRASH \"<<a;\n    }\n    else if(b<169){\n        cout<<\"CRASH \"<<b;\n    }\n    else{\n        cout<<\"CRASH \"<<c;\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "4744. Caja mágica",
        "url": "https://omegaup.com/arena/problem/caja_magica/",
        "descripcion": "Vlasta la Sabia del reino del más allá, recibió una caja mágica con un secreto como un regalo de su amiga Haya la Sabia del reino de un poco más acá. Sin embargo, Vlasta la Sabia no sabe cuál es el secreto de la caja mágica, no la ha podido abrir. Ella tiene la esperanza de que la ayudes. La cerradura de la caja se ve como algo así: contiene 4 huecos para colocar piedras preciosas formando un cuadrado de 2 x 2, y algunos números enteros están escritos en el borde de los huecos. La siguiente imagen te dará un panorama de como está la cerradura. La caja viene acompañada de 9 piedras preciosas. Sus formas corresponden a los huecos y cada piedra contiene un número del 1 al 9 (cada número está escrito sólamente en una piedra preciosa). La caja se abrirá sólo después de que sean colocadas las piedras preciosas correctamente; es decir, en cada hueco debería haber exactamente una piedra. También la suma de los números de los renglones del cuadrado, columnas y diagonales deberán corresponder con los números escritos en los bordes de los huecos. Por ejemplo, la cerradura mostrada en la figura de arriba, se abrirá si colocamos las piedras en los huecos con los números como se muestran en la figura de abajo. Vlasta la Sabia quiere saber, dados los números de la cerradura de la caja, como colocar las piedras preciosas para que la abran. Ayuda a Vlasta a resolver esta difícil tarea. Fíjate en el último caso del problema. Es imposible abrir la caja porque Vlasta la Sabia necesitará 4 piedras preciosas idénticas que tengan el número \"5\". Sin embargo, Vlasta sólo tiene una piedra preciosa con cada uno de los números del 1 al 9. Como los casos son únicos, al no existir solución, están agrupados.",
        "entrada": "La entrada contiene los números escritos en los bordes de la cerradura de la caja. La primer línea contiene los números enteros, separados con un espacio, r_1 y r_2 que son las sumas de los números en los renglones del cuadrado. La segunda línea contiene los números enteros, separados con un espacio, c_1 y c_2 que son las sumas de los números en las columnas del cuadrado. La tercer línea contiene los números enteros separados con un espacio, d_1 y d_2, que son la suma de los números de la diagonal principal y lateral del cuadrado (1<= r_1, r_2, c_1, c_2, d_1, d_2 <= 20). La correspondencia entre las 6 variables anteriores y los lugares donde están escritas se muestra en la imagen de abajo. Para más aclaraciones por favor observa el segundo caso que muestra el ejemplo dado en la descripción del problema.",
        "salida": "Muestra la forma en que deberán estar acomodadas las piedras en la caja: dos líneas que contengan dos enteros del 1 al 9, separados por un espacio. Los números deberán ser diferentes entre sí. Si no hay una solución para abrir la cerradura, entonces despliega un sólo número \"-1\" (sin las comillas). Si hay muchas salidas, muestra cualquier salida válida.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Loops"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e, f, g, h, l, m, n;\n    cin>>a>>b>>c>>d>>e>>f;\n    g=min(a, c);\n    g=min(g, e);\n    g--;\n    if(a>17 || b>17 || c>17 || d>17 || e>17 || f>17 || a<3 || b<3 || c<3 || d<3 || e<3 || f<3){\n        cout<<\"-1\"; return 0;\n    }\n    h=a-g;\n    l=c-g;\n    m=e-g;\n    n=l+m;\n    if(b!=n){\n        if(b%2!=n%2){\n            cout<<\"-1\"; return 0;\n        }\n        if(n<b){\n            while(n<b){\n                l++;\n                g--;\n                h++;\n                m++;\n                if(!g || l==10 || h==10 || m==10){\n                    cout<<\"-1\"; return 0;\n                }\n                n=l+m;\n            }\n        }\n        else if(n>b){\n            while(n>b){\n                l--;\n                g++;\n                h--;\n                m--;\n                if(g==10 || !l || !h || !m){\n                    cout<<\"-1\"; return 0;\n                }\n                n=l+m;\n            }\n        }\n    }\n    n=h+m;\n    if(d!=n){\n        if(d%2!=n%2){\n            cout<<\"-1\"; return 0;\n        }\n        if(n<d){\n            while(n<d){\n                l++;\n                g--;\n                h++;\n                m++;\n                if(!g || l==10 || h==10 || m==10){\n                    cout<<\"-1\"; return 0;\n                }\n                n=h+m;\n            }\n        }\n        else if(n>d){\n            while(n>d){\n                l--;\n                g++;\n                h--;\n                m--;\n                if(g==10 || !l || !h || !m){\n                    cout<<\"-1\"; return 0;\n                }\n                n=h+m;\n            }\n        }\n    }\n    if(g!=h && g!=l && g!=m && h!=l && h!=m && l!=m){\n        cout<<g<<\" \"<<h<<\"\\n\"<<l<<\" \"<<m;\n    }\n    else{\n        cout<<\"-1\"; return 0;\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "2863. Detención",
        "url": "https://omegaup.com/arena/problem/Detencion/",
        "descripcion": "Pepito quiere saber cuanto minutos pasa en detención. Como no es muy aplicado en matemáticas no ha podido calcularlo. Solo tiene como datos la hora exacta de entrada y salida. Ayúdale escribiendo un programa que haga el cálculo.",
        "entrada": "En la primera los enteros hi, mi separados por un espacio que denotan la hora de inicio. En la segunda línea y separados por espacios, los enteros hf, mf que denotan la hora y minuto de salida. Considera que el formato de hora es militar, es de decir, de 0 a 23.",
        "salida": "Un entero que denota cuantos minutos estuvo Pepito en detención.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Aritmética"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c, d, e, f, g, h;\n    cin>>a>>b>>c>>d;\n    if(c==a){\n        if(d==b){\n            cout<<\"0\"; return 0;\n        }\n        if(d>b){\n            e=d-b;\n            cout<<e; return 0;\n        }\n        e=60*24;\n        f=b-d;\n        e-=f;\n        cout<<e; return 0;\n    }\n    else if(c>a){\n        g=c-a;\n        g*=60;\n        if(d==b){\n            cout<<g; return 0;\n        }\n        if(d>b){\n            e=d-b;\n            g+=e;\n            cout<<g; return 0;\n        }\n        f=b-d;\n        g-=f;\n        cout<<g; return 0;\n    }\n    else{\n        h=a-c;\n        g=60*24;\n        h*=60;\n        g-=h;\n        if(d==b){\n            cout<<g; return 0;\n        }\n        if(d>b){\n            f=d-b;\n            g+=f;\n            cout<<g; return 0;\n        }\n        f=b-d;\n        g-=f;\n        cout<<g; return 0;\n    }\n\n    return 0;\n}\n"
    },
    {
        "titulo": "6270. Conversión de temperaturas",
        "url": "https://omegaup.com/arena/problem/Conversion-temperaturas/",
        "descripcion": "A pesar de que México utiliza el sistema internacional de unidades (SI), así como los símbolos internacionales de ese sistema, seguimos indicando la temperatura en grados centígrados (°C). Además de los Kelvin (K), en algunas partes del mundo se indica la temperatura en grados Fahrenheit (°F) o en grados Réaumur (°R). Como existen fórmulas de conversión para todos estos tipos de grados, si sabemos la temperatura C en grados centígrados, entonces podemos calcular la temperatura aproximada K en Kelvin, F en grados Fahrenheit y R en grados Réaumur. Por ejemplo, si la temperatura es de 0°C, entonces es aproximadamente de 273K, 32°F y 0°R (con los decimales truncados).",
        "entrada": "Consiste de un número entero C que tendrá un valor entre -273 y 1000.",
        "salida": "Consiste de tres números enteros, K, F, R, separados por espacios. ",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Aritmética"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b;\n    cin>>a;\n    b=273+a;\n    cout<<b<<\" \";\n    b=(a*1.8)+32;\n    cout<<b<<\" \";\n    b=a*.8;\n    cout<<b;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "2989. PostesDF",
        "url": "https://omegaup.com/arena/problem/PostesDF/",
        "descripcion": "Cierta empresa de renta lonas para eventos sociales (fiestas, reuniones, etc.). Requieren elegir “k” postes de los “n” postes que poseen de diversos tamaños, mismos que serán usados para colocar la lona. Es necesario que la distancia entre el poste de menor tamaño y el poste de mayor tamaño sea la mínima para que la lona quede balanceada y luzca una apariencia agradable. Debes construir un programa que determine cuál es la diferencia mínima (entre el poste mayor y de menor tamaño) de los “k” postes que sea posible encontrar de entre todos los postes que posee la empresa y que servirán para fijar la lona.",
        "entrada": "Tu programa deberá leer del teclado los siguientes datos. El primer renglón va el número 1<= k <= 10,000 de postes que se requieren para el evento. En el segundo renglones va el número k<=n <= 100,000 de postes que tiene la empresa En el tercer renglón van el tamaño de cada poste separado por un espacio el tamaño de cada poste está entre 1 <= t <= 1,000,000. En la cinta habrá entre 3 y 1,000,000 de programas (es una cinta muy larga). • Todas las duraciones serán números enteros.",
        "salida": "La salida consistirá en un solo renglón indicando la diferencia mínima posible de la combinación de “k” postes que posee la empresa.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Aritmética",
            "Loops",
            "Ordenamiento",
            "Vectores"
        ],
        "estructuras": [
            "long long",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c=10000000, e, f, g;\n    vector<int> num(100000, 0);\n    cin>>a>>b;\n    for(auto i=0; i<b; i++){\n        cin>>num[i];\n    }\n    sort(num.begin(), num.end());\n    for(auto i=a-1; i<b; i++){\n        e=num[(i-a)+1];\n        f=num[i];\n        g=f-e;\n        if(g<c){\n            c=g;\n        }\n    }\n    cout<<c;\n\n    return 0;\n}\n"
    },
    {
        "titulo": "4301. iCow",
        "url": "https://omegaup.com/arena/problem/pi_iCow/",
        "descripcion": "Fatigado por las tareas interminables de la granja, el Granjero Juan ha decidido meter sus manos en el mercado de reproductores MP3 con el nuevo iCow. Es un reproductor MP3 que almacena N canciones (1 <= N <= 1,000) indexadas de 1 a N que toca canciones en un orden \"mezclado\", como se determina por un algoritmo propio del Granjero Juan: Cada Canción i tiene una calificación inicial R_i (1 <= R_i <= 10,000). La siguiente canción ha ser tocada es siempre la que tiene la calificación más alta (o, si dos o más están empatadas, se elige la canción con calificación más alta con menor índice). Después que una canción es tocada, su calificación se pone en cero, y sus puntos de calificación son distribuidos uniformemente entre las otras N-1 canciones. Si los puntos de calificación no pueden ser distribuidos uniformemente (esto es, si no son divisibles por N-1), entonces los puntos extra son asignados de uno en uno a las primeras canciones en la lista (esto es, R_1, R_2, etc, -- pero no en la canción tocada) hasta que no queden puntos extra. Este proceso se repite con las nuevas calificaciones después que la siguiente canción es tocada. Determine las primeras T canciones (1 <= T <= 1000) que son tocadas por el iCow.",
        "entrada": "Línea 1: Dos enteros separados por espacio: N, y T. Líneas 2: N+1: La línea i+1 contiene un solo entero: R_i. El iCow contiene 3 canciones, con calificaciones 10, 8, y 11, respectivamente. Usted debe determinar las primeras 4 canciones a ser tocadas.",
        "salida": "Líneas 1..T: La línea i contiene un solo entero que es la i-ésima canción que toca el iCow. Las calificaciones después que cada canción es tocada son: C_1 C_2 C_3: (10, 8, 11) -> toca #3, 11/2 = 5, residuo = 1; (16, 13, 0) -> toca #1, 16/2 = 8; (0, 21, 8) -> toca #2, 21/2 = 10, residuo = 1; (11, 0, 18) -> toca #3 ...",
        "nivel": "",
        "categorias": [
            "Vectores"
        ],
        "estructuras": [
            "long long",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c=0, d=-1, e, f, g;\n    vector<int> num(1000, 0);\n    cin>>a>>b;\n    for(auto i=0; i<a; i++){\n        cin>>num[i];\n        if(num[i]>c){\n            c=num[i];\n            d=i;\n        }\n    }\n    a--;\n    while(b--){\n        cout<<d+1<<\"\\n\";\n        e=num[d]/a;\n        if(num[d]%a){\n            f=num[d]%a;\n        }\n        g=d;\n        num[d]=0;\n        c=d=0;\n        for(auto i=0; i<=a; i++){\n            if(i!=g){\n                if(f){\n                    num[i]+=e;\n                    num[i]++;\n                    f--;\n                }\n                else{\n                    num[i]+=e;\n                }\n            }\n            if(num[i]>c){\n                c=num[i];\n                d=i;\n            }\n        }\n    }\n    \n    return 0;\n}\n"
    },
    {
        "titulo": "3055. Agrupando Limones",
        "url": "https://omegaup.com/arena/problem/Agrupando-Limones/",
        "descripcion": "Ricardo tiene dos amores en la vida: los tacos y las matemáticas. Cuando va a comer tacos con sus amigos siempre lo hace de una forma particular: pide T tacos desde el inicio, porque sabe que esos son los que se acabará y además pide limones, pero como el kilo está muy caro, sólo le dan una cantidad L de éstos. Como Ricardo vive haciendo cálculos de cosas sin sentido dice que su vida es \"regular\" si puede repartir de forma equitativa los L limones que le dan en los T tacos que pidió, sin que sobren limones y sin partirlos. Tu tarea es ayudar a Ricardo a saber si su vida es regular dadas parejas de tacos y limones.",
        "entrada": "Un número N que representa la cantidad de parejas que Ricardo te dará. Las siguientes N líneas son parejas que contienen la cantidad de tacos T y limones L de la orden de Ricardo (en ese orden). (1 <= N <= 1000), (0 <= T, L <= 10^6).",
        "salida": "Para cada pareja, si Ricardo puede destinar los limones de forma regular imprime \"R\", de lo contrario imprime \"I\" ",
        "nivel": "Intermedio (medio) - Matemáticas en la programación",
        "categorias": [
            "Aritmética modular",
            "Loops",
            "Condicionales"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c;\n    cin>>a;\n    for(auto i=0; i<a; i++){\n        cin>>b>>c;\n        if(!b || !c){\n            cout<<\"R\\n\";\n        }\n        else if(c%b==0 || b%c==0){\n            cout<<\"R\\n\";\n        }\n        else{\n            cout<<\"I\\n\";\n        }\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "2277. Transformaciones",
        "url": "https://omegaup.com/arena/problem/Transformaciones/",
        "descripcion": "Dado un número entero S. Puedes transformar cualquier entero A a otro entero B mediante la suma de otro entero X tal que X sea un factor primo de A (toma en cuenta que 1 y A no están siendo considerados como factor primo de A). Tu tarea consiste en encontrar el mínimo número de transformaciones necesarias para transformar el entero S a otro entero T.",
        "entrada": "Una línea con los enteros S y T separados por un espacio. En el primer caso de prueba se puede llegar a 12, de la siguiente forma: los factores primos de 6 son 2 y 3, si se suma 3 se obtiene 9. El número 9 solo tiene un factor primo, 3. por lo tanto se suma 3 a 9 y se obtiene 12. 6+3=9+3=12. En el segundo caso de prueba se llega a 21 a partir de 10 haciendo tres operaciones. Factores primos de 10: 2, 5 hacemos 10+2=12 Factores de 12: 2, 3 hacemos 12+2=14 Factores de 14: 2, 7 hacemos 14+7=21. Otra forma de llegar seria: 10+5=15, 15+3=18, 18+3=21. 1<=S<=100 1<=T<=1000.",
        "salida": "Imprimir el entero correspondiente al mínimo número de transformaciones para convertir S en T. En caso de no ser posible imprime -1.",
        "nivel": "",
        "categorias": [
            "Colas",
            "Vectores"
        ],
        "estructuras": [
            "int",
            "long long",
            "vector<queue<int>>",
            "queue<pair<int,int>>",
            "pair<int, int>",
            "pair<int, int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    int sub[95]={2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499};\n    long long a, b, c, d, f=0;\n    vector<queue<int>> num(1001);\n    queue<pair<int, int> >falta;\n    pair<int, int>dd;\n    pair<int, int>ee;\n    cin>>a>>b;\n    for(auto i=0; i<95; i++){\n        d=c=sub[i];\n        c+=d;\n        while(c<1001){\n            num[c].push(sub[i]);\n            c+=d;\n        }\n    }\n    if(a>b){\n        cout<<\"-1\"; return 0;\n    }\n    while(num[a].size()){\n        dd.first=a+num[a].front();\n        num[a].pop();\n        dd.second=1;\n        falta.push(dd);\n    }\n    while(falta.size()){\n        dd=falta.front();\n        c=dd.first;\n        ee.second=dd.second+1;\n        while(num[c].size()){\n            ee.first=dd.first+num[c].front();\n            num[c].pop();\n            if(ee.first==b){\n                f=ee.second;\n                b=0;break;\n            }\n            if(ee.first<b){\n                falta.push(ee);\n            }\n        }\n        if(!b){\n            break;\n        }\n        falta.pop();\n    }\n    if(!falta.size()){\n        cout<<\"-1\";\n    }\n    else{\n        cout<<f;\n    }\n    \n    return 0;\n}"
    },
    {
        "titulo": "1930. pb Figuras Rectangulares",
        "url": "https://omegaup.com/arena/problem/pb-Figuras-Rectangulares/",
        "descripcion": "Tenemos un conjunto de cuadrados y rectángulos cuyos medidas de sus diferentes lados son cantidades enteras y mayores a 1 y , si tenemos el área de la figura, es posible que sea un cuadrado o un rectángulo. Construye un programa que nos ayude a resolver este problema (dada el área de una figura determinar si es cuadrado o rectángulo), la lectura la debes hacer de la entrada estándar (teclado) y la escritura se debe hacer a la salida estándar (pantalla). Tips Área de un cuadrado = lado * lado, Área de un rectángulo= (base * altura ), ¿Hasta que valor con respecto a “N” debo probar?, Observa que solo debes probar desde 2 hasta raíz de \"N\", si un número es divisible entre 2 significa que también es divisible entre N/2 por tanto si probamos con el numero 2, estamos al mismo tiempo probando con el numero N/2.",
        "entrada": "La primera línea contendrá un número \"N\" entre 1 y 1,000,000,000, representando el área. Tu programa se ejecutara con varios casos de prueba.",
        "salida": "Una sola línea indicando la figura que se puede formar, si el área puede formar un cuadrado debes imprimir la palabra “cuadrado” si el área puede formar un rectángulo, debes imprimir la palabra “rectangulo” y si el área puede formar ambos debe imprimir la palabra “ambos” (note no hay acentos ni mayusculas), en caso de que no se pueda formar un cuadrado o rectángulo escriba \"ninguno\".",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Aritmética"
        ],
        "estructuras": [
            "sqrt()",
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b, c=0, d=0;\n    cin>>a;\n    b=sqrt(a);\n    if(b*b==a){\n        c=1;\n    }\n    b=2;\n    while(b<=sqrt(a)){\n        if(a%b==0){\n            if(b*b==a){\n                break;\n            }\n            d=1;break;\n        }\n        b++;\n    }\n    if(c && d){\n        cout<<\"ambos\";\n    }\n    else if(c){\n        cout<<\"cuadrado\";\n    }\n    else if(d){\n        cout<<\"rectangulo\";\n    }\n    else{\n        cout<<\"ninguno\";\n    }\n    \n    return 0;\n}\n"
    },
    {
        "titulo": "712. Área de un triángulo",
        "url": "https://omegaup.com/arena/problem/area_de_un_triangulo/",
        "descripcion": "Se te dará la base y la altura de un triángulo, deberás desplegar su área.",
        "entrada": "Dos números b y a.",
        "salida": "La salida deberá ser el área del triángulo con dos decimales después del punto.",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Aritmética"
        ],
        "estructuras": [
            "setprecision()",
            "fixed",
            "long double"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long double a, b, c;\n    cin>>a>>b;\n    c=(a*b)/2;\n    cout<<fixed<<setprecision(2)<<c;\n    \n    return 0;\n}"
    },
    {
        "titulo": "2797. Ordenando Dígitos",
        "url": "https://omegaup.com/arena/problem/Ordenando-Digitos/#problems",
        "descripcion": "Se tiene un archivo que contiene una gran cantidad de dígitos en desorden. Como ordenar es una de las tareas más básicas de la computación te interesa utilizar dicho archivo para practicar tus algoritmos de ordenación. Escribe un programa que dado N de dígitos, entregue como resultado los mismos N dígitos en orden ascendente. NOTA: Para este problema se hará un especial énfasis en la eficiencia de los algoritmos, por lo que te recomendamos que implementes la solución más eficiente que encuentres, es decir, la que se ejecute en el menor tiempo posible.",
        "entrada": "En la primera línea el número 1 ≤ N ≤ 1,000,000. En la segunda línea habrá N dígitos separados cada uno por un espacio.",
        "salida": "En la primera y única línea, los N dígitos ordenados, separados por un espacio cada uno.",
        "nivel": "Intermedio (fácil) - Estructuras de datos y Algoritmos",
        "categorias": [
            "Ordenamiento",
            "Vectores"
        ],
        "estructuras": [
            "long long",
            "vector<int>"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    vector<int> num(1000000, 0);\n    long long a;\n    cin>>a;\n    for(auto i=0; i<a; i++){\n        cin>>num[i];\n    }\n    sort(num.begin(), num.begin()+a);\n    for(auto i=0; i<a; i++){\n        cout<<num[i]<<\" \";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "2434. Suma de los dígitos",
        "url": "https://omegaup.com/arena/problem/Suma-de-los-digitos/#problems",
        "descripcion": "Escribe un programa que lea un entero positivo y regrese la suma de sus dígitos. Por ejemplo: si el entero es 123, el programa deberá producir 6, ya que 1 + 2 + 3 = 6. Nota: Si tu programa usa una función recursiva, vale 50 puntos, si no usa una función recursiva vale 30 puntos.",
        "entrada": "Una línea con un entero n > 0",
        "salida": "",
        "nivel": "Básico (medio) - Introducción a la programación",
        "categorias": [
            "Loops",
            "Aritmética",
            "Caracteres y cadenas"
        ],
        "estructuras": [
            "string",
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a=0;\n    string g;\n    cin>>g;\n    for(auto i=0; i<g.size(); i++){\n        a+=(g[i]-48);\n    }\n    cout<<a;\n\n    return 0;\n}"
    },
    {
        "titulo": "2968. Divisores positivos",
        "url": "https://omegaup.com/arena/problem/Divisores-positivos/",
        "descripcion": "Dado un número entero N, escriba un programa que cuente cuántos divisores positivos tiene N.",
        "entrada": "El entero N. Puedes asumir que 1 <= N <= 1000.",
        "salida": "Un número entero que es el recuento de divisores positivos de N.",
        "nivel": "Intermedio (fácil) - Matemáticas en la programación",
        "categorias": [
            "Aritmética modular",
            "Loops",
            "Aritmética"
        ],
        "estructuras": [
            "long long",
            "sqrt()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b=2, c=2;\n    cin>>a;\n    while(b<=sqrt(a)){\n        if(a%b==0){\n            if(b*b==a){\n                c++;\n            }\n            else{\n                c+=2;\n            }\n        }\n        b++;\n    }\n    cout<<c;\n\n    return 0;\n}"
    },
    {
        "titulo": "5156. Divisores_par/impar",
        "url": "https://omegaup.com/arena/problem/Divisores_parimpar/",
        "descripcion": "Un día Mayra y Deby discutían de que números eran los mejores, Mayra decía los números pares eran los mejores y Deby decía que los mejores eran los impares. Para resolver su problema preguntaron a Charly un número aleatorio n, y si la suma de los divisores pares de n era mayor que la suma de los divisores impares del mismo número Mayra tendría la razón, en caso contrario Deby tendría la razón. Ayuda a estas 2 amigas a saber quién tiene la razón.",
        "entrada": "Una línea el número entero n que les dio Charly (1<=10^9<=100). No se evaluara con el caso de ejemplo. Sólo imprime el texto que se indica.",
        "salida": "Imprime \"Mayra\", sin comillas en caso de que ella tenga la razón, si no la tiene imprime \"Deby\", sin comillas.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Loops",
            "Aritmética",
            "Condicionales"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b=1, c=2, d=0, e=0, f;\n    cin>>a;\n    while(b<=sqrt(a)){\n        if(a%b==0){\n            if(b*b==a){\n                c++;\n                if(b%2==0){\n                    e+=b;\n                }\n                else{\n                    d+=b;\n                }\n            }\n            else{\n                c+=2;\n                if(b%2==0){\n                    e+=b;\n                }\n                else{\n                    d+=b;\n                }\n                f=a/b;\n                if(f%2==0){\n                    e+=f;\n                }\n                else{\n                    d+=f;\n                }\n            }\n        }\n        b++;\n    }\n    if(e>=d){\n        cout<<\"Mayra\\n\";\n    }\n    else{\n        cout<<\"Deby\\n\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "6941. Homólogo",
        "url": "https://omegaup.com/arena/problem/Homologo/",
        "descripcion": "Tú profe de Mate te ha impartido el tema de Semejanza. Él te dará los valores a y b de un triángulo y el valor a_1 de otro triángulo, y te ha pedido que calcules el valor faltante x de ese triángulo.",
        "entrada": "Los números enteros a, b y a_1",
        "salida": "El número x",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Cálculos aritméticos"
        ],
        "estructuras": [
            "long double"
        ],
        "codigo": "\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct sobra\n{\n    int aa, bb, cc;\n};\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    vector<vector<char>> num(2000, vector<char>(2000, ''));\n    long long a, b, c;\n    queue<sobra> falta;\n    sobra z;\n    cin >> a >> b >> c;\n    for (auto i = 0; i < a; i++)\n    {\n        for (auto j = 0; j < b; j++)\n        {\n            cin >> num[i][j];\n            if (num[i][j] == '$')\n            {\n                z.aa = i;\n                z.bb = j;\n                z.cc = 0;\n                falta.push(z);\n            }\n        }\n    }\n    while (falta.size())\n    {\n        z = falta.front();\n        falta.pop();\n        z.cc++;\n        if (z.cc > c)\n        {\n            break;\n        }\n        if (z.aa - 1 > -1 && num[z.aa - 1][z.bb] == '.')\n        {\n            num[z.aa - 1][z.bb] = '*';\n            z.aa--;\n            falta.push(z);\n            z.aa++;\n        }\n        if (z.bb - 1 > -1 && num[z.aa][z.bb - 1] == '.')\n        {\n            num[z.aa][z.bb - 1] = '*';\n            z.bb--;\n            falta.push(z);\n            z.bb++;\n        }\n        if (z.aa + 1 < a && num[z.aa + 1][z.bb] == '.')\n        {\n            num[z.aa + 1][z.bb] = '*';\n            z.aa++;\n            falta.push(z);\n            z.aa--;\n        }\n        if (z.bb + 1 < b && num[z.aa][z.bb + 1] == '.')\n        {\n            num[z.aa][z.bb + 1] = '*';\n            z.bb++;\n            falta.push(z);\n            z.bb--;\n        }\n    }\n    for (auto i = 0; i < a; i++)\n    {\n        for (auto j = 0; j < b; j++)\n        {\n            cout << num[i][j];\n        }\n        cout << \"\\n\";\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "6897. Porcentaje en masa",
        "url": "https://omegaup.com/arena/problem/Lavoisier/",
        "descripcion": "Nuestro padre Antoine Lavoisier nos ha pedido calcular el porcentaje en masa de las sustancias. ¿Podrás ayudarlo con esta tarea? ",
        "entrada": "Deberás ingresar dos enteros positivos n y k, donde n representa a la masa del soluto y k a la masa del solvente.",
        "salida": "El número p representado al porcentaje en masa de la sustancia redondeado a dos decimales.",
        "nivel": "Básico (fácil) - Introducción a la programación",
        "categorias": [
            "Cálculos aritméticos"
        ],
        "estructuras": [
            "long double",
            "setprecision()"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long double a, b, c;\n    cin >> a >> b;\n    c = (a / (b + a)) * 100;\n    cout << fixed << setprecision(2) << c << \"%\";\n\n    return 0;\n}"
    },
    {
        "titulo": "2900. El problema de los Dígitos",
        "url": "https://omegaup.com/arena/problem/El-problema-de-los-Digitos/",
        "descripcion": "Un día te diste cuenta de que del 1 al 10 hay 11 dígitos, por lo que te llamó la atención saber cuántos dígitos hay del 1 al N. Dado un número N leído del teclado, tu trabajo será imprimir por pantalla el número D de dígitos que existen del 1 al N.",
        "entrada": "Un único número N (1<=N<=10000000000).",
        "salida": "El número D de dígitos que hay del 1 al N",
        "nivel": "()",
        "categorias": [
            "Ciclos"
        ],
        "estructuras": [
            "long long"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    long long a, b = 9, c = 0, d = 9, e = 1;\n    cin >> a;\n    while (a >= b)\n    {\n        c += (d * e);\n        b *= 10;\n        b += 9;\n        d *= 10;\n        e++;\n    }\n    b /= 10;\n    c += ((a - b) * e);\n    cout << c;\n\n    return 0;\n}"
    },
    {
        "titulo": "5707. Los 4 Dígitos Fantásticos",
        "url": "https://omegaup.com/arena/problem/Los-4-Digitos-Fantasticos/",
        "descripcion": "Sabemos que dado un número n, al hacer n%10 obtenemos su último dígito, pues es el residuo de dividir entre 10, ahora si hacemos n%100 obtenemos los últimos dos dígitos de n. Escribe un programa que dado un número de 5 dígitos (sin ceros a la izquierda), imprima sus últimos cuatro dígitos.",
        "entrada": "Un número n (10000 <= n <= 99999)",
        "salida": "Los últimos 4 dígitos de n.",
        "nivel": "()",
        "categorias": [
            "Caracteres y cadenas",
            "Ciclos"
        ],
        "estructuras": [
            "string",
            "auto"
        ],
        "codigo": "#include <bits/stdc++.h>\n\nusing namespace std\n\n    int\n    main()\n{\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    cout.tie(0);\n    string g;\n    cin >> g;\n    for (auto i = 1; i < g.size(); i++)\n    {\n        cout << g[i];\n    }\n\n    return 0;\n}"
    },
    {
        "titulo": "...",
        "url": "...",
        "descripcion": "...",
        "entrada": "...",
        "salida": "...",
        "nivel": "...",
        "categorias": [
            "...",
            "..."
        ],
        "estructuras": [
            "..."
        ],
        "codigo": "..."
    },
    "Problemas totales: 402",
    "Avanzado (difícil) - Programación competitiva: 4",
    "Avanzado (medio) - Temas especializados: 1",
    "Avanzado (medio) - Programación competitiva: 3",
    "Avanzado (fácil) - Programación competitiva: 7",
    "Intermedio (difícil) - Estructuras de datos y Algoritmos: 5",
    "Intermedio (difícil) - Análisis y diseño de algoritmos: 14",
    "Intermedio (difícil) - Matemáticas en la programación: 7",
    "Intermedio (medio) - Estructuras de datos y Algoritmos: 3",
    "Intermedio (medio) - Análisis y diseño de algoritmos: 12",
    "Intermedio (medio) - Matemáticas en la programación: 5",
    "Intermedio (fácil) - Estructuras de datos y Algoritmos: 3",
    "Intermedio (fácil) - Análisis y diseño de algoritmos: 5",
    "Básico (difícil) - Introducción a la programación: 17",
    "Básico (medio) - Introducción a la programación: 33",
    "Básico (fácil) - Introducción a la programación: 41"
]